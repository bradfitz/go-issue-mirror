{
	"id": 66067944,
	"body": "\u003ca id=\"c1\"\u003e\u003c/a\u003eComment 1:\n\n\u003cpre\u003eHere is even simpler program to demonstrate your issue:\n\npackage rpc\n\nimport (\n\t\"net/http\"\n\t\"net\"\n\t\"testing\"\n)\n\nfunc TestALEX(t *testing.T) {\n\tarith := new(Arith)\n\tRegister(arith)\n\tHandleHTTP()\n\tl, e := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif e != nil {\n\t\tt.Fatalf(\"listen error: %v\", e)\n\t}\n\tdefer l.Close()\n\tgo http.Serve(l, nil)\n\n\tclient, err := DialHTTP(\"tcp\", l.Addr().String())\n\tif err != nil {\n\t\tt.Fatalf(\"dialing: %v\", err)\n\t}\n\tdefer client.Close()\n\n\targs := Args{17, 8}\n\tvar reply Reply\n\terr = client.Call(\"Arith.Mul\", args, \u0026reply)\n\tif err != nil {\n\t\tt.Fatal(\"arith error:\", err)\n\t}\n\tt.Logf(\"Arith: %d*%d=%d\\n\", args.A, args.B, reply)\n}\n\nI think the problem here is, we do not use tcp as intended. Here is pure net test to\ndemonstrate what is happening:\n\npackage net\n\nimport (\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestALEX(t *testing.T) {\n\tl, e := Listen(\"tcp\", \"127.0.0.1:0\")\n\tif e != nil {\n\t\tt.Fatal(e)\n\t}\n\tdefer l.Close()\n\n\tread := func(r io.Reader) (byte, error) {\n\t\tvar m [1]byte\n\t\t_, e = io.ReadFull(r, m[:])\n\t\treturn m[0], e\n\t}\n\n\twrite := func(w io.Writer, m byte) {\n\t\t_, e = w.Write([]byte{m})\n\t\tif e != nil {\n\t\t\tt.Fatal(e)\n\t\t}\n\t}\n\n\tch := make(chan error)\n\n\tgo func() {\n\t\tc, e := l.Accept()\n\t\tif e != nil {\n\t\t\tt.Fatal(e)\n\t\t}\n\t\tdefer c.Close()\n\t\tfor e == nil {\n\t\t\t_, e = read(c)\n\t\t}\n\t\tch \u0026lt;- e\n\t}()\n\n\tc, err := Dial(\"tcp\", l.Addr().String())\n\tif err != nil {\n\t\tt.Fatal(e)\n\t}\n\twrite(c, 'A')\n\tgo read(c)\n\ttime.Sleep(10 * time.Millisecond)\n\tc.Close()\n\te = \u0026lt;-ch\n\tif e != nil \u0026\u0026 e != io.EOF {\n\t\tt.Fatal(e)\n\t}\n}\n\nThis test fails because tcp connection is reset by c.Close. We should really use\nc.(*TCPConn).CloseWrite() instead. But we do not. In net/rpc and in net/http/fcgi\n(\u003ca href=\"https://golang.org/issue/3710)\"\u003ehttps://golang.org/issue/3710)\u003c/a\u003e we assume that tcp connection can\njust be closed and final bits of conversation will reach their destination reliably. But\nhere we see connection is reset, so tcp peers are out of sync and confused.\n\nWe could change our windows network code to ignore these read errors - rewrite this\nerror code into io.EOF, but I am not sure if this is always appropriate. This suggestion\nwill not help when we hurt other programs, like in\n\u003ca href=\"https://golang.org/issue/3710\"\u003ehttps://golang.org/issue/3710\u003c/a\u003e.\n\nI am not sure what to do.\n\nAlex\u003c/pre\u003e\n\n\n\n_Status changed to **Accepted**._",
	"user": {
		"login": "alexbrainman",
		"id": 9796621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2012-06-22T02:16:55Z",
	"updated_at": "2014-12-22T06:15:49Z"
}
