{
	"id": 66090855,
	"body": "\u003ca id=\"c2\"\u003e\u003c/a\u003eComment 2 by **pruthvirajsinh7**:\n\n\u003cpre\u003eGreetings!\nPlease Checkout the output of hockeypuck(Developed in golang) and SKS for same key.\ne.g.\noutput of \n\u003ca href=\"http://hockeypuck.gazzang.net/pks/lookup?op=get\u0026search=0x4f283d2f192189397419c3a61c2402a6529472b4\"\u003ehttp://hockeypuck.gazzang.net/pks/lookup?op=get\u0026search=0x4f283d2f192189397419c3a61c2402a6529472b4\u003c/a\u003e\nand\n\u003ca href=\"http://ha.pool.sks-keyservers.net/pks/lookup?op=get\u0026search=0x1C2402A6529472B4\"\u003ehttp://ha.pool.sks-keyservers.net/pks/lookup?op=get\u0026search=0x1C2402A6529472B4\u003c/a\u003e\ndiffers though they are the same key.\n\nI want to sign a public key from ascii armor with a private key in go language using\nfollowing code.The armor produced by following code gets parsed by gpg but the\nsignature,when checked is reported as bad signature.Is it also a bug or I am doing\nsomething wrong,please tell me.Thank you.\nimport (\n\"bytes\"\n\"code.google.com/p/go.crypto/openpgp\"\n\"code.google.com/p/go.crypto/openpgp/armor\"\n\"code.google.com/p/go.crypto/openpgp/packet\"\n)\n\n// This function takes asciiarmored private key which will sign the public key\n//Public key is also ascii armored,pripwd is password of private key in string\n//This function will return ascii armored signed public key i.e. (pubkey+sign by prikey)\nfunc SignPubKeyPKS(asciiPub string, asciiPri string, pripwd string) (asciiSignedKey\nstring) {\n   //get Private key from armor\n   _, priEnt := getPri(asciiPri, pripwd)//pripwd is the password todecrypt the private key\n   _, pubEnt := getPub(asciiPub)\n   usrIdstring := \"\"\n   for _, uIds := range pubEnt.Identities {\n       usrIdstring = uIds.Name\n    }\n   pubEnt.SignIdentity(usrIdstring, \u0026priEnt, nil) //This will generate signature and add it to pubEnt\n   asciiSignedKey = PubEntToAsciiArmor(pubEnt)\n   return\n}\n//get packet.PublicKey and openpgp.Entity of Public Key from ascii armor\nfunc getPub(asciiPub string) (pubKey packet.PublicKey, retEntity openpgp.Entity) {\n   read1 := bytes.NewReader([]byte(asciiPub))\n   entityList, _ := openpgp.ReadArmoredKeyRing(read1)\n   for _, pubKeyEntity := range entityList {\n       if pubKeyEntity.PrimaryKey != nil {\n           pubKey = *pubKeyEntity.PrimaryKey\n           retEntity = *pubKeyEntity\n       }\n   }\n   return\n}\n//get packet.PrivateKEy and openpgp.Entity of Private Key from ascii armor\nfunc getPri(asciiPri string, pripwd string) (priKey packet.PrivateKey, priEnt\nopenpgp.Entity) {\n    read1 := bytes.NewReader([]byte(asciiPri))\n    entityList, _ := openpgp.ReadArmoredKeyRing(read1)\n    for _, can_pri := range entityList {\n       smPr := can_pri.PrivateKey\n       retEntity := can_pri\n       if smPr == nil {\n          return\n       }\n       priKey = *smPr\n       priKey.Decrypt([]byte(pripwd))\n       retEntity.PrivateKey.Decrypt([]byte(pripwd))\n       retEntity.PrivateKey = \u0026priKey\n       priEnt = *retEntity\n    }\n    return\n}\n//Create ASscii Armor from openpgp.Entity\nfunc PubEntToAsciiArmor(pubEnt openpgp.Entity) (asciiEntity string) {\n    gotWriter := bytes.NewBuffer(nil)\n    wr, _ := armor.Encode(gotWriter, openpgp.PublicKeyType, nil)\n    pubEnt.Serialize(wr)\n    wr.Close()\n    asciiEntity = gotWriter.String()\n    return\n}\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-02-04T15:12:54Z",
	"updated_at": "2014-12-08T10:40:15Z"
}
