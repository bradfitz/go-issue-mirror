{
	"id": 66090857,
	"body": "\u003ca id=\"c4\"\u003e\u003c/a\u003eComment 4 by **pruthvirajsinh7**:\n\n\u003cpre\u003eHere you go sir.Following code has all the errors checked.The code still doesn't give\nany errors but every time it is giving different output in armor and hash of the armor\nchanges i.e. Each time new 4 character at the end of the armor.e.g. in one run its\n===7lfn and in next its ===OFlB.\nThanks a lot for such quick replies , Please forgive if I didn't report bug in well\nformatted manner as this is my first bug report (I am a grad student).Also did you check\nthe outputs of the hockeypuck and sks? It is showing different output for same key as\nwell.\n\n// signer\npackage main\n\nimport (\n\t\"bytes\"\n\t\"code.google.com/p/go.crypto/openpgp\"\n\t\"code.google.com/p/go.crypto/openpgp/armor\"\n\t\"code.google.com/p/go.crypto/openpgp/packet\"\n\t\"fmt\"\n)\n\n// This function takes asciiarmored private key which will sign the public key\n//Public key is also ascii armored,pripwd is password of private key in string\n//This function will return ascii armored signed public key i.e. (pubkey+sign by prikey)\nfunc SignPubKeyPKS(asciiPub string, asciiPri string, pripwd string) (asciiSignedKey\nstring) {\n\t//get Private key from armor\n\t_, priEnt := getPri(asciiPri, pripwd) //pripwd is the password todecrypt the private key\n\t_, pubEnt := getPub(asciiPub)         //This will generate signature and add it to pubEnt\n\tusrIdstring := \"\"\n\tfor _, uIds := range pubEnt.Identities {\n\t\tusrIdstring = uIds.Name\n\n\t}\n\tfmt.Println(usrIdstring)\n\terrSign := pubEnt.SignIdentity(usrIdstring, \u0026priEnt, nil)\n\tif errSign != nil {\n\t\tfmt.Println(\"Signing Key \", errSign.Error())\n\t\treturn\n\t}\n\tasciiSignedKey = PubEntToAsciiArmor(pubEnt)\n\treturn\n}\n\n//get packet.PublicKey and openpgp.Entity of Public Key from ascii armor\nfunc getPub(asciiPub string) (pubKey packet.PublicKey, retEntity openpgp.Entity) {\n\tread1 := bytes.NewReader([]byte(asciiPub))\n\tentityList, errReadArm := openpgp.ReadArmoredKeyRing(read1)\n\tif errReadArm != nil {\n\t\tfmt.Println(\"Reading Pubkey \", errReadArm.Error())\n\t\treturn\n\t}\n\tfor _, pubKeyEntity := range entityList {\n\t\tif pubKeyEntity.PrimaryKey != nil {\n\t\t\tpubKey = *pubKeyEntity.PrimaryKey\n\t\t\tretEntity = *pubKeyEntity\n\t\t}\n\t}\n\treturn\n}\n\n//get packet.PrivateKEy and openpgp.Entity of Private Key from ascii armor\nfunc getPri(asciiPri string, pripwd string) (priKey packet.PrivateKey, priEnt\nopenpgp.Entity) {\n\tread1 := bytes.NewReader([]byte(asciiPri))\n\tentityList, errReadArm := openpgp.ReadArmoredKeyRing(read1)\n\tif errReadArm != nil {\n\t\tfmt.Println(\"Reading PriKey \", errReadArm.Error())\n\t\treturn\n\t}\n\tfor _, can_pri := range entityList {\n\t\tsmPr := can_pri.PrivateKey\n\t\tretEntity := can_pri\n\t\tif smPr == nil {\n\t\t\tfmt.Println(\"No Private Key\")\n\t\t\treturn\n\t\t}\n\n\t\tpriKey = *smPr\n\n\t\terrDecr := priKey.Decrypt([]byte(pripwd))\n\t\tif errDecr != nil {\n\t\t\tfmt.Println(\"Decrypting \", errDecr.Error())\n\t\t\treturn\n\t\t}\n\t\tretEntity.PrivateKey = \u0026priKey\n\t\tpriEnt = *retEntity\n\t}\n\treturn\n}\n\n//Create ASscii Armor from openpgp.Entity\nfunc PubEntToAsciiArmor(pubEnt openpgp.Entity) (asciiEntity string) {\n\tgotWriter := bytes.NewBuffer(nil)\n\twr, errEncode := armor.Encode(gotWriter, openpgp.PublicKeyType, nil)\n\tif errEncode != nil {\n\t\tfmt.Println(\"Encoding Armor \", errEncode.Error())\n\t\treturn\n\t}\n\terrSerial := pubEnt.Serialize(wr)\n\tif errSerial != nil {\n\t\tfmt.Println(\"Serializing PubKey \", errSerial.Error())\n\t}\n\terrClosing := wr.Close()\n\tif errClosing != nil {\n\t\tfmt.Println(\"Closing writer \", errClosing.Error())\n\t}\n\tasciiEntity = gotWriter.String()\n\treturn\n}\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-02-05T05:19:29Z",
	"updated_at": "2014-12-08T10:40:15Z"
}
