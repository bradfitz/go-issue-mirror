{
	"id": 66091910,
	"body": "\u003ca id=\"c6\"\u003e\u003c/a\u003eComment 6 by **nicolashillegeer**:\n\n\u003cpre\u003eI thought to verify this and I found some strange things that I didn't expect.\n\nI tried copying memmove_amd64.s from the Go source (1.3.3 or tip, they're the same) and\nincluding that in the benchmark. This should be the same as copy() (at least that's what\nI get from reading the source, that copy() is implemented using memmove). The results:\n\nBenchmarkCopy   50000000                54.0 ns/op\nBenchmarkSimpleCopy     50000000                47.2 ns/op  // SimpleCoy is just a REP\nMOVSQ, see below\nBenchmarkMyCopy 100000000               27.5 ns/op\nBenchmarkStdLibCopy     100000000               29.7 ns/op\n\nThe interesting things being that the stdlib copy is about the same speed as the SSE\nbased copy. I wonder if there is some sort of overhead to calling via the go builtin\ncopy(dstslice, srcslice) instead of the direct asm routine call: stdlibcpy(dstptr,\nsrcptr, len). For reference, I'm running \"go version go1.3.2 darwin/amd64\".\n\nMy first thought was that this was due to the underlying memory not being in cache for\nthe first run, but I tested that this wasn't the case and also realized that go test\nlikely already guards against this by rejecting outliers.\n\nAnyway, just for kicks, since the OP has an Ivy Bridge, it would be entertaining to try\na simple REP MOVSB (no epilogue needed of course, the simplest possible memcpy). The\nreason I ask is that since Ivy Bridge onwards, intel provides enhanced rep movsb/stosb\noperations that are competitive (and sometimes beat) equivalent SSE code. See the Intel\nOptimization Manual chapter 3.7.7:\n\u003ca href=\"http://www.intel.com/content/dam/doc/manual/64-ia-32-architectures-optimization-manual.pdf\"\u003ehttp://www.intel.com/content/dam/doc/manual/64-ia-32-architectures-optimization-manual.pdf\u003c/a\u003e\n(Enhanced REP MOVSB and STOSB operation (ERMSB))\n\nSimpleCopy is just a REP MOVSQ without epilogue:\n\n#define NOSPLIT 4\nTEXT Â·simplecopy(SB), NOSPLIT, $0-24\n    MOVQ\tto+0(FP), DI\n    MOVQ\tfrom+8(FP), SI\n    MOVQ\tn+16(FP), CX\n\n    // move SI to DI until CX is 0\n    CLD\n\n    // move per byte (try this on Ivy Bridge and up)\n    // REP;\tMOVSB\n\n    // move per quadword (note to self, would need an epilogue but this is\n    // quick and dirty)\n    SHRQ\t$3, CX\n    REP;\tMOVSQ\n    RET\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-10-01T22:54:26Z",
	"updated_at": "2014-12-08T10:41:18Z"
}
