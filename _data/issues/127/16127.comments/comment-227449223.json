{
	"id": 227449223,
	"body": "Add a new `const` called `escapeQueryComponent` which would be used to escape \"everything\" by default when constructing safe URL strings.\r\n```go\r\nconst (\r\n\tencodePath encoding = 1 + iota\r\n\tencodeHost\r\n\tencodeZone\r\n\tencodeUserPassword\r\n\tencodeQueryComponent\r\n\tescapeQueryComponent\r\n\tencodeFragment\r\n)\r\n```\r\n\r\nAdhere properly to RFC3986 in the `shouldEscape()` function.\r\n```go\r\n// Return true if the specified character should be escaped when\r\n// appearing in a URL string, according to RFC 3986.\r\n//\r\n// Please be informed that for now shouldEscape does not check all\r\n// reserved characters correctly. See golang.org/issue/5684.\r\nfunc shouldEscape(c byte, mode encoding) bool {\r\n\t// §2.3 Unreserved characters (alphanum)\r\n\tif 'A' \u003c= c \u0026\u0026 c \u003c= 'Z' || 'a' \u003c= c \u0026\u0026 c \u003c= 'z' || '0' \u003c= c \u0026\u0026 c \u003c= '9' {\r\n\t\treturn false\r\n\t}\r\n\r\n\tif mode == encodeHost || mode == encodeZone {\r\n\t\t// §3.2.2 Host allows\r\n\t\t// sub-delims = \"!\" / \"$\" / \"\u0026\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\r\n\t\t// as part of reg-name.\r\n\t\t// We add : because we include :port as part of host.\r\n\t\t// We add [ ] because we include [ipv6]:port as part of host.\r\n\t\t// We add \u003c \u003e because they're the only characters left that\r\n\t\t// we could possibly allow, and Parse will reject them if we\r\n\t\t// escape them (because hosts can't use %-encoding for\r\n\t\t// ASCII bytes).\r\n\t\tswitch c {\r\n\t\tcase '!', '$', '\u0026', '\\'', '(', ')', '*', '+', ',', ';', '=', ':', '[', ']', '\u003c', '\u003e', '\"':\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\tswitch c {\r\n\tcase '-', '_', '.', '~': // §2.3 Unreserved characters (mark)\r\n\t\treturn false\r\n\r\n\t// §2.2 Reserved characters (reserved)\r\n\t// reserved = gen-delims / sub-delims\r\n\t// gen-delims = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\r\n\t// sub-delims = \"!\" / \"$\" / \"\u0026\" / \"'\" / \"(\" / \")\" / \"*\"\r\n\t// sub-delims (contd.) =  \"+\" / \",\" / \";\" / \"=\"\r\n\tcase '$', '\u0026', '!', '#', '+', ',', '\\'', '/', ':', ';', '=', '?', '@',\r\n\t\t'(', ')', '[', ']', '*':\r\n\t\t// Different sections of the URL allow a few of\r\n\t\t// the reserved characters to appear unescaped.\r\n\t\tswitch mode {\r\n\t\tcase encodePath: // §3.3\r\n\t\t\t// The RFC allows sub-delims and : @ but saves / ; , for assigning\r\n\t\t\t// meaning to individual path segments. This package\r\n\t\t\t// only manipulates the path as a whole, so we allow those\r\n\t\t\t// last two as well. That leaves only ? to escape.\r\n\t\t\treturn c == '?' || c == '#' || c == '[' || c == ']'\r\n\r\n\t\tcase encodeUserPassword: // §3.2.1\r\n\t\t\t// The RFC allows ';', ':', '\u0026', '=', '+', '$', and ',' in\r\n\t\t\t// userinfo, so we must escape only '@', '/', and '?'.\r\n\t\t\t// The parsing of userinfo treats ':' as special so we must escape\r\n\t\t\t// that too.\r\n\t\t\treturn c == '@' || c == '/' || c == '?' || c == ':'\r\n\r\n\t\tcase encodeQueryComponent: // §3.4\r\n\t\t\t// The RFC allows : @ and sub-delims. Escape all gen-delims except\r\n\t\t\t// : and @. Additionally escape any superfluous \u0026.\r\n\t\t\t// pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\".\r\n\t\t\t// RFC 3986, Appendix A.\r\n\t\t\treturn c == '\u0026' || c == '?' || c == '/' || c == '#' || c == '[' || c == ']'\r\n\r\n\t\tcase encodeFragment: // §4.1\r\n\t\t\t// The RFC text is silent but the grammar allows\r\n\t\t\t// everything, so escape nothing.\r\n\t\t\treturn false\r\n\r\n\t\tcase escapeQueryComponent:\r\n\t\t\t// As a special case, escape everything by default when\r\n\t\t\t// constructing URLs.\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\t// Everything else must be escaped.\r\n\treturn true\r\n}\r\n```\r\n\r\nUse the `escapeQueryComponent` case for the `QueryEscape()` function.\r\n```go\r\n// QueryEscape escapes the string so it can be safely placed\r\n// inside a URL query.\r\nfunc QueryEscape(s string) string {\r\n\treturn escape(s, escapeQueryComponent)\r\n}\r\n```\r\n\r\nAdd support for the `escapeQueryComponent` case to the `escape()` function.\r\n```go\r\nfunc escape(s string, mode encoding) string {\r\n\tspaceCount, hexCount := 0, 0\r\n\tfor i := 0; i \u003c len(s); i++ {\r\n\t\tc := s[i]\r\n\t\tif shouldEscape(c, mode) {\r\n\t\t\tif c == ' ' \u0026\u0026 mode == encodeQueryComponent {\r\n\t\t\t\tspaceCount++\r\n\t\t\t} else if c == ' ' \u0026\u0026 mode == escapeQueryComponent {\r\n\t\t\t\tspaceCount++\r\n\t\t\t} else {\r\n\t\t\t\thexCount++\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif spaceCount == 0 \u0026\u0026 hexCount == 0 {\r\n\t\treturn s\r\n\t}\r\n\r\n\tt := make([]byte, len(s)+2*hexCount)\r\n\tj := 0\r\n\tfor i := 0; i \u003c len(s); i++ {\r\n\t\tswitch c := s[i]; {\r\n\t\tcase c == ' ' \u0026\u0026 (mode == encodeQueryComponent || mode == escapeQueryComponent):\r\n\t\t\tt[j] = '+'\r\n\t\t\tj++\r\n\t\tcase shouldEscape(c, mode):\r\n\t\t\tt[j] = '%'\r\n\t\t\tt[j+1] = \"0123456789ABCDEF\"[c\u003e\u003e4]\r\n\t\t\tt[j+2] = \"0123456789ABCDEF\"[c\u002615]\r\n\t\t\tj += 3\r\n\t\tdefault:\r\n\t\t\tt[j] = s[i]\r\n\t\t\tj++\r\n\t\t}\r\n\t}\r\n\treturn string(t)\r\n}\r\n```\r\n\r\nRemove the work-around for RFC3986 characters in the `validEncodedPath()` function\r\n```go\r\n// validEncodedPath reports whether s is a valid encoded path.\r\n// It must not contain any bytes that require escaping during path encoding.\r\nfunc validEncodedPath(s string) bool {\r\n\tfor i := 0; i \u003c len(s); i++ {\r\n\t\tswitch s[i] {\r\n\t\tcase '[', ']':\r\n\t\t\t// ok - not specified in RFC 3986 but left alone by modern browsers\r\n\t\tcase '%':\r\n\t\t\t// ok - percent encoded, will decode\r\n\t\tdefault:\r\n\t\t\tif shouldEscape(s[i], encodePath) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n```",
	"user": {
		"login": "gmccue",
		"id": 1085902,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-06-21T14:02:22Z",
	"updated_at": "2016-06-21T14:03:24Z"
}
