{
	"id": 97674417,
	"number": 11907,
	"state": "closed",
	"title": "runtime: crashes on cgo callbacks",
	"body": "This was reported privately as episodic crashes on 1.4:\r\n\r\n```\r\nruntime: garbage collector found invalid heap pointer *(0xc208237fe0+0x0)=0xc208104010 span=0xc208104000-0xc208109a00-0xc20810a000 state=2\r\nfatal error: invalid heap pointer\r\n\r\nruntime stack:\r\nruntime.throw(0xb0e6c3)\r\n\t/usr/local/go/src/runtime/panic.go:491 +0xad fp=0x7fb617ffbbd8 sp=0x7fb617ffbba8\r\nscanblock(0xc208237fe0, 0x18, 0x80bc68)\r\n\t/usr/local/go/src/runtime/mgc0.c:381 +0x551 fp=0x7fb617ffbd18 sp=0x7fb617ffbbd8\r\nscanframe(0x7fb617ffbe20, 0x0, 0x7fb600000001)\r\n\t/usr/local/go/src/runtime/mgc0.c:743 +0x1c2 fp=0x7fb617ffbd88 sp=0x7fb617ffbd18\r\nruntime.gentraceback(0x44a770, 0xc208237b50, 0x0, 0xc20841a5a0, 0x0, 0x0, 0x7fffffff, 0x7fb617ffbed0, 0x0, 0x0, ...)\r\n\t/usr/local/go/src/runtime/traceback.go:311 +0x7a8 fp=0x7fb617ffbe78 sp=0x7fb617ffbd88\r\nscanstack(0xc20841a5a0)\r\n\t/usr/local/go/src/runtime/mgc0.c:780 +0x21c fp=0x7fb617ffbee8 sp=0x7fb617ffbe78\r\nmarkroot(0xc208010000, 0x32)\r\n\t/usr/local/go/src/runtime/mgc0.c:556 +0xe7 fp=0x7fb617ffbf48 sp=0x7fb617ffbee8\r\nruntime.parfordo(0xc208010000)\r\n\t/usr/local/go/src/runtime/parfor.c:91 +0x13b fp=0x7fb617ffbfc8 sp=0x7fb617ffbf48\r\ngc(0x7fb617ffc100)\r\n\t/usr/local/go/src/runtime/mgc0.c:1442 +0x25e fp=0x7fb617ffc0e0 sp=0x7fb617ffbfc8\r\nruntime.gc_m()\r\n\t/usr/local/go/src/runtime/mgc0.c:1371 +0xe0 fp=0x7fb617ffc118 sp=0x7fb617ffc0e0\r\nruntime.onM(0x7fb617ffc120)\r\n\t/usr/local/go/src/runtime/asm_amd64.s:257 +0x68 fp=0x7fb617ffc120 sp=0x7fb617ffc118\r\nruntime.mstart()\r\n\t/usr/local/go/src/runtime/proc.c:818 fp=0x7fb617ffc128 sp=0x7fb617ffc120\r\n\r\ngoroutine 389 [garbage collection, locked to thread]:\r\nruntime.switchtoM()\r\n\t/usr/local/go/src/runtime/asm_amd64.s:198 fp=0xc208237b58 sp=0xc208237b50\r\nruntime.gogc(0xc200000000)\r\n\t/usr/local/go/src/runtime/malloc.go:469 +0x1cf fp=0xc208237b90 sp=0xc208237b58\r\nruntime.mallocgc(0xa00000, 0x0, 0xc200000003, 0xc20824a380)\r\n\t/usr/local/go/src/runtime/malloc.go:341 +0x391 fp=0xc208237c40 sp=0xc208237b90\r\nruntime.rawstring(0xa00000, 0x0, 0x0, 0x0, 0x0, 0x0)\r\n\t/usr/local/go/src/runtime/string.go:195 +0x93 fp=0xc208237c70 sp=0xc208237c40\r\nruntime.gostringn(0x7fb60c002330, 0xa00000, 0x0, 0x0)\r\n\t/usr/local/go/src/runtime/string.go:275 +0x57 fp=0xc208237cd0 sp=0xc208237c70\r\ngithub.com/bioothod/elliptics-go/elliptics._Cfunc_GoStringN(0x7fb60c002330, 0x7fb600a00000, 0x0, 0x0)\r\n\t/root/go/src/github.com/bioothod/elliptics-go/elliptics/:83 +0x4b fp=0xc208237cf8 sp=0xc208237cd0\r\ngithub.com/bioothod/elliptics-go/elliptics.NewDnetFile(0x7fb617ffc230, 0x0, 0x0, 0x0)\r\n\t/root/go/src/github.com/bioothod/elliptics-go/elliptics/ctogo.go:203 +0x7f fp=0xc208237d50 sp=0xc208237cf8\r\ngithub.com/bioothod/elliptics-go/elliptics.go_read_callback(0x7fb617ffc230, 0x10f62)\r\n\t/root/go/src/github.com/bioothod/elliptics-go/elliptics/callback.go:124 +0x184 fp=0xc208237f28 sp=0xc208237d50\r\nruntime.call16(0x7fb617ffc150, 0x7fb617ffc1d0, 0x10)\r\n\t/usr/local/go/src/runtime/asm_amd64.s:401 +0x45 fp=0xc208237f40 sp=0xc208237f28\r\nruntime.cgocallbackg1()\r\n\t/usr/local/go/src/runtime/cgocall.go:239 +0x12a fp=0xc208237fa0 sp=0xc208237f40\r\nruntime.cgocallbackg()\r\n\t/usr/local/go/src/runtime/cgocall.go:193 +0x6e fp=0xc208237fd0 sp=0xc208237fa0\r\nruntime.cgocallback_gofunc(0xc208104010, 0xc208597000, 0x1000)\r\n\t/usr/local/go/src/runtime/asm_amd64.s:766 +0x57 fp=0xc208237fe0 sp=0xc208237fd0\r\nruntime.goexit()\r\n\t/usr/local/go/src/runtime/asm_amd64.s:2232 +0x1 fp=0xc208237fe8 sp=0xc208237fe0\r\n```\r\n\r\nI can reproduce it on tip using the following program:\r\n\r\n```go\r\n// test.go\r\npackage main\r\n\r\nimport \"runtime\"\r\n\r\n// void foo();\r\nimport \"C\"\r\n\r\n//export go_callback\r\nfunc go_callback() {\r\n\truntime.GC()\r\n\tgrow()\r\n\truntime.GC()\r\n}\r\n\r\nvar cnt int\r\n\r\nfunc grow() {\r\n\tx := 10000\r\n\tsum := 0\r\n\tif grow1(\u0026x, \u0026sum) == 0 {\r\n\t\tpanic(\"bad\")\r\n\t}\r\n}\r\n\r\nfunc grow1(x, sum *int) int {\r\n\tif *x == 0 {\r\n\t\treturn *sum+1\r\n\t}\r\n\t*x--\r\n\tsum1 := *sum + *x\r\n\treturn grow1(x, \u0026sum1)\r\n}\r\n\r\nfunc main() {\r\n\tconst P = 100\r\n\tdone := make(chan bool)\r\n\t// allocate a bunch of stack frames and spray them with pointers\r\n\tfor i := 0; i \u003c P; i++ {\r\n\t\tgo func() {\r\n\t\t\tgrow()\r\n\t\t\tdone \u003c- true\r\n\t\t}()\r\n\t}\r\n\tfor i := 0; i \u003c P; i++ {\r\n\t\t\u003c-done \r\n\t}\r\n\t// now give these stack frames to cgo callbacks\r\n\tfor i := 0; i \u003c P; i++ {\r\n\t\tgo func() {\r\n\t\t\tC.foo()\r\n\t\t\tdone \u003c- true\r\n\t\t}()\r\n\t}\r\n\tfor i := 0; i \u003c P; i++ {\r\n\t\t\u003c-done \r\n\t}\r\n}\r\n```\r\n\r\n```c\r\n// test.c\r\n#include \u003cpthread.h\u003e\r\n\r\nvoid go_callback();\r\n\r\nvoid *thr(void *arg) {\r\n\tgo_callback();\r\n\treturn 0;\r\n}\r\n\r\nvoid foo() {\r\n\tpthread_t th;\r\n\tpthread_create(\u0026th, 0, thr, 0);\r\n\tpthread_join(th, 0);\r\n}\r\n```\r\n\r\n```\r\n$ GODEBUG=invalidptr=1,gccheckmark=1 GOGC=0 GOTRACEBACK=2 GOMAXPROCS=4 ./test\r\n```\r\n```\r\nruntime:greyobject: checkmarks finds unexpected unmarked object obj=0xc8203acd80\r\nruntime: found obj at *(0xc8203b7f80+0x8)\r\nbase=0xc8203b7f80 k=0x64101db s.start*_PageSize=0xc8203b0000 s.limit=0x0 s.sizeclass=0 s.elemsize=0\r\nobj=0xc8203acd80 k=0x64101d6 s.start*_PageSize=0xc8203ac000 s.limit=0xc8203adf80 s.sizeclass=32 s.elemsize=1152\r\n *(obj+0) = 0xc8203ad200\r\n *(obj+8) = 0x0\r\n *(obj+16) = 0x0\r\n *(obj+24) = 0x0\r\n *(obj+32) = 0x0\r\n *(obj+40) = 0x0\r\n *(obj+48) = 0x0\r\n```\r\n\r\nAnd if I enable object validation during GC, then it crashes as:\r\n```\r\nruntime:objectstart Span weird: p=0xc820ed0fc0 k=0x6410768 s.start=0xc820e72000 s.limit=0xc820e73f80 s.state=0\r\nfatal error: objectstart: bad pointer in unexpected span\r\nruntime:objectstart Span weird: p=0xc820b3fee8 k=0x641059f s.start=0xc820c96000 s.limit=0xc820c97f80 s.state=0\r\nfatal error: objectstart: bad pointer in unexpected span\r\nruntime:objectstart Span weird: p=0xc820b0cfb0 k=0x6410586 s.start=0xc820c96000 s.limit=0xc820c97f80 s.state=0\r\nfatal error: objectstart: bad pointer in unexpected span\r\nruntime:objectstart Span weird: p=0xc820ed2fc8 k=0x6410769 s.start=0xc820e72000 s.limit=0xc820e73f80 s.state=0\r\nfatal error: objectstart: bad pointer in unexpected span\r\n\r\nruntime stack:\r\nruntime.throw(0x48a1a0, 0x2b)\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/panic.go:527 +0x96 fp=0x7fa4fd7f98a0 sp=0x7fa4fd7f9888\r\nruntime.heapBitsForObject(0xc820ed0fc0, 0x0, 0x0, 0x0, 0x7fa65020b5a0)\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/mbitmap.go:214 +0x27d fp=0x7fa4fd7f98d8 sp=0x7fa4fd7f98a0\r\nruntime.scanblock(0xc820c28fb0, 0x30, 0x492ea8, 0xc820024720)\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/mgcmark.go:797 +0xef fp=0x7fa4fd7f9960 sp=0x7fa4fd7f98d8\r\nruntime.scanframeworker(0x7fa4fd7f9b18, 0x0, 0xc820024720)\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/mgcmark.go:485 +0x1b9 fp=0x7fa4fd7f99f8 sp=0x7fa4fd7f9960\r\nruntime.scanstack.func1(0x7fa4fd7f9b18, 0x0, 0x1)\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/mgcmark.go:384 +0x65 fp=0x7fa4fd7f9a40 sp=0x7fa4fd7f99f8\r\nruntime.gentraceback(0x426719, 0xc820c28b00, 0x0, 0xc82017c600, 0x0, 0x0, 0x7fffffff, 0x7fa4fd7f9c38, 0x0, 0x0, ...)\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/traceback.go:336 +0xa7e fp=0x7fa4fd7f9b70 sp=0x7fa4fd7f9a40\r\nruntime.scanstack(0xc82017c600)\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/mgcmark.go:406 +0x391 fp=0x7fa4fd7f9c78 sp=0x7fa4fd7f9b70\r\nruntime.scang(0xc82017c600)\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/proc1.go:417 +0x96 fp=0x7fa4fd7f9c98 sp=0x7fa4fd7f9c78\r\nruntime.markroot(0xc820020000, 0xd6)\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/mgcmark.go:133 +0x1ba fp=0x7fa4fd7f9d38 sp=0x7fa4fd7f9c98\r\nruntime.parfordo(0xc820020000)\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/parfor.go:110 +0x1d4 fp=0x7fa4fd7f9dc0 sp=0x7fa4fd7f9d38\r\nruntime.gchelper()\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/mgc.go:1665 +0x59 fp=0x7fa4fd7f9e08 sp=0x7fa4fd7f9dc0\r\nruntime.stopm()\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/proc1.go:1125 +0x15e fp=0x7fa4fd7f9e30 sp=0x7fa4fd7f9e08\r\nruntime.gcstopm()\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/proc1.go:1315 +0xfe fp=0x7fa4fd7f9e60 sp=0x7fa4fd7f9e30\r\nruntime.schedule()\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/proc1.go:1574 +0xa5 fp=0x7fa4fd7f9e98 sp=0x7fa4fd7f9e60\r\nruntime.mstart1()\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/proc1.go:725 +0x129 fp=0x7fa4fd7f9eb8 sp=0x7fa4fd7f9e98\r\nruntime.mstart()\r\n\t/usr/local/google/home/dvyukov/src/go/src/runtime/proc1.go:685 +0x72 fp=0x7fa4fd7f9ec8 sp=0x7fa4fd7f9eb8\r\n```\r\n\r\nThe bug is that cgocallback_gofunc allocates a fake frame for cgocallback_gofunc:\r\n```\r\n\t// Switch to m-\u003ecurg stack and call runtime.cgocallbackg.\r\n\t// Because we are taking over the execution of m-\u003ecurg\r\n\t// but *not* resuming what had been running, we need to\r\n\t// save that information (m-\u003ecurg-\u003esched) so we can restore it.\r\n\t// We can restore m-\u003ecurg-\u003esched.sp easily, because calling\r\n\t// runtime.cgocallbackg leaves SP unchanged upon return.\r\n\t// To save m-\u003ecurg-\u003esched.pc, we push it onto the stack.\r\n\t// This has the added benefit that it looks to the traceback\r\n\t// routine like cgocallbackg is going to return to that\r\n\t// PC (because the frame we allocate below has the same\r\n\t// size as cgocallback_gofunc's frame declared above)\r\n\t// so that the traceback will seamlessly trace back into\r\n\t// the earlier calls.\r\n\t//\r\n\t// In the new goroutine, 0(SP) holds the saved R8.\r\n\tMOVQ\tm_curg(BX), SI\r\n\tMOVQ\tSI, g(CX)\r\n\tMOVQ\t(g_sched+gobuf_sp)(SI), DI  // prepare stack as DI\r\n\tMOVQ\t(g_sched+gobuf_pc)(SI), BX\r\n\tMOVQ\tBX, -8(DI)\r\n\t// Compute the size of the frame, including return PC and, if\r\n\t// GOEXPERIMENT=framepointer, the saved based pointer\r\n\tLEAQ\tfv+0(FP), AX\r\n\tSUBQ\tSP, AX\r\n\tSUBQ\tAX, DI\r\n\tMOVQ\tDI, SP\r\n```\r\n\r\nBut the frame contains garbage while cgocallback_gofunc arguments contain 2 pointers, so these pointer slots contain garbage during GC and stack copying.\r\n\r\nI can confirm that by spraying newly allocated stacks with any magic value and then observing these values in panic traces:\r\n```\r\nruntime.cgocallback_gofunc(0x67, 0x67, 0x67)\r\n```\r\n\r\nThis happens on 1.4 and tip and can lead to false memory retention and crashes.",
	"user": {
		"login": "dvyukov",
		"id": 1095328,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		}
	],
	"comments": 3,
	"closed_at": "2015-07-29T22:31:08Z",
	"created_at": "2015-07-28T10:48:03Z",
	"updated_at": "2016-08-05T16:11:29Z",
	"milestone": {
		"id": 905105,
		"number": 1,
		"title": "Go1.5"
	}
}
