{
	"id": 254565634,
	"body": "I know the original author of the assembly code (which was not written with Go in mind) and I suspect that it was correct at the time. I don't know the person who originally converted it to Go however, and I suspect that I'll need some assistance in fixing this.\r\n\r\nThe only entry point for the functions in `sum_arm.s` is `poly1305_auth_armv6`. The other `TEXT` lines might well be superfluous?\r\n\r\nBuilding a binary and running `go tool objdump` on it results in this (which I'll comment on inline):\r\n\r\n(Recall that the `TEXT` line is `TEXT Â·poly1305_auth_armv6(SB), $280-16`.)\r\n\r\n```\r\nTEXT golang.org/x/crypto/poly1305.poly1305_auth_armv6(SB) /home/agl/devel/gopkg/src/golang.org/x/crypto/poly1305/sum_arm.s\r\n        sum_arm.s:367   0xd1e48 e59a1008        MOVW 0x8(R10), R1\r\n        sum_arm.s:367   0xd1e4c e24d2f47        SUB $284, R13, R2\r\n        sum_arm.s:367   0xd1e50 e1520001        CMP R1, R2\r\n        sum_arm.s:367   0xd1e54 9a000018        B.LS 0xd1ebc\r\n```\r\n\r\nThis is stack check, I assume, and it's checking for 284 bytes of free space. If the stack isn't large enough, it'll end up back here via `runtime.morestack_noctxt`.\r\n\r\n```\r\n        sum_arm.s:367   0xd1e58 e52de11c        MOVW.W R14, -0x11c(R13)\r\n```\r\n\r\nThis has been added by the compiler, although I'm not sure why.\r\n\r\n```\r\n        sum_arm.s:368   0xd1e5c e59d4120        MOVW 0x120(R13), R4\r\n        sum_arm.s:369   0xd1e60 e59d5124        MOVW 0x124(R13), R5\r\n        sum_arm.s:370   0xd1e64 e59d6128        MOVW 0x128(R13), R6\r\n        sum_arm.s:371   0xd1e68 e59d712c        MOVW 0x12c(R13), R7\r\n```\r\n\r\nThis is the loading of argument from the stack, but the offsets assume that R13 has already been moved down ~280 bytes, although I don't know when that happened.\r\n\r\n```\r\n        sum_arm.s:373   0xd1e6c e1a0800d        MOVW R13, R8\r\n        sum_arm.s:374   0xd1e70 e3cdd03f        BIC $63, R13, R13 \r\n        sum_arm.s:375   0xd1e74 e24dd040        SUB $64, R13, R13\r\n```\r\n\r\nThis will subtract between 64 and 127 bytes from the stack pointer and end up aligning it to 64 bytes. The rest of the code here operates on a datastructure that's ~64 bytes and which will be placed at this point in the stack.\r\n\r\n```\r\n        sum_arm.s:376   0xd1e78 e1a0000d        MOVW R13, R0\r\n        sum_arm.s:377   0xd1e7c e1a01007        MOVW R7, R1\r\n        sum_arm.s:378   0xd1e80 ebfffe93        BL poly1305_init_ext_armv6(SB)\r\n```\r\n\r\nIt doesn't help that I don't understand ARM assembly (instructions like `MOVM.DB.W` seem to be updating the destination address register?) but we should have at least 280-128 bytes of stack to play with, right? So if the remaining functions don't overflow that we should be ok? (Or has R13 already been moved down, thus the masking with ~63 and subtraction of 64 just send us off into space.)\r\n\r\nThe code does keep pointers into the stack in registers however. But there are no other stack-splitting points after the first. Can the GC preempt arbitrarily, or only at stack splits? \r\n\r\n```\r\n        sum_arm.s:379   0xd1e84 e3d6200f        BIC.S $15, R6, R2\r\n        sum_arm.s:380   0xd1e88 0a000004        B.EQ 0xd1ea0\r\n        sum_arm.s:381   0xd1e8c e1a0000d        MOVW R13, R0\r\n        sum_arm.s:382   0xd1e90 e1a01005        MOVW R5, R1\r\n        sum_arm.s:383   0xd1e94 e0855002        ADD R2, R5, R5\r\n        sum_arm.s:384   0xd1e98 e0466002        SUB R2, R6, R6\r\n        sum_arm.s:385   0xd1e9c ebfffeaa        BL poly1305_blocks_armv6(SB)\r\n        sum_arm.s:388   0xd1ea0 e1a0000d        MOVW R13, R0\r\n        sum_arm.s:389   0xd1ea4 e1a01005        MOVW R5, R1\r\n        sum_arm.s:390   0xd1ea8 e1a02006        MOVW R6, R2\r\n        sum_arm.s:391   0xd1eac e1a03004        MOVW R4, R3\r\n        sum_arm.s:392   0xd1eb0 ebffff46        BL poly1305_finish_ext_armv6(SB)\r\n        sum_arm.s:393   0xd1eb4 e1a0d008        MOVW R8, R13 \r\n        sum_arm.s:394   0xd1eb8 e49df11c        RET #284\r\n        sum_arm.s:367   0xd1ebc e1a0300e        MOVW R14, R3\r\n        sum_arm.s:367   0xd1ec0 ebfe3be8        BL runtime.morestack_noctxt(SB)\r\n        sum_arm.s:367   0xd1ec4 eaffffdf        B golang.org/x/crypto/poly1305.poly1305_auth_armv6(SB)\r\n```\r\n```",
	"user": {
		"login": "agl",
		"id": 21203,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-10-18T16:38:00Z",
	"updated_at": "2016-10-18T16:38:00Z"
}
