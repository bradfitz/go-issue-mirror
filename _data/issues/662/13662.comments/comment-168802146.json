{
	"id": 168802146,
	"body": "I've done some investigation on this and there are two things that don't seem right for the gcc 5 branch with gccgo on Power.\r\n\r\nFirst, the failure started happening with commit 227785, with the change to subtract off the value of runtime_stacks_sys from the next_gc value.\r\n// conservatively set next_gc to high value assuming that everything is live\r\n// concurrent/lazy sweep will reduce this number while discovering new garbage\r\nmstats.next_gc = mstats.heap_alloc+(mstats.heap_alloc-runtime_stacks_sys)*gcpercent/100;\r\n\r\nOn Power in gcc5, split stack support was not backported so the value of runtime_stacks_sys is a large value, which means next_gc is not being set to a high value as described in the comments.  (In other words, the value of runtime_stacks_sys is likely to be a large portion of the total heap at the beginning).  Instead the next run of GC is done soon.  The problem doesn't happen on gcc6 because of the split stack implementation or the effect of this patch https://gcc.gnu.org/ml/gcc-patches/2015-10/msg03503.html, both of which keep runtime_stacks_sys as a low value.\r\n\r\nBut as was noted above, running GC more frequently shouldn't cause a failure so there also seems to be a problem related to the use of GC with optimized code.  I found that if the pointer returned from a heap allocation is kept in a register and never stored then it is being freed too early by GC causing the failure in this test.  When next_gc is a low value and the next GC is done soon this problem is more likely to occur.\r\n\r\n       F := []uint64{2, 3, 5}\r\n    10002248:   39 f8 ff 4b     bl      10001a80 \u003c000000bf.plt_call.__go_new_nopointers\u003e\r\n    1000224c:   18 00 41 e8     ld      r2,24(r1)\r\n    10002250:   fe ff e2 3c     addis   r7,r2,-2\r\n    10002254:   60 6c e7 e8     ld      r7,27744(r7)\r\n    10002258:   fe ff 02 3d     addis   r8,r2,-2\r\n    1000225c:   68 6c 08 e9     ld      r8,27752(r8)\r\n    10002260:   fe ff 22 3d     addis   r9,r2,-2\r\n    10002264:   70 6c 29 e9     ld      r9,27760(r9)\r\n    ./src/gcc/testsuite/go.test/test/235.go:42\r\n        var n = len(F)\r\n        OUT := []uint64{\r\n    10002268:   20 03 80 38     li      r4,800\r\n     ./src/gcc/testsuite/go.test/test/235.go:40\r\n        return m\r\n    }\r\n\r\n\r\n    func main() {\r\n        F := []uint64{2, 3, 5}\r\n    1000226c:   78 1b 7b 7c     mr      r27,r3    \u003c=== r3 is not stored\r\n    10002270:   00 00 e3 f8     std     r7,0(r3)\r\n    10002274:   08 00 03 f9     std     r8,8(r3)\r\n    10002278:   f8 ff 7b 3b     addi    r27,r27,-8\r\n    1000227c:   10 00 23 f9     std     r9,16(r3)\r\n    ./src/gcc/testsuite/go.test/test/235.go:42\r\n        var n = len(F)\r\n        OUT := []uint64{\r\n    10002280:   ff ff 62 3c     addis   r3,r2,-1\r\n    10002284:   e0 78 63 38     addi    r3,r3,30944\r\n    10002288:   f9 f7 ff 4b     bl      10001a80 \u003c000000bf.plt_call.__go_new_nopointers\u003e\r\n    1000228c:   18 00 41 e8     ld      r2,24(r1)\r\n    10002290:   20 03 a0 38     li      r5,800\r\n    10002294:   18 00 95 38     addi    r4,r21,24\r\n    10002298:   08 01 61 f8     std     r3,264(r1)\r\n    1000229c:   95 f9 ff 4b     bl      10001c30 \u003c000000bf.plt_call.memcpy@@GLIBC_2.17\u003e\r\n\r\nBy the time the call is made to memcpy, the storage containing the values that should be copied have been garbage collected and the values are 0.  When compiled without optimization, the pointer is stored and the failure does not occur.  ",
	"user": {
		"login": "laboger",
		"id": 9433228,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-04T20:46:46Z",
	"updated_at": "2016-01-04T20:46:46Z"
}
