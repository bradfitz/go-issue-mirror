{
	"id": 88534411,
	"body": "I was going to say more last night but did not, but the way this has been\ndealt with in other languages with a formal safe/unsafe separation\n(Modula-3, Cedar Mesa, one niche-and-not-widely-known Java implementation)\nis to have a way in the safe language to talk about unsafe (C-malloc'd,\narithemetic'd, mmap'd, etc) memory layout (i.e, structures and pointers to\nthose structures).  Go is a little funny from that POV in that it doesn't\nhave a traced/untraced distinction on its struct types, but it *does* have\nthe implementation artifact that its gc is okay with untraced pointers\nleaking into the heap (and RLH says he's relatively happy with that).\n\nIn particular, that brand-X Java implementation had an all-objects-moving\ngarbage collector, and this technique worked fine there, and we used it for\nfile and network buffers.  I'll try to work up an example (I am still\nlearning Go) and post it later.\n\nThe lack of traced/untraced in the type system means that you are not\nstatically prohibited from making the mistake of (in Go code) storing Go\npointers into the C heap, but it allows zero-copy interchange of C pointers\n*into* Go.  The other issue with lacking a traced/untraced distinction is\nthat if this interchange is supported, then Go structure layout must always\nmimic the C structure layout (but this is a problem we have already leaking\nGo into C).  Both of these can be avoided if types are explicitly marked\ntraced/untraced.\n\nAn altnerate way to address the leaking-pointers problem w/o separating\ntraced from untraced is to provide a CMalloc interface that will only work\nfor data types that do not themselves contain pointers.  This is less\nsatisfying for things like array-of-arrays.\n\nSlices are also a problem because the usual idiom uses finalizers in a\nwrapper to ensure eventual reclamation of the C storage, and slices are not\ntied to the wrapper object.\n\n\n\nOn Wed, Apr 1, 2015 at 10:36 AM, JT Olds \u003cnotifications@github.com\u003e wrote:\n\n\u003e I agree it does seem like keeping zero-copy byte slices between C and Go\n\u003e kills a lot of possible Go GC strategies (unless byte slices are special\n\u003e cased and come out of a different memory segment I suppose). @dvyukov\n\u003e \u003chttps://github.com/dvyukov\u003e, in the case that the heap isn't being moved\n\u003e around, is there much harm in forcing things that go into C-land to the\n\u003e heap? I think you end up getting the ability to remember Go pointers in\n\u003e C-land for free that way.\n\u003e\n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/10303#issuecomment-88507903\u003e.\n\u003e\n",
	"user": {
		"login": "dr2chase",
		"id": 1928999,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-04-01T16:04:29Z",
	"updated_at": "2015-04-01T16:04:29Z"
}
