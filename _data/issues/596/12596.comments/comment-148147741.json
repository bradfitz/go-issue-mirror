{
	"id": 148147741,
	"body": "Here is a simplified version of your Go program:\r\n\r\n\tpackage main\r\n\t\r\n\timport (\r\n\t\t\"fmt\"\r\n\t\t\"time\"\r\n\t)\r\n\t\r\n\tfunc main() {\r\n\t\tslimslice := make([]uint64, 256, 256)\r\n\t\tfatslice := make([]uint64, 0, 1024*1024*1024/8)\r\n\t\tstart := time.Now()\r\n\t\tfor {\r\n\t\t\tfatslice = append(fatslice, slimslice...)\r\n\t\t\tif len(fatslice)+len(slimslice) \u003e cap(fatslice) {\r\n\t\t\t\tsize := len(fatslice) * 8\r\n\t\t\t\tt := time.Since(start).Seconds()\r\n\t\t\t\tfmt.Printf(\"%d MB at %.2f = %.2f MB/s\\n\", size\u003e\u003e20, t, float64(size)/(1\u003c\u003c20)/t)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\nOn my Linux workstation with 32 GB of RAM, the program prints:\r\n\r\n\t1024 MB at 0.16 = 6234.55 MB/s\r\n\t1280 MB at 0.48 = 2657.89 MB/s\r\n\t1600 MB at 0.83 = 1926.98 MB/s\r\n\t2000 MB at 1.27 = 1576.00 MB/s\r\n\t2500 MB at 1.78 = 1400.88 MB/s\r\n\t3125 MB at 2.43 = 1285.36 MB/s\r\n\t3906 MB at 3.55 = 1100.12 MB/s\r\n\t4882 MB at 5.44 = 896.84 MB/s\r\n\t6103 MB at 10.71 = 569.75 MB/s\r\n\t7629 MB at 29.75 = 256.48 MB/s\r\n\t9536 MB at 53.44 = 178.47 MB/s\r\n\r\nHere is a roughly equivalent C program:\r\n\r\n\t#include \u003cstdio.h\u003e\r\n\t#include \u003csys/time.h\u003e\r\n\t#include \u003cstdlib.h\u003e\r\n\t#include \u003cstring.h\u003e\r\n\t\r\n\tchar zero[256*8];\r\n\t\r\n\tdouble\r\n\tnow(void)\r\n\t{\r\n\t\tstruct timeval tv;\r\n\t\tgettimeofday(\u0026tv, 0);\r\n\t\treturn (double)tv.tv_sec+tv.tv_usec/1e6;\r\n\t}\r\n\t\r\n\tint \r\n\tmain(void)\r\n\t{\r\n\t\tchar *p;\r\n\t\tlong long size, i;\r\n\t\tdouble start, t;\r\n\t\t\r\n\t\tstart = now();\r\n\t\tsize = 1\u003c\u003c30;\r\n\t\tfor(;;) {\r\n\t\t\tp = malloc(size);\r\n\t\t\tfor(i=0; i\u003csize; i+=sizeof zero)\r\n\t\t\t\tmemmove(p+i, zero, sizeof zero);\r\n\t\t\tt = now() - start;\r\n\t\t\tprintf(\"%lld MB at %.2f = %.2f MB/s\\n\", size\u003e\u003e20, t, size/(double)(1\u003c\u003c20)/t);\r\n\t\t\tsize += size/4;\r\n\t\t}\r\n\t\r\n\t\treturn 0;\r\n\t}\r\n\r\nOn the same workstation it prints:\r\n\r\n\t1024 MB at 0.15 = 6736.14 MB/s\r\n\t1280 MB at 0.32 = 3962.02 MB/s\r\n\t1600 MB at 0.54 = 2981.77 MB/s\r\n\t2000 MB at 0.80 = 2486.34 MB/s\r\n\t2500 MB at 1.14 = 2197.36 MB/s\r\n\t3125 MB at 1.55 = 2011.59 MB/s\r\n\t3906 MB at 2.07 = 1884.13 MB/s\r\n\t4882 MB at 2.72 = 1793.49 MB/s\r\n\t6103 MB at 5.37 = 1137.05 MB/s\r\n\t7629 MB at 18.39 = 414.96 MB/s\r\n\t9536 MB at 40.92 = 233.07 MB/s\r\n\r\nThis is the same behavior. The program is getting ahead of what the operating system can give it, and the operating system is working hard to free up more memory. Even though you have more memory on the machine, it's in use: freeing it up is expensive. Maybe that's swapping or maybe not, but either way it's hard.\r\n\r\nThe C program does not free any of the buffers because neither does the Go program. Although the garbage collector does reclaim the memory, the allocation pattern is such that each new allocation cannot use the memory the program has available so it must ask for more from the operating system. (Go does release memory to the operating system at a gradual pace, but this program runs far ahead of that.)\r\n\r\nI think this is working as expected, more or less, at least given the current implementation of Linux.\r\n",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-10-14T18:33:45Z",
	"updated_at": "2015-10-14T18:33:45Z"
}
