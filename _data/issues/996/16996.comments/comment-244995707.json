{
	"id": 244995707,
	"body": "Go does not guarantee that a finalizer will be run in some bounded amount\nof time. In fact Go does not even guarantee that a finalizer will be run\nbefore the program terminates.\n\nThis test seems to assume otherwise. If a program want to execute\n\"close(closed)\" in a timely deterministic fashion the application needs to\nbe structure so that it does not rely on finalizers.\n\n\n\nOn Mon, Sep 5, 2016 at 5:19 PM, Brad Fitzpatrick \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e When writing a test for #16983 \u003chttps://github.com/golang/go/issues/16983\u003e,\n\u003e I encountered what looks like perhaps a liveness bug with variadic calls.\n\u003e\n\u003e If I set \"const useVariadic\" to true below, the test fails (buf1 is never\n\u003e collected), but if I set it to false, buf1 is collected.\n\u003e\n\u003e func twoReader(b1, b2 *bytes.Reader) Reader {\n\u003e         return MultiReader(b1, b2)\n\u003e }\n\u003e func TestMultiReaderFreesExhaustedReaders(t *testing.T) {\n\u003e         var mr Reader\n\u003e         closed := make(chan struct{})\n\u003e         {\n\u003e                 buf1 := bytes.NewReader([]byte(\"foo\"))\n\u003e                 buf2 := bytes.NewReader([]byte(\"bar\"))\n\u003e                 const useVariadic = true // set to true to see the bug; false to see the workaround\n\u003e                 if useVariadic {\n\u003e                         mr = MultiReader(buf1, buf2)\n\u003e                 } else {\n\u003e                         mr = twoReader(buf1, buf2)\n\u003e                 }\n\u003e                 runtime.SetFinalizer(buf1, func(*bytes.Reader) {\n\u003e                         close(closed)\n\u003e                 })\n\u003e         }\n\u003e\n\u003e         buf := make([]byte, 4)\n\u003e         if n, err := ReadFull(mr, buf); err != nil || string(buf) != \"foob\" {\n\u003e                 t.Fatalf(`ReadFull = %d (%q), %v; want 3, \"foo\", nil`, n, buf[:n], err)\n\u003e         }\n\u003e\n\u003e         println(\"runtime.GC...\")\n\u003e         runtime.GC()\n\u003e         println(\"waiting...\")\n\u003e         select {\n\u003e         case \u003c-closed:\n\u003e         case \u003c-time.After(5 * time.Second):\n\u003e                 t.Fatal(\"timeout waiting for collection of buf1\")\n\u003e         }\n\u003e\n\u003e         if n, err := ReadFull(mr, buf[:2]); err != nil || string(buf[:2]) != \"ar\" {\n\u003e                 t.Fatalf(`ReadFull = %d (%q), %v; want 2, \"ar\", nil`, n, buf[:n], err)\n\u003e         }\n\u003e }\n\u003e\n\u003e /cc @randall77 \u003chttps://github.com/randall77\u003e @josharian\n\u003e \u003chttps://github.com/josharian\u003e @minux \u003chttps://github.com/minux\u003e\n\u003e @cherrymui \u003chttps://github.com/cherrymui\u003e\n\u003e\n\u003e â€”\n\u003e You are receiving this because you are subscribed to this thread.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/16996\u003e, or mute the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AA7WnylwzhlnxU5EMWVoJM_iRnk5CX7Oks5qnId9gaJpZM4J1UkH\u003e\n\u003e .\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-09-06T15:49:13Z",
	"updated_at": "2016-09-06T15:49:13Z"
}
