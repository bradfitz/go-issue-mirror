{
	"id": 112969710,
	"body": "I think I see what you're getting at. I claimed that it is in fact okay to let scanobject see stale/invalid spans as long as it can correctly ignore them and let the write barrier in the user code mark the object. If I understand, you're questioning whether it can reliably ignore them, since if it can't and it winds up using information from a stale span, very bad things will happen (which is true).\r\n\r\nI convinced myself last Friday that it can reliably ignore them. However, the reasoning was convoluted and not something I would trust to remain true. And I think there's a much better answer wherein the scanobject simply will not see stale spans. I think I can reconstruct my reasoning if you want, but do you agree that if scanobject never sees a stale span, that the question of whether it can detect a stale span is moot?\r\n\r\nI assert that a store/store barrier at the end of mallocgc ensures that scanobject will not see a stale span for pointers into the heap. This barrier ensures that all writes performed by mallocgc, including initializing an mspan and storing it to h_spans if it got a fresh span, occur before the caller can perform any writes that make the object visible to the garbage collector (through a write barrier or just regular tracing). Once this span has been allocated from, the start, limit, and state fields will not change until the sweeper reclaims it, at which point there are no more objects to lead the garbage collector to this span. When scanobject gets the heap bits of an object, its data dependencies form the load/load side of the barrier. It's a somewhat unusual data dependency, but it is a data dependency: scanobject must load the pointer before it can compute the offset in h_spans and look up the span, so the load of the pointer must happen before the load of the *mspan or any fields of the mspan. Thus, it will see the up-to-date span, since the span cannot have changed since the store/store barrier in mallocgc.\r\n\r\nI have to think more about the special pointers from the heap into the stack that scanobject is supposed to ignore. Stack spans don't have the nice monotonic properties of heap spans, since they can be freed at any time. So, it's possible scanobject could load a pointer into a stack from an object, then some other thread grows that stack and frees the original stack span, and then heapBitsForObject sees a freed span (or even a reused one). If that's the case, I think this could happen regardless of memory ordering.",
	"user": {
		"login": "aclements",
		"id": 2688315,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-06-17T22:28:25Z",
	"updated_at": "2015-06-17T22:28:25Z"
}
