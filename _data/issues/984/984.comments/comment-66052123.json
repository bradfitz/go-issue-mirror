{
	"id": 66052123,
	"body": "\u003ca id=\"c2\"\u003e\u003c/a\u003eComment 2:\n\n\u003cpre\u003eSorry for the long delay on this one.  \n\nLocking is slower on the Mac than on Linux.  We use the\nMach semaphore system calls, which seem to have\nhigher overhead than Linux's futex.  I don't know if maybe\nwe should be using something else.  \n\nDoes annealing refer to any global state using locks? \nDoes it call top-level functions in package rand? \nThose functions have an implicit lock inside them \nto make it safe to call from multiple goroutines.  If you're\ngenerating a lot of random numbers you're better off\ngiving each goroutine its own generator, by using:\n\n    r := rand.New(rand.NewSource(seed))\n\nto give each goroutine its own r, and then have them\ncall r.Float64() instead of rand.Float64().\n\nThis program demonstrates the kind of contention problems we see:\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"rand\"\n)\n\nfunc main() {\n\tconst SERVERS = 4\n\n\tm := make(map[string] int)\n\tc := make(chan string, 1)\n\tdone := make(chan bool)\n\t\n\tfor i := 0; i \u0026lt; SERVERS; i++ {\n\t\tgo server(c, done)\n\t}\n\n\tvar running = SERVERS\n\t\n\tfor {\n\t\tselect {\n\t\tcase \u0026lt;-done:\n\t\t\tif running--; running == 0 {\n\t\t\t\treturn\n\t\t\t}\n\t\tcase s := \u0026lt;-c:\n\t\t\tm[s]++\n\t\t\tfmt.Println(\"pling!\")\n\t\t}\n\t}\n}\n\nfunc server(c chan string, done chan bool) {\n\tfor j := 0; j \u0026lt; 1\u0026lt;\u0026lt;23; j++ {\n\t\tr := rand.Uint32()\n\t\tif r \u0026lt; 1\u0026lt;\u0026lt;8 {\n\t\t\tc \u0026lt;- fmt.Sprint(r)\n\t\t}\n\t}\n\tdone \u0026lt;- true\n}\n\t\t\n$ GOMAXPROCS=1 time 6.out\npling!\npling!\n3.95u 0.03s 4.15r \t 6.out\n$ GOMAXPROCS=2 time 6.out\npling!\npling!\n24.20u 35.81s 52.43r \t 6.out\n$ \n\nBut if we change server to do:\n\nfunc server(c chan string, done chan bool) {\n\tmyRand := rand.New(rand.NewSource(rand.Int63()))\n\tfor j := 0; j \u0026lt; 1\u0026lt;\u0026lt;23; j++ {\n\t\tr := myRand.Uint32()\n\t\tif r \u0026lt; 1\u0026lt;\u0026lt;8 {\n\t\t\tc \u0026lt;- fmt.Sprint(r)\n\t\t}\n\t}\n\tdone \u0026lt;- true\n}\n\nThen the program does get faster with more cores\n(and is even faster on one core because of the\nreduced locking overhead):\n\n$ GOMAXPROCS=1 time 6.out\npling!\npling!\npling!\npling!\npling!\n1.03u 0.01s 1.08r \t 6.out\n$ GOMAXPROCS=2 time 6.out\npling!\npling!\npling!\npling!\npling!\n1.03u 0.01s 0.69r \t 6.out\n$\n\nI suspect some similar lock contention is the problem\nin your program.\u003c/pre\u003e\n\n\n_Owner changed to **r...@golang.org**._\n\n_Status changed to **WaitingForReply**._",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2010-09-11T18:06:45Z",
	"updated_at": "2014-12-22T05:52:31Z"
}
