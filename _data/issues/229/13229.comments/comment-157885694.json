{
	"id": 157885694,
	"body": "**The offical proposal of the new test:**\r\nWe use this specific variant of the [Baillie-PSW](https://en.wikipedia.org/wiki/Baillie-PSW_primality_test) primality test:\r\nBPSW := MR(base=2) \u0026\u0026 AESLucas( (D/input) = -1 )\r\n\r\nAES stands for almost (skips the U sequence, works only with V) extra strong (as told in Grantham theorem 2.3). This is exactly what [Sage](http://git.sagemath.org/sage.git/tree/src/sage/rings/integer.pyx) / [PariGp](http://pari.math.u-bordeaux.fr/download.html) / [Mathematica](http://reference.wolfram.com/language/tutorial/SomeNotesOnInternalImplementation.html#6849) does. [Java](http://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/12d1f39ed743/src/share/classes/java/math/BigInteger.java) uses a weaker variant of Lucas test.\r\n\r\nWe search discriminant D=P^2-4 of the V sequence (odd P, constrained to Q=1) with Method B of Baillie \u0026 Wagstaff. This can be relaxed with also allowing even P. We use odd P as this is what PariGp/Sage does, and Baillie \u0026 Wagstaff chose to have D=1 mod 4 for both methods A \u0026 B, which requires odd P.\r\nAfter calculating jacobi (D/input), we do handle 0 \u0026 1 as well.\r\n\r\nMR sequence a^(k-1)-1 has (discriminant/input)=1, and we complement this with a lucas test with (discriminant/input)=-1. This, however unproven, is strongly believed to give this test its terrific capability of detecting composite numbers and there is a big amount of [academic](http://www.ams.org/journals/mcom/1980-35-152/S0025-5718-1980-0583518-6/S0025-5718-1980-0583518-6.pdf) [work](http://www.ams.org/journals/mcom/2001-70-234/S0025-5718-00-01197-2/S0025-5718-00-01197-2.pdf) [examinig](https://math.dartmouth.edu/~carlp/PDF/paper25.pdf) BPSW. It is the current state-of-the-art in primality testing.\r\n\r\nBPSW is:\r\n- either necassary \u0026 sufficient for primality\r\n- or it has an extremely very low error rate (a single MR has error rate less than 1/4). there is no known counter example since 1980.\r\n\r\n**Class of numbers:**\r\nThis specific combination of MR(base=2) and various lucas tests is known to give a definite result for inputs \u003c 2^64. There wont be a big difference between BPSW \u0026 MR(n\u003e0) for small inputs. For bigger inputs:\r\n\r\n- If the user strictly needs a \"proven\" bound on error rate and inputs are known to be random then existing MR(n\u003e0) can be used.\r\n- The user should use BPSW otherwise because MR(n\u003e0) is not suitable for testing numbers in *for example* cryptographic applications where the input may have been \"crafted\".\r\n\r\n**The cost:**\r\nMR(n=40) arguably provides cryptographic level confidence and can be used if the inputs are known to be totally random. We compare BPSW with it. These are the total times ([details](https://github.com/golang/go/issues/13229#issuecomment-156547627)):\r\n\r\n// 5 primes with 256 256 697 730 995 bits\r\nMR(n= 40) total: 90ms\r\nBPSW total: 16ms\r\n\r\n// 10 pairwise products of 5 primes\r\nMR(n= 40) total: 21ms\r\nBPSW total: 36ms\r\n\r\nBelow we time:\r\n- per-round cost of MR (random base generation+single test)\r\n- JL: jacobi calculation+lucas test\r\n\r\n// 256 bits prime\r\nMR 55.716µs\r\nBPSW 413.391µs\r\n\r\n// 256 bits prime\r\nMR 51.933µs\r\nBPSW 395.738µs\r\n\r\n// 697 bits prime\r\nMR 468.014µs\r\nBPSW 2.874695ms\r\n\r\n// 512 bits composite\r\nMR 227.235µs\r\nBPSW 1.23973ms\r\n\r\n// 953 bits composite\r\nMR 944.782µs\r\nBPSW 4.432682ms\r\n\r\n// 986 bits composite\r\nMR 1.295064ms\r\nBPSW 5.977547ms\r\n\r\nFor primes: JL ~ 6 to 7.5 times MR-round\r\nFor composites: JL ~ 4.5 to 5.4 times MR-round",
	"user": {
		"login": "jfcg",
		"id": 1410597,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-18T22:29:48Z",
	"updated_at": "2015-11-19T08:44:44Z"
}
