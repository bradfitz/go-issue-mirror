{
	"id": 156480895,
	"body": "First of all: I did not study the patch carefully because we are not doing code review. Understanding if your proposed extension is fine should not require one to study (or even *open*) a code patch. And certainly not one with functions named `sprp` and `slprp`.\r\n\r\n\u003e sprp: strong probable prime (standard term in number theory)\r\nslprp: strong lucas probable prime (standard term in number theory)\r\nReally easy definitions, you would quickly recognize them if you cared to read my patch, the wiki or the papers ;)\r\n\r\nThis is a non-argument. I quickly glanced to the diff in `ProbablyPrime`, and what I found is\r\n\r\n```\r\n+ return x.abs.sprp(natTwo, nm1, q, k) \u0026\u0026 x.abs.slprp(b == 2)\r\n```\r\n\r\ncompare with Java SDK implementation\r\n\r\n```\r\nreturn passesMillerRabin(rounds, random) \u0026\u0026 passesLucasLehmer();\r\n```\r\n\r\n\r\n\u003e As you know, Go has a compatibility promise. I did not want to clutter the api, just extend the current api with how Sage/Pari/Gp does it. Notice that there is no loss of MR(n) functionality.\r\nThat's why we need 'configuration'.\r\nUsers just use whatever they want. n=0 for BPSW, n\u003e0 if they want MR(n).\r\n\r\nYes, I understand that. And yet everyone who has read your proposal said that the proposed API is ugly. Maybe a new fuction would be better (as Minux said). There's no agreement, not even on the *signature* of the function, and yet you expect someone to carefully study the whole patch.\r\n\r\n\u003e If you cared to read some basic info about primality testing, you would not ask why we use the strong versions, but I'll explain in any case: strong tests are better detectors of primes/composites. Also the existing MR code is itself a strong probable prime test ;)\r\n\r\nI know the difference between strong and weak tests, thank you. My point was that you can't both write \"we should do it this way because this is how everyone is doing it\" and avoid being questioned about remarkable differences between your implementation and other languages/libraries/platforms implementations.\r\n\r\nI look at Java's implementation and I see weak-Lucas, I look at GMPL and they don't even do Lucas. Mathematica and PARI/GP do exactly what you're doing in your patch. The sage reference returns 404. Perl and Python implement Lucas and BPSW in external libraries.\r\n\r\nTo sum the evidence up:\r\n- Mathematica and PARI/GP do BPSW out of the box for `isPrime`\r\n- Java does MR + weak-Lucas after a certain threshold \r\n- GMPL does MR only\r\n- Other languages provide Lucas and BPSW in external libraries\r\n\r\n\u003e You should use BPSW, if not, you should use MR(n=40+) for a serious application. BPSW is faster than the latter case.\r\n\r\nHow much faster for `n=40` ?\r\n\r\n\u003e Probable prime means:\r\n    either prime\r\n    very rare composite that fooled your prp test.\r\nThat is the mathematically correct term for what all these functions produce.\r\n\r\nI was specifically asking if we do have a bound. You write \"very rare\", I deduce that a bound is not known. That's fine.\r\n\r\nIMHO the first thing to do is decide how the API will look if this goes in (new function? `n \u003c= 0` trick? Out-of-the-box Lucas in isProbablyPrime?).\r\n",
	"user": {
		"login": "ALTree",
		"id": 3586803,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-13T16:32:29Z",
	"updated_at": "2015-11-13T16:42:11Z"
}
