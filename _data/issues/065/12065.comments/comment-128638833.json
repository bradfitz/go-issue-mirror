{
	"id": 128638833,
	"body": "The error means that the debug info shows that the debug info defines id as a struct that has size 0 but has an 8 byte field.  That is clearly wrong.  I can recreate the problem using clang/LLVM 3.4 on GNU/Linux (your test case works fine with GCC).  Using readelf --debug on the object file generated by LLVM, I see this:\r\n\r\n    \u003c1\u003e\u003c79\u003e: Abbrev Number: 10 (DW_TAG_typedef)\r\n        \u003c7a\u003e   DW_AT_type        : \u003c0x84\u003e   \r\n        \u003c7e\u003e   DW_AT_name        : (indirect string, offset: 0xa1): id      \r\n        \u003c82\u003e   DW_AT_decl_file   : 2        \r\n        \u003c83\u003e   DW_AT_decl_line   : 6        \r\n \u003c1\u003e\u003c84\u003e: Abbrev Number: 7 (DW_TAG_pointer_type)\r\n    \u003c85\u003e   DW_AT_type        : \u003c0x89\u003e   \r\n \u003c1\u003e\u003c89\u003e: Abbrev Number: 11 (DW_TAG_structure_type)\r\n    \u003c8a\u003e   DW_AT_name        : (indirect string, offset: 0x95): objc_object     \r\n    \u003c8e\u003e   DW_AT_byte_size   : 0        \r\n \u003c2\u003e\u003c8f\u003e: Abbrev Number: 12 (DW_TAG_member)\r\n    \u003c90\u003e   DW_AT_name        : (indirect string, offset: 0x86): isa     \r\n    \u003c94\u003e   DW_AT_type        : \u003c0x9b\u003e   \r\n    \u003c98\u003e   DW_AT_data_member_location: 0        \r\n    \u003c99\u003e   DW_AT_accessibility: 1       (public)\r\n \u003c2\u003e\u003c9a\u003e: Abbrev Number: 0\r\n \u003c1\u003e\u003c9b\u003e: Abbrev Number: 7 (DW_TAG_pointer_type)\r\n    \u003c9c\u003e   DW_AT_type        : \u003c0xa0\u003e   \r\n \u003c1\u003e\u003ca0\u003e: Abbrev Number: 13 (DW_TAG_structure_type)\r\n    \u003ca1\u003e   DW_AT_name        : (indirect string, offset: 0x8a): objc_class      \r\n    \u003ca5\u003e   DW_AT_declaration : 1        \r\n \u003c1\u003e\u003ca6\u003e: Abbrev Number: 2 (DW_TAG_variable)\r\n    \u003ca7\u003e   DW_AT_name        : (indirect string, offset: 0xa4): __cgo__1        \r\n\r\n\r\nThis says that id is a typedef for a pointer to the struct objc_object, and that objc_object has a size of 0 but has one member, isa, which is a pointer to the struct objc_class (the size of 0 can be seen at the line labeled 8e).  So this debug info is incorrect: objc_object is 0 bytes but has a pointer field.  The right fix would be to change LLVM to generate the correct debug info.\r\n\r\nI can't think of a good way for cgo to handle this case.  I think workarounds in the source code, as you suggest, is going to be your best bet.  So I'm going to close this issue since it doesn't seem to be a problem we can fix in Go.",
	"user": {
		"login": "ianlancetaylor",
		"id": 3194333,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-07T08:24:22Z",
	"updated_at": "2015-08-07T08:24:22Z"
}
