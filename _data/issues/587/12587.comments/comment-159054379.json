{
	"id": 159054379,
	"body": "Here is the function in question, sysUsed. It is broken in multiple ways:\r\n\r\n\tfunc sysUsed(v unsafe.Pointer, n uintptr) {\r\n\t\tr := stdcall4(_VirtualAlloc, uintptr(v), n, _MEM_COMMIT, _PAGE_READWRITE)\r\n\t\tif r != uintptr(v) {\r\n\t\t\tthrow(\"runtime: failed to commit pages\")\r\n\t\t}\r\n\t\r\n\t\t// Commit failed. See SysUnused.\r\n\t\tfor n \u003e 0 {\r\n\t\t\tsmall := n\r\n\t\t\tfor small \u003e= 4096 \u0026\u0026 stdcall4(_VirtualAlloc, uintptr(v), small, _MEM_COMMIT, _PAGE_READWRITE) == 0 {\r\n\t\t\t\tsmall /= 2\r\n\t\t\t\tsmall \u0026^= 4096 - 1\r\n\t\t\t}\r\n\t\t\tif small \u003c 4096 {\r\n\t\t\t\tthrow(\"runtime: failed to decommit pages\")\r\n\t\t\t}\r\n\t\t\tv = add(v, small)\r\n\t\t\tn -= small\r\n\t\t}\r\n\t}\r\n\r\nWhat this code was supposed to do: If the VirtualAlloc MEM_COMMIT failed, the assumption was that it failed because the region being accessed was too large (corresponded to an aggregation of multiple MEM_DECOMMIT operations) and needed to be split up. The pseudo-binary search identifies the boundaries of the original operations and executes the appropriately aligned calls.\r\n\r\nWhat this code actually does: If the VirtualAlloc MEM_COMMIT fails, the code throws, without trying anything else. But if the VirtualAlloc MEM_COMMIT succeeds, then it does this pseudo-binary search trying to find an alternate way to make it succeed. Since the initial operation already succeeded, so will the first iteration of the loop (VirtualAlloc with MEM_COMMIT is idempotent), so the loop terminates after one iteration, no harm done.\r\n\r\nThis was untested largely because it's difficult to trigger. But I just plain got the logic leading to the fallback wrong. You can tell because the throw says \"failed to commit pages\" not \"failed to decommit pages\". The cut and paste from sysUnused did not update the second error message (but CL 14633 did), so we know it was the first throw that happened.\r\n\r\nThat first throw is just wrong, assuming we want to do the fallback loop. We know from the definition of VirtualAlloc that it must have returned 0 (failure), we know from the history (issue #7143, [CL 96300046](https://golang.org/cl/96300046), issue #8038, and [CL 147820043](https://golang.org/cl/147820043)) that the most likely reason for failure is this alignment issue, and we know from reading the code that such a failure is not handled correctly.\r\n\r\nMy guess is that if we handle the failure correctly, all will be well. The code:\r\n\r\n\t\tif r != uintptr(v) {\r\n\t\t\tthrow(\"runtime: failed to commit pages\")\r\n\t\t}\r\n\t\r\n\t\t// Commit failed. See SysUnused.\r\n\r\nshould change to be\r\n\r\n\t\tif r == uintptr(v) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\r\n\t\t// Commit failed. See SysUnused.\r\n\r\nThat revised test actually matches the comment that follows. :-)\r\n\r\n",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-23T20:27:47Z",
	"updated_at": "2015-11-23T20:28:51Z"
}
