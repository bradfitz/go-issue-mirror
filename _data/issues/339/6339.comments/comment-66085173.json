{
	"id": 66085173,
	"body": "\u003ca id=\"c4\"\u003e\u003c/a\u003eComment 4 by **liviobs**:\n\n\u003cpre\u003eHi Russ,\n\nThanks for the suggestion. I tried your suggestion (i.e., encoding nil IP as \"\"), and it\nworks better than what I had previously tried (in my previous attempt, unmarshal would\nget confused, and my attempts to fix the unmarshal in json/decode.go by special-casing\nthe 'null' identifier was failing).\n\nIf I use the following example: \u003ca href=\"http://play.golang.org/p/Iz_EhNcaAC\"\u003ehttp://play.golang.org/p/Iz_EhNcaAC\u003c/a\u003e , and apply the\nchanges below to tip, I get (what I believe is) sane behavior for both marshal and\nunmarshal:\n\n{192.168.0.1}\n{\"IP\":\"192.168.0.1\"} \u0026lt;nil\u0026gt;\n{192.168.0.1} \u0026lt;nil\u0026gt;\n{\u0026lt;nil\u0026gt;}\n{\"IP\":\"\"} \u0026lt;nil\u0026gt;\n{\u0026lt;nil\u0026gt;} \u0026lt;nil\u0026gt;\n\nI just had to tweak the tests in ip_test.go ever so slightly to get the build to succeed.\n\nAlso, I agree with your reasoning about earlier forms of JSON-ized net.IP not being a\nconcern given that unmarshal of the base64 version did not work \"out of the box\" (I had\nto work around the problem by implementing a UnmarshalJSON for the parent struct and\nspecial casing the net.IP field member).\n\n\ndiff -r 58e5ed6b5029 src/pkg/net/ip.go\n--- a/src/pkg/net/ip.go\tThu Sep 05 23:06:34 2013 -0400\n+++ b/src/pkg/net/ip.go\tFri Sep 06 00:19:18 2013 -0400\n@@ -315,6 +315,9 @@\n // MarshalText implements the encoding.TextMarshaler interface.\n // The encoding is the same as returned by String.\n func (ip IP) MarshalText() ([]byte, error) {\n+\tif len(ip) == 0 {\n+\t\treturn []byte(\"\"), nil\n+\t}\n \tif len(ip) != IPv4len \u0026\u0026 len(ip) != IPv6len {\n \t\treturn nil, errors.New(\"invalid IP address\")\n \t}\n@@ -324,6 +327,10 @@\n // UnmarshalText implements the encoding.TextUnmarshaler interface.\n // The IP address is expected in a form accepted by ParseIP.\n func (ip *IP) UnmarshalText(text []byte) error {\n+\tif len(text) == 0 {\n+\t\tip = nil\n+\t\treturn nil\n+\t}\n \ts := string(text)\n \tx := ParseIP(s)\n \tif x == nil {\ndiff -r 58e5ed6b5029 src/pkg/net/ip_test.go\n--- a/src/pkg/net/ip_test.go\tThu Sep 05 23:06:34 2013 -0400\n+++ b/src/pkg/net/ip_test.go\tFri Sep 06 00:19:18 2013 -0400\n@@ -13,18 +13,19 @@\n var parseIPTests = []struct {\n \tin  string\n \tout IP\n+\terr error\n }{\n-\t{\"127.0.1.2\", IPv4(127, 0, 1, 2)},\n-\t{\"127.0.0.1\", IPv4(127, 0, 0, 1)},\n-\t{\"127.0.0.256\", nil},\n-\t{\"abc\", nil},\n-\t{\"123:\", nil},\n-\t{\"::ffff:127.0.0.1\", IPv4(127, 0, 0, 1)},\n-\t{\"2001:4860:0:2001::68\", IP{0x20, 0x01, 0x48, 0x60, 0, 0, 0x20, 0x01, 0, 0, 0, 0, 0,\n0, 0x00, 0x68}},\n-\t{\"::ffff:4a7d:1363\", IPv4(74, 125, 19, 99)},\n-\t{\"fe80::1%lo0\", nil},\n-\t{\"fe80::1%911\", nil},\n-\t{\"\", nil},\n+\t{\"127.0.1.2\", IPv4(127, 0, 1, 2), nil},\n+\t{\"127.0.0.1\", IPv4(127, 0, 0, 1), nil},\n+\t{\"127.0.0.256\", nil, \u0026ParseError{\"IP address\", \"127.0.0.256\"}},\n+\t{\"abc\", nil, \u0026ParseError{\"IP address\", \"abc\"}},\n+\t{\"123:\", nil, \u0026ParseError{\"IP address\", \"123:\"}},\n+\t{\"::ffff:127.0.0.1\", IPv4(127, 0, 0, 1), nil},\n+\t{\"2001:4860:0:2001::68\", IP{0x20, 0x01, 0x48, 0x60, 0, 0, 0x20, 0x01, 0, 0, 0, 0, 0,\n0, 0x00, 0x68}, nil},\n+\t{\"::ffff:4a7d:1363\", IPv4(74, 125, 19, 99), nil},\n+\t{\"fe80::1%lo0\", nil, \u0026ParseError{\"IP address\", \"fe80::1%lo0\"}},\n+\t{\"fe80::1%911\", nil, \u0026ParseError{\"IP address\", \"fe80::1%911\"}},\n+\t{\"\", nil, nil},\n }\n \n func TestParseIP(t *testing.T) {\n@@ -34,8 +35,8 @@\n \t\t}\n \t\tvar out IP\n \n-\t\tif err := out.UnmarshalText([]byte(tt.in)); !reflect.DeepEqual(out, tt.out) ||\n(tt.out == nil) != (err != nil) {\n-\t\t\tt.Errorf(\"IP.UnmarshalText(%q) = %v, %v, want %v\", tt.in, out, err, tt.out)\n+\t\tif err := out.UnmarshalText([]byte(tt.in)) ; !reflect.DeepEqual(out, tt.out) ||\n!reflect.DeepEqual(err, tt.err) {\n+\t\t\tt.Errorf(\"IP.UnmarshalText(%q) = %v, %v, want %v, %v\", tt.in, out, err, tt.out,\ntt.err)\n \t\t}\n \t}\n }\n@@ -65,10 +66,6 @@\n \t\t\tif out, err := tt.in.MarshalText(); string(out) != tt.out || err != nil {\n \t\t\t\tt.Errorf(\"IP.MarshalText(%v) = %q, %v, want %q, nil\", out, err, tt.out)\n \t\t\t}\n-\t\t} else {\n-\t\t\tif _, err := tt.in.MarshalText(); err == nil {\n-\t\t\t\tt.Errorf(\"IP.MarshalText(nil) succeeded, want failure\")\n-\t\t\t}\n \t\t}\n \t}\n }\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-09-06T04:32:57Z",
	"updated_at": "2014-12-22T06:28:38Z"
}
