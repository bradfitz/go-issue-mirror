{
	"id": 233786585,
	"body": "@dlsniper Apologies, I missed your 2nd question (I assume you are referring to the export of types under an `internal/` directory). I disagree that this is bad design: If you do have a large library consisting of several sub-packages, in general it won't be possible to cleanly \"pull out\" all the relevant declarations (types, functions) into a single package \"at the top\". In fact, because of dependencies in such a library, exactly the opposite is happening: All the types that you want to export eventually end up \"at the bottom\" in a package that is imported by all other packages. Those other packages are likely to export functions that should really be at the component API level, together with those types. The result is not pretty.\r\n\r\nI have a very concrete example; the go/* packages in the std library: Essentially, the go/* libraries together build what I would call a \"component\", a larger library that is factored into sub-packages such as the go/tokens, go/scanner, go/parser, type-checker, etc., each of which implements a sufficiently large, complex, and self-contained subset of the component's overall functionality.\r\n\r\nA client of this component never cares about this separation into sub-packages. Almost all clients do the following: They want the abstract syntax tree (AST) for some given source. Then, they want to do something with that AST. They may want it augmented with types (type-checked), and possibly printed. That is, the component's API could actually be streamlined quite a bit: It could export the AST and perhaps go/types types as well as a small number of functions to parse, print, and perhaps type-check that AST. In such a component, the AST should be exported by the top-level package together with operations on that AST. That's really want a client wants.\r\n\r\nBut in reality things are the other way around because of import requirements: The AST is at the bottom of the package tree. Types (as in go/types) are \"attached\" via maps (because we couldn't put them \"below\" the AST due to the Go 1 guarantee). All the other functionality is on top. Most clients have to import a variety of packages (go/token, go/parser, go/ast, go/printer) when in fact they really only care about the AST and some high-level operations on top.\r\n\r\nThis is less hypothetical than in sounds. I have been working on a new AST implementation (part of which we might see in 1.8) where I am trying to achieve exactly that, which is to make the client's API as simple and easy to use as possible. I have resorted to moving everything (lexer, parser, AST, printer) into a single package, so that I can present a streamlined API. It's not too bad, but it's not my first choice. Separation of concerns and isolation of code now requires programmer discipline; I cannot enforce it by moving stuff into sub-packages. Testing is less isolated. Had we alias declarations, one could provide a very clean high-level API, hide the internals under an `internal/` directory, and get all the benefits of package encapsulation, separate testing, etc. w/o the need to present an overly complex multi-package API to a client.\r\n\r\nThis is truly a large-scale engineering problem and unlikely to present itself as a serious issue in smaller applications.",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"reactions": {
		"total_count": 6,
		"+1": 6
	},
	"created_at": "2016-07-19T22:31:39Z",
	"updated_at": "2016-07-19T22:31:39Z"
}
