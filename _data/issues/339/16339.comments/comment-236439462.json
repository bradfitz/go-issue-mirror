{
	"id": 236439462,
	"body": "I'm still in the camp that's looking for a good use case for this proposal.\r\n\r\n- The large-scale refactoring within Google _sounds_ like it could have a different solution, specially given that in their particular use case they have a monorepo, so _in principle_ moving types from one package to another can be done mechanically. This proposal in helps with that particular type of refactoring: moving types around. The old package has to have something (an alias in this proposal) that provides the complete old API and somehow forwards that to the new type. Specifically this proposal does not help _directly_ with refactorings that involve both a move and change. It does help with situations where old types are moved to new packages, and the target packages are not all the same. This proposal actually sounds more useful in cases where the monorepo doesn't exist, but even in that case it's possible to imagine solutions for some cases. In the general case this proposal would help with that, as the types can be added in their new homes, and then the aliases can be added in their old locations. Under that light I'm not seeing the \"this benefits mostly Google\" argument.\r\n\r\n- the x/net/context â†’ context move doesn't really benefit from this proposal, at least not as much as people seem to think it does. Both context packages export _two_ types: the `context.Context` interface and `context.CancelFunc`. Many functions in the original package return `context.Context` and some return `context.CancelFunc`. There are \"constructor\" functions that return instance of non-exported types as `context.Context`. Given that interface satisfaction is implict, the `context.Context` type returned from `x/net/context` can be passed to functions taking `context.Context` from the new package. Furthermore, `x/net/context` is _already_ importing `context` in order to provide a compatibility layer between the two packages. The problematic type (`context.CancelFunc`) is simply casted back and forth. With this proposal the compatibility layer would be even smaller, yes. I don't see why the generated code would be any faster (or more efficient in general), so this argument is about having a simple way to maintain an old API.\r\n\r\n- the protobuf case is for me the most compelling example so far and it's actually the same as what I was mentioning in the first bullet above: the the `.proto` files you _remove_ \"types\" from one package (`old.proto`) and _add_ them to a new package (`new.proto`). In order to not break existing clients of `old.proto`, you simply add `import public \"new.proto\"`, which in Go-ish terms reexports the public identifiers found in `new.proto` as if they were part of `old.proto`. But again, for this to work, the new package is not changing the old type. Also note that in this particular case, the new proto package is _not_ free to add new types because they become part of the old package. This is not a concern for this proposal because the reexporting happens at the type level, not the whole package level. The other thing mentioned in the context of protobuf is breaking the API in two, and in theory the old API would be built from a simple composition of (parts of) the two new APIs. The new APIs would be free to provide additional functions acting on the old types, but the types themselves would be the same (including their method sets).\r\n\r\nThere's the concern for what godoc would do. Consider this:\r\n\r\n```\r\npackage A\r\n\r\ntype X struct {\r\n        y Y\r\n}\r\n\r\ntype Y int\r\n```\r\n\r\nand\r\n\r\n```\r\npackage B\r\n\r\nimport \"A\"\r\n\r\ntype U =\u003e A.X\r\n```\r\n\r\nhere `B.U` is an alias for `A.X`, and it contains a member of type `A.Y` which doesn't have an alias. Note that while most of the discussion so far has used the form \"type X =\u003e A.X\", the proposal doesn't place limits on the new name. If the documentation is simply inlined, it's fair to assume that it will talk about \"X\" and maybe even \"Y\". When godoc displays the definition of the type U, it would either have to inline the type `A.X` or spell out the fact that this is an alias. The first option doesn't make sense because it refers to a non-existent `Y`.\r\n\r\nWhat if A looks exactly the same, but it's in an internal package? Meaning B looks like this:\r\n\r\n```\r\npackage B\r\n\r\nimport \"internal/A\"\r\n\r\ntype U =\u003e A.X\r\n```\r\n\r\ngodoc doesn't even hint at A's existence. What would it say that `U` is an alias for if it doesn't display the documentation for `A` at all? (look for example at the current documentation for the image package).\r\n\r\nDoes this mean that B must have its own documentation?",
	"user": {
		"login": "mem",
		"id": 189701,
		"type": "User",
		"site_admin": false
	},
	"reactions": {
		"total_count": 1,
		"+1": 1
	},
	"created_at": "2016-07-31T16:22:32Z",
	"updated_at": "2016-07-31T16:22:32Z"
}
