{
	"id": 236306539,
	"body": "I have a couple of things to notice about this.\r\n\r\nFirst, it has been mentioned that Go itself would benefit from this in order to make the internals cleaner. Probably the proposal would have been received better with that context in mind rather than the Google example.\r\n\r\nSecond, and a more important one, people are happy with tools being broken or not under the alias syntax properly.\r\nI think this is the worst outcome that this proposal could have if accepted.\r\nHaving an extra layer of indirection will bring a host of problems to this and will make understanding of code harder. And mind you, Guru and godoc are not the only tools that need updated.\r\n\r\nNow talking about the proposal itself.\r\n\r\nIt feels like the proposal will be pushed forward despite all the negative comments and concerns from the community, some coming from googlers as well.\r\n\r\nI understand the problem that the proposal wants to fix, allow packages to move at their own maintainer speed towards the new implementation but I do see the following case for it: the whole issue assumes that there can't be a tool which automates refactoring of the import path to point from the old path to the new path. However I think I would trust more a tool to do that refactoring than humans to update to the latest and greatest package.\r\n\r\nAlso the proposal ignores the fact that usually, after moving the package/type around, one would usually immediately change the functionality as well. In that case, the aliases will point to the changed versions as well, so I don't get how alias will help.\r\nIf anything, aliasing will just delay the inevitable and when the aliased type will change the code that uses the alias will need to be changed as well.\r\n\r\nAnother point that maybe I've missed from the alias proposal, will one be able to define methods on the alias or only on the aliased type. If the former then this will make things even worse for using this feature.\r\n\r\nFinally, I strongly think this is a bad feature to have in Go.\r\nNothing that has been said can't be solved with versioning and SemVer. This solution allows me to prevent upgrading to the said breaking version than being forced into updating to the latest version because there's nothing else to be done.\r\nOther languages seem to be doing just fine with that and while it relies on authors getting that right. Which, seems to be the point of relying on people not abusing aliases. \r\n\r\nTo sum it up:\r\nAlias won't bring anything but delays into upgrading the package until a subtle break will be introduced and things won't compile. At that point I'd rather have a SemVer for the the said package rather than start figuring out why the alias stuff doesn't work anymore.\r\nAnd not only Go will need to be updated, but the all the tools in the ecosystem as well. \r\nThe mental overhead it adds and complexity when the aliased type upgrades bring more work for the user which is contrary to the main benefit (for me) of Go: quick and simple to understand. \r\n\r\nEdit:\r\nYes, I understand that large scale software engineering problems are hard and I'm not able to comprehend them to the full extent but after watching a lot of talks about how Google specifically organizes its codebase and how awesome are the automated refactoring tools and mono-repo is great, I do wonder at which scale does this issue really happen that I cannot comprehend it well enough to understand the benefits of this proposal.",
	"user": {
		"login": "dlsniper",
		"id": 607868,
		"type": "User",
		"site_admin": false
	},
	"reactions": {
		"total_count": 3,
		"+1": 3
	},
	"created_at": "2016-07-29T22:10:35Z",
	"updated_at": "2016-07-29T22:40:53Z"
}
