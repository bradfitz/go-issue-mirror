{
	"id": 236390529,
	"body": "@dlsniper \r\n\r\n\u003e I'll be the first one to say it: Go is not representative for software written in Go. There are many libraries / apps out there that would like to break compatibility but can't because of how packages are currently handled.\r\n\r\nYou can break compatibility. But it implies creating another package. In fact, it has the same effect either way : clients have to be updated in both cases. It's no problem. I exaggerate: breaking compatibility within a package is worse since it breaks clients that were not interested in moving to the new version.\r\n\r\nThe design of Go being oriented toward backward-compatibility is a good thing because everyone is ideally forced to pay much more attention to an API before releasing it in the wild.\r\nConstraints make better.\r\n\r\nNow we just need a release methodology and maybe some tooling associated with it. (not necessarily a \"package manager\" as currently exist for other languages.)\r\n\r\nAnyway, that's slightly off-topic :)",
	"user": {
		"login": "atdiar",
		"id": 12191458,
		"type": "User",
		"site_admin": false
	},
	"reactions": {
		"total_count": 1,
		"+1": 1
	},
	"created_at": "2016-07-30T21:19:14Z",
	"updated_at": "2016-07-30T21:26:00Z"
}
