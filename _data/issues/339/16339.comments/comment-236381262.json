{
	"id": 236381262,
	"body": "@dlsniper \r\n\u003e for normal projects, once you move stuff around, the next thing you'll want to do is to also change the API in some cases\r\n\r\nThere are existing, backward-compatible patterns that suffice for most other API changes: for example, adding methods or fields to concrete struct or pointer types is already backward-compatible.  Aliasing does not - and does not need to - address the use-cases that Go already handles well.\r\n\r\n\u003e Please explain how an automated tool [...] isn't effective at any scale inside an organization with high velocity? Surely this can be done when people are not working on the code base, \r\n\r\nThere is never a time during which people, users, and/or other automatic tooling are not working on the codebase.  Doubly so for open-source projects (including `protobuf`).  Even if there were such a time, at scale it is necessary to be able to make multiple changes at once.\r\n\r\nFor that matter, as Ian points out, you cannot upgrade the code you cannot see.  If you provide an open-source package, how will you send pull requests to your users who have not published their source code?\r\n\r\nIf you're dealing with contributors and users from around the world - whether in a large corporation or a large set of open-source projects - it simply isn't practical to stop the rest of development while you refactor all of the call sites of some particular package.\r\n\r\nAn automated tool doesn't help resolve diamond dependencies (per [my previous comment](https://github.com/golang/go/issues/16339#issuecomment-235705270)), particularly when only a subset of types are moved from one package to another.  (Moving an entire package such as `context` is just one example - and a fairly simple one at that.)\r\n\r\nSo moving to the kind of semantic-versioning world you're proposing would require:\r\n* All users of Go packages to publish all of their Go code.\r\n* All users of Go packages to standardize on and migrate to some semantic-versioning tool.\r\n* All users and maintainers of Go packages to do their development only on public branches and to accept pull requests on those branches ~immediately.\r\n* All maintainers of widely-used Go packages to publish sophisticated migration tools whenever they change package boundaries.\r\n* All maintainers of Go packages to maintain backports of critical bugs on all release branches, rather that just fixing those bugs at head.\r\n\r\n...and that's not even considering the documentation and discoverability problems introduced by having multiple published versions.\r\n\r\nThat's a *much* more invasive change - and, I'd argue, a much higher burden on Go users - than merely adding type aliases to the language.  Especially when you consider the fraction of Go programmers who are already familiar with aliases from working with other languages.\r\n\r\n\u003e If I suddenly want to add a method to an interface that's aliased or change its signature everything else will break, alias or not. If you are suggesting that we allow method definitions on aliases [...]\r\n\r\nAliases would not allow you to add methods to interfaces or change interface signatures.  Fortunately, I think most providers of Go APIs already understand that and are careful to engineer around it (e.g. by exporting concrete types instead).\r\n\r\nNobody is proposing to allow method definitions on aliases.  (And note that most other languages with type aliases do not allow the addition of methods to aliased types either.)",
	"user": {
		"login": "bcmills",
		"id": 5200974,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-30T18:25:34Z",
	"updated_at": "2016-07-30T18:25:34Z"
}
