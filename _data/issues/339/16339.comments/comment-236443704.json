{
	"id": 236443704,
	"body": "@josharian\r\nI don't understand what the build-comment is supposed to solve. It seems semantically equivalent - whether the go tool rewrites the code passed to the compiler or the compiler enacts the semantic change, the fact remains that the definition of the type changes it's package, so tools need to be able to cope with that and show it in a decent way. The abuse concerns also don't change, as it's the same feature, whether you abuse a build-directive or a language feature doesn't seem to make a big difference. So I don't think that's a good idea. If anything, it's mostly a syntactical modification or implementation detail, we would first need to agree on the semantics of when and how aliases would work, before we can bikeshed on syntax or implementation.\r\n\r\n@mem \r\n\u003e Specifically this proposal does not help directly with refactorings that involve both a move and change.\r\n\r\nMoving types and changing them are really orthogonal problems with orthogonal solutions. Changing them already has a technical solution in the form of temporary shims. So I disagree: As this proposal or something similar, is a prerequisite for moving, it's also a prerequisite for moving and changing. It helps directly, because the two are independent and it enables one of the two.\r\n\r\n\u003e Given that interface satisfaction is implict, the context.Context type returned from x/net/context can be passed to functions taking context.Context from the new package.\r\n\r\nYes, but we don't have covariant interface types, meaning that while you can pass a `context.Context` as a `x/net/context.Context` and vice versa, you can't pass a `func(context.Context)` as a `func(x/net/context.Context)` (excuse the bastardized notation), which is really at the heart of the issue. In the end, if you have a couple of packages, each taking and passing various higher-order versions of `func(Context,…)` and you want to move all of them to a post-go1.7 world of using the stdlib-version, you need to either change all at once (otherwise values of one package can't be passed to values of other packages).\r\n\r\nThe only other way I could see to provide a graceful upgrade path, would be to\r\n\r\n* introduce a globally unique build-tag `newcontext` (or something)\r\n* change every package to provide a shim that transforms a `context`-based API to a `x/net/context` based API and maintain both for a while\r\n* after everyone have implemented the switch, do every build with the `newcontext` build-tag\r\n* switch the untagged-API for each package to use `context` (everything will continue to build, as the build-tag is used by everyone, so everyone provides a `context`-based API)\r\n* after everyone has removed the shim, abandon the `newcontext` build-tag\r\n\r\nAnd yes, you can of course replace the idea of a build tag by semantic versions and simply ignore the \"graceful\" part, but it won't change the general process.\r\n\r\nCompare this with an alias-based approach of gradually upgrading:\r\n\r\n* define all exported identifiers of `x/net/context` to be aliases of `context` (guarded by the go1.7 tag, of course)\r\n* wait for approximately everyone to move to `context` (as the two packages now provide the same type, there is no shim or extra build tag needed).\r\n* remove `x/net/context`\r\n\r\nNote that we have deprecated packages before (`syscall` is, AFAIK, mostly deprecated and should be replaced by `x/sys/…`), so the second step is not without precedent. Even if the second step would be infeasible, there is minimal cost associated with just leaving the `x/net/context` package just lying around and everything would continue to work.\r\n\r\n\u003e The problematic type (context.CancelFunc) is simply casted back and forth. With this proposal the compatibility layer would be even smaller, yes. I don't see why the generated code would be any faster (or more efficient in general), so this argument is about having a simple way to maintain an old API.\r\n\r\nNo, it's about providing a graceful upgrade path. Yes, `CancelFunc` (and similar types. Don't think that this problem can be viewed only as a problem of `context`, it's a mostly a problem of third-party packages *using* `context`) can be converted, but that requires a source-change and thus it will break builds in the meantime.\r\n\r\n\u003e Also note that in this particular case, the new proto package is not free to add new types because they become part of the old package.\r\n\r\nThat's a backwards-compatible change (pretty much the only one you can do), ignoring `.`-imports, so I wouldn't worry about that :)\r\n\r\n\u003e There's the concern for what godoc would do\r\n\r\nI think that's, for now, an implementation detail that can be hashed out after general consensus has been reached. I, personally, would expect it to either automatically or manually forward me.\r\n\r\n\u003e What if A looks exactly the same, but it's in an internal package?\r\n\r\nWhile some people have expressed that they'd want aliases into internal packages to be allowed, I still don't like the idea. Note, however, that godoc [doesn't give a damn](https://godoc.org/golang.org/x/build/internal/httpdl) about whether a package is internal or not :)",
	"user": {
		"login": "Merovius",
		"id": 720787,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-31T17:26:19Z",
	"updated_at": "2016-07-31T17:26:19Z"
}
