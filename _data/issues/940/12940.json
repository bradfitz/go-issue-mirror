{
	"id": 111463037,
	"number": 12940,
	"state": "closed",
	"title": "fmt: Scanf supports %X for integers but not strings. [Patch+Tests included]",
	"body": "The fmt Documentation states two things:\r\n\r\n* Firstly, for Printing:\r\n```\r\nString and slice of bytes (treated equivalently with these verbs):\r\n\r\n%s\tthe uninterpreted bytes of the string or slice\r\n%q\ta double-quoted string safely escaped with Go syntax\r\n%x\tbase 16, lower-case, two characters per byte\r\n%X\tbase 16, upper-case, two characters per byte\r\n```\r\n* Secondly, for Scanning:\r\n```\r\nThe formats behave analogously to those of Printf with the following exceptions:\r\n\r\n%p is not implemented\r\n%T is not implemented\r\n%e %E %f %F %g %G are all equivalent and scan any floating point or complex value\r\n%s and %v on strings scan a space-delimited token\r\nFlags # and + are not implemented.\r\n```\r\n\r\n(Note how `%X` is not listed among the exceptions)\r\n\r\nSo given the following:\r\n```go\r\nvar (\r\n    hex = \"48C3A43F\"\r\n    b   []byte\r\n    i   int\r\n    s   string\r\n)\r\n\r\nfmt.Sscanf(hex, \"%X\", \u0026b)\r\nfmt.Sscanf(hex, \"%X\", \u0026i)\r\nfmt.Sscanf(hex, \"%X\", \u0026s)\r\nfmt.Println(\"Bytes:  \", b)\r\nfmt.Println(\"Integer:\", i)\r\nfmt.Println(\"String: \", s)\r\n```\r\none would assume that `b`, `i` and `s` now respectively contain byte and integer representations of the hex-value `48C3A43F`. **However, this is not the case!** Instead, the following output is generated:\r\n\r\n```\r\nBytes:   []\r\nInteger: 1220781119\r\nString:  \r\n```\r\n\r\nOnly the integer variable gets correctly assigned.\r\n\r\n**But:** Substituting `\"%X\"` with lower-case `\"%x\"` in the example above gives the **desired output**:\r\n```\r\nBytes:   [72 195 164 63]\r\nInteger: 1220781119\r\nString:  HÃ¤?\r\n```\r\n\r\n**I conclude that this behavior is a bug.** Either the verb `\"%X\"` should be explicitly listed as an exception in the Scanning-documentation or it should be fully supported for all relevant types.\r\n\r\nI therefore submit the following patch (including additional relevant tests) which adds support for upper-case `\"%X\"` when scanning into []byte or strings:\r\n\r\n```diff\r\ndiff --git a/src/fmt/scan.go b/src/fmt/scan.go\r\nindex e3e0fd0..68cb8bb 100644\r\n--- a/src/fmt/scan.go\r\n+++ b/src/fmt/scan.go\r\n@@ -813,7 +813,7 @@ func (s *ss) scanComplex(verb rune, n int) complex128 {\r\n // convertString returns the string represented by the next input characters.\r\n // The format of the input is determined by the verb.\r\n func (s *ss) convertString(verb rune) (str string) {\r\n-\tif !s.okVerb(verb, \"svqx\", \"string\") {\r\n+\tif !s.okVerb(verb, \"svqxX\", \"string\") {\r\n \t\treturn \"\"\r\n \t}\r\n \ts.skipSpace(false)\r\n@@ -821,7 +821,7 @@ func (s *ss) convertString(verb rune) (str string) {\r\n \tswitch verb {\r\n \tcase 'q':\r\n \t\tstr = s.quotedString()\r\n-\tcase 'x':\r\n+\tcase 'x', 'X': // s.hexString() supports both upper and lower-case hex strings, so we can support both verbs here.\r\n \t\tstr = s.hexString()\r\n \tdefault:\r\n \t\tstr = string(s.token(true, notSpace)) // %s and %v just return the next word\r\ndiff --git a/src/fmt/scan_test.go b/src/fmt/scan_test.go\r\nindex 334c4a6..1924c02 100644\r\n--- a/src/fmt/scan_test.go\r\n+++ b/src/fmt/scan_test.go\r\n@@ -255,12 +255,14 @@ var scanfTests = []ScanfTest{\r\n \t// Strings\r\n \t{\"%s\", \"using-%s\\n\", \u0026stringVal, \"using-%s\"},\r\n \t{\"%x\", \"7573696e672d2578\\n\", \u0026stringVal, \"using-%x\"},\r\n+\t{\"%X\", \"7573696E672D2558\\n\", \u0026stringVal, \"using-%X\"},\r\n \t{\"%q\", `\"quoted\\twith\\\\do\\u0075bl\\x65s\"` + \"\\n\", \u0026stringVal, \"quoted\\twith\\\\doubles\"},\r\n \t{\"%q\", \"`quoted with backs`\\n\", \u0026stringVal, \"quoted with backs\"},\r\n \r\n \t// Byte slices\r\n \t{\"%s\", \"bytes-%s\\n\", \u0026bytesVal, []byte(\"bytes-%s\")},\r\n \t{\"%x\", \"62797465732d2578\\n\", \u0026bytesVal, []byte(\"bytes-%x\")},\r\n+\t{\"%X\", \"62797465732D2558\\n\", \u0026bytesVal, []byte(\"bytes-%X\")},\r\n \t{\"%q\", `\"bytes\\rwith\\vdo\\u0075bl\\x65s\"` + \"\\n\", \u0026bytesVal, []byte(\"bytes\\rwith\\vdoubles\")},\r\n \t{\"%q\", \"`bytes with backs`\\n\", \u0026bytesVal, []byte(\"bytes with backs\")},\r\n ```",
	"user": {
		"login": "benthor",
		"id": 623903,
		"type": "User",
		"site_admin": false
	},
	"comments": 4,
	"closed_at": "2015-10-20T01:09:14Z",
	"created_at": "2015-10-14T18:38:13Z",
	"updated_at": "2015-10-20T01:09:14Z"
}
