{
	"id": 66049770,
	"body": "\u003ca id=\"c4\"\u003e\u003c/a\u003eComment 4 by **jpetkau**:\n\n\u003cpre\u003eAlready closed, so I suppose there's not much point adding to this, but this issue \n(broken integer division and modulus) is a pet peeve of mine, and I was disappointed \nto find it in Go.\n\n\u0026gt; the current semantics for % is directly available as a result from x86 \narchitectures\n\nUnfortunately true, but:\n\n\u0026gt; it's fairly easy to compute another modulus from the % result\n\nSort of. There are two ways to do it: doing an extra (expensive) division\n\n    ((m % n) + n) % n;\n\nor doing an extra (expensive) conditional\n\n    temp = m % n\n    if temp \u0026lt; 0: temp += n\n\nHopefully the compiler will see that it can do a conditional move in the second case, \nbut it's not obvious.\n\n\u0026gt; it would be confusing to change the meaning of the elementary operator % and not \nchange its name\n\nConfusing to existing Go users for a little while, but there aren't many of them yet.  \nUsers from other languages will expect different behavior; Python, for example, \ntruncates integer division toward negative infinity and thus % / remainder / modulus \nare all the same thing.\n\nThe real problem with the current behavior is that it's literally useless. I defy you \n(= whoever reads this) to come up with *any* example where round-toward-zero is \nactually the desired behavior (by which I mean, it translates into simpler code.) \nThere are basically only three cases that actually occur in practice:\n\n1. (very common) The divisor is known to be positive, so the behavior doesn't matter\n2. (occasional) Negative numbers have to be handled specially anyway, so the behavior \ndoesn't matter.\n3. (common) Modulus is the desired behavior, and dealing with negative remainders is \na pain.\n\nFor example: how do you adjust an array index with wraparound?\n  array[(i+step) % arraysize] vs. array[(i+step+arraysize) % arraysize] vs. \narray[((i+step)%arraysize+arraysize)%arraysize].\n  Note that the second example is correct for small steps but breaks when they get \nbig enough.\n\nOr date arithmetic:\n  (weekday + delta_days) % 7 vs. ((weekday + delta_days) % 7) + delta_days) % 7 vs. \nthe incredible buggy hacks that people actually come up with\n\nAnd since this is already turning into a rant, float-to-int conversion has the same \nproblem (truncate toward zero). And you can't claim that it's better on x86--in fact \nyou have to jump through terrible hoops to do it, messing with the rounding modes and \nall. (Ok, not so much these days, since SSE2 finally baked this abomination into \nsilicon. But it's still shameful.)\n\nIf it really is too late to change the language, could there perhaps be some \nadditions to the Math package, with standard implementations of the sane behavior, \nand some expectation that the compiler would know about them and compile them into \nthe appropriate instructions? E.g.\n\ndiv(i1,i2) // integer division with round to -inf\nmod(i1,i2) // modulus, with div(i1,i2)*i2 + mod(i1,i2) == i1\n\nifloor(float) // convert float to int, rounding toward -inf\niceil(float) // convert float to int, rounding toward +inf\niround(float) // convert float to int, using ieee round-to-nearest\nitrunc(float) // convert float to int, rounding toward zero\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2010-02-04T04:49:11Z",
	"updated_at": "2014-12-22T05:45:50Z"
}
