{
	"id": 145004656,
	"body": "Firstly, thank you for responding so quickly. Secondly, I should apologize for saying the problem is \"very easily solved\". It definitely comes off as glib, which I didn't realize when writing it. In addition I don't think I explained some of the usage scenarios I had in mind properly. Now onto your questions.\r\n\r\n\u003e Besides, I want to know how to handle the case when exported functions of pkg1 and pkg2 both depend on some types of pkg3.\r\n\r\nThat's a very good point. What I described earlier doesn't address this properly since there is room for user error when running `gobind` manually for each package, which is never a good thing. Having said that, a single step for code generation makes the \"separate bind and build\" irrelevant for this specific issue. Now that I think about it, I was primarily motivated by some other problems I am currently facing with having the code gen and build be part of one step. I'll answer your questions regarding that in a separate comment and create a separate issue for the questions I have. \r\n\r\n### Proposal\r\n\r\nThere are two parts to this. One addresses the problem of manually wrapping libraries and the other, sharing cross platform code.\r\n\r\n#### Binding multiple libraries in the face of package conflicts\r\n\r\nCreate a main file as you suggested in Option 3. Instead of adding comments per package just list all the packages. For packages that have name collisions use the standard Go mechanism of resolving name collisions.\r\n\r\n    package main\r\n    \r\n    import (\r\n    \t_ \"pkg1\"\r\n        otherpkg1 \"some/other/pkg1\"\r\n        _ \"pkg2\"\r\n    )\r\n    \r\n    // Avoid the unused import warning\r\n    var _ = otherpkg1.SomeFunction\r\n    \r\n    func main() {\r\n    \tpanic(\"placebo main\")\r\n    }\r\n\r\n\r\nNow run `gomobile bind` as you decided on earlier, but instead of listing all packages just point to this main package.\r\n\r\nJava:\r\n\r\n    $ gomobile bind -target=android -pkgpath=com.golang.app path.to.main.package\r\n\r\nObjective-C:\r\n\r\n    $ gomobile bind -target=ios -prefix=App path.to.main.package\r\n\r\nThis makes it consistent with how go resolves the same package namespace collision issue and keeps things simple as with your earlier decision. Things can be made even simpler if you disallow having any other exported members in the main package so you don't have to worry about how to bind those.\r\n\r\n#### Sharing libraries with supporting Java or ObjC code \r\n\r\nThis is a separate issue, but it is affected by the choice of prefix/package path.\r\n\r\nConsider the following scenario. I am writing an SDK app with go code shared between iOS and Android. I want to do the following in my shared go code:\r\n\r\n   * Know which directory to store my database files in.\r\n   * Know whether the network is on WiFi or 3G so I can decide whether or not to download a file.\r\n   * Run a download in the background.\r\n\r\nAll the above have standardized solutions in Android and iOS respectively. If I wanted a common interface to the above I could write a go library that accepts an interface and have Java/ObjC implement that interface. The go code then calls that interface to get the directory, network state, etc. This is the kind of code that can easily live in a third party library and make development easy for everyone. However, in order to do this, the library author needs to know what Java interface / ObjC protocol to implement in their Java / ObjC supporting code. \r\n\r\nOne solution is to allow package authors to specify their own Java/ObjCpackage prefix.\r\n\r\n    //Package network implements cross-platform support for network state on iOS and Android\r\n    package network // java:com.foo.network ios:GoNet\r\n    \r\nPackages that force a prefix are disallowed from having third party package references in their exported code. This ensures that the problem you described does not occur.\r\n\r\nNow I can do the following:\r\n\r\n    $ go get gomobile/support # (or something similar)\r\n\r\nAnd write go code like so:\r\n\r\n    import (\r\n        \"gomobile/support/network\"\r\n        \"gomobile/support/storage\"\r\n    )\r\n\r\n    func DoSomething() {\r\n    \tswitch network.Type() {\r\n        case network.WiFi:\r\n\t    // do something\r\n        }\r\n    }\r\n\r\n    func DoSomethingElse() {\r\n    \t// ... compute url\r\n        location := filepath.Join(storage.UserDataDir(), \"somefile\")\r\n        network.DownloadInBackground(url, location)\r\n    }\r\n\r\nThe `network` and `storage` packages would handle their platform specific code by using their SDK provided Java/ObjC code.\r\n\r\n*Distributing the supporting code*\r\n\r\nFor this, one way would be to ask library authors to use the native code distribution options for their language. They would use Maven for Java and Cocoapods/Carthage for iOS. They just have to be careful not to package the generated binding code. Another would be allow them to place these files in a directory in their go tree. These files are then automatically copied by `gomobile bind` when it is generating the bindings for these packages. This makes things easier since a user of the library would just `go get` a library and be able to use it without having to worry about the right version of the supporting native code.\r\n\r\nThe `gobind` tool could follow the convention that any files found in a directory named `java` under a go package are copied to the generated java package. For ObjC a directory named `objc` is treated similarly. It would be simpler to have the Java and ObjC files live in the same directory as the go package, but this causes problems when building for android since the `go` tool complains about ObjC files being present without cgo being used.\r\n\r\nI'll put together a small prototype describing the above scenarios so it is clearer.\r\n",
	"user": {
		"login": "sridharv",
		"id": 326998,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-10-02T12:32:30Z",
	"updated_at": "2015-10-02T12:32:30Z"
}
