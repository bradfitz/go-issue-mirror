{
	"id": 250431840,
	"body": "The links were meant as just an example of (maybe) unexpected EPOLLET behavior.\r\n\r\nAs to why/when notification happen - that's a longer story.\r\n\r\nTL;DR: zillions of notifications don't appear on 3.10.0-327.28.2.el7.x86_64 and up.\r\n(and yes, the machines affected were running 3.10.0-327.18.2.el7.x86_64, not -36.1)\r\n\r\nAs for the 3.10.0-327.18.2.el7 code path: `unix_dgram_recvmsg()` (handling AF_LOCAL datagram input, as the name suggests) ends its processing trying to free the datagram (`skb_free_datagram()`). This passes control to the appropriate destructor - `unix_destruct_scm()` in case of AF_LOCAL sockets. This one in turn calls the generic `sock_wfree()`:\r\n\r\n```\r\n/*\r\n * Write buffer destructor automatically called from kfree_skb.\r\n */\r\nvoid sock_wfree(struct sk_buff *skb)\r\n{\r\n        struct sock *sk = skb-\u003esk;\r\n        unsigned int len = skb-\u003etruesize;\r\n\r\n        if (!sock_flag(sk, SOCK_USE_WRITE_QUEUE)) {\r\n                /*\r\n                 * Keep a reference on sk_wmem_alloc, this will be released\r\n                 * after sk_write_space() call\r\n                 */\r\n                atomic_sub(len - 1, \u0026sk-\u003esk_wmem_alloc);\r\n                sk-\u003esk_write_space(sk);\r\n                len = 1;\r\n        }\r\n        /*\r\n         * if sk_wmem_alloc reaches 0, we must finish what sk_free()\r\n         * could not do because of in-flight packets\r\n         */\r\n        if (atomic_sub_and_test(len, \u0026sk-\u003esk_wmem_alloc))\r\n                __sk_free(sk);\r\n}\r\n```\r\n\r\n`sk_write_space()` for AC_LOCAL is set to `unix_write_space()`:\r\n\r\n```\r\nstatic inline int unix_writable(struct sock *sk)\r\n{\r\n        return (atomic_read(\u0026sk-\u003esk_wmem_alloc) \u003c\u003c 2) \u003c= sk-\u003esk_sndbuf;\r\n}\r\n   \r\nstatic void unix_write_space(struct sock *sk)\r\n{\r\n        struct socket_wq *wq;\r\n\r\n        rcu_read_lock();\r\n        if (unix_writable(sk)) {\r\n                wq = rcu_dereference(sk-\u003esk_wq);\r\n                if (wq_has_sleeper(wq))\r\n                        wake_up_interruptible_sync_poll(\u0026wq-\u003ewait,\r\n                                POLLOUT | POLLWRNORM | POLLWRBAND);\r\n                sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\r\n        }\r\n        rcu_read_unlock();\r\n}\r\n```\r\n\r\nA notification will be generated provided there is buffer space available (a new event every time, even with EPOLLET). With many packets received, expect even more than zillions of notifications.\r\n\r\nSee also: http://vger.kernel.org/~davem/skb_sk.html\r\n\r\nBut now, the bomb: some recent AF_LOCAL changes backported to 3.10.0-327.28.2.el7 (and up) hide the problem.",
	"user": {
		"login": "tpotega",
		"id": 20204290,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-09-29T10:43:08Z",
	"updated_at": "2016-09-29T10:43:08Z"
}
