{
	"id": 168224900,
	"body": "I'm hearing two design preferences:\r\n 1. Prefer to copy dependencies you don't control into the local repository and write down the revision you copied.\r\n 2. Prefer to not copy into your repository and split what you write down into two files, a design file and a lock file.\r\n\r\nWe agree that:\r\n * encouraging code authors to release their code in some manner is a good thing.\r\n * writing down the final revision you use in an executable is important for reproducible builds.\r\n\r\n---\r\n\r\nIn your examples, you put the version spec in the design file and the revisions in the lock file. If the tools you used copied the version spec and any other needed information into the lock file, then you would only need the one file when comparing versions.\r\n\r\nI have considered adding a version field to the vendor-spec, but I need to get experience with versions, in Go, before doing so. As such I was going to implement remote package fetching and then version parsing in govendor to gain such experience in Go.\r\n\r\nThe vitess sub-package I use in my db interface doesn't require that downstream developers fetch vitess because I've copied the packages I need locally.\r\n\r\n---\r\n\r\nYou are correct that the Go specification was written with many past examples to draw from. It also drew from examples of what not to do. In consulting, I often see users define use cases that made sense in their previous paradigm (old software or on paper), but isn't fully valid in the new paradigm (new software). But that doesn't mean the use cases were without reason.\r\n\r\nI enjoy hearing specifics of what other package managers do and how you have used them. I am confidant that a reader of this issue will fully see the details of two perspectives presented here.\r\n\r\nMy question is, is there design room to enable both methods in the same file format?\r\n\r\n---\r\n\r\nI have observed that while I usually want to copy packages locally, there are cases where I totally understand the need not to. I think Cockroach DB offers a good example of a need to not copy packages locally. It depends on a few large C++ dependencies it statically links in and are largely developed separately. It also depends on a few other large dependencies it needs to track with upstream. I want to ensure that this is possible with any vendor-spec.\r\n\r\nI understand your experience with PHP and would like to assist if I can, but I would like you to understand that I see version ranges as a symptom of a much greater problem. When I see version ranges for puppet and ruby and other systems, I gag. I am (unfortunately) familiar with what you are describing and the experience has not left a nice taste. The alternative is to encourage releases and to encourage package stability. When you update to a new revision, you double and triple check everything is still alright. That might sound trite but I am completely serious. \r\n\r\nLet me put this another way. I'm a fan of up-to-date static containers. I'm less of a fan of the current state of Linux package managers where everything depends on everything else (Can I build the latest version of X? No, I'm on an stable release and I don't have the right libs for that.). If Linux dependency managers are modern then containers are neo-modern.\r\n\r\n...\r\n\r\nAs a side note, go already has the ability to offer redirects to go packages:\r\n * https://godoc.org/k8s.io/kubernetes/pkg/client\r\n * https://godoc.org/rsc.io/pdf\r\n\r\nGo offers a level of indirection not with a central clearing house, but decentralized, the neo-modern way.\r\n",
	"user": {
		"login": "kardianos",
		"id": 755121,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-31T17:19:16Z",
	"updated_at": "2015-12-31T17:19:16Z"
}
