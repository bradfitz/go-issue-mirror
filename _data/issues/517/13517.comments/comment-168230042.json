{
	"id": 168230042,
	"body": "\u003e When you update to a new revision, you double and triple check everything is still alright. That might sound trite but I am completely serious.\r\n\r\nI don't think it's trite at all.  Regardless of the package manager in use, you have tests, you run tests with a CI system, and you don't deploy unless everything is green. I don't think that's a controversial statement to make.  (That's one reason why everyone here seems to be on board with a machine-readable lock file that references commit hashes as a part of the solution.)\r\n\r\n\u003e I would like you to understand that I see version ranges as a symptom of a much greater problem.\r\n\r\nThis is the part I don't get.  Why is that a problem?  I tested my YAML library, version 1.5.2, with the 2.4.3 version of a file system library, and I know that works.  When 2.4.4 comes out, with some bug fixes:\r\n\r\n1. Should I be required to test that and release a new version of my library, 1.5.3, whose only change is that it now depends on 2.4.3 of the FS lib?  That means every time a package is released there's a huge ripple effect on any other packages that use it, all on down the line.\r\n2. Should someone using my YAML library test it with the new 2.4.4 release, then hack the code to make it use the 2.4.4 release instead of the 2.4.3 that it said to use initially?  That seems very error prone.\r\n3. Should we assume that if I declare a compatibility with 2.4.3, then the odds of 2.4.4 working as well are really good and if it's not, that's something for the application instance builder to figure out and report?  (This is what PHP and, AFAIK, most languages now do, and why semver is a necessity.)\r\n\r\nI think (please correct me if I'm wrong here) your ideal world involves no version tags at all, just commit IDs on all the things.  While that does offer a level of predictability, it has two I believe terminal problems:\r\n\r\n1. Without version numbers, there's no way to indicate when a change is \"safe\" for everyone to update to and when it's not, for BC reasons.  BC breaks in code *will happen*, always, guaranteed, and a good package manager needs to make handling that straightforward.  Version numbers that communicate the level of safety are the standard mechanism for that, and I've not found a better one.  \r\n2. As @sdboyer notes, diamond dependencies.  I tested my YAML library with FSLib 2.4.3, and it works.  @sdboyer's Atom parser library was tested with FSLib 2.4.2, and it works.  The latest stable of FSLib is 2.4.5.  Now when you install both my YAML parser and Sam's Atom parser in your application... what version of FSLib should be used?  If both the YAML and Atom parsers are pinned at a specific commit hash (either directly or via a specific tag), you cannot use them at the same time.  The package manager will report a conflict.  If Sam and I both specify a range of \"2.4.x\", then it's clear 2.4.5 should be installed and everything should be fine.  (And yes you still run tests to make sure that's still the case.)\r\n\r\nHow do you solve those issues without version ranges?\r\n\r\n-----\r\n\r\nRe redirects, nifty, I didn't realize that.  I'll have to look into that more the next time I'm messing with Go more regularly.",
	"user": {
		"login": "Crell",
		"id": 254863,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-31T17:57:51Z",
	"updated_at": "2015-12-31T17:57:51Z"
}
