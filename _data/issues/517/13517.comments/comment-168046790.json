{
	"id": 168046790,
	"body": "@jbuberel - ahh, yes, I see what you mean now. Sure, go-kit makes sense as an example. Thanks.\r\n\r\n@ardan-bkennedy - great, so, the crucial question is very clearly out there, now.\r\n\r\n\u003e The language is package oriented.\r\n\r\nYep.\r\n\r\n\u003e A package is the basic unit of compilation, and we are taught to think in terms of components (packages).\r\n\r\nYep.\r\n\r\n\u003e Our API's are based on a package. We import packages. \r\n\r\nYep.\r\n\r\n\u003e So why would package and dependency management not be package based?\r\n\r\nFirst, because Go packages are not (necessarily) individually retrievable units. `go get` creates the illusion that they are - convenient, but illusory. I get that some people may not want to care about this, in the same way that I don't really care about the cardboard boxes Amazon ships me stuff in. But I'm pretty sure that Amazon wouldn't be so successful if they treated boxes as some transparent, irrelevant detail around my stuff.\r\n\r\nSecond, as previously noted in this thread, versions matter, and versions are a property of the SCM, not the Go package.\r\n\r\nI realize these points might seem like small details. But I'd encourage folks to step back and think about other situations where information from one discrete level of a software architecture has been conflated into another. In bad cases, these sorts of issues are difficult to diagnose (or even comprehend), and can induce *years* of hair-tearing. This, IMO, is one such case.\r\n\r\n\u003e Back in 2013 when I learned how go get worked, it seemed that a repo should represent a single package. This would allow the package to be go gettable and everything that comes with that. But I think we have learned that repo management is a lot of work, so minimizing the number of repos you need to manage is important. This leads to the idea of a repo representing a project.\r\n\r\nI think it's important to distinguish between the general problem of package management, and the lessons that `go get` has taught us over the years. IMO, the vagaries of `go get` have gaslit us, and stuck us optimizing around local optima. The next step forward in this area should be rooted in deeper changes, not course corrections begotten from `go get` experience. \r\n\r\nIn that vein, I see those kit repositories (go-kit, gizmo, yours), and this proposed spec, as a totally reasonable response to the situation `go get` creates. Certainly, I see how your examples address your immediate problem. But this proposal is a very permanent band-aid on just a symptom of the real problem.\r\n\r\nReally, you said as much yourself:\r\n\r\n\u003e In the end for me, this just needs to be manageable to the extent that I am not hesitating to use a dependency.\r\n\r\nI do empathize with this feeling. Very much. Under different circumstances, I would probably agree that it's a good enough basis to move forward with a change that makes an incremental improvement in the status quo. But it's not appropriate here, I think, because there is a **mountain** of prior art on package management - ideas we can follow to escape our local optimum. And this approach would, I suspect, conflict with that.\r\n\r\nI am working on an article that lays out a bigger-picture way of thinking about the information a package manager needs, and how any sort of tool should operate. I hope to have it up by the end of the week.\r\n\r\n---\r\n\r\nAside - the irony here is that we're having these challenges when the structure of Go programs and the constraints of the compiler make solving this problem *so much easier* than it is in other languages - including ones that currently have much better solutions. We have such potential!",
	"user": {
		"login": "sdboyer",
		"id": 21599,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-30T18:06:20Z",
	"updated_at": "2015-12-30T18:40:55Z"
}
