{
	"id": 168100857,
	"body": "I blame @mattfarina for my participation in this thread...\r\n\r\nI'm still very much a baby Gopher.  Maybe Gopher fetus, frankly, as I'm still just playing with Go.  However, I have a long history of PHP experience, including watching the PHP world transition in the last few from a crappy package manager that no one liked (PEAR) to a really nice one that most people are now using (Composer).  I've also been involved in the Drupal community for the past decade, which has had its own package handling for a long time (because PEAR was so poor) and is trying to transition to Composer, a process that is still ongoing.  Hopefully some of that experience here is useful, especially since it seems an awful lot of people migrate to Go from PHP.\r\n\r\nAlso a disclaimer: I used to work with @mattfarina @technosophos and @sdboyer.  (Hi guys!)  However, I've not used Glide, just vanilla `go get` so I have no particular horse in this race myself.\r\n\r\nIt feels like there's an unstated assumption that some are making that is not clear to others.  That is, the needs of a library and the needs of an application instance are quite different.\r\n\r\nA **library** needs to declare (at minimum):\r\n* Its identifier by which others can reference it.\r\n* What its dependencies are, if any.\r\n* The version ranges of those dependencies with which it is compatible (a minimum, maximum, or both)\r\n\r\nAn **application instance** needs to declare (at minimum):\r\n* What its dependencies are, if any.\r\n* The precise version of those dependencies with which it is compatible. In this case, \"precise version\" means commit ID, or something equally precise to indicate a specific snapshot of source code.\r\n* Optionally, post-download instructions or other details relevant only to the top of a dependency tree.  (These could include test-only dependencies.)\r\n\r\nNote specifically that an application instance doesn't need an identifier (although it doesn't hurt it to have one), but more importantly that an application instance needs far greater precision in terms of its dependencies' versions.  That's because a library is specifying \"these are the versions of a dependency you *could* use\", whereas an application instance is specifying \"these are the versions of a dependency you *should* use\".  That's a very important distinction.\r\n\r\nSay I'm releasing a YAML parsing library, and it depends on a file system utility library.  (This example may not make any sense for Go, but swap your own example nouns in if so.)  My YAML library should, assuming no bugs, work with version 2 of the FS library, but not the 1.x version, and I don't know if it will work with the 3.x version that doesn't exist yet.  Or it could depend specifically on the 2.4 version of the library as that version introduced some new feature I rely on.  When 2.4.3 comes out, fixing bugs that I don't care about, I don't want to have to go in and tell my library that it requires 2.4.3 rather than 2.4.2.  Odds are it doesn't matter to me, and it's just more work for me to change the specific commit hash I depend on.  Rather, I depend on a certain public feature set.  Doing so would also preclude another library that want at least the 2.5 version of the FS lib, which would also work fine with my YAML parser but so does 2.4.\r\n\r\nAn application instance, however, does need that specificity.  In order to ensure multiple developers are working with the same dependency, and the CI server is testing the exact same code (and set of bugs) that I have on my laptop, it needs to start from the precise exact same set of lines of code.  If I decide to upgrade one of the libraries my application is using, that should be a conscious, deliberate decision on my part so that everyone on the team gets that change at the same time.  The \"assuming no bugs\" statement that a library can make for its dependencies simply cannot be made by an application instance.\r\n\r\nPackaging solutions that ignore that duality tend to run into problems.  It looks like the Glide Matts tried to avoid it for a long time before finally giving in and accepting the two-case solution: http://technosophos.com/2015/12/11/why-glide-0-8-is-our-biggest-release.html  (That link explains this duality better than I am, probably.)\r\n\r\n(Note that I'm also not covering applications, which are slightly different than application instances.  A ready-to-install application could go either way, depending on specific commits or ranges, depending on a wide number of non-technical factors.  But it will fall into one of those two use cases, so I am not covering it separately.)\r\n\r\nThat is, there's a need for a \"build file\" (which specifies ranges) and a separate \"lock file\" (which specifies precise snapshots by commit ID).\r\n\r\nIt sounds like the OP wants to standardize the lock file, and then punt on the build file.  I firmly believe that is a very bad idea, as those two need to work in concert.  The build file is a human-editable file; the lock file is a more precise result of aggregating all available build files together *at a specific point in time.*  That means every package being aggregated needs to be readable by whatever tool is doing the aggregated.  If some of the libraries in question are using Glide's format, some are using glock, some are using none of the above, then the aggregating tool needs to understand **all** possible build file formats.  Alternatively, every library could maintain redundant copies of a build file, one for each build tool available.  Both of those are crappy situations that should be avoided, hence the need for a standard build AND lock file format.\r\n\r\nAnother important factor here is versioning.  Quite simply, I do not believe any package dependency management system can function without a (near-)universal versioning scheme, which is what Semantic Versioning provides.  Without semantic versioning of packages none of this will work.  Period, kthxbye.  The only way it could work is if no package ever has a BC break ever in its entire commit history, which is about as realistic as the Chicago Cubs winning the Super Bowl.  (Think about it...)\r\n\r\nThus, I would argue that a successful Go package manager file format MUST:\r\n\r\n1. Expect Semantic Versioning of packages.\r\n2. Include a \"build file\" format, that is human-editable that every library uses to declare the version *ranges* of its dependencies that it supports.\r\n3. Include a \"lock file\" format, that is machine-readable that application instances, and only application instances, will include in its repository.  (Libraries would NOT do so.)\r\n\r\nThis wheel has been built before and always ends up round, so let's just skip straight to round wheels.",
	"user": {
		"login": "Crell",
		"id": 254863,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-31T00:45:16Z",
	"updated_at": "2015-12-31T00:56:09Z"
}
