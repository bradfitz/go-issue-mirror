{
	"id": 168026325,
	"body": "@mattfarina @sdboyer. The language is package oriented. A package is the basic unit of compilation, and we are taught to think in terms of components (packages). Our API's are based on a package. We import packages. So why would package and dependency management not be package based?\r\n\r\n_From my point of view of history_\r\n\r\nBack in 2013 when I learned how `go get` worked, it seemed that a repo should represent a single package. This would allow the package to be _go gettable_ and everything that comes with that. But I think we have learned that repo management is a lot of work, so minimizing the number of repos you need to manage is important. This leads to the idea of a repo representing a project.\r\n\r\nA project can take on two forms:\r\n\r\n1) A set of packages that produce a set of binaries for a product or service.\r\n2) A set of packages for use by others. This is where the kit comes in.\r\n\r\nThe Gorilla web toolkit uses a set of repos where each package is contained in a repo. But I think if this was being developed today it would follow what Peter Bourgon is doing with [go-kit](https://github.com/go-kit/kit) and JP Robinson is doing with [gizmo](https://github.com/nytimes/gizmo) and now what I am doing with my [kit](https://github.com/ardanlabs/kit).\r\n\r\nIf you look at my kit, I have added a vendor folder at the root of the project. This was not a good idea prior to the vendor experiment and the govendor tool. But I think these two tools in combination have solved a big problem.\r\n\r\nI can `go get` the entire kit I want something from and bring it into my GOPATH.\r\n\r\nI can vendor just the log package from the ardanlabs kit into my project:\r\n`govendor add github.com/ardanlabs/kit/log`\r\n\r\nUpdate it as need be:\r\n`govendor update github.com/ardanlabs/kit/log`\r\n\r\n`govendor` will see a vendor folder exists inside of `github.com/ardanlabs/kit` during the add and update. So before it copies `log` into my projects vendor folder, it can look at any dependences that `log` is using that needs to also be added/updated from that vendor folder first. Again, if the dependencies already exist, the tooling just has to let me know so I can make a decision about what to do. This is not a big deal. I have knowledge and control.\r\n\r\nThis is where the vendor file is critical. I want to know if what I already have vendored in my project for this package matches what is vendored in the kit project. If they are the same, nothing needs to be reported, just copy the code. If they are not the same, I need to know. This is where using commit ids can be too granular, but then again, using semver could be a problem if the code bases are really not the same. So maybe a combination of knowing both.\r\n\r\n\"Hey the commit ids are not the same but both commits report the same version 1.0.2. How do you want to proceed?\"\r\n\r\nI'm not saying this logic is trivial, it is not. But if we start with tooling that can report issues and give us options to choose from, it would be a huge head start. Once we learn more and fix bugs, some of that can be automated.\r\n\r\nIn the end for me, this just needs to be manageable to the extent that I am not hesitating to use a dependency. I am at that point now with the vendor flag and govendor. I also take a minimal approach to using dependencies and don't run into these edge problems. Using the projects vendor folder to pull dependencies when it exists will take care of some of the edge cases.\r\n\r\nI just wish the vendor experiment would isolate a vendor folder to the root of a project and dictate a single vendor folder per project. This would simplify things tremendously.\r\n\r\n",
	"user": {
		"login": "ardan-bkennedy",
		"id": 2280005,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-30T16:16:56Z",
	"updated_at": "2015-12-30T16:16:56Z"
}
