{
	"id": 169421311,
	"body": "@kostya-sh - ah right, yes, sorry. I'm always going to struggle with splitting up an upstream repository, because it undermines commit atomicity of the upstream repository - and given how hard a problem space this is to build something both sane and usable, I like taking advantage of every bit of upstream information we can get.\r\n\r\nI don't think `golang.org/x` repos following such a structure should be an example to follow. The Go authors wrote with a monorepo background, and a monorepo in mind, which is why we're having these problems in the first place. (The preceding comments here discuss this issue extensively).\r\n\r\nI still struggle with the performance argument, though. It seems to me that exploring caching more would be preferable over carving up what amounts to generated code. Particularly for Go, where it's not necessary to fetch those packages beyond the build server (unlike an interpreted lang). And if the build server is ephemeral (e.g., hosted CI), [at least some of them provide support](https://github.com/pipeviz/pipeviz/blob/master/circle.yml#L19) for caching across ephemeral instances.\r\n\r\nSo, I can entirely see being convinced about it. But some (*not all*) of what I've seen about that so far seems to amount to complaints that \"the tool doesn't currently do as well as I can manually.\" Well, of course not. But...cmon. Disk is very cheap. Network is relatively cheap. There is a point where it becomes preferable to eat it on those in order to reduce complexity of a real implementation.\r\n\r\n@freeformz\r\n\r\n\u003e Semver may not catch any of those, but code analysis would at least catch the v2 issue (as you stated code analysis can only tell me what's incompatible). Tests, as you, me and/or others have pointed out above would be required to catch the v3 issue, semver or not.\r\n\r\n\u003e This is the crux of our disagreement AFAICT: You have faith in semver being meaningful beyond stating intent. I don't. In my mind semver is just intent and I would prefer to consider actual API changes and leave the rest to integration testing.\r\n\r\nAnd even tests aren't sufficient, of course (Dijkstra: \"Testing can only prove the presence of bugs, never their absence!\"). But yes, you're absolutely right - semver ranges carry no guarantees whatsoever. They could be *completely* right, or *completely* wrong. What's important is that they're *not mutually exclusive* with static analysis.\r\n\r\nIf you're working and pull in a new project (A), which in turn has a dependency on another project (C) specified in a range, but you already had another dep (B) which also had a dependency on C, then when attempting to resolve the diamond, your tooling should ABSOLUTELY run static analysis on the A-\u003eC relationship to ensure that all the versions the semver range indicates are acceptable, actually are. Because yes - you shouldn't just take A's maintainer at their word. You'd be no better off than we are now in the unreasonable \"just ensure tip always works\" world.\r\n\r\nSo, let's say that `main` in [my previous example](https://gist.github.com/sdboyer/ba6e46245d45883dcc7b) is A, and C is the package offering the `Square()` func. Static analysis has knocked out v2 - great. You're left with staying with v1, or going to v3, or to some v4 (which isn't in my example, but it's easy to imagine one), any of which is permitted by the semver range.\r\n\r\nSo you go in, do the work, and figure out that A is actually incompatible with Cv3, but is compatible with Cv4. \r\n\r\n**This work you just did is extremely valuable.** It should be recorded, so that no one ever has to do it again. Which you can do by filing a patch against A that further restricts the semver range to exclude v3. And now, when the next user of A comes along, they'll never hit that v3 pothole. They'll never even need to know it exists. (And the FLOSS cherubim sing.)\r\n\r\nI think we all understand that there's a ton of uncertainty in software development. Superficially, semver may appear to just blithely ride that uncertainty train, or even make things worse. But all it's actually doing is taking a whole lot of awful, complicated shit that can happen, and providing a lens for seeing it all within a single field of view. (If youâ€™re a fan of [Cynefin](https://en.wikipedia.org/wiki/Cynefin_Framework), semver is an excellent example of an organizing system that moves a problem out of the *complex* space, into the *complicated* space.) While our individual builds must be reproducible and deterministic, the broader ecosystem will always be (in practice, from any one person's perspective) uncertain. All real software must constantly move back and forth between these two spaces. Semver facilitates a process by which we can inject *more* certainty into the ecosystem incrementally, as we learn more about it.\r\n\r\n\u003e We both view the world very differently apparently.\r\n\r\nMost people do :) Though I still tend to think, in this regard, maybe not so far off.\r\n\r\n\u003e Your article will be an interesting read for me I'm sure. :-)\r\n\r\nWith any luck! Discussing over here has gotten me enmeshed in too much detail over there now, I think...I'm a bit stuck. Trying to pull back from the trees for the forest. Hopefully I'll have it done soon.\r\n\r\n\u003e I would love to get some sort of higher throughput (video / in person / etc) discussion wrt this issue.\r\n\r\n+1 from me.",
	"user": {
		"login": "sdboyer",
		"id": 21599,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-06T19:01:02Z",
	"updated_at": "2016-02-06T03:07:59Z"
}
