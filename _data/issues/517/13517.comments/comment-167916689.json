{
	"id": 167916689,
	"body": "@mattfarina I am not 100% sure what you mean by package level versioning but vendoring at a package level is a must because more and more of us are creating kit type repos where not all the packages will need/want to be vendored.\r\n\r\nI have been giving @kardianos feedback on govendor and I think the tool is very close to having most of the bases covered for project management. I am at the point thanks to the vendor flag and govendor where I don't even think about dependency management anymore.\r\n\r\nThis is what I am doing today and it has kept things simple and manageable.\r\n\r\n1. I believe projects need to own the dependencies they use and vendor them into the projects source tree.\r\n\r\n2. A project uses a single repo and MUST contain only a single vendor folder at the root of the source tree.\r\n\r\n3. Each project can only contain a single version of any given dependency in the vendor folder.\r\n\r\n4. When adding a dependency (package) inside the vendor folder several things need to be taken into account.\r\n  a. Copy the package code from the GOPATH. If the code is not there, complain.\r\n  b. If that package has dependencies, look inside the packages project for a root vendor folder. Pull dependencies from there first. Else look in GOPATH.\r\n\r\n_4.b allows repos to have a root vendor folder to secure dependencies. These dependencies can be respected._\r\n\r\nConflicts\r\nThis is where tooling becomes very important. The user has to make choices.\r\n\r\nWhen a version of a package is already vendored an update command will replace it. When this update is a direct and conscious decision let it happen. If the tool is pulling a dependency from a project vendor folder, then versions need to be checked. **This is a place where the vendor file is critical**.\r\n\r\nFetching\r\nI would like to see govendor be able to fetch a dependency and place it directly into the vendor folder without leaving any artifacts in the GOPATH.  The same conflict rules apply.\r\n\r\nFinally\r\nI don't think everything needs to be automated. The tooling just needs to provide information and guidance. Each project and situation is different. Project structure and information is the key. I believe the project model with a single repo and a single vendor folder at the root of the project simplifies things and works.\r\n\r\nIf you want to use tagged versions to identify conflicts I think that could work. I do like the idea of tagging with semver because I think commit ids are too granular. I may have a dozens changes that don't break the API. That being said, bugs can still be introduced so the commit id will flag potential issues that the user can look into.\r\n\r\nJust don't become paralyzed with edge cases, let the tooling provide the information so the user can make an informed decision.",
	"user": {
		"login": "ardan-bkennedy",
		"id": 2280005,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-30T01:54:32Z",
	"updated_at": "2015-12-30T01:54:32Z"
}
