{
	"id": 168056144,
	"body": "This is a question of code ownership to me. I must own all the code I use and only use the code I need. If the repo is nothing more than a box. What is inside the box is important. What things in the box I want are important. The box is not what is important. The box for the package I want is not more important than the package itself. Don't make this about the box. The version being applied to the box does not negate that the version can be applied to an individual package in the box. It follows the shipping model you are describing very well. \n\nOwn the code your project uses, don't lease it. Too much risk in leasing and taking more than you need. Minimize, reduce and simplify. \n\n\u003e On Dec 30, 2015, at 1:07 PM, Sam Boyer \u003cnotifications@github.com\u003e wrote:\n\u003e \n\u003e @jbuberel - ahh, yes, I see what you mean now. Sure, go-kit makes sense as an example. Thanks.\n\u003e \n\u003e @ardan-bkennedy - great, so, the crucial question is very clearly out there, now.\n\u003e \n\u003e The language is package oriented.\n\u003e \n\u003e Yep.\n\u003e \n\u003e A package is the basic unit of compilation, and we are taught to think in terms of components (packages).\n\u003e \n\u003e Yep.\n\u003e \n\u003e Our API's are based on a package. We import packages.\n\u003e \n\u003e Yep.\n\u003e \n\u003e So why would package and dependency management not be package based?\n\u003e \n\u003e First, because Go packages are not (necessarily) individually retrievable units. go get creates the illusion that they are - convenient, but illusory. I get that some people may not want to care about this, in the same way that I don't really want to care about the cardboard boxes Amazon ships my stuff in. But I'm pretty sure that if Amazon wouldn't be so successful if they treated boxes as an irrelevant detail.\n\u003e \n\u003e Second, as previously noted in this thread, versions matter, and versions are a property of the SCM, not the Go package.\n\u003e \n\u003e I realize these points might seem like small details. But I'd encourage folks to step back and think about other situations where information from one discrete level of a software architecture has been conflated into another. In bad cases, these sorts of issues can cause difficult to diagnose (or even comprehend), and induce years of hair-tearing. This, IMO, is one such case.\n\u003e \n\u003e Back in 2013 when I learned how go get worked, it seemed that a repo should represent a single package. This would allow the package to be go gettable and everything that comes with that. But I think we have learned that repo management is a lot of work, so minimizing the number of repos you need to manage is important. This leads to the idea of a repo representing a project.\n\u003e \n\u003e I think it's important to distinguish between the general problem of package management, and the lessons that go get has taught us over the years. IMO, the vagaries of go get have gaslit us, and stuck us optimizing around local optima. The next step forward in this area should not be rooted in go get-based course corrections, but a more foundational improvement.\n\u003e \n\u003e In that vein, I see those kit repositories (go-kit, gizmo, yours), and this proposed spec, as a totally reasonable response to the situation go get creates. Certainly, I see how your examples address your immediate problem, but this spec treats a symptom of the problem with a very permanent band-aid.\n\u003e \n\u003e Really, you said as much yourself:\n\u003e \n\u003e In the end for me, this just needs to be manageable to the extent that I am not hesitating to use a dependency.\n\u003e \n\u003e I do empathize with this feeling. Very much. Under different circumstances, I would probably agree that it's a good enough basis to move forward with a change that makes an incremental improvement in the status quo. But it's not appropriate here, I think, because there is a mountain of prior art on package management - ideas we can follow to escape our local optimum. And this approach would, I suspect, conflict with that.\n\u003e \n\u003e I am working on an article that lays out a bigger-picture way of thinking about the information a package manager needs, and how any sort of tool should operate. I hope to have it up by the end of the week.\n\u003e \n\u003e Aside - the irony here is that we're having these challenges when the structure of Go programs and the constraints of the compiler make solving this problem so much easier than it is in other languages (that have solved it better). We have such potential!\n\u003e \n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub.\n\u003e \n",
	"user": {
		"login": "goinggo",
		"id": 5329657,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-30T18:59:25Z",
	"updated_at": "2015-12-30T18:59:25Z"
}
