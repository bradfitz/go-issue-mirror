{
	"id": 182471775,
	"body": "Not sure if this conversation has moved on elsewhere, but I enjoyed reading through it as it is at the heart of the exact problems I have been struggling to deal with.  Feel free to point me elsewhere if it has moved on in the last month.  \r\n\r\n@kardianos  I would disagree with that `working_with_forks` is not related to this issue.   \r\n\r\nThis is precisely the problem I keep having.  Our product is using a 3rd party dependency (doesn't even matter really, happens with internal ones too), there is a bug or hotfix in that dependency affecting our product, that has to be fixed immediately and release a new version of our product.  One of the typical ways you do this is to fork the dependency, fix the bug, build the product using the forked dependency and release.  You then push the change upstream and close the loop later of having your application switch back to the mainline after it is merged.    \r\n\r\nI know there are multiple ways to solve this, but the easiest way would be to update a spec file that says use the following URL (fork) for import X;   \r\n* I do not want to have to go rewrite (mutate...) import paths, \r\n* I do not want to have to copy code into some subdirectory\r\n* I do not want to have to play games with routing hostnames or other similar tricks at the environment level (think what people do with SSH configs to work with multiple GitHub accounts and different SSH keys...)\r\n* I do not want to have to script around it with the build process by having it clone the dependency into the path representing the upstream repository and then manage the remotes of the workspace and checkout the fork changes\r\n\r\nI want to be able to make the changes on the forked dependency, make the fork available.  Then update the application using the dependency.  Ideally, all I should need to do is update a spec file that says, use version blah of this dependency.   Since golang ties source, import paths, and other things related to projects so tightly together, it hinders these pivot points that almost every other language provides.   \r\n\r\nThis is most evident when it comes into 'what is a version' of a dependency.   Because golang ties the import path to the repo home (URL) of the dependency it implies that the version the of a dependency is only within the scope of that repo URL.   I believe that to be not ideal.\r\n\r\nA version of a dependency should be an 'instance' of that dependency, and an 'instance' of that dependency should be able to originate from multiple places, and thus that origin should be part of the scoping of the version.   In golang, we are saying that origin should be URL addressable so it can be retrieved as an import.   That would allow using forks.   ",
	"user": {
		"login": "mhoglan",
		"id": 5976085,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-02-10T16:43:47Z",
	"updated_at": "2016-02-10T16:43:47Z"
}
