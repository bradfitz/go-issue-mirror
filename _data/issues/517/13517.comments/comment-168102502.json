{
	"id": 168102502,
	"body": "An additional point, on libraries vs. repositories.  To add to what @sdboyer said, I'll cut to the chase and say this is a bad idea waiting to explode in your face.\r\n\r\nDrupal (my primary OSS project) has supported multiple modules (extension libraries) in one repository for 15 years now.  When a couple of libraries are closely related -- such as when you've one main module and a few optional modules that provide integration with some other module -- it can absolutely be convenient to cluster them together in a single repository.  It's very tempting.  It's also a huge mistake.\r\n\r\nDoing so results in the following issues:\r\n* You cannot download just the pieces you need.  You have to get it all, which may or may not be prohibitively large.\r\n* Detecting what entry points are present in a downloaded bundle becomes more difficult. This is particularly true for the build file.  Where do you find multiple build files?  How do you tell them apart?\r\n* When you specify a dependency, do you depend on the library or on the meta-package that includes that library?  What if those are sometimes the same name, sometimes not?  (This is not a hypothetical example, but a common situation in Drupal.)\r\n* How do you version just one of the libraries in that repository?  If you have just one lib in the repository then tags become a super-easy way to denote versions.  If you can't rely on a tag (since each library versions separately), how do you figure it out?  Do you have to include that in the build file?  What happens when (not if) you forget to change the build file?\r\n* If I have to deep-link to get to a specific version of a sub-library, how do I know I'm getting the right version?  If the deep-link changes for the version (the way it would in SVN, for instance), do I have to update my identifier?  The identifier then *sometimes* becomes a version specification, sometimes not.  But that precludes ranged dependencies (at least version 2.4.3 as above), which are a necessity for libraries.\r\n\r\nSome of those issues may not be entirely relevant for Go (since the compiler, I think, can skip unused source code entirely), but the principle is the same and there's probably other Go-specific issues.  Linking one repository to one package solves all of those issues, and allows the use of tags as the version specification mechanism.  Simple, elegant.\r\n\r\nMany of us are pushing for Drupal to abandon multiple modules per package to avoid the above issues.  Generally speaking, I'd agree with @sdboyer that if multi-library repositories seems like a good idea then you're solving the wrong problem.  It's a solution to a problem that shouldn't exist in the first place.  Honestly I've never had much issue maintaining separate libraries in separate repositories.\r\n\r\nSome other examples in the PHP space:\r\n* The Symfony project includes about 30-ish components, all developed in a single repository. However, they also go through an extensive song and dance to split them off to their own read-only repositories so that they can be reused individually.  This process is automated, but was quite a chore to setup and is not fast.\r\n* The Zend Framework project used to do the same, but this year broke all of their libraries up into separate repositories to avoid all of the issues Symfony has.  They also can now make a new release of just one library without having to version-bump the entire suite.  Some libraries are just inherently more stable and less in need of change, so bumping their version just because its siblings do is rude to downstream users of that library.\r\n* The Aura project (another component framework) has a separate repository for everything and has since the beginning.\r\n\r\nI believe the KDE project now separately versions all of its components, too, and has a separate version for the integrated package that is independent of the versions of the underlying libs.  In all, I see that as being the trend, not moving more toward one-repo-to-rule-them-all.\r\n\r\nIt actually took me a while to realize that the discussed \"repository level\" vs \"package level\" was backwards from what I'm used to seeing.  At first, I thought package-level meant in a central repository like Packagist.org (the default index of PHP packages that can be used by Composer), rather than a subset of a repository.  Such a central index is likely a separate discussion, but that's how far from anything I've seen elsewhere such an idea is.\r\n\r\nIn conclusion, I do believe that a Go package manager should assume 1 library==1 repository, as it simplifies a huge number of questions.  If there's some reason that maintaining multiple repositories is problematic, that is an issue that should be fixed on its own rather than trying to paper over it.",
	"user": {
		"login": "Crell",
		"id": 254863,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-31T01:09:29Z",
	"updated_at": "2015-12-31T01:09:29Z"
}
