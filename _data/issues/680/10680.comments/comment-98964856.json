{
	"id": 98964856,
	"body": "Yes, builders are running in separate VMs now. Thanks for correcting me @minux and @bradfitz. I am not sure why this test fails more often in VMs.\r\n\r\nLike I mentioned before, I can break this test reliably if I add this:\r\n\r\n```\r\ndiff --git a/src/time/sleep.go b/src/time/sleep.go\r\nindex e7a2ee2..673d433 100644\r\n--- a/src/time/sleep.go\r\n+++ b/src/time/sleep.go\r\n@@ -97,8 +97,10 @@ func sendTime(c interface{}, seq uintptr) {\r\n \t// Used in NewTicker, dropping sends on the floor is\r\n \t// the desired behavior when the reader gets behind,\r\n \t// because the sends are periodic.\r\n+\tt := Now()\r\n+\tprint(\"sendTime: t=\", t.String(), \"\\n\")\r\n \tselect {\r\n-\tcase c.(chan Time) \u003c- Now():\r\n+\tcase c.(chan Time) \u003c- t:\r\n \tdefault:\r\n \t}\r\n }\r\ndiff --git a/src/time/sleep_test.go b/src/time/sleep_test.go\r\nindex 2fce753..508f689 100644\r\n--- a/src/time/sleep_test.go\r\n+++ b/src/time/sleep_test.go\r\n@@ -220,10 +220,60 @@ func TestAfterStop(t *testing.T) {\r\n \t}\r\n }\r\n \r\n+var (\r\n+\tsalt1 = 0\r\n+\tsalt2 = 0\r\n+)\r\n+\r\n+func cpuHog1() {\r\n+\tfoo := salt1\r\n+\tfor i := 0; i \u003c 1e5; i++ {\r\n+\t\tif foo \u003e 0 {\r\n+\t\t\tfoo *= foo\r\n+\t\t} else {\r\n+\t\t\tfoo *= foo + 1\r\n+\t\t}\r\n+\t}\r\n+\tsalt1 = foo\r\n+}\r\n+\r\n+func cpuHog2() {\r\n+\tfoo := salt2\r\n+\tfor i := 0; i \u003c 1e5; i++ {\r\n+\t\tif foo \u003e 0 {\r\n+\t\t\tfoo *= foo\r\n+\t\t} else {\r\n+\t\t\tfoo *= foo + 2\r\n+\t\t}\r\n+\t}\r\n+\tsalt2 = foo\r\n+}\r\n+\r\n+func cpuHogger(f func()) {\r\n+\t// We only need to get one 100 Hz clock tick, so we've got\r\n+\t// a 25x safety buffer.\r\n+\t// But do at least 500 iterations (which should take about 100ms),\r\n+\t// otherwise TestCPUProfileMultithreaded can fail if only one\r\n+\t// thread is scheduled during the 250ms period.\r\n+\tt0 := Now()\r\n+\tfor i := 0; i \u003c 500 || Since(t0) \u003c 5000*Millisecond; i++ {\r\n+\t\tf()\r\n+\t}\r\n+}\r\n+\r\n func TestAfterQueuing(t *testing.T) {\r\n+\tgo func() {\r\n+\t\tc := make(chan int)\r\n+\t\tgo func() {\r\n+\t\t\tcpuHogger(cpuHog1)\r\n+\t\t\tc \u003c- 1\r\n+\t\t}()\r\n+\t\tcpuHogger(cpuHog2)\r\n+\t\t\u003c-c\r\n+\t}()\r\n \t// This test flakes out on some systems,\r\n \t// so we'll try it a few times before declaring it a failure.\r\n-\tconst attempts = 3\r\n+\tconst attempts = 1\r\n \terr := errors.New(\"!=nil\")\r\n \tfor i := 0; i \u003c attempts \u0026\u0026 err != nil; i++ {\r\n \t\tdelta := 100 * Millisecond\r\n@@ -247,7 +297,9 @@ type afterResult struct {\r\n }\r\n \r\n func await(slot int, result chan\u003c- afterResult, ac \u003c-chan Time) {\r\n-\tresult \u003c- afterResult{slot, \u003c-ac}\r\n+\tt := \u003c-ac\r\n+\tprint(\"await: t=\", t.String(), \"\\n\")\r\n+\tresult \u003c- afterResult{slot, t}\r\n }\r\n \r\n func testAfterQueuing(t *testing.T, delta Duration) error {\r\n```\r\n\r\nthe output\r\n\r\n```\r\nC:\\\u003eu:\\test -test.short -test.v -test.run=TestAfterQueuing\r\n=== RUN TestAfterQueuing\r\nsendTime: t=2015-05-04 22:44:37.4667308 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4667308 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4677073 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4677073 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4677073 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4677073 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4686838 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4686838 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4686838 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4686838 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4686838 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4696603 -0700 PDT\r\nsendTime: t=2015-05-04 22:44:37.4696603 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4667308 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4686838 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4677073 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4686838 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4686838 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4686838 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4677073 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4667308 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4677073 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4686838 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4696603 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4677073 -0700 PDT\r\nawait: t=2015-05-04 22:44:37.4696603 -0700 PDT\r\n--- FAIL: TestAfterQueuing (0.23s)\r\n        sleep_test.go:285: attempt 0 failed: After calls returned out of order: [0 5 3 6 6 6 1 1 2 7 9 4 8]\r\n        sleep_test.go:289: After calls returned out of order: [0 5 3 6 6 6 1 1 2 7 9 4 8]\r\nFAIL\r\n```\r\n\r\nTimers are fired fine - I tested this by adding debug prints in runtime/time.go (not shown). But then when sendTime puts timer events in the channel (returned by time.After), the events are received (in await) out of order - see the output. I think it just the way our scheduler works when there is some runnable code or, perhaps, when in VM. I don't know why this only happens on windows. Perhaps it is to do with Windows time granularity being around 15ms.\r\n\r\nThe only thing I can think of is to increase delta further from 100ms to 200ms or even more. This makes adjusted test PASS.\r\n\r\nLooking for suggestions. Thank you.\r\n\r\nAlex\r\n\r\n@dvyukov @randall77 ",
	"user": {
		"login": "alexbrainman",
		"id": 9796621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-05-05T06:07:16Z",
	"updated_at": "2015-05-05T06:07:16Z"
}
