{
	"id": 66052150,
	"body": "\u003ca id=\"c1\"\u003e\u003c/a\u003eComment 1 by **jdnurmi**:\n\n\u003cpre\u003eOk, I really wanted this, so I started hacking around to prove I wasn't crazy.\n\nThe following will generate a pkcs1 key (only version 0, since I still don't understand\noPI, but that seems to be sufficient to make openssl happy.\n\n*** There's also a flaw in the current implementation I saw -- integers must be encoded\nto follow DER, (see \u003ca href=\"http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf\"\u003ehttp://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf\u003c/a\u003e\n; Section 8.3;);  \n\nThis is related to, but not directly fixed by issue/997, as it relates to the encoding\nof 'big' to ASN1 (which is done in the PKCS1 Marshalling function of the x509 module).\n\nSince 2s complement encoding is used, so if you have a very large number whose first bit\nin the Byte-series is 1, the encoding would be interpreted to be negative by other ASN.1\ninterpreters.  RSA does not generally use negative numbers.\n\nIMHO, A better solution would be to either always pad the result of big.Byte() if\nnecessary to represent the sign correctly, or add an big.SignedBytes() internally that\ncould evaluate the pos/neg of the big;  The below is just a hack to do the encoding\n\"correctly\", so I can generate a PEM.\n\n\ntype otherPrimeInfos struct {\n  Prime asn1.RawValue\n  Exponent asn1.RawValue\n  Coefficient asn1.RawValue\n}\n\ntype pkcs1Key struct {\n  Version int\n  N       asn1.RawValue\n  E       int\n  D       asn1.RawValue\n  P       asn1.RawValue\n  Q       asn1.RawValue\n  Exponent1 asn1.RawValue\n  Exponent2 asn1.RawValue\n  Coefficient asn1.RawValue\n  //OtherPrimeInfos []otherPrimeInfos\n}\n\nfunc BigInt2ASN(t int, b *big.Int)(asn1.RawValue){\n  origBytes := b.Bytes()\n  if origBytes[0] \u0026 0x80 == 0x80 {\n    newBytes := make([]byte, len(origBytes) + 1)\n    copy(newBytes[1:], origBytes)\n    return asn1.RawValue{Tag: t, Bytes: newBytes}\n  }\n  return asn1.RawValue{Tag: t, Bytes: origBytes}\n}\n\n\nfunc setuppkcs1Key(pk *rsa.PrivateKey) (b []byte, err os.Error ){\n  k := pkcs1Key {\n    Version: 0,\n    N: BigInt2ASN(2, pk.N),\n    E: pk.PublicKey.E,\n    D: BigInt2ASN(2, pk.D),\n    P: BigInt2ASN(2, pk.P),\n    Q: BigInt2ASN(2, pk.Q),\n  }\n\n  //k.OtherPrimeInfos = make([]otherPrimeInfos, 0)\n  minusone := big.NewInt(-1)\n  one := big.NewInt(1)\n  q_1 := big.NewInt(0).Sub(pk.Q, one)\n  p_1 := big.NewInt(0).Sub(pk.P, one)\n\n  exp1 := big.NewInt(0).Mod(pk.D, p_1)\n  exp2 := big.NewInt(0).Mod(pk.D, q_1)\n  coeff := big.NewInt(0).Exp(pk.Q, minusone, pk.P)\n  k.Exponent1 = BigInt2ASN(2, exp1)\n  k.Exponent2 = BigInt2ASN(2, exp2)\n  k.Coefficient = BigInt2ASN(2, coeff)\n  b, err = asn1.MarshalToMemory(k)\n  return\n}\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2010-08-11T15:25:19Z",
	"updated_at": "2014-12-08T10:06:36Z"
}
