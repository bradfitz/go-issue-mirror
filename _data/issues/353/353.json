{
	"id": 51276376,
	"number": 353,
	"state": "closed",
	"title": "runtime: precise garbage collection of stack",
	"body": "by **pts+legacy@google.com**:\n\n\u003cpre\u003eI would expect a full run of a mark-and-sweep GC to mark all used memory,\nand then free all unused memory. However, in the example below, the GC\nwon't free some unused memory.\n\nWhat steps will reproduce the problem?\n\n$ cat \u0026gt;stack_gc_try.go \u0026lt;\u0026lt;'END'\npackage main\n\nimport (\n  \u0026quot;malloc\u0026quot;;\n)\n\nvar a, b uint64\n\nfunc DoGC() {\n  print(\u0026quot;running gc\\n\u0026quot;);\n  malloc.GC();\n  b = malloc.GetStats().Alloc;\n  mb := (b - a + (1 \u0026lt;\u0026lt; 19)) \u0026gt;\u0026gt; 20;\n  print(\u0026quot;cannot be freed on stack: \u0026quot;, mb, \u0026quot;MB (\u0026quot;, b - a, \u0026quot; bytes)\\n\u0026quot;);\n}\n\nfunc ManyArgs(p0, p1, p2, p3, p4, p5, p6, p7, p8 []byte) {\n}\n\nfunc WipeStack() {\n  ManyArgs(nil, nil, nil, nil, nil, nil, nil, nil, nil);\n}\n\nfunc Work() {\n  ManyArgs(make([]byte, 1 \u0026lt;\u0026lt; 20),  // 1MB\n           make([]byte, 1 \u0026lt;\u0026lt; 21),\n           make([]byte, 1 \u0026lt;\u0026lt; 22),\n           make([]byte, 1 \u0026lt;\u0026lt; 23),\n           make([]byte, 1 \u0026lt;\u0026lt; 24),\n           make([]byte, 1 \u0026lt;\u0026lt; 25),\n           nil, nil, nil);\n  DoGC();\n}\n\nfunc main() {\n  print(\u0026quot;stack_gc_try start\\n\u0026quot;);\n  malloc.GC();\n  a = malloc.GetStats().Alloc;\n  Work();\n  DoGC();\n  WipeStack();\n  DoGC();\n  print(\u0026quot;stack_gc_try end\\n\u0026quot;);\n}\nEND\n$ 8g stack_gc_try.go \u0026amp;\u0026amp; 8l stack_gc_try.8 \u0026amp;\u0026amp; ./8.out\n\nWhat is the expected output?\n\nstack_gc_try start\nrunning gc\ncannot be freed on stack: 0MB (0 bytes)\nrunning gc\ncannot be freed on stack: 0MB (0 bytes)\nrunning gc\ncannot be freed on stack: 0MB (0 bytes)\nstack_gc_try end\n\nWhat do you see instead?\n\nstack_gc_try start\nrunning gc\ncannot be freed on stack: 63MB (66060288 bytes)\nrunning gc\ncannot be freed on stack: 38MB (39845888 bytes)\nrunning gc\ncannot be freed on stack: 2MB (2097152 bytes)\nstack_gc_try end\n\nWhat is your $GOOS?  $GOARCH?\n\nexport GOOS=linux GOARCH=386\n\nWhich revision are you using?  (hg identify)\n\nbe2d6a785638 tip\n\nPlease provide any additional information below.\n\nA C function which dumps the stack helped me analyze what's going on. My\nconclusion is that the memory is not freed because there are some\nunreachable pointers on the stack, pointing to the arrays.\n\nThe stack of a Go function looks like this (memory addresses increasing\nleft to right on 386): temporary-data, return-address, arguments,\nreturn-value.  One use of temporary-data within the function is to build\nthe arguments of functions called.\n\nThe function Work() in the example above calls the function ManyArgs(),\nwhich has 9 arguments. These 9 arguments (6 new slices and 3 nils) are\nbuilt on Work's temporary-data before space calling ManyArgs(). The\ntemporary-data is not cleared automtically after ManyArgs returns, so the 6\nnew slices remain on the stack until that part of the stack is reused. In\nthe example, it is never reused until Work returns. So the DoGC() call in\nWork will have the stack layout: temporary-data-of-DoGC,\nreturn-address-of-DoGC, temporary-data-of-Work, return-address-of-Work. The\ntemporary-data-of-Work contains pointers to [...]byte buffers totaling\n63MB. The garbage collector finds these pointers on the stack, marks them,\nand the 63MB is not reclaimed (as indicated on the program's output).\n\nSubsequent calls to DoGC() are from a higher point on the stack, so parts\nof temporary-data-of-Work is overwritten at that time, so the garbage\ncollector would free some of the [...]byte buffers, but not all of them --\npossibly because that part of temporary-data-of-Work is never overwritten\n(e.g. reserved for an uninitialized C local variable).\n\nMy summary of the analysis: leftover temporary-data on the stack prevents\nthe garbage collector from finding (and freeing) some unused memory.\n\nI think this could be fixed by modifying the Go compiler (8g) to generate\nmachine code which shortens temporary-data from the left after a function\nreturns. So when ManyArgs() called from Work() returns, the\ntemporary-data-of-Work could be shortened by increasing the stack pointer\nto skip past the ManyArgs's arguments (and its return value, if not used).\u003c/pre\u003e\n\n\n\n\n\nAttachments:\n\n1. \u003ca href=\"https://storage.googleapis.com/go-attachment/353/0/stack_gc_try.go\"\u003estack_gc_try.go\u003c/a\u003e (1189 bytes)",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		}
	],
	"comments": 14,
	"closed_at": "2014-12-08T10:04:14Z",
	"created_at": "2009-11-28T10:59:48Z",
	"updated_at": "2016-06-24T19:08:42Z"
}
