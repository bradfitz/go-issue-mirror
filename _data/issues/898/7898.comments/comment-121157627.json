{
	"id": 121157627,
	"body": "In order to support nested transactions, I see two obvious alternatives.\r\n\r\nTL;DR - Option 2 is better.\r\n\r\n## Option 1\r\nMake the `driver.Tx` interface include an additional function\r\n```go\r\ntype Tx interface {\r\n        Commit() error\r\n        Rollback() error\r\n        Begin() (*Tx, error)\r\n}\r\n```\r\nThe `Begin()` function can return an error indicating that transactions cannot be nested (any further). This would allow the `sql.Tx` object to expose a `Begin()`, which directly calls the underlying Begin function on the `driver.Tx` (which it wraps). E.g.\r\n\r\n```go\r\n// - - - - - - - - - - - - - - - - - \r\n// In package sql\r\n//\r\n\r\nfunc (tx *Tx) Begin() (*Tx, error) {\r\n      return tx.txi.Begin()\r\n}\r\n\r\n// - - - - - - - - - - - - - - - - - \r\n// In the driver implementation package\r\n//\r\n\r\nfunc (t *MyTx) Begin() (*Tx, error) {\r\n      // error sanity checks\r\n      _, err  := t.conn.Exec(...) // execute a SAVEPOINT maybe?\r\n      if err != nil {\r\n            return nil, err\r\n      }\r\n      newTx := t.clone()\r\n      // some bookkeeping for newTx\r\n      return \u0026newTx, nil\r\n}\r\n```\r\n\r\nThe immediate drawback of this approach is that the next release will mean existing DB drivers will immediately stop compiling since their implementations of transaction object will no longer satisfy the `driver.Tx` interface. \r\n\r\nHowever, the benefit is that having the transaction struct (that implements `driver.Tx`) implement the function that begins the nested transaction feels more natural. It is likely* that the transaction already holds a reference to the `driver.Conn` that it is tied to, so all the state it needs is already present in the transaction struct itself (* = my reading of 2 driver implementations)\r\n\r\n## Option 2\r\nHave `driver.Conn` optionally implement an additional interface (`driver.NestedBeginner`?) which indicates that it can begin nested transactions\r\n```go\r\ntype NestedBeginner interface {\r\n  NestedBegin(origTx *Tx) Tx\r\n}\r\n```\r\nAnd expose this on the `sql.Tx` object as a `Begin()` function, which calls the NestedBegin() on the conn object, passing it the current transaction. E.g.\r\n\r\n```go\r\n// - - - - - - - - - - - - - - - - - \r\n// In package sql\r\n//\r\n\r\nvar ErrNestedTxUnsupported = errors.New(\"sql: Driver does not support nested transactions\")\r\n\r\nfunc (tx *Tx) Begin() (*Tx, error) {\r\n      if tx.done {\r\n            return ErrTxDone\r\n      }\r\n      if beginner, ok := tx.dc.ci.(driver.NestedBeginner); ok {\r\n            tx.dc.Lock()\r\n            nestedTx, err := beginner.NestedBegin(tx.txi) \r\n            if err != nil {\r\n                  tx.dc.Unlock()\r\n                  return nil, err\r\n            }\r\n            tx.dc.Unlock()\r\n            return \u0026Tx{db:  tx.db, dc:  dc, txi: nestedTx}, nil\r\n      }\r\n      return nil, ErrNestedTxUnsupported\r\n}\r\n\r\n// - - - - - - - - - - - - - - - - - \r\n// In the driver implementation package\r\n//\r\n\r\n// This function makes the driver connection object satisfy the NestedBeginner interface\r\nfunc (c *MyConn) NestedBegin(origTxn driver.Tx) (driver.Tx, error) {\r\n      return origTxn.NestedBegin() \r\n}\r\n\r\nfunc (t *MyTxn) NestedBegin() {\r\n      // implementation (similar to proposal 1) goes here\r\n}\r\n```\r\nThe benefit of this approach is that nothing changes for existing driver implementations (they are deemed to not support nested transactions until the pkg maintainers make the Conn satisfy the new interface). The `sql.Tx.Begin()` returns an error if the underlying `driver.Conn` doesn't implement the function.\r\n\r\nHowever, this means the `driver.Conn` has to implement the `NestedBeginner` interface. This, in turn, means that in order for a nested transaction to begin, the struct that implements the `driver.Conn` acts as a proxy to the actual function that likely needs to be invoked on the existing transaction, to start a new transaction. This could end up feeling slightly clunkier than the first option, although that is not as important as maintaining the interface contract for backwards compatibility.\r\n\r\nHence I believe that option 2 is the more desirable one. I'd appreciate thoughts/feedback on this.\r\n\r\n### Note\r\n\r\nThe semantics of the nested transaction (and how Commits/Rollback might cause interactions between the inner/outer transactions) are to be implemented by the underlying driver. The `sql` package simply propagates them.\r\n\r\nIts not clear to me if these discussions are to be had on the golang-dev mailing list or on the bug itself (the instructions on golang.org didn't call it out explicitly). It seems that both places would be able to persist design  discussions for posterity but I'm happy to post this on the mailing list if needed.",
	"user": {
		"login": "amoghe",
		"id": 1750664,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-07-14T07:59:39Z",
	"updated_at": "2015-07-14T08:00:44Z"
}
