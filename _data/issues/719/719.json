{
	"id": 51276846,
	"number": 719,
	"state": "closed",
	"title": "Excessive memory usage in relation with maps",
	"body": "by **serge.hulne**:\n\n\u003cpre\u003eProblem:\n\nThe following code uses a map to store unique bigrams (couple of\nwords) from a text file (and an array to sort them according to their\nfrequency of occurence).\n\nThe file used for the test is  :\n\u003ca href=\"http://www.gutenberg.org/cache/epub/100/pg100.txt\"\u003ehttp://www.gutenberg.org/cache/epub/100/pg100.txt\u003c/a\u003e\n(concatenated  a couple of times for the sake of the test)\n\nAt no point during the run of program does the map store an amount of\ndata comparable to the size of the text file, since the most frequent\nbigrams appear thousands of time in said text file.\n\nOne would therefore expect the memory usage of the executable to use\nan amount of  RAM which is less than the size of the text file.\n\nHowever it seem to be quite the opposite in practice.\nHere is the source code:\n\nThe version of 6g is : 6g version 5189 release.2010-03-30 release\nThe hardware is : Mac Mini , Intel Core Duo\n\nThe Go env. variables are:\nGOBIN=/Users/serge2/go/src/bin\nGOARCH=amd64\nGOROOT=/Users/serge2/go\nGOOS=darwin\n\n\nSerge Hulne\n\n-------------------\npackage main\n\nimport (\n        \u0026quot;fmt\u0026quot;\n        \u0026quot;os\u0026quot;\n        \u0026quot;bufio\u0026quot;\n        \u0026quot;unicode\u0026quot;\n        \u0026quot;strings\u0026quot;\n        \u0026quot;time\u0026quot;\n        \u0026quot;runtime\u0026quot;\n        \u0026quot;sort\u0026quot;\n)\n\nfunc monitor() {\n        for {\n                fmt.Printf(\u0026quot;Memory usage = %d\\n\u0026quot;,\nruntime.MemStats.Alloc)\n                time.Sleep(1e9)\n        }\n\n}\n\n//---\ntype Bigram struct {\n        key string\n        value string\n        freq uint\n\n}\n\ntype BigramArray []Bigram\n\n// Methods required by sort.Interface to sort structures of the type\nBigramArray.\nfunc (s BigramArray) Len() int           { return len(s) }\nfunc (s BigramArray) Less(i, j int) bool { return s[i].freq \u0026gt;\ns[j].freq } //(reverse sort)\nfunc (s BigramArray) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\nfunc hash_bigram(b *Bigram) uint {\n        var h uint = 5381\n        for _, r := range (*b).key {\n                h = (h \u0026lt;\u0026lt; 5) + h + uint(r)\n        }\n        h = (h \u0026lt;\u0026lt; 5) + h + uint('_')\n        for _, r := range (*b).value {\n                h = (h \u0026lt;\u0026lt; 5) + h + uint(r)\n        }\n        return h\n}\n\n//---\n\nfunc main() int {\n\n        l_cnt := 0\n        w_cnt := 0\n        cpt_chars := 0\n        inword := false\n        buf := \u0026quot;\u0026quot;\n        old_word := \u0026quot;\u0026quot;\n        new_word := \u0026quot;\u0026quot;\n        var bigram Bigram\n\n        T := map [uint] Bigram{}\n\n        //f, err := os.Open(\u0026quot;faust.txt\u0026quot;, os.O_RDONLY, 0666)\n        //f, err := os.Open(\u0026quot;test.txt\u0026quot;, os.O_RDONLY, 0666)\n        //f, err := os.Open(\u0026quot;hamlet.txt\u0026quot;, os.O_RDONLY, 0666)\n        f, err := os.Open(\u0026quot;../shakespeare.txt\u0026quot;, os.O_RDONLY, 0666)\n        //f, err := os.Open(\u0026quot;/Users/serge2/development/NLP/B60W20.txt\u0026quot;,\nos.O_RDONLY, 0666)\n        //f, err := os.Open(\u0026quot;../B60W20.txt\u0026quot;, os.O_RDONLY, 0666)\n\n        go monitor()\n\n        if err != nil {\n                fmt.Printf(\u0026quot;\\nError =\u0026gt; %s\\n\\n\u0026quot;, err)\n        }\n\n        reader := bufio.NewReader(f) //Buffered reader\n\n        for {\n                c, _ ,err := reader.ReadRune() //\u0026quot;ReadRune\u0026quot;: reads unicode\nchars\n                cpt_chars++\n                if err != os.EOF \u0026amp;\u0026amp; err == nil {\n                        if c == '\\n' {\n                                l_cnt++\n                        }\n                        ///////////////////////////////\n                        if unicode.IsSpace(c) == false { //Scanner :\nfilters out whitespace\n                                if inword == false {\n                                        buf =  \u0026quot;\u0026quot;\n                                        buf += string(c)\n                                        inword = true\n                                        w_cnt++\n                                } else {\n                                        buf += string(c)\n                                }\n                        } else if inword == true {\n\n                                //---\n                                buf = strings.ToLower(buf)\n                                new_word = buf\n                                if len(new_word)\u0026gt;0 \u0026amp;\u0026amp; len(old_word)\u0026gt;0 {\n                                        bigram.key = old_word\n                                        bigram.value = new_word\n                                        h := hash_bigram(\u0026amp;bigram)\n                                        if _, ok := T[h]; ok {\n                                                b := T[h]\n                                                b.freq++\n                                                T[h] = b\n                                        } else {\n                                                T[h] = bigram\n                                        }\n                                }\n                                old_word = new_word\n                                //---\n\n                                //fmt.Printf(\u0026quot;%d\\t buf = (%s)\\n\u0026quot;, w_cnt ,buf)\n                                inword = false\n                                buf =  \u0026quot;\u0026quot;\n                        }\n                        ///////////////////////////////\n                } else { //EOF detected\n                        if err == os.EOF  {\n                                break\n                        }\n                } //end if (err=nil)\n        } // end for (main loop)\n\n        //---\n        var bigramsArray BigramArray\n        bigramsArray = make (BigramArray, len(T))\n\n        i := 0\n        for _, v := range T{\n                bigramsArray[i] = v\n                i++\n        }\n\n        sort.Sort(bigramsArray)\n\n        for _, v := range bigramsArray[0:20]{\n                fmt.Printf(\u0026quot;%d\\t (%s,%s)\\n\u0026quot;, v.freq, v.key, v.value)\n        }\n        //---\n\n        fmt.Printf(\u0026quot;\\nlines = %d, words = %d, chars = %d\\n\u0026quot;, l_cnt, w_cnt,\ncpt_chars)\n        return 0\n\n}\n\n-------------------\n\nHere is the result of the run:\n\nserge-hulnes-mac-mini:Go_test serge2$ ls -l ../shakespeare.txt\n-rw-r--r--  1 serge2  staff  15862370  5 mar 11:07 ../shakespeare.txt\nserge-hulnes-mac-mini:Go_test serge2$ time ./bigrammes_7\nMemory usage = 347648\nMemory usage = 18181624\nMemory usage = 33399512\nMemory usage = 22003136\nMemory usage = 32615280\nMemory usage = 19154104\nMemory usage = 29662040\nMemory usage = 18441376\nMemory usage = 28763680\nMemory usage = 18525536\nMemory usage = 28688216\nMemory usage = 18481616\nMemory usage = 28727720\n6809     (of,the)\n5619     (in,the)\n5539     (to,the)\n4699     (i,am)\n4149     (i,will)\n3459     (i,have)\n3079     (it,is)\n2769     (if,you)\n2609     (that,i)\n2589     (and,the)\n2569     (by,the)\n2469     (to,be)\n2099     (and,i)\n2059     (my,lord,)\n2039     (of,syracuse.)\n2019     (you,are)\n1999     (is,the)\n1999     (for,the)\n1989     (antipholus,of)\n1899     (of,my)\n\nlines = 495200, words = 2703240, chars = 15862351\n\nreal    0m12.725s\nuser    0m12.602s\nsys     0m0.104s\u003c/pre\u003e\n\n\n\n\n\nAttachments:\n\n1. \u003ca href=\"https://storage.googleapis.com/go-attachment/719/0/bigrammes_7.go\"\u003ebigrammes_7.go\u003c/a\u003e (2930 bytes)",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		}
	],
	"comments": 2,
	"closed_at": "2014-12-08T10:05:37Z",
	"created_at": "2010-04-09T09:25:20Z",
	"updated_at": "2016-06-24T19:15:12Z"
}
