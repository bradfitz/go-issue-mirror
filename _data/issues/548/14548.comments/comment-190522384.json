{
	"id": 190522384,
	"body": "\u003e The reason is in the two dtruss snippets.\r\n\r\nUm, I'm still not sure because there are two types of kevent calls; one is for initial registration to the single per-process kqueue and another is for capturing kernel events, and I don't know whether dtruss has good tracing functionality than dtrace. Anyway, when I tweak the dtrace script mentioned above like the following:\r\n```\r\nsyscall::kevent:entry\r\n/execname == \"tcp\" \u0026\u0026 arg2 != 0/\r\n{\r\n        self-\u003ekevent = arg0;\r\n        self-\u003enreg = arg2;\r\n        self-\u003enevt = arg4;\r\n        printf(\"REG: tid=%d s=%d nreg=%d nevt=%d\", tid, arg0, arg2, arg4);\r\n}\r\n\r\nsyscall::kevent:entry\r\n/execname == \"tcp\" \u0026\u0026 arg2 == 0/\r\n{\r\n        self-\u003ekevent = arg0;\r\n        self-\u003enreg = arg2;\r\n        self-\u003enevt = arg4;\r\n        printf(\"EVT: tid=%d s=%d nreg=%d nevt=%d\", tid, arg0, arg2, arg4);\r\n}\r\n\r\nsyscall::kevent:return\r\n/execname == \"tcp\" \u0026\u0026 self-\u003enreg != 0/\r\n{\r\n        printf(\"REG: tid=%d s=%d nreg=%d nevt=%d n=%d errno=%d\", tid, self-\u003ekevent, self-\u003enreg, self-\u003enevt, arg0, errno);\r\n}\r\n\r\nsyscall::kevent:return\r\n/execname == \"tcp\" \u0026\u0026 self-\u003enreg == 0/\r\n{\r\n        printf(\"EVT: tid=%d s=%d nreg=%d nevt=%d n=%d errno=%d\", tid, self-\u003ekevent, self-\u003enreg, self-\u003enevt, arg0, errno);\r\n}\r\n```\r\nwe can see\r\n```\r\n  0    338                   connect:return tid=243094 s=8 errno=36\r\n  0    867                     kevent:entry REG: tid=243094 s=4 nreg=2 nevt=0\r\n  0    868                    kevent:return EVT: tid=243088 s=4 nreg=0 nevt=64 n=3 errno=0\r\n  0    868                    kevent:return REG: tid=243094 s=4 nreg=2 nevt=0 n=0 errno=0\r\n  0    377                 getsockopt:entry tid=243094 s=8\r\n  0    147                       read:entry tid=243088 s=18\r\n  0    378                getsockopt:return tid=243094 s=8 errno=0\r\n  0    148                      read:return tid=243088 s=18 n=512 errno=0\r\n  0    147                       read:entry tid=243097 s=11\r\n  0    338                   connect:return tid=243099 s=10 errno=36\r\n  0    338                   connect:return tid=243095 s=17 errno=36\r\n  0    153                      close:entry tid=243088 s=18\r\n  0    148                      read:return tid=243097 s=11 n=512 errno=0\r\n  0    867                     kevent:entry REG: tid=243099 s=4 nreg=2 nevt=0\r\n  0    867                     kevent:entry REG: tid=243095 s=4 nreg=2 nevt=0\r\n  0    149                      write:entry tid=243094 s=8\r\n  0    153                      close:entry tid=243097 s=11\r\n  0    338                   connect:return tid=243098 s=9 errno=36\r\n  0    150                     write:return tid=243094 s=8 n=-1 errno=57\r\n```\r\nPerhaps there's a potential race condition on the kqueue implementation for Darwin, like #14127.\r\n\r\nSummary:\r\n- There is a spurious kevent notification during TCP connection setup process\r\n- The notification may occur not only with Go 1.4 and below but with Go 1.5 and above\r\n - I confirmed that it happened with Go 1.4 last night\r\n- Still unclear whether the notification depends on kernel version\r\n - At least it occurs on OS X 10.11\r\n- Still unclear what's the root cause of spurious notification",
	"user": {
		"login": "mikioh",
		"id": 92117,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-03-01T03:32:05Z",
	"updated_at": "2016-03-01T03:59:49Z"
}
