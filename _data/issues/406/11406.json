{
	"id": 91071347,
	"number": 11406,
	"state": "closed",
	"title": "gccgo, runtime:  panic with checkdead:  find g 19 in status 1",
	"body": "Using gccgo from latest gcc5 branch.  Building Docker from their master branch on ppc64le trying to provide continuous integration.  This had been working without issue up until sometime in the past 2 weeks, where there is a failure during the Docker build.  This same failure occurs when running one of the Docker unit tests after we've built Docker this way.\r\n\r\nFailure occurs when building on Ubuntu 14.04 and 14.10 ppc64le.\r\n\r\nHere is and example of the stack information for the Docker build failure:\r\n\r\nruntime: checkdead: find g 19 in status 1\r\nfatal error: checkdead: runnable g\r\n\r\nruntime stack:\r\nruntime_dopanic\r\n\t../../../src/libgo/runtime/panic.c:135\r\nruntime_throw\r\n\t../../../src/libgo/runtime/panic.c:193\r\ncheckdead\r\n\t../../../src/libgo/runtime/proc.c:2866\r\nmput\r\n\t../../../src/libgo/runtime/proc.c:3113\r\nstopm\r\n\t../../../src/libgo/runtime/proc.c:1456\r\nfindrunnable\r\n\t../../../src/libgo/runtime/proc.c:1764\r\nschedule\r\n\t../../../src/libgo/runtime/proc.c:1847\r\npark0\r\n\t../../../src/libgo/runtime/proc.c:1912\r\nruntime_mstart\r\n\t../../../src/libgo/runtime/proc.c:1076\r\n\r\ngoroutine 16 [chan receive]:\r\nmain.mainDaemon\r\n\t/go/src/github.com/docker/docker/docker/daemon.go:186\r\nmain.main\r\n\t/go/src/github.com/docker/docker/docker/docker.go:99\r\ncreated by main\r\n\t../../../src/libgo/runtime/go-main.c:48\r\n\r\ngoroutine 18 [finalizer wait]:\r\ncreated by runtime_createfing\r\n\t../../../src/libgo/runtime/mgc0.c:2572\r\n\r\ngoroutine 19 [runnable]:\r\nsyscall.Exitsyscall\r\n\t../../../src/libgo/runtime/proc.c:2122\r\nos_signal.signal_recv\r\n\t../../../src/libgo/runtime/sigqueue.goc:110\r\nsignal.loop\r\n\t../../../src/libgo/go/os/signal/signal_unix.go:21\r\ncreated by os_signal..import\r\n\t../../../src/libgo/go/os/signal/signal_unix.go:25\r\n\r\ngoroutine 25 [chan receive]:\r\ngithub_com_docker_docker_api_server.ServeApi.pN42_github_com_docker_docker_api_server.Server\r\n\t/go/src/github.com/docker/docker/api/server/server.go:110\r\nmain.$nested2\r\n\t/go/src/github.com/docker/docker/docker/daemon.go:136\r\ncreated by main.mainDaemon\r\n\t/go/src/github.com/docker/docker/docker/daemon.go:135\r\n\r\ngoroutine 26 [chan receive]:\r\ndaemon.$nested20\r\n\t/go/src/github.com/docker/docker/daemon/debugtrap.go:17\r\ncreated by daemon.setupSigusr1Trap\r\n\t/go/src/github.com/docker/docker/daemon/debugtrap.go:16\r\n\r\ngoroutine 63 [chan receive]:\r\ndatabase_sql.connectionOpener.pN15_database_sql.DB\r\n\t../../../src/libgo/go/database/sql/sql.go:589\r\n\r\nWe can also generate a failure in one of the unit tests with the same message, and the stack trace is not quite the same:  \r\n\r\n+ go test -test.timeout=180m github.com/docker/docker/pkg/archive\r\nruntime: checkdead: find g 20 in status 1\r\nfatal error: checkdead: runnable g\r\n\r\nruntime stack:\r\nruntime_dopanic\r\n\t../../../src/libgo/runtime/panic.c:135\r\nruntime_throw\r\n\t../../../src/libgo/runtime/panic.c:193\r\ncheckdead\r\n\t../../../src/libgo/runtime/proc.c:2866\r\nmput\r\n\t../../../src/libgo/runtime/proc.c:3113\r\nstopm\r\n\t../../../src/libgo/runtime/proc.c:1456\r\nexitsyscall0\r\n\t../../../src/libgo/runtime/proc.c:2205\r\nruntime_mstart\r\n\t../../../src/libgo/runtime/proc.c:1076\r\n\r\ngoroutine 16 [chan receive]:\r\ntesting.RunTests\r\n\t../../../src/libgo/go/testing/testing.go:556\r\ntesting.Run.pN9_testing.M\r\n\t../../../src/libgo/go/testing/testing.go:485\r\nmain.main\r\n\t/tmp/go-build271522865/github.com/docker/docker/pkg/archive/_test/_testmain.go:180\r\ncreated by main\r\n\t../../../src/libgo/runtime/go-main.c:48\r\n\r\ngoroutine 18 [finalizer wait]:\r\ncreated by runtime_createfing\r\n\t../../../src/libgo/runtime/mgc0.c:2572\r\n\r\ngoroutine 73 [runnable]:\r\nsyscall.Exitsyscall\r\n\t../../../src/libgo/runtime/proc.c:2122\r\nsyscall.Getdents\r\n\t../../../src/libgo/go/syscall/libcall_linux.go:236\r\nsyscall.ReadDirent\r\n\t../../../src/libgo/go/syscall/libcall_linux.go:250\r\narchive.readdirnames\r\n\t/go/src/github.com/docker/docker/pkg/archive/changes_linux.go:236\r\ngithub_com_docker_docker_pkg_archive.walk.pN43_github_com_docker_docker_pkg_archive.walker\r\n\t/go/src/github.com/docker/docker/pkg/archive/changes_linux.go:120\r\narchive.collectFileInfoForChanges\r\n\t/go/src/github.com/docker/docker/pkg/archive/changes_linux.go:53\r\ngithub_com_docker_docker_pkg_archive.ChangesDirs\r\n\t/go/src/github.com/docker/docker/pkg/archive/changes.go:309\r\narchive.checkNoChanges\r\n\t/go/src/github.com/docker/docker/pkg/archive/archive_test.go:553\r\ngithub_com_docker_docker_pkg_archive.TestTarFiles\r\n\t/go/src/github.com/docker/docker/pkg/archive/archive_test.go:521\r\ntesting.tRunner\r\n\t../../../src/libgo/go/testing/testing.go:447\r\ncreated by testing.RunTests\r\n\t../../../src/libgo/go/testing/testing.go:555\r\n\r\ngoroutine 74 [runnable]:\r\nsync.runtime_Syncsemacquire\r\n\t../../../src/libgo/runtime/sema.goc:262\r\nsync.Wait.pN9_sync.Cond\r\n\t../../../src/libgo/go/sync/cond.go:62\r\nio.write.pN7_io.pipe\r\n\t../../../src/libgo/go/io/pipe.go:94\r\nio.Write.pN13_io.PipeWriter\r\n\t../../../src/libgo/go/io/pipe.go:161\r\nbufio.flush.pN12_bufio.Writer\r\n\t../../../src/libgo/go/bufio/bufio.go:530\r\nbufio.Flush.pN12_bufio.Writer\r\n\t../../../src/libgo/go/bufio/bufio.go:519\r\npools.$nested3\r\n\t/go/src/github.com/docker/docker/pkg/pools/pools.go:102\r\ngithub_com_docker_docker_pkg_ioutils.Close.pN55_github_com_docker_docker_pkg_ioutils.writeCloserWrapper\r\n\t/go/src/github.com/docker/docker/pkg/ioutils/writers.go:31\r\narchive.$nested0\r\n\t/go/src/github.com/docker/docker/pkg/archive/archive.go:476\r\ncreated by github_com_docker_docker_pkg_archive.TarWithOptions\r\n\t/go/src/github.com/docker/docker/pkg/archive/archive.go:393\r\n\r\nTests failed: ./pkg/archive\r\n\r\nInteresting that in both cases there is a stack marked as runnable with syscall.Exitsyscall at the top.\r\n\r\nI have been looking at the code in checkdead where the message is coming from.  In order for this to correctly detect a deadlock, the counts found in the runtime_sched structure must be in sync (i.e. must reflect the same state) with the entries runtime_allg list and I don't see how that is enforced.  Seems like the run count could be computed but before the runtime_allg list is processed, a new goroutine could be added, resulting in a new run count, identifying a deadlock when there isn't one.\r\n\r\n       run = runtime_sched.mcount - runtime_sched.nmidle - runtime_sched.nmidlelocked - 1 - countextra();\r\n        if(run \u003e 0)\r\n                return;\r\n        // If we are dying because of a signal caught on an already idle thread,\r\n        // freezetheworld will cause all running threads to block.\r\n        // And runtime will essentially enter into deadlock state,\r\n        // except that there is a thread that will call runtime_exit soon.\r\n        if(runtime_panicking \u003e 0)\r\n                return;\r\n        if(run \u003c 0) {\r\n                runtime_printf(\"runtime: checkdead: nmidle=%d nmidlelocked=%d mcount=%d\\n\",\r\n                        runtime_sched.nmidle, runtime_sched.nmidlelocked, runtime_sched.mcount);\r\n                runtime_throw(\"checkdead: inconsistent counts\");\r\n        }\r\n        grunning = 0;\r\n        runtime_lock(\u0026allglock);\r\n        for(i = 0; i \u003c runtime_allglen; i++) {\r\n                gp = runtime_allg[i];\r\n                if(gp-\u003eisbackground)\r\n                        continue;\r\n                s = gp-\u003estatus;\r\n                if(s == Gwaiting)\r\n                        grunning++;\r\n                else if(s == Grunnable || s == Grunning || s == Gsyscall) {\r\n                        runtime_unlock(\u0026allglock);\r\n                        runtime_printf(\"runtime: checkdead: find g %D in status %d\\n\", gp-\u003egoid, s);\r\n                        runtime_throw(\"checkdead: runnable g\");\r\n                }\r\n        }\r\n        runtime_unlock(\u0026allglock);\r\n\r\nWe will continue to try to reproduce this problem in a smaller testcase and do some more debugging.",
	"user": {
		"login": "laboger",
		"id": 9433228,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		}
	],
	"comments": 5,
	"closed_at": "2015-07-13T18:03:16Z",
	"created_at": "2015-06-25T20:46:26Z",
	"updated_at": "2016-07-13T16:06:28Z",
	"milestone": {
		"id": 1069171,
		"number": 23,
		"title": "Gccgo"
	}
}
