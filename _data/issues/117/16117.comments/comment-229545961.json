{
	"id": 229545961,
	"body": "For `hash4`, somehow I see a different disassembly than what you saw:\r\nOn ARM32, with SSA off:\r\n```\r\n\t0x0000 00000 \tTEXT\t\"\".hash4(SB), $0-16\r\n\t0x0000 00000 \tMOVW\t8(g), R1\r\n\t0x0004 00004 \tCMP\tR1, R13\r\n\t0x0008 00008 \tBLS\t204\r\n\t0x000c 00012 \tMOVW.W\tR14, -4(R13)\r\n\t0x0010 00016 \tFUNCDATA\t$0, gclocals路8355ad952265fec823c17fcf739bd009(SB)\r\n\t0x0010 00016 \tFUNCDATA\t$1, gclocals路69c1753bd5f81501d95132d08af04464(SB)\r\n\t0x0010 00016 \tMOVW\t$0, R0\r\n\t0x0014 00020 \tMOVW\t$\"\".b(FP), R0\r\n\t0x0018 00024 \tMOVW\t4(R0), R1\r\n\t0x001c 00028 \tMOVW\t$3, R2\r\n\t0x0020 00032 \tCMP\tR2, R1\r\n\t0x0024 00036 \tBHI\t$1, 48\r\n\t0x0028 00040 \tPCDATA\t$0, $1\r\n\t0x0028 00040 \tCALL\truntime.panicindex(SB)\r\n\t0x002c 00044 \tUNDEF\r\n\t0x0030 00048 \tMOVW\t(R0), R0\r\n\t0x0034 00052 \tMOVBU\t3(R0), R0\r\n\t0x0038 00056 \tMOVW\t$\"\".b(FP), R1\r\n\t0x003c 00060 \tMOVW\t4(R1), R2\r\n\t0x0040 00064 \tMOVW\t$2, R3\r\n\t0x0044 00068 \tCMP\tR3, R2\r\n\t0x0048 00072 \tBHI\t$1, 84\r\n\t0x004c 00076 \tPCDATA\t$0, $1\r\n\t0x004c 00076 \tCALL\truntime.panicindex(SB)\r\n\t0x0050 00080 \tUNDEF\r\n\t0x0054 00084 \tMOVW\t(R1), R1\r\n\t0x0058 00088 \tMOVBU\t2(R1), R1\r\n\t0x005c 00092 \tMOVW\tR1\u003c\u003c8, R1\r\n\t0x0060 00096 \tORR\tR1, R0, R0\r\n\t0x0064 00100 \tMOVW\t$\"\".b(FP), R1\r\n\t0x0068 00104 \tMOVW\t4(R1), R2\r\n\t0x006c 00108 \tMOVW\t$1, R3\r\n\t0x0070 00112 \tCMP\tR3, R2\r\n\t0x0074 00116 \tBHI\t$1, 128\r\n\t0x0078 00120 \tPCDATA\t$0, $1\r\n\t0x0078 00120 \tCALL\truntime.panicindex(SB)\r\n\t0x007c 00124 \tUNDEF\r\n\t0x0080 00128 \tMOVW\t(R1), R1\r\n\t0x0084 00132 \tMOVBU\t1(R1), R1\r\n\t0x0088 00136 \tMOVW\tR1\u003c\u003c16, R1\r\n\t0x008c 00140 \tORR\tR1, R0\r\n\t0x0090 00144 \tMOVW\t$\"\".b(FP), R1\r\n\t0x0094 00148 \tMOVW\t4(R1), R2\r\n\t0x0098 00152 \tCMP\t$0, R2\r\n\t0x009c 00156 \tBHI\t$1, 168\r\n\t0x00a0 00160 \tPCDATA\t$0, $1\r\n\t0x00a0 00160 \tCALL\truntime.panicindex(SB)\r\n\t0x00a4 00164 \tUNDEF\r\n\t0x00a8 00168 \tMOVW\t(R1), R1\r\n\t0x00ac 00172 \tMOVBU\t(R1), R1\r\n\t0x00b0 00176 \tMOVW\tR1\u003c\u003c24, R1\r\n\t0x00b4 00180 \tORR\tR1, R0\r\n\t0x00b8 00184 \tMOVW\t$506832829, R1\r\n\t0x00bc 00188 \tMULU\tR1, R0\r\n\t0x00c0 00192 \tMOVW\tR0\u003e\u003e15, R0\r\n\t0x00c4 00196 \tMOVW\tR0, \"\".~r1+12(FP)\r\n\t0x00c8 00200 \tMOVW.P\t4(R13), R15\r\n\t0x00cc 00204 \tNOP\r\n\t0x00cc 00204 \tMOVW\tR14, R3\r\n\t0x00d0 00208 \tCALL\truntime.morestack_noctxt(SB)\r\n\t0x00d4 00212 \tJMP\t0\r\n\t0x00d8 00216 \tJMP\t0(PC)\r\n\t0x00dc 00220 \tWORD\t$506832829\r\n```\r\nWith SSA on:\r\n```\r\n\t0x0000 00000 \tTEXT\t\"\".hash4(SB), $4-16\r\n\t0x0000 00000 \tMOVW\t8(g), R1\r\n\t0x0004 00004 \tCMP\tR1, R13\r\n\t0x0008 00008 \tBLS\t92\r\n\t0x000c 00012 \tMOVW.W\tR14, -8(R13)\r\n\t0x0010 00016 \tFUNCDATA\t$0, gclocals路8355ad952265fec823c17fcf739bd009(SB)\r\n\t0x0010 00016 \tFUNCDATA\t$1, gclocals路69c1753bd5f81501d95132d08af04464(SB)\r\n\t0x0010 00016 \tMOVW\t\"\".b+4(FP), R0\r\n\t0x0014 00020 \tCMP\t$3, R0\r\n\t0x0018 00024 \tBLS\t84\r\n\t0x001c 00028 \tMOVW\t\"\".b(FP), R0\r\n\t0x0020 00032 \tMOVBU\t3(R0), R1\r\n\t0x0024 00036 \tMOVBU\t2(R0), R2\r\n\t0x0028 00040 \tMOVBU\t1(R0), R3\r\n\t0x002c 00044 \tMOVBU\t(R0), R0\r\n\t0x0030 00048 \tORR\tR2\u003c\u003c8, R1, R1\r\n\t0x0034 00052 \tMOVW\tR3, R2\r\n\t0x0038 00056 \tORR\tR2\u003c\u003c16, R1, R1\r\n\t0x003c 00060 \tORR\tR0\u003c\u003c24, R1, R0\r\n\t0x0040 00064 \tMOVW\t$506832829, R1\r\n\t0x0044 00068 \tMUL\tR0, R1, R0\r\n\t0x0048 00072 \tSRL\t$15, R0, R0\r\n\t0x004c 00076 \tMOVW\tR0, \"\".~r1+12(FP)\r\n\t0x0050 00080 \tMOVW.P\t8(R13), R15\r\n\t0x0054 00084 \tPCDATA\t$0, $1\r\n\t0x0054 00084 \tCALL\truntime.panicindex(SB)\r\n\t0x0058 00088 \tUNDEF\r\n\t0x005c 00092 \tNOP\r\n\t0x005c 00092 \tMOVW\tR14, R3\r\n\t0x0060 00096 \tCALL\truntime.morestack_noctxt(SB)\r\n\t0x0064 00100 \tJMP\t0\r\n\t0x0068 00104 \tJMP\t0(PC)\r\n\t0x006c 00108 \tWORD\t$506832829\r\n```\r\nSo it is about 50% shorter. Currently it does not do combined unaligned load. It seems CSE helps mostly.\r\n\r\nIt might be possible to do combined load. Newer ARM support unaligned load. But currently the compiler (both backends) generates same instructions, only the assembler rewrite some instructions based on GOARM.",
	"user": {
		"login": "cherrymui",
		"id": 14119929,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-06-30T02:47:34Z",
	"updated_at": "2016-06-30T02:47:34Z"
}
