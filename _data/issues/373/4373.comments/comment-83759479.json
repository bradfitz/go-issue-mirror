{
	"id": 83759479,
	"body": "The general strategy I use is to have a \"reader\" goroutine sitting in a [blocking] Read() passing any received []byte buffers to channel. I use ragel based parsers to parse the incoming []byte slices into higher order ResponseMessage's. There's also a \"writer\" that takes a RequestMessage, calls \"ToWire()\" to get a []byte representation and Write()'s it to the network. Usually an inbound ResponseMessage is matched up to the pending RequestMessage (via a channel), occasionally I have unsolicited messages that are posted to a separate channel for out-of-bound processing.\r\n\r\nThis describes the steady-state of the system, aside from normal processing of messages, one of three things can happen:\r\n\r\n1. Remote server closes \u0026 disconnects (e.g. it might be restarting etc).\r\n2. Network error (read timeout, host unreachable etc)\r\n3. Local shutdown (e.g. `systemctl stop myservice.service`)\r\n\r\n1 \u0026 2 are similar, in general the system moves to a mode of attempting to reconnect while pausing operations -- the underlying RequestMessage instances will timeout waiting for responses and the application handle that appropriately. In general, if I'm seeing a connection closed by remote host, then I typically suppress the error. If I'm seeing other kinds of network errors, I want to log them.\r\n\r\nAs for 3, I close the network connection from main() (in response to a signal) which forces the \"reader\" out of it's Read() with an error. Again, I don't want to report the error if it's ErrClosed, the reader should shutdown quietly. Otherwise, the reader should be attempting a reconnection.\r\n\r\nTypically, the \"reader\" handles any reconnecting as the \"writer\" is usually blocking on a select waiting for messages to send, but it's possible that the writer will encounter the error before the reader does. In either case, I call Close() on the connection to ensure that both the reader and writer both see the error.\r\n\r\n_Linux: dead connection detection_\r\nI have some additional logic in the writer to check the kernel output queue size by calling ioctl(fd, SIOCOUTQ) after a select/time.After(30s) on the write channel. If there's still data in the queue, then it's likely the connection has failed somewhere along the line (despite using TCP_KEEPALIVE) and I need to bounce the connection by calling Close() on it.\r\n",
	"user": {
		"login": "smithwinston",
		"id": 1114593,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-03-19T21:03:08Z",
	"updated_at": "2015-03-19T21:03:08Z"
}
