{
	"id": 192917670,
	"body": "OK so to avoid adding a public API I've added a `parsePostFormURLEncoded` method in the `http` package such as :\r\n\r\n\tvar (\r\n\t\tbyteAmp = []byte(\"\u0026\")\r\n\t\tbyteEqual = []byte(\"=\")\r\n\t\tbyteSemiColon = []byte(\";\")\r\n\t)\r\n\r\n\tfunc parsePostFormURLEncoded(reader io.Reader, vs url.Values, maxFormSize int64) (err error) {\r\n\t\tvar buf bytes.Buffer\r\n\t\tvar key string\r\n\t\tvar value string\r\n\t\tvar i int64\r\n\t\tb := make([]byte, 1)\r\n\t\tfor {\r\n\t\t\tif i \u003e= maxFormSize {\r\n\t\t\t\terr = errors.New(\"http: POST too large\")\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tn, e := reader.Read(b)\r\n\t\t\tif e != nil \u0026\u0026 e.Error() != io.EOF.Error() {\r\n\t\t\t\terr = e\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\ti += int64(n)\r\n\t\t\tif bytes.Equal(b, byteEqual) {\r\n\t\t\t\tkey, e = url.QueryUnescape(buf.String())\r\n\t\t\t\tif e != nil {\r\n\t\t\t\t\terr = e\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tbuf.Reset()\r\n\t\t\t} else if bytes.Equal(b, byteAmp) || bytes.Equal(b, byteSemiColon) || n == 0 {\r\n\t\t\t\tvalue, e = url.QueryUnescape(buf.String())\r\n\t\t\t\tif e != nil {\r\n\t\t\t\t\terr = e\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tvs[key] = append(vs[key], value)\r\n\t\t\t\tbuf.Reset()\r\n\t\t\t} else {\r\n\t\t\t\tbuf.Write(b)\r\n\t\t\t}\r\n\t\t\tif n == 0 {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\nIs that what you had in mind ?\r\n\r\nBecause running the same benchmark gives me worse results than the last 2 benchmarks :\r\n\r\n\t$ go test ./src/net/http -v -run=^$ -bench=BenchmarkParsePostForm -benchtime=10s -parallel=4 -memprofile=prof.mem\r\n\tBenchmarkParsePostForm-4\t     500\t  30509320 ns/op\t 7506321 B/op\t      29 allocs/op\r\n\tPASS\r\n\tok  \tnet/http\t26.665s\r\n\r\nJust by looking at this result we can see that it's 3 times slower and allocates as much as the original implementation (since this time it only does 500 repetitions vs 2000 last time)\r\n\r\n\t$ go tool pprof --alloc_space http.test prof.mem Entering interactive mode (type \"help\" for commands)\r\n\t(pprof) top\r\n\t6091.52MB of 6093.02MB total (  100%)\r\n\tDropped 2 nodes (cum \u003c= 30.47MB)\r\n\tShowing top 10 nodes out of 12 (cum \u003e= 6050.36MB)\r\n\t      flat  flat%   sum%        cum   cum%\r\n\t 4644.73MB 76.23% 76.23%  4644.73MB 76.23%  bytes.makeSlice\r\n\t 1403.63MB 23.04% 99.27%  6048.36MB 99.27%  net/http.parsePostFormURLEncoded\r\n\t   42.66MB   0.7%   100%    42.66MB   0.7%  net/http_test.BenchmarkParsePostForm\r\n\t    0.50MB 0.0082%   100%  6048.86MB 99.28%  net/http.parsePostForm\r\n\t\t 0     0%   100%  4644.73MB 76.23%  bytes.(*Buffer).Write\r\n\t\t 0     0%   100%  4644.73MB 76.23%  bytes.(*Buffer).grow\r\n\t\t 0     0%   100%  6048.86MB 99.28%  net/http.(*Request).ParseForm\r\n\t\t 0     0%   100%  6050.36MB 99.30%  net/http_test.BenchmarkParsePostForm.func1\r\n\t\t 0     0%   100%  6093.02MB   100%  runtime.goexit\r\n\t\t 0     0%   100%  6050.36MB 99.30%  testing.(*B).RunParallel.func1\r\n\t(pprof) list parsePostFormURLEncoded\r\n\tTotal: 5.95GB\r\n\tROUTINE ======================== net/http.parsePostFormURLEncoded in /home/asticode/projects/go/go/src/net/http/request.go\r\n\t    1.37GB     5.91GB (flat, cum) 99.27% of Total\r\n\t\t .          .    940:\t\t\t\terr = e\r\n\t\t .          .    941:\t\t\t\treturn\r\n\t\t .          .    942:\t\t\t}\r\n\t\t .          .    943:\t\t\tbuf.Reset()\r\n\t\t .          .    944:\t\t} else if bytes.Equal(b, byteAmp) || bytes.Equal(b, byteSemiColon) || n == 0 {\r\n\t    1.37GB     1.37GB    945:\t\t\tvalue, e = url.QueryUnescape(buf.String())\r\n\t\t .          .    946:\t\t\tif e != nil {\r\n\t\t .          .    947:\t\t\t\terr = e\r\n\t\t .          .    948:\t\t\t\treturn\r\n\t\t .          .    949:\t\t\t}\r\n\t\t .          .    950:\t\t\tvs[key] = append(vs[key], value)\r\n\t\t .          .    951:\t\t\tbuf.Reset()\r\n\t\t .          .    952:\t\t} else {\r\n\t\t .     4.54GB    953:\t\t\tbuf.Write(b)\r\n\t\t .          .    954:\t\t}\r\n\t\t .          .    955:\t\tif n == 0 {\r\n\t\t .          .    956:\t\t\treturn\r\n\t\t .          .    957:\t\t}\r\n\t\t .          .    958:\t}\r\n\r\nIs there any particular reason you don't want to go the `sync.Pool` way ?\r\n\r\nIf you still do, is there anything I've misinterpreted from your guidelines that would worsen the benchmark ?",
	"user": {
		"login": "asticode",
		"id": 11619296,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-03-06T15:43:46Z",
	"updated_at": "2016-03-06T15:43:46Z"
}
