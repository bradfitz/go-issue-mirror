{
	"id": 254064887,
	"body": "@funny-falcon I find that really unconvincing\r\n\r\n\u003e Converting \"synchronous code\" to \"asynchronous\" usually means running goroutine for every \"synchronous-\u003easynchronous conversion\". It is really expensive and scales bad.\r\n\r\nThis may *sound* like an argument, but it really isn't. If you have a feature, you already need to run stuff in a separate goroutine. The order of concurrency is untouched by whether a function does stuff in a goroutine and sends on a future, or whether the goroutine is created by the caller and gets send on a channel.\r\n\r\n\u003e Practice shows that \"asynchronous first\" API is more scalable.\r\n\r\n[citation needed]\r\n\r\n\u003e For example, one kv storage has asynchronous network protocol and allows to send asynchronous requests.\r\n\u003e If one need to send bunch of independent queries (for example, batch insert, or batch fetch for meany ids), then he should send asynchronous requests to maximize throughput and reduce total time of computation.\r\n\r\nAgain, this makes no sense. I don't think overall the code will be simplified, if you end up with a slice of futures that you need to wait on and convert to values.\r\n\r\nBut also, I never claimed *there are no* use cases for futures; I just said that I think a) they are relatively rare, b) they are better served by letting the user handle that concurrency themselves and c) that it's not worth poisoning most users of that code to make those few use cases minimally shorter.\r\n\r\nIn fact, this specific example, more or less, is what gave me such a strong opinion on futures in the first place. Because [hashicorp's raft-implementation](https://godoc.org/github.com/hashicorp/raft) uses futures extensively, which now meant that we needed to riddle our source code with code to juggle those futures, even though they had literally zero use to us. We never made any call, that we didn't immediately needed the result to anyway. But because it's a future, you need to put it into a dedicated variable, then check the error, then extract the value, instead of something like `res, err := r.Apply(cmd []byte)`. \r\n\r\nWhich also shows the next flaw of this proposal (not, that you had actually argued against any of the other ones mentioned so far): Probably 99% of the use cases of futures will require to also signal an error condition (because they'll involve the network or something like that, otherwise, why use a future in the first place). With a synchronous API, that is simple enough to do; you just return `(res Result, err error)` and I use an [errgroup](https://godoc.org/golang.org/x/sync/errgroup) to handle the error. With futures, you need to actually wrap your result and error in a dedicated struct, which you can then send over the channel, or (ugh) return a separate `error` future, only send on one of them and hope, that you don't end up with leaks, because some reader is blocking on the wrong one.\r\n\r\nAnyway. I think it's best for everyone if I leave this issue. I will be sincerely sad if this gets accepted, because the whole idea of futures has just so much wrong with itâ€¦",
	"user": {
		"login": "Merovius",
		"id": 720787,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-10-16T18:34:23Z",
	"updated_at": "2016-10-16T18:34:23Z"
}
