{
	"id": 254069387,
	"body": "@Merovius \r\n\r\n\u003e This may sound like an argument, but it really isn't. If you have a feature, you already need to run stuff in a separate goroutine. The order of concurrency is untouched by whether a function does stuff in a goroutine and sends on a future, or whether the goroutine is created by the caller and gets send on a channel.\r\n\r\nNo, you need only working goroutines, no need goroutine per future.\r\nGiven that kv storage with async protocol, there is only three goroutines: one for writing to tcp socket, one for reading from tcp socket and one waiting for \"closing\" signal from control channel.\r\nAnd single reading goroutine is responsible for filling all the futures.\r\nIn fact, library for this kv storage first implements synchronous api, but users ask to provide async or batch api. It were decided to implement async api as more flexible. Synchronous api then were implemented on top of asynchronous api. It were decided to leave synchronous api inplace just for backward compatibility, though it were clearly redundant.\r\n\r\n\u003e Again, this makes no sense. I don't think overall the code will be simplified, if you end up with a slice of futures that you need to wait on and convert to values.\r\n\r\nYes, but it is simpler than batch api, cause then you need a) separate batch api, b) you still need to convert array of interfaces to exact results.\r\nMore often, it doesn't matter in your code: iteration over slice of futures is almost the same as iteration over slice of exact results, cause usually you fetch value once (from future or directly from slice), and then you do some operation over it.\r\n\r\nYou are right about returning error: one should pack it in a struct. Similar thing one ought to do if you provide slice or channel of independent result values which could be accompanied with error. While it is better to couple future with error passing, I've tried to make least invasive proposal.\r\n\r\nUsually, when I implement future as a code, I give it method `Result() (v inteface{}, err error)`, so there is no need for separate variable:\r\n````go\r\n    if v, err = r.Action(args).Result(); err != nil {\r\n        return err\r\n    }\r\n    useValue(v.(ActualType))\r\n````\r\nBut it looks not much worse with wrapped struct:\r\n````go\r\n    if res = \u003c-r.Action(args); res.err != nil {\r\n        return res.err\r\n    }\r\n    useValue(res.v)\r\n````\r\n\r\nAs a variant, there could be \"more invasive\" proposal for allowing tuple type as a future value type:\r\n````go\r\n    func Greating() (f fusture (string, error)) {\r\n        f = make(future (string, error))\r\n        go func() {\r\n           if moonIsYoung() {\r\n               f \u003c- (\"hello\", nil)\r\n           } else {\r\n               f \u003c- (\"\", errors.New(\"goodbuy\")}\r\n           }\r\n        }()\r\n        return f\r\n    }\r\n    if str, err = \u003c-Greating() ; err != nil {\r\n        return fmt.Sprintf(\"%v cruel world\", err), err\r\n    } else {\r\n        return fmt.Sprintf(\"%s wonderful world\", str), nil\r\n    }\r\n````\r\nThis tuple will be backed by unnamed struct type inferred by compiler.\r\nBut, certainly such proposal has less chances to be accepted.\r\n\r\n\u003e  the whole idea of futures has just so much wrong with itâ€¦\r\n\r\nIt is just your experience. I've used futures for different tasks where they were suitable, and they always leads to more flexible and performant code.\r\nAs I mentioned in a proposal header, usually futures are suitable when both cases could happen simultaneously:\r\n- several waiters for single value (so you need \"broadcast\" behavior)\r\n- and one waiter for several values (so you may send thousands of requests simultaneously without using thousands of goroutines).\r\n\r\n~~Looks like you rarely face such requirements, but~~ I face them quite often.\r\nEdit: excuse me for last sentence.",
	"user": {
		"login": "funny-falcon",
		"id": 249427,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-10-16T19:43:09Z",
	"updated_at": "2016-10-16T20:12:09Z"
}
