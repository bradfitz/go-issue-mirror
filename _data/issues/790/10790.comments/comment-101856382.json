{
	"id": 101856382,
	"body": "What I wrote on at the end of #10399 more or less applies here, after s/BMP/WEBP/:\r\n\r\n----\r\n\r\nThe structure of the file format is first header, then payload. The image dimensions are in the header, and the decoder allocates a pixel buffer after the header is processed but before the payload is processed, because processing the payload involves writing the pixels to somewhere: the pixel buffer.\r\n\r\nDecode takes an io.Reader, not an io.ReadSeeker, so at the time it allocates the pixel buffer, it cannot know whether or not there's 'enough input' remaining. Conversely, we may be decoding an image downloaded from a socket, where we cannot know how much input is remaining. So I think this is all WAI.\r\n\r\nFor decoding images in general, with compression, knowing the total file size doesn't necessarily mean that you know whether or not there's enough pixel data. LZW-style length-difference or RLE encoding means that very large uncompressed data can compress very, very well.\r\n\r\nThat the various image libraries should reject an 16x1073741836 early, checking some sort of MaxMem option before allocating a buffer, is issue #5050.\r\n\r\n----\r\n\r\nReading 1MB, 2MB, etc. isn't the right fix. That would mean unnecessary re-allocation and copying of large slices as the image was filled in, which I suspect will have a measurable performance impact, as well as complicate the code. Even if you did that, RLE compression can compress uniform-color input really, really well, so all this staggered memory approach might do is make a bunch of smaller allocations on the way to OOM, when the input is small in bytes but large (and otherwise valid) in pixels.\r\n\r\nAgain, this is WAI. I appreciate that you're trying to improve the image packages by fuzzing inputs, but until issue #5050 is fixed (which won't be at least until the tree is open for 1.6), the false positive (like this issue and issue #10399) to true positive ratio is possibly becoming too high.\r\n\r\nIf you want to continue fuzzing, \"comment 1\" on issue #5050 has an approach to avoid \"image too large\" false positives: buffer the reader, call DecodeConfig, check the image width and height, and conditionally rewind the buffer and call Decode.",
	"user": {
		"login": "nigeltao",
		"id": 8565232,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-05-14T00:04:55Z",
	"updated_at": "2015-05-14T00:06:07Z"
}
