{
	"id": 157430271,
	"body": "For the purposes of lexing byte-at-a-time, all multibyte sequences are tentatively alpha. Then we filter once we've parsed the runes. We've always* done that. I know the comment makes it sound like what the Plan 9 C compiler does, but it's really not.\r\n\r\nThis is from Go 1.1 (just to show that the behavior has been this way for a long time):\r\n\r\n\tif(c \u003e= Runeself) {\r\n\t\t/* all multibyte runes are alpha */\r\n\t\tcp = lexbuf;\r\n\t\tep = lexbuf+sizeof lexbuf;\r\n\t\tgoto talph;\r\n\t}\r\n\r\n\tif(yy_isalpha(c)) {\r\n\t\tcp = lexbuf;\r\n\t\tep = lexbuf+sizeof lexbuf;\r\n\t\tgoto talph;\r\n\t}\r\n\r\n\tif(yy_isdigit(c))\r\n\t\tgoto tnum;\r\n\r\n\tswitch(c) {\r\n\tcase EOF:\r\n\t\tlineno = prevlineno;\r\n\t\tungetc(EOF);\r\n\t\treturn -1;\r\n\r\n\tcase '_':\r\n\t\tcp = lexbuf;\r\n\t\tep = lexbuf+sizeof lexbuf;\r\n\t\tgoto talph;\r\n\r\nThat's all the possible ways to start an identifier, leading to the talph label. Then at the label:\r\n\r\n\ttalph:\r\n\t\tfor(;;) {\r\n\t\t\tif(cp+10 \u003e= ep) {\r\n\t\t\t\tyyerror(\"identifier too long\");\r\n\t\t\t\terrorexit();\r\n\t\t\t}\r\n\t\t\tif(c \u003e= Runeself) {\r\n\t\t\t\tungetc(c);\r\n\t\t\t\trune = getr();\r\n\t\t\t\t// 0xb7 · is used for internal names\r\n\t\u003e\u003e\u003e\t\t\tif(!isalpharune(rune) \u0026\u0026 !isdigitrune(rune) \u0026\u0026 (importpkg == nil || rune != 0xb7))\r\n\t\u003e\u003e\u003e\t\t\t\tyyerror(\"invalid identifier character U+%04x\", rune);\r\n\t\t\t\tcp += runetochar(cp, \u0026rune);\r\n\t\u003e\u003e\u003e\t\t} else if(!yy_isalnum(c) \u0026\u0026 c != '_')\r\n\t\t\t\tbreak;\r\n\t\t\telse\r\n\t\t\t\t*cp++ = c;\r\n\t\t\tc = getc();\r\n\t\t}\r\n\t\t*cp = 0;\r\n\t\tungetc(c);\r\n\r\nSo any multibyte non-alphanumeric will end up at talph and then be rejected with a message about that being an invalid character for an identifier (probably the best possible message, although strictly speaking it's making an assumption; maybe the user didn't intend the non-alphanumeric as part of an identifier).\r\n\r\nThe only bug in the code (that I found) was that leading non-ASCII digits were allowed (#11359). I closed this issue without a CL because I don't see any other problems. There is now a test for leading non-ASCII digits, as part of the CL for #11359. The current Go version of the talph block is:\r\n\r\n\ttalph:\r\n\t\tfor {\r\n\t\t\tif c \u003e= utf8.RuneSelf {\r\n\t\t\t\tungetc(c)\r\n\t\t\t\tr := rune(getr())\r\n\t\r\n\t\t\t\t// 0xb7 · is used for internal names\r\n\t\t\t\tif !unicode.IsLetter(r) \u0026\u0026 !unicode.IsDigit(r) \u0026\u0026 (importpkg == nil || r != 0xb7) {\r\n\t\t\t\t\tYyerror(\"invalid identifier character U+%04x\", r)\r\n\t\t\t\t}\r\n\t\t\t\tif cp.Len() == 0 \u0026\u0026 unicode.IsDigit(r) {\r\n\t\t\t\t\tYyerror(\"identifier cannot begin with digit U+%04x\", r)\r\n\t\t\t\t}\r\n\t\t\t\tcp.WriteRune(r)\r\n\t\t\t} else if !isAlnum(c) \u0026\u0026 c != '_' {\r\n\t\t\t\tbreak\r\n\t\t\t} else {\r\n\t\t\t\tcp.WriteByte(byte(c))\r\n\t\t\t}\r\n\t\t\tc = getc()\r\n\t\t}\r\n\r\nThere is also a test (test/fixedbugs/bug163.go):\r\n\r\n\t// errorcheck\r\n\t\r\n\t// Copyright 2009 The Go Authors. All rights reserved.\r\n\t// Use of this source code is governed by a BSD-style\r\n\t// license that can be found in the LICENSE file.\r\n\t\r\n\tpackage main\r\n\t\r\n\tfunc main() {\r\n\t\tx⊛y := 1;\t// ERROR \"identifier\"\r\n\t}\r\n\r\nI'd be happy to look again given a specific test case that is incorrectly accepted.\r\n\r\n* \"always\" here means since June 2009. https://go.googlesource.com/go/+/5d5904bb4dc132e6f97ab990e0bb0c73a2af15ff",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-17T16:56:20Z",
	"updated_at": "2015-11-17T16:56:20Z"
}
