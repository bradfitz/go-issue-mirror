{
	"id": 134691443,
	"body": "There's much debate and feedback already on the linked Google Docs. @codeblooded perhaps you may want to consolidate the feedback in one place or suggest where (here or in the Google doc) you want additional input.\r\n\r\nThere is a deep connection between struct (also called _records_ in other languages) and function parameters (= which are part of the activation _record_ ). It is very intriguing to have similar notation for setting up structs and invoking functions.\r\n\r\nI do like that the proposal is pretty minimal, but that said, here are some of the concerns brought up so far, plus a few new ones:\r\n\r\n- Exported functions cannot change their parameter names anymore or risk to invalidate existing code that uses those names (mentioned by @bradfitz ).\r\n- Named arguments lead to overly long parameter lists ( @bradfitz ).\r\n- What about variables of function types? At the moment, one can assign functions with different parameter names to assignment-compatible function variables. Do parameter names have to match (and thus become part of type identity)? ( @nigeltao )\r\n- When should one use named arguments, and when not? Easily can lead to needless style-guide wars.\r\n- What about variadic functions? How do I provide arguments for the variadic parameter? Or should variadic functions be excluded from this?\r\n- What about functions with unnamed parameters? (We cannot use the type names as in structs since the same parameter type may occur more than once). We would have to exclude those functions as well.\r\n\r\nMy conclusion so far, certainly as far as language design is concerned: When in doubt, leave it out!\r\n\r\nI think permitting automatic deduction of a struct composite literal from assignment context (not just when used inside another composite literal) has a much higher chance of being adopted (@minux, point 2, I also think there's already a proposal or discussion about this elsewhere). This would permit struct parameters and simple passing of struct values w/o the need of the struct type. E.g.:\r\n```\r\ntype Point struct{x, y int}\r\nfunc Distance(p Point) float64 { ... }\r\nfunc Distance(struct{x, y int}) float64 { ... } // note that we already permit this\r\n...\r\nDistance(Point{1, 2}) // currently permitted\r\nDistance(Point{x: 1, y: 2}) // currently permitted\r\nDistance({1, 2}) // would be permitted if struct type were inferred\r\nDistance({x: 1, y: 2}) // would be permitted if struct type were inferred\r\n```\r\n\r\n",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-25T18:16:46Z",
	"updated_at": "2015-08-25T18:18:02Z"
}
