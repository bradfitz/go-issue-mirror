{
	"id": 212641752,
	"body": "This is fixed in 1.6 and at tip; it appears to occur in 1.5.3 and 1.5.4. See below for a diff for a local fix if desired. The diff is basically the backport of changes to the Montgomery code. Closing.\r\n\r\n```\r\ndiff --git a/src/math/big/nat.go b/src/math/big/nat.go\r\nindex 6c242c8..d716ace 100644\r\n--- a/src/math/big/nat.go\r\n+++ b/src/math/big/nat.go\r\n@@ -233,25 +233,25 @@ func (z nat) montgomery(x, y, m nat, k Word, n int) nat {\r\n        if len(x) != n || len(y) != n || len(m) != n {\r\n                panic(\"math/big: mismatched montgomery number lengths\")\r\n        }\r\n-       var c1, c2, c3 Word\r\n        z = z.make(n)\r\n        z.clear()\r\n+       var c Word\r\n        for i := 0; i \u003c n; i++ {\r\n                d := y[i]\r\n-               c2 = addMulVVW(z, x, d)\r\n+               c2 := addMulVVW(z, x, d)\r\n                t := z[0] * k\r\n-               c3 = addMulVVW(z, m, t)\r\n+               c3 := addMulVVW(z, m, t)\r\n                copy(z, z[1:])\r\n-               cx := c1 + c2\r\n+               cx := c + c2\r\n                cy := cx + c3\r\n                z[n-1] = cy\r\n                if cx \u003c c2 || cy \u003c c3 {\r\n-                       c1 = 1\r\n+                       c = 1\r\n                } else {\r\n-                       c1 = 0\r\n+                       c = 0\r\n                }\r\n        }\r\n-       if c1 != 0 {\r\n+       if c != 0 {\r\n                subVV(z, z, m)\r\n        }\r\n        return z\r\n@@ -1076,26 +1076,22 @@ func (z nat) expNNWindowed(x, y, m nat) nat {\r\n // expNNMontgomery calculates x**y mod m using a fixed, 4-bit window.\r\n // Uses Montgomery representation.\r\n func (z nat) expNNMontgomery(x, y, m nat) nat {\r\n-       var zz, one, rr, RR nat\r\n-\r\n        numWords := len(m)\r\n \r\n        // We want the lengths of x and m to be equal.\r\n+       // It is OK if x \u003e= m as long as len(x) == len(m).\r\n        if len(x) \u003e numWords {\r\n-               _, rr = rr.div(rr, x, m)\r\n-       } else if len(x) \u003c numWords {\r\n-               rr = rr.make(numWords)\r\n-               rr.clear()\r\n-               for i := range x {\r\n-                       rr[i] = x[i]\r\n-               }\r\n-       } else {\r\n-               rr = x\r\n+               _, x = nat(nil).div(nil, x, m)\r\n+               // Note: now len(x) \u003c= numWords, not guaranteed ==.\r\n+       }\r\n+       if len(x) \u003c numWords {\r\n+               rr := make(nat, numWords)\r\n+               copy(rr, x)\r\n+               x = rr\r\n        }\r\n-       x = rr\r\n \r\n        // Ideally the precomputations would be performed outside, and reused\r\n-       // k0 = -mˆ-1 mod 2ˆ_W. Algorithm from: Dumas, J.G. \"On Newton–Raphson\r\n+       // k0 = -m**-1 mod 2**_W. Algorithm from: Dumas, J.G. \"On Newton–Raphson\r\n        // Iteration for Multiplicative Inverses Modulo Prime Powers\".\r\n        k0 := 2 - m[0]\r\n        t := m[0] - 1\r\n@@ -1105,9 +1101,9 @@ func (z nat) expNNMontgomery(x, y, m nat) nat {\r\n        }\r\n        k0 = -k0\r\n \r\n-       // RR = 2ˆ(2*_W*len(m)) mod m\r\n-       RR = RR.setWord(1)\r\n-       zz = zz.shl(RR, uint(2*numWords*_W))\r\n+       // RR = 2**(2*_W*len(m)) mod m\r\n+       RR := nat(nil).setWord(1)\r\n+       zz := nat(nil).shl(RR, uint(2*numWords*_W))\r\n        _, RR = RR.div(RR, zz, m)\r\n        if len(RR) \u003c numWords {\r\n                zz = zz.make(numWords)\r\n@@ -1115,8 +1111,7 @@ func (z nat) expNNMontgomery(x, y, m nat) nat {\r\n                RR = zz\r\n        }\r\n        // one = 1, with equal length to that of m\r\n-       one = one.make(numWords)\r\n-       one.clear()\r\n+       one := make(nat, numWords)\r\n        one[0] = 1\r\n \r\n        const n = 4\r\n```",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-04-20T22:44:57Z",
	"updated_at": "2016-04-20T22:44:57Z"
}
