{
	"id": 150743300,
	"body": "On a procedural note, I don't want to use the issue tracker and the proposal process to plan Go 2. We have enough work keeping up with Go 1, and we haven't even begun to think about considering possibly planning Go 2. I am closing this issue so that it does not appear in pending proposals, but I'm leaving the Go2 and Proposal labels so we can find the issue if we ever do get to Go 2.\n\nAs for the actual content of the proposal, Ian noted that it is difficult to implement. But on top of that, it has a serious semantic problem. Andrew noticed the concrete problem with the error example, but it's not just a style nit. It's actually a complete showstopper.\n\nLet's suppose we have:\n\n\ttype I interface {\n\t\tF(X) Y\n\t}\n\t\n\ttype T whatever\n\t\n\tfunc (T) F(X1) Y1 { ... }\n\n\tvar t T\n\tvar x X\n\tvar i I = t // proposal magic happens here\n\tvar y Y = i.F(x) // or maybe here\n\nIt must be that those last two lines of code would behave as the one line:\n\n\tvar y Y = Y(t.F(X1(x)))\n\nI've written the conversions from X to X1 and from Y1 to Y explicitly but of course Go does not require them to be written in code like this. The conversions imply that X1 and Y must be interface types. X and Y1 may or may not be.\n\nSuppose Y is interface{} and Y1 is int and t.F returns 0. Then y ends up being interface{}(0), which seems about right.\n\nSuppose Y is error and Y1 is *MyError and t.F returns (*MyError)(nil). Then y ends up being a non-nil error containing (*MyError)(nil). (See the FAQ entry Andrew mentioned if this does not ring alarm bells.) So when T satisfies I in this case, it cannot return a successful result. It always returns an error. One could of course introduce an exception for typed nil pointers converting to interface{}, but why is the type lost in that one case? Why is a zero pointer different from a zero int? And we surely can't change the way existing interface conversions work. Why is the magic due to interface conversion different from an explicit interface conversion?\n\nThe same narrowing of possibility happens for the arguments, and again it might be a problem. If the interface says F(*MyError) but T's method is F(error), again you have the problem that F may need to be called with a nil error and cannot be. It's less of a concern in the argument position perhaps. But it is still likel a real problem.\n\nThis issue with nil does not happen if you require that all of X, X1, Y, Y1 are interface types. Then the conversion from nil of one interface type to nil of another interface type works as expected. But that likely restricts the utility of the change. It does not allow the Read example.\n\nI think this is the showstopper.\n\nBut then I think there are also other semantic issues and circularities in even deciding whether one recursively defined interface is to be considered to implement a second one. I'm not going to say more about this problem but I think it's there.",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-10-24T02:42:35Z",
	"updated_at": "2015-10-24T02:42:35Z"
}
