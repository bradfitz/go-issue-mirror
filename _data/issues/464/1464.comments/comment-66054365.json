{
	"id": 66054365,
	"body": "\u003ca id=\"c15\"\u003e\u003c/a\u003eComment 15 by **m@capitanio.org**:\n\n\u003cpre\u003eJust notes if someone outside the go team will try to understand\nthe problem. The change was made in commit\n\u003ca href=\"http://code.google.com/p/go/source/detail?r=dba56641aa19\"\u003ehttp://code.google.com/p/go/source/detail?r=dba56641aa19\u003c/a\u003e\n\n-ulimit -v 4000000\n+# Linux charges reserved but not mapped addresses to ulimit -v\n+# so we have to use ulimit -m.\n+ulimit -m 4000000\n\nas mentioned in #9 this is nop at least on linux\n\nThe comments in src/pkg/runtime/malloc.goc and\nsrc/pkg/runtime/malloc.h explain more what's going on:\n\n+\tif(sizeof(void*) == 8) {\n+\t\t// On a 64-bit machine, allocate from a single contiguous reservation.\n+\t\t// 16 GB should be big enough for now.\n+\t\t//\n+\t\t// The code will work with the reservation at any address, but ask\n+\t\t// SysReserve to use 0x000000f800000000 if possible.\n+\t\t// Allocating a 16 GB region takes away 36 bits, and the amd64\n+\t\t// doesn't let us choose the top 17 bits, so that leaves the 11 bits\n+\t\t// in the middle of 0x00f8 for us to choose.  Choosing 0x00f8 means\n+\t\t// that the valid memory addresses will begin 0x00f8, 0x00f9, 0x00fa, 0x00fb.\n+\t\t// None of the bytes f8 f9 fa fb can appear in valid UTF-8, and\n+\t\t// they are otherwise as far from ff (likely a common byte) as possible.\n+\t\t// Choosing 0x00 for the leading 6 bits was more arbitrary, but it\n+\t\t// is not a common ASCII code point either.  Using 0x11f8 instead\n+\t\t// caused out of memory errors on OS X during thread allocations.\n+\t\t// These choices are both for debuggability and to reduce the\n+\t\t// odds of the conservative garbage collector not collecting memory\n+\t\t// because some non-pointer block of memory had a bit pattern\n+\t\t// that matched a memory address.\n+\t\tarena_size = 16LL\u0026lt;\u0026lt;30;\n+\t\tp = runtime·SysReserve((void*)(0x00f8ULL\u0026lt;\u0026lt;32), arena_size);\n+\t\tif(p == nil)\n+\t\t\truntime·throw(\"runtime: cannot reserve arena virtual address space\");\n+\t\truntime·mheap.arena_start = p;\n+\t\truntime·mheap.arena_used = p;\n+\t\truntime·mheap.arena_end = p + arena_size;\n+\t} else {\n+\t\t// On a 32-bit machine, we'll take what we can get for each allocation\n+\t\t// and maintain arena_start and arena_end as min, max we've seen.\n+\t\truntime·mheap.arena_start = (byte*)0xffffffff;\n+\t\truntime·mheap.arena_end = 0;\n+\t}\n+\n+\t// Initialize the rest of the allocator.\t\n \truntime·MHeap_Init(\u0026runtime·mheap, runtime·SysAlloc);\n \tm-\u0026gt;mcache = runtime·allocmcache();\n...\n+\t// Number of bits in page to span calculations (4k pages).\n+\t// On 64-bit, we limit the arena to 16G, so 22 bits suffices.\n+\t// On 32-bit, we don't bother limiting anything: 20 bits for 4G.\n #ifdef _64BIT\n-#include \"mheapmap64.h\"\n+\tMHeapMap_Bits = 22,\n #else\n-#include \"mheapmap32.h\"\n+\tMHeapMap_Bits = 20,\n #endif\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2011-02-04T06:56:53Z",
	"updated_at": "2014-12-22T05:47:49Z"
}
