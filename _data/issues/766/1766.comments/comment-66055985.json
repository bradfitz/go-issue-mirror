{
	"id": 66055985,
	"body": "\u003ca id=\"c4\"\u003e\u003c/a\u003eComment 4 by **umbricola**:\n\n\u003cpre\u003eThanks for the 6l -a tip --- my gdb seems not to be able to disassemble gc binaries.\n\nRuss, what are your CPU specs?  I am surprised that you got a billion loop iterations to\nrun in 0.24 seconds.  I think that would require your CPU to be running at a bit over\n4.0 GHz at minimum.\n\nAlso, the code you cite from addloop1_c and addloop1_modular has essentially the same\nfirst three instructions, but then addloop1_c branches with jg, while addloop1 says JLT.\n Those don't appear to mean the same thing.\n\nNote that addloop1_monolithic differs from addloop1_modular not only in reloading limit\nfrom memory, but also in keeping the accumulator t in memory.  The accumulation into t\nis a loop-carried dependence chain; routing that through memory is bound to be expensive\nin a short loop like this.  I bet the performance is getting hurt from t being in memory\nmore than from reloading bx through r8, which is not involved in a loop-carried\ndependence chain.\n\nIt is interesting that t was put in memory during the loop: it is local to the function\nand nothing has happened to it yet but := and += statements.  The only thing I can think\nof is that the later call to fmt.Printf() might be taking the address of t under the\nhood (I don't know what the compiler does to make an interface{} out of an int for that\ncall).\n\nRegarding inc versus add, Agner Fog's excellent manuals do warn that using inc foo\ninstead of add $1, foo can cause stalls or extra dependencies in some cases, but I don't\nhave a good understanding of when it hurts.  I have attached another tarball that runs\nfour different assembly implementations of the addition loop.  On my chip it doesn't\nseem to matter in this case whether I use add $1, foo or inc foo.  But it does matter\nwhether I use jg or jne as the loop branch instruction: jne is better here.  I think\nthat is because my chip (running in 32-bit mode for this executable) can macrofuse a cmp\nwith a jne but not with a jg.  I wouldn't have expected that to hurt this much, though:\n\n% ./addloop1_asm-run.sh\ninc + jg:\n-1243309312\n        0.86 real         0.86 user         0.00 sys\nadd + jg:\n-1243309312\n        0.86 real         0.85 user         0.00 sys\ninc + jne:\n-1243309312\n        0.50 real         0.50 user         0.00 sys\nadd + jne:\n-1243309312\n        0.50 real         0.50 user         0.00 sys\n\nIn the numbers I posted originally, my gcc figured out that provided limit is positive,\nit could use jne instead of jg or the like in the arithmetic loop, and that's why the\nbinary it compiled ran in 0.50 seconds instead of 0.86 seconds.\n\nRegarding branch target alignment, that can matter, but I wouldn't expect Russ's listed\naddloop1_modular code to get hurt because the whole loop fits into one naturally aligned\n16-byte code block despite the branch target's misalignment.\u003c/pre\u003e\n\n\n\n\n\nAttachments:\n\n1. \u003ca href=\"https://storage.googleapis.com/go-attachment/1766/4/umbricola-go-defect-report-addloop1_asm.tar\"\u003eumbricola-go-defect-report-addloop1_asm.tar\u003c/a\u003e (10240 bytes)",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2011-05-03T13:16:24Z",
	"updated_at": "2014-12-08T10:09:48Z"
}
