{
	"id": 66094189,
	"body": "\u003ca id=\"c8\"\u003e\u003c/a\u003eComment 8:\n\n\u003cpre\u003eOK, I have to admit now I see this issue originally written with a relatively vague\nunderstanding of the problem. With (hopefully) somewhat more specific view of the domain\nhere is my current list of possible \"contractual\" promises behind the GC() call:\n\n1. No promise regarding functionality whatsoever.\n2. No promise regarding instance freeze whatsoever.\n3. After GC() return freed application memory will be available for the OS to collect at\nit's own pace.\n4. If something to be done, it will be over by the time GC() returns.\n5. If there will be a freeze, it will be over by the time GC() returns. A specific\nruntime implementation should document if a behavior is different.\n6. There is no other freeze initiated except for when something calls GC() either in by\nuser code or the runtime library. A specific runtime implementation should document if a\nbehavior is different.\n7. Runtime calls to GC() are controlled by the feature ___ (fill the blank). A specific\nruntime implementation should document if a behavior is different.\n\nNote, I am avoiding to mention implementation details in promises except for freeze\nboundaries expectations. The indeterminate timing side effect of a freeze feels\nimpactful enough to request it to be somewhat documented. A side effect is not an\nimplementation detail, isn't it?\n\nIn addition to the promises themselves, there are longevity expectations (horizons),\ngiven the still-flexible status of memory management in Go. So here are my candidates:\n\nA. May change at any time\nB. May never change\nC. Will not change until the next minor release\nD. Will not change until the next major release\nE. Will not change until drastic changes in Go gc architecture\n\nI take it as granted that these lists are incomplete.\n\nThe current code (and embedded doc) promises seem to be 1, 2, 3, A, B. Which makes me\nwonder, why GC() is made a public method at all? My guess is that other packages, like\nbenchmarks, actually do need some of promises above, and do need public access to the\ncall. So there are promises beyond 3 and horizons beyond b which are known to a group of\ndevelopers, just not documented to the rest of the public. If one takes time to read the\ncode, than may answer promise questions, yet this will not clarify horizons. If one\nsearches forums they may get a feeling of a horizon for a specific promise. Both take\nconsiderable time. It is hard to see this part of documentation as an efficient and\neffective developer-to-developer communication.\n\nAs Ian caught me red-handed :D I would like to have this contract changed. My\npreferences are promises 5, 6, and 7 with the E horizon. Logic being that if gc changes\ndramatically, the consumers will want to adjust for the new behavior anyhow.\n\nI understand the beauty of programming for an unpredictable environment. I understand\nand experienced that this approach tends to produce more reliable systems. However, it\nis effective as an approach when a developer strike a fine balance in their trade-offs.\nI think we can improve this communication to have a better understanding of behavior\ndeterminism inside our executables after build time. I also think it is reasonable that\nsome important documentation to be delegated to and request from runtime implementations.\u003c/pre\u003e",
	"user": {
		"login": "didenko",
		"id": 99670,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-05-25T18:16:39Z",
	"updated_at": "2014-12-08T10:43:41Z"
}
