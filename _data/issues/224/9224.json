{
	"id": 51390175,
	"number": 9224,
	"state": "closed",
	"title": "cmd/go: get -u fails partially first time, succeeds second time when dependencies were refactored",
	"body": "## Overview\r\n\r\nIn certain (reproducible and predictable) situations, running `go get -u` will **partially fail the first time, but succeed the second time**. During the first run, it will succeed to update the repository, but fail to build while printing an erroneous error message about a missing dependency. During the second run, everything will succeed.\r\n\r\nThis happens when Go code is refactored in a way so that one Go package that was previously imported ceases to exist, but it is also no longer imported hence the Go code is valid. For example, if a package that was previously imported is merged into another, or if a package is renamed and now has a new import path.\r\n\r\nThis is a problem because it hinders ones ability to refactor Go code. **We now have ever-more-powerful refactoring tools** like [`gorename`](https://groups.google.com/d/topic/golang-nuts/96hGPXYfqsM/discussion) that are able to help with refactoring. In its todo list is the ability to rename import paths. That ability is already present within another tool [`govers`](http://godoc.org/launchpad.net/govers) today. Being able to seamlessly improve and refactor Go code is important to allow it to get better. No one can come up with the perfect version the first time around, so it's possible they'll want to refactor after using the package for some time and having a better vision. An implementation detail limitation of `go get -u` should not hinder that.\r\n\r\n#### What does `go version` print?\r\n\r\n`go version go1.4rc2 darwin/amd64`\r\n\r\n#### What steps reproduce the problem?\r\n\r\nIn order to prepare a (minimal) environment where the problem can be reproduced (i.e., it happens when `go get -u` runs and there are updates available), you need the following preparation steps first:\r\n\r\n1. Run `go get -d -u github.com/shurcooL/go-get-test-cmd`. It has only one external dependency repo `github.com/shurcooL/go-get-test-lib` which will also be fetched.\r\n2. Cd into `$GOPATH/src/github.com/shurcooL/go-get-test-lib` folder.\r\n3. _Being careful to do this in the right folder (!)_, run `git reset --hard master^` to hard reset `go-get-test-lib` repo to previous commit. This will make it so that when we run `go get -u` there will be one update available.\r\n    - The `go-get-test-lib` repo has 2 commits. We need to pretend that at this time it only has 1 commit, and a new commit is made available later on.\r\n\r\nThat simulates a scenario where a user has an existing version of your Go package and its dependencies, and you decide to refactor one of the dependencies in this way:\r\n\r\nhttps://github.com/shurcooL/go-get-test-lib/compare/master%5E...master\r\n\r\nNow, you are ready to reproduce the problem, follow these steps:\r\n\r\n1. Run `go get -u github.com/shurcooL/go-get-test-cmd`.\r\n2. Run `ls $GOPATH/bin/go-get-test-cmd` and see that it failed to build.\r\n3. Run `go get -u github.com/shurcooL/go-get-test-cmd` a second time.\r\n4. Run `ls $GOPATH/bin/go-get-test-cmd`.\r\n\r\n#### What happened?\r\n\r\n```bash\r\n$ go get -u github.com/shurcooL/go-get-test-cmd\r\npackage github.com/shurcooL/go-get-test-cmd\r\n\timports github.com/shurcooL/go-get-test-lib/liba\r\n\timports github.com/shurcooL/go-get-test-lib/libb\r\n\timports github.com/shurcooL/go-get-test-lib/libb\r\n\timports github.com/shurcooL/go-get-test-lib/libb: cannot find package \"github.com/shurcooL/go-get-test-lib/libb\" in any of:\r\n\t/usr/local/go/src/github.com/shurcooL/go-get-test-lib/libb (from $GOROOT)\r\n\t/Users/Dmitri/GoPath/src/github.com/shurcooL/go-get-test-lib/libb (from $GOPATH)\r\n$ ls $GOPATH/bin/go-get-test-cmd\r\nls: /Users/Dmitri/GoPath/bin/go-get-test-cmd: No such file or directory\r\n$ go get -u github.com/shurcooL/go-get-test-cmd\r\n$ ls $GOPATH/bin/go-get-test-cmd\r\n/Users/Dmitri/GoPath/bin/go-get-test-cmd\r\n$ \r\n```\r\n\r\n#### What should have happened instead?\r\n\r\nEverything should've succeeded the on the first run of `go get -u`.\r\n\r\n```\r\n$ go get -u github.com/shurcooL/go-get-test-cmd\r\n$ ls $GOPATH/bin/go-get-test-cmd\r\n/Users/Dmitri/GoPath/bin/go-get-test-cmd\r\n$ go get -u github.com/shurcooL/go-get-test-cmd\r\n$ ls $GOPATH/bin/go-get-test-cmd\r\n/Users/Dmitri/GoPath/bin/go-get-test-cmd\r\n$ \r\n```\r\n\r\n#### Please provide any additional information below.\r\n\r\nThis happens when Go code is refactored in a way so that one Go package that was previously imported ceases to exist, but it is also no longer imported hence the Go code is valid. However, when a user runs `go get -u` to update, it _first_ parses the previous code to get a list of Go packages, then updates repos and does not re-parse the updated code (to find that a certain dependency is actually no longer imported) before returning an error that the previously imported package doesn't exist.\r\n\r\nIn the reproduce steps above, I used a refactor example where previously `liba` and `libb` were used, but `libb` is merged into `liba`. I would imagine the same issue would happen if `libb` were renamed to `libc` (and imported under new name) for example.\r\n\r\nThis likely affects `/internal/` Go packages too. That means one can not use the argument that \"you should not be removing old import path since someone might be importing it\" for `/internal/` Go packages as they're guaranteed not to be imported by anyone else, and you should be free to refactor them.\r\n\r\nWorkarounds:\r\n\r\n- Tell users to always run `go get -u` twice and ignore (possible) problems on first run.\r\n- Keep the old package around indefinitely.\r\n- Keep old package around for some amount of time. However, even if you keep it for a month, there's no guarantee some user will not run `go get -u` after 2 months and encounter this problem, it just reduces that chance.\r\n    - Alternatively, provide an empty package stub at the old location, for example see https://github.com/shurcooL/go/commit/c53996fe3f061319df88893596bfc50547f1768d. This allows the issue to be avoided.",
	"user": {
		"login": "shurcooL",
		"id": 1924134,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		}
	],
	"comments": 2,
	"closed_at": "2015-07-15T04:41:22Z",
	"created_at": "2014-12-09T05:44:45Z",
	"updated_at": "2016-07-18T19:45:32Z",
	"milestone": {
		"id": 905105,
		"number": 1,
		"title": "Go1.5"
	}
}
