{
	"id": 202572084,
	"body": "\u003e Also if you decide not to unescape %2F then you also can't unescape %252F, and because you're not unescaping that, you can't unescape %25252F, or %2525252F, and so on. It gets into a rathole pretty quickly. And if we started doing this all of a sudden then you'd have to worry about people seeing %2F and not knowing if it was a preserved %2F or a decoded %252F being process by an earlier version of Go.\r\n\r\nTrue. However, RFC3986 defines a concept of equivalence, which goes as far as unescaping unreserved characters. Problem with `URL.Path` is that it maps URLs from distinct equivalence classes to the same string value, and any change in how things are unescaped for `URL.Path` is API-breaking change. So it's either `URL.Path` is left broken or someone's code exhibits behavior change; you can't avoid both of these because there may be existing code that relies on this particular brokenness. \r\n\r\nIt is possible to preserve equivalence while mapping URL paths to string values by unescaping only unreserved characters (and \"%\" is _not_ unreserved, it's funny^Wannoying that \"reserved\" + \"unreserved\" sets don't cover full ASCII), and then having `UnescapeNonUnreserved(string) string` function to be used on separate path components. But it would be less fragile to expose parsed and unescaped path as `[]string`.\r\n\r\n\u003e https://www.reddit.com/r/golang/comments/46bd5h/ama_we_are_the_go_contributors_ask_us_anything/d05lewi.\r\n\u003e Similarly, the decision to use unescaped URLs in the API has been overall very helpful: no handler has to worry about turning index%2Ehtml into index.html, for example.\r\n\r\nI totally agree that unescaping (more precisely â€“ normalization https://tools.ietf.org/html/rfc3986#section-6 ) is very useful and simplifies user code, but it was taken a bit too far and now it's too late to fix it in-place without breaking someone's code.\r\n\r\n\u003e In the long term I think very limited wildcard support in ServeMux might help provide an API with the convenience of the single string form and still have the ability to pull out these kinds of mangled paths from individual elements.\r\n\r\nIn my case it doesn't mess the routing (i.e. it invokes the exact handler I want it to), but once it does, there's already no way to distinguish between `/` (path separator) and `%2F` (escaped \"/\" character). So unless you plan to bring preserving of escaped reserved characters (i.e. using `URL.RawPath` instead of `URL.Path`) along with wildcards, it won't help.\r\n\r\n\u003e It should have been 'Path []string' and people who wanted the full path would have to strings.Join(u.Path, \"\") or something like that. But obviously we can't do that now.\r\n\r\nHow about adding `URL.ParsedPath []string`? Just like `URL.RawPath` was added in 1.5. It may require some considerations about what to do when it gets inconsistent with `URL.Path` and `URL.RawPath`, but I don't see any fundamental reason why it's not possible. Oh, and before joining path components you'd need to escape non-unreserved characters in each component, so it's a bit more complicated than simple `strings.Join`.\r\n\r\nIt's also possible to add it as `URL.ParsedPath() []string` (that will work off `URL.EscapedPath()`) and transition to use that instead of `URL.Path` in `http.ServeMux` and other standard packages.\r\n\r\n\u003e The workaround is to pass your own handler to Serve or ListenAndServe and have that handler pick off the %2F paths you care about before handing the rest to ServeMux.\r\n\r\nYeah, for now I'm stuck with my own clone of `http.ServeMux` that preserves only `%2F` in the path.",
	"user": {
		"login": "gelraen",
		"id": 654649,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-03-28T20:38:33Z",
	"updated_at": "2016-03-28T20:38:33Z"
}
