{
	"id": 225462091,
	"body": "`Size() int64` would be the first method mentioned in package io which does not return an error -- that does seem quite inconsistent.\r\n\r\nAs far as I can tell, Sizer's original use came from os.FileInfo. Subsequent cases skipped the `Stat() (FileInfo, error)` indirection.\r\n\r\nA few options I see (in decreasing order of personal preference):\r\n\r\n### Function that produces a conventional SizeReaderAt from any StatReaderAt\r\n\r\nWe could provide a function like:\r\n\r\n```func NewSizeReaderAt(StatReaderAt) (SizeReaderAt, error)```\r\n\r\nIn this case, SizeReaderAt would just be `interface { ReaderAt; Size() int64 }`\r\n\r\nThis would allow an os.File to be used fairly conveniently as an os.SizeReaderAt without adding any methods to existing types.\r\n\r\n### Implement Stat method on {bytes,strings}.Reader\r\n\r\nbytes.Reader and strings.Reader can be given a stat method which returns a mostly-stubbed os.FileInfo. This would make those types more file-like, but increase the complexity of the interfaces that would come out of this (io.StatReaderAt). A `func NewSizeStat(size int64) os.FileInfo` or `func NewStat(struct { Size int64; ... }) os.FileInfo` could be added somewhere to make stubbed Stat methods trivial to write.\r\n\r\nThis would also make it easier for strings.Reader and other types to be used in implementing http.File and similar.\r\n\r\n### Multiple incompatible interfaces for the same method name\r\n\r\nAny code accepting a \"Size\" method should check for both `Size() int64` and `Size() (int64, error)` implementations; io could contain a `type Sizer interface { Size() (int64, error) }` and provide a utility function to aid compatibility:\r\n\r\n```\r\n// Size has the following behaviors:\r\n// - Size(interface { Size() (sz int64, err error) }) -\u003e (sz, err)\r\n// - Size(interface { Size() (sz int64) }) -\u003e (sz, nil)\r\n// - Size(interface { Len() (sz int) }) -\u003e (int64(sz), nil)\r\nfunc Size(interface{}) (int64, error)\r\n```\r\n\r\nAlternatively, or in addition, a `NewSizer(interface{}) io.Sizer` could be provided. vet could warn if inputs to these functions do not implement any of the accepted interfaces.\r\n\r\n### Make a new method, with a new name\r\n\r\n`ByteLen() (int64, error)` for example. This would allow bytes.Reader, strings.Reader, and os.File to all gain a unified method with the expected semantics, without breaking compatibility. This would be the third method for bytes.Reader and strings.Reader, however.\r\n\r\n### Give os.File conventional Stat method, but also `Err() error`\r\n\r\nMake os.File stateful, similar to bufio.Scanner, such that the Err method acts as a surrogate for a missing error return value in Size.",
	"user": {
		"login": "extemporalgenome",
		"id": 536740,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-06-12T21:38:58Z",
	"updated_at": "2016-06-12T21:38:58Z"
}
