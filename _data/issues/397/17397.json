{
	"id": 182023104,
	"number": 17397,
	"state": "closed",
	"title": "Multiple issues with gzip package",
	"body": "Please answer these questions before submitting your issue. Thanks!\r\n\r\n### What version of Go are you using (`go version`)?\r\n\r\n`go version go1.6.1 linux/amd64`\r\n\r\n### What operating system and processor architecture are you using (`go env`)?\r\n\r\n```\r\nGOARCH=\"amd64\"\r\nGOBIN=\"\"\r\nGOEXE=\"\"\r\nGOHOSTARCH=\"amd64\"\r\nGOHOSTOS=\"linux\"\r\nGOOS=\"linux\"\r\nGOPATH=\"/redacted\"\r\nGORACE=\"\"\r\nGOROOT=\"/usr/local/go\"\r\nGOTOOLDIR=\"/usr/local/go/pkg/tool/linux_amd64\"\r\nGO15VENDOREXPERIMENT=\"1\"\r\nCC=\"gcc\"\r\nGOGCCFLAGS=\"-fPIC -m64 -pthread -fmessage-length=0\"\r\nCXX=\"g++\"\r\nCGO_ENABLED=\"1\"\r\n```\r\n\r\n### What did you do?\r\nIf possible, provide a recipe for reproducing the error.\r\nA complete runnable program is good.\r\nA link on play.golang.org is best.\r\n\r\nI tried to read gzipped stream over SSH using `gzip` package.  I'm still struggling with minimal example, but here's the gist of it:\r\n1. Using `golang.org/x/crypto/ssh` package connect to a remote machine and execute\r\n```\r\ncat some-large.file | gzip -f\r\n```\r\n2. Set `session.Stdout` to an instance of `bytes.Buffer`.\r\n3. Try feeding this buffer to `gzip.NewReader`\r\n\r\n### What did you expect to see?\r\nGzip stream is parsed.\r\n\r\n### What did you see instead?\r\n\r\n1. First problem: `gzip.NewReader` is blocking - why do you try to read in this function? A workaround is to create a fake reader which will instantiate `gzip.Reader` after ensuring some data are already received.\r\n2. Second problem: `gzip` code seems to not be able to read from stream (i.e. it wants all bytes to have been already received). This is just my guess though. See below: it panics when truncating the `bytes.Buffer`\r\n\r\n```\r\npanic(0xa2fec0, 0xc820c9a370)\r\n\t/usr/local/go/src/runtime/panic.go:481 +0x3e6\r\nbytes.(*Buffer).Truncate(0xc820bf2690, 0x0)\r\n\t/usr/local/go/src/bytes/buffer.go:71 +0xbf\r\nbytes.(*Buffer).ReadByte(0xc820bf2690, 0xf7, 0x0, 0x0)\r\n\t/usr/local/go/src/bytes/buffer.go:300 +0x51\r\ncompress/flate.(*decompressor).moreBits(0xc82111a400, 0x0, 0x0)\r\n\t/usr/local/go/src/compress/flate/inflate.go:719 +0x4d\r\ncompress/flate.(*decompressor).huffSym(0xc82111a400, 0xc82111a430, 0x0, 0x0, 0x0)\r\n\t/usr/local/go/src/compress/flate/inflate.go:741 +0x5b\r\ncompress/flate.(*decompressor).huffmanBlock(0xc82111a400)\r\n\t/usr/local/go/src/compress/flate/inflate.go:485 +0x46\r\ncompress/flate.(*decompressor).copyHuff(0xc82111a400)\r\n\t/usr/local/go/src/compress/flate/inflate.go:638 +0x3e\r\ncompress/flate.(*decompressor).Read(0xc82111a400, 0xc820d78000, 0x8000, 0x8000, 0xc82015b400, 0x0, 0x0)\r\n\t/usr/local/go/src/compress/flate/inflate.go:355 +0x1ae\r\ncompress/gzip.(*Reader).Read(0xc820c8c2c0, 0xc820d78000, 0x8000, 0x8000, 0x656375746f624578, 0x0, 0x0)\r\n\t/usr/local/go/src/compress/gzip/gunzip.go:269 +0xef\r\n```\r\n3. Error message in both `bytes` and in `gzip` packages are nondescript and carry very little useful information.  Eg. `\"bytes.Buffer: truncation out of range\"` is next to useless w/o specifying what the range was and what the index was.  Same goes for `\"gzip: invalid checksum\"` and `\"gzip: invalid header\"`, spurious `io.EOF` and other low-level non-digestable stuff.",
	"user": {
		"login": "least-olegs",
		"id": 16243408,
		"type": "User",
		"site_admin": false
	},
	"comments": 1,
	"closed_at": "2016-10-10T17:28:05Z",
	"created_at": "2016-10-10T14:04:34Z",
	"updated_at": "2016-10-10T17:28:55Z"
}
