{
	"id": 220187886,
	"body": "I fear this line of investigation is mostly my fault because of my focus on\nthe from scratch compile time of jujud. It is a useful benchmark because it\nruns in human time scales and has generated great results including the\nhuge improvements in link time.\n\nWithout excluding the excellent investigation that Josh has done, I think\nthat the focus should be on parallising cmd/compile as that will give\nbenefit to all compiler users, not just the ones that build front scratch\nevery time.\n\nThanks\n\nDave\n\nOn Thu, 19 May 2016, 09:11 Keith Randall, \u003cnotifications@github.com\u003e wrote:\n\n\u003e On Wed, May 18, 2016 at 3:51 PM, Josh Bleecher Snyder \u003c\n\u003e notifications@github.com\u003e wrote:\n\u003e\n\u003e \u003e parallelizing packages and parallelizing compilation within a\n\u003e \u003e package (which we're also thinking about doing), are going after the same\n\u003e \u003e idle cycles\n\u003e \u003e\n\u003e \u003e Indeed. However, (a) there will always be inefficiencies in getting work\n\u003e \u003e scheduled, so doing both could help nevertheless and (b) as @bradfitz\n\u003e \u003e \u003chttps://github.com/bradfitz\u003e observed, scheduling compilation processes\n\u003e \u003e better helps a lot more if you start to ship compilation off over the\n\u003e \u003e network to other machines.\n\u003e \u003e\n\u003e \u003e Parallelizing compiles sounds like the code is easier, but it may make\n\u003e the\n\u003e \u003e system harder to manage - how many parallel compiles should be running?\n\u003e \u003e How much memory would that take? What if there's an error? The\n\u003e \u003e multiprocess spiderweb gets unwieldy after a while.\n\u003e \u003e\n\u003e \u003e cmd/go already parallelizes compiles, just not super efficiently; it\n\u003e \u003e already handles errors and juggles the spiderweb. That said, I rather\n\u003e \u003e dislike the cmd/go codebase, in part for this reason. :)\n\u003e \u003e\n\u003e \u003e cmd/go chooses ncpus as the number of parallel compiles to run, which can\n\u003e \u003e be altered with -p. My experiments with the -p flag so far indicate that\n\u003e \u003e doing fewer parallel compiles is clearly bad for wall time. And that\n\u003e \u003e despite the fact that cmd/compile actually already does rely on more\n\u003e than a\n\u003e \u003e single CPU (due to GC?): compiling with GOMAXPROCS=1 on my machine\n\u003e causes a\n\u003e \u003e roughly 30-50% slowdown.\n\u003e \u003e\n\u003e \u003e Also worth noting is that not all of cmd/go's work is in the\n\u003e compiler--cgo\n\u003e \u003e and resulting c compilations can be a big part of compile times, and\n\u003e those\n\u003e \u003e are not likely to be as core-saturating as cmd/compile anytime soon.\n\u003e \u003e\n\u003e True.\n\u003e\n\u003e \u003e So I'm inclined to say it is still worth pursuing both paths. And we have\n\u003e \u003e the tools to control concurrency on both fronts (-p, GOMAXPROCS), so\n\u003e \u003e benchmarking and experimentation is easy.\n\u003e \u003e\n\u003e Scheduling multiple parallel-capable processes is tricky. Suppose we're in\n\u003e the middle of a build and there's only one compile that can be started. Do\n\u003e we give it all the rest of the available cpus? Maybe the answer is yes.\n\u003e But then what if a previously-issued compile completes and now a bunch of\n\u003e new compiles are ready to go? We've already committed almost all the\n\u003e processors to that one compile, so there aren't many left for all the\n\u003e (possibly on the critical path) compiles that are now ready. Maybe we\n\u003e could steal some processors back from the compile we already started?\n\u003e Pretty soon we've reimplemented the entire Go work-stealing scheduler in\n\u003e cmd/go.\n\u003e\n\u003e I'm not saying we shouldn't do this. I'd really like to have the tracing\n\u003e output, at least. But getting the parallelization right isn't easy and\n\u003e splitting up the decision point into two different binaries won't help any.\n\u003e\n\u003e \u003e —\n\u003e \u003e You are receiving this because you commented.\n\u003e \u003e Reply to this email directly or view it on GitHub\n\u003e \u003e \u003chttps://github.com/golang/go/issues/15736#issuecomment-220181188\u003e\n\u003e \u003e\n\u003e\n\u003e —\n\u003e You are receiving this because you are subscribed to this thread.\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/15736#issuecomment-220185013\u003e\n\u003e\n",
	"user": {
		"login": "davecheney",
		"id": 7171,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-05-18T23:27:50Z",
	"updated_at": "2016-05-18T23:27:50Z"
}
