{
	"id": 66075750,
	"body": "\u003ca id=\"c3\"\u003e\u003c/a\u003eComment 3:\n\n\u003cpre\u003eYes. The overhead can be 30% in some cases and goes down toward 5%-10% in\ngeneral. What I'm using is this non-leaf method:\n\n// add: z += a\nfunc (z *Integer) Add(a *Integer) {\n FixedAdd(z, a) // Sigh... not possible to generate methods in assembler\n}\n\n// increment: z += 1\nfunc (z *Integer) Inc() {\nFixedInc(z) // Sigh... not possible to generate methods in assembler\n}\n\nAn alternate would be to inline these calls. Perhaps gcflags=\"-l -l -l -l\n-l -l -l -l -l -l -l -l -l -l\" will (asymptotically with enough L's) do the\njob.\n\nAnother is to unwrap my method calls in all the call sites. I have three\nversions of math libraries under my code, one of which has the assembler\nversions. In the others, the code is inline or else uses math/big. I could\nmake an m4 macro ADD(a,b) that expands to a.Add(b) in two cases and\nAdd(a,b) in the third. Easy to do, and easy to run m4 from a Makefile.\n\nThe reason for the bug/feature request was aspirational toward a\nclean/complete solution as opposed to the workarounds. I'm actually\ncomfortable with the workarounds. Every tool has limits, and limits can be\ncircumvented.\n\nThe problem is that the code itself is trivial in assembler but impossible\nin Go (or C or ...) because I need to look at the carry flag. Not doing\nthat means very awkward workarounds:\n\nfunc FixedAdd(z, a *Integer) {\n// general, portable, slow version\n carry := uint64(0)\nfor i, v := range a {\n t := z[i] + v + carry\nz[i] = t\n carry = 0\nif t \u0026lt; v {\n carry = 1\n}\n }\n}\n\nvs\n\n// FixedAdd: z += a, z and a are 4-word (256 bit) fixed precision integers\n// func FixedAdd(z, a *Integer)\nTEXT �FixedAdd(SB),$0-16\n MOVQ a+8(FP), CX    // make a[] accessible\nMOVQ z+0(FP), AX    // make z[] accessible\n MOVQ (CX), BX       // load a[0]\nMOVQ (AX), R8       // load z[0]\n ADDQ BX, R8         // sum = a[0] + z[0], set carry\nMOVQ R8, (AX)       // store sum in z[0]\n MOVQ 8(CX), BX      // load a[1]\nMOVQ 8(AX), R8      // load z[1]\n ADCQ BX, R8         // sum = a[1] + z[1] + carry\nMOVQ R8, 8(AX)      // store sum in z[1]\n MOVQ 16(CX), BX     // load a[2]\nMOVQ 16(AX), R8     // load z[2]\n ADCQ BX, R8         // sum = a[2] + z[2] + carry\nMOVQ R8, 16(AX)     // store sum in z[2]\n MOVQ 24(CX), BX     // load a[3]\nMOVQ 24(AX), R8     // load z[3]\n ADCQ BX, R8         // sum = a[3] + z[3] + carry\nMOVQ R8, 24(AX)     // store sum in z[3]\n RET\n\n// FixedInc: z++, z is a 4-word (256 bit) fixed precision integer\n// func FixedInc(z *Integer)\nTEXT �FixedInc(SB),$0-8\nMOVQ z+0(FP),AX     // make z[] accessible\n MOVQ (AX),BP        // load z[0]\nADDQ $1,BP          // increment\n MOVQ BP,(AX)        // store sum in z[0]\nMOVQ 8(AX),BP       // load z[1]\n ADCQ $0,BP          // add carry\nMOVQ BP,8(AX)       // store sum in z[1]\n MOVQ 16(AX),BP      // load z[2]\nADCQ $0,BP          // add carry\n MOVQ BP,16(AX)      // store sum in z[2]\nMOVQ 24(AX),BP      // load z[3]\n ADCQ $0,BP          // add carry\nMOVQ BP,24(AX)      // store sum in z[3]\n RET\n\nfor the 4-Word unrolled case. I know most people don't care about things\nlike this, but my code is 3x faster than math/big and that matters to me\nwhen the program has month-long runtimes on my 8-core Xeon. 10 days is a\nlot shorter than a month, especially in terms of threats like power outages\nor accidental family unplugging. ;-)\n\nThe (seemingly) needless call in the method is at most two or three days\nwasted. I can deal with that, though it feels incomplete that developers\ncan't compile -S, tweak code, and replace the original with an assembler\nversion.\n\nOne other thought--slightly hacky--is that my assembler versions *are\nalready the methods* that I need, given the calling sequence. If there was\na relaxation of something in the existing toolchain that would look at the\ndeclaration file and call methods there as the simple functions that they\nare, all would be well. For clarity:\n\nPresent case, in fixed_decl.go:\n\npackage integer\n\n// implemented in add_$GOARCH.s\nfunc FixedAdd(z, a *Integer)\nfunc FixedInc(z *Integer)\n\n\nPresent case, in mind of compiler, \"Fixed add is a function of two\narguments...\"\n\nAlternate case, fixed_decl.go would be:\n\npackage integer\n\n// implemented in add_$GOARCH.s\nfunc (z *Integer) FixedAdd(a *Integer)\nfunc (z *Integer) FixedInc()\n\n\nAlternate case, in mind of compiler, \"Fixed add is a function of two\narguments...\". The change being to use the declaration as \"func (z\n*Integer) FixedAdd(a *Integer)\" for calling purposes but knowingly link in\n\"func FixedAdd(z, a *Integer)\" for symbol table/type purposes. This is\nacknowledging that if the tool chain would just play along, then it would\nall work out fine as it already is. (The futility of which makes waiting an\nextra week seem like an extra two weeks! ;-)\n\nBest to you whatever makes sense for Go,\nMichael\u003c/pre\u003e",
	"user": {
		"login": "MichaelTJones",
		"id": 7877285,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-03-05T19:39:32Z",
	"updated_at": "2014-12-22T06:22:40Z"
}
