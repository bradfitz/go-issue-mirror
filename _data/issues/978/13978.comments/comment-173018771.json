{
	"id": 173018771,
	"body": "I can think of a few hypotheses:\r\n\r\n1. The background mark worker goroutine was resumed from preemption with g.m == nil.\r\n2. The background mark worker was running and something it did set g.m to nil (without stopping the G).\r\n3. The background mark worker was running and another thread concurrently set g.m to nil.\r\n4. The background mark worker was running and a signal (running synchronously) returned with g.m set to nil.\r\n5. Memory corruption.\r\n\r\nWe may be able to disprove 1 by looking at where the SIGSEGVs happen relative to possible preemption points. The background mark worker has fairly limited preemption points and since the goroutine can only resume at a preemption point, if there are any successful accesses to g.m between the crash and the previous preemption point, we can rule out 1.\r\n\r\nMy case from #13363 does not disprove 1. In fact, since we resume from an involuntary preemption at the call to morestack, the crash happened just a few instructions after a possible resume point. This lends support to theory 1, but does not prove it.\r\n\r\n@rhysh, in 1452891329, do you know which acquirem crashed?\r\n\r\nCrash 1453060415 would seem to disprove 1. As of the acquirem in gopark, the goroutine hasn't been preemptible for quite a while. On all of the code paths that lead from disabling preemption to gopark (of which I think there are three: function entry, regular looping around, and looping around from the gcMarkDone condition), we've done our own acquirem, which would indicate g.m != nil since the last preemption point.\r\n\r\nFurther evidence against 1 is that execute itself would crash if g.m were nil. However, there are other calls to gogo that wouldn't crash if g.m were nil.\r\n\r\nFor 2 and 3, we need to consider the places that modify g.m. Ignoring places where we assign g0.m or gsignal.m, there are four: newextram, execute, dropg, and goexit0. newextram always sets it to non-nil (and immediately uses it), so we can discount it. Likewise, execute would crash if g.m were nil. dropg and goexit0 do set g.m to nil.\r\n\r\n@rhysh or @tarrant, could you have GDB dump the whole current G?\r\n\r\nFor 2, it's almost certainly not goexit0. For 3, it could conceivably be goexit0. However, in #13363, it's definitely not goexit0 because the status is _Grunning and the waitstatus is set. Likewise, all of the calls to dropg are immediately preceded by setting the status to something other than _Grunning. Most paths back to _Grunning would crash if g.m were nil, but I'm not sure all of them would. This would be a useful place to dig deeper.\r\n\r\nFor 4, I'm pretty sure there's nothing specific in the signal code that modifies g.m and I don't think it can call any of the functions I mentioned above. So 4 seems unlikely.\r\n\r\nI hope it's not 5.",
	"user": {
		"login": "aclements",
		"id": 2688315,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-19T23:14:14Z",
	"updated_at": "2016-01-19T23:14:14Z"
}
