{
	"id": 152844364,
	"number": 15526,
	"state": "closed",
	"title": "proposal: add intrinsic variadic slice push() and pop() mechanism",
	"body": "# Proposal: intrinsic variadic slice push() and pop() mechanism\r\n\r\nAuthor: Michael Jones\r\n\r\nLast updated: May 2016\r\n\r\n## Abstract\r\n\r\nCareful bounds checking for array and slice operations is inherently in conflict with efficiency of operation.\r\n\r\nWhile the Go compiler aspires to minimize redundant bounds checks, the common Push and Pop stack operations are situation where a special notation in source code would be a clarity benefit for the programmers writing and reading code and a compiler optimization benefit in terms of efficient code generation. This proposal explains that benefit.\r\n\r\n## Review\r\n\r\nThe Push() operation adds data to a stack by copying items to the end of a storage area (indexed write) and then advances the stack pointer (the index). For a stack implemented as an array, this might look like:\r\n\r\nvar sp int\r\nvar stack [STACKSIZE]float64\r\n\r\n: \r\n\r\n//push\r\nstack[sp] = 17.0\r\nsp++\r\n\r\n: \r\n\r\n//pop\r\nsp--\r\nx := stack[sp]\r\n\r\nNote that advancing the stack pointer with sp++ must not move beyond the end of the stack storage area just as retreating it with sp-- must not move before the start of the storage area. These can be tested in the increment and decrement, or equivalently, accesses can be tested on every indexed access to the storage area (\"stack[sp]\") as is the case of the Go compiler.\r\n\r\nThis example could potentially be simpler when the stack storage area is a slice because the stack pointer is implicitly the end of the slice's active region, the remaining space is the slice's unused underlying capacity, and the minimum depth is naturally zero; push and pop could easily become native actions on a slice.\r\n\r\n## Multiple Values\r\n\r\nIt is often the case that multiple values need to be pushed-to or popped-from a stack. Since the first days of C-language programming, this has resulted in the idiomatic group Push():\r\n\r\n*sp++ = a;\r\n*sp++ = b;\r\n*sp++ = c;\r\n*sp++ = d;\r\n\r\nand group Pop():\r\n\r\nd = *--sp;\r\nc = *--sp;\r\nb = *--sp;\r\na = *--sp;\r\n\r\n...which is speedy given indexed addressing modes in CPU instruction sets and the direct expressions provided by C. For Go, though, we cannot do this. We are forced into one of two paths, each with four bounds checks and four additions:\r\n\r\nstack[sp] = a\r\nsp++\r\nstack[sp] = b\r\nsp++\r\nstack[sp] = c\r\nsp++\r\nstack[sp] = d\r\nsp++\r\n: \r\n\r\nor else\r\n\r\nstack[sp] = a\r\nstack[sp+1] = b\r\nstack[sp+2] = c\r\nstack[sp+3] = d\r\nsp += 4\r\n\r\n## Insight\r\n\r\nThe opportunity here is that the bounds check for the final Push() in a polyadic Push() sequence is a comprehensive replacement for each of the other bounds checks. That is, if sp+3 is safe to reference, then sp, sp+1, and sp+2 must also be safe to reference. The same notion applies to Pop(), where the lowest element in the stack, say sp-3, is a perfect test of the safety of access at offsets sp-2, sp-1, and sp.\r\n\r\nThis means that even a many valued push or pop need only do one bounds check to provide the full safety of the Go Language guarantee. The resulting performance gain scales linearly with the number of items pushed or popped as a group.\r\n\r\n## Notation\r\n\r\nNo specific notation is proposed. Here are a few musings, but part of the discussion needs to center on how to most naturally express this notion in Go. The proposer likes the second of these best, but perhaps better ways are possible.\r\n\r\n#### Compiler recognized function\r\n\r\nStackPush(slice, a, b, c, d)\r\nStackPop(slice, d, c, b, a) or \"a, b, c, d\" if preferred\r\n\r\n#### Language recognized function\r\n\r\nStack(slice) = a, b, c, d // \"absorbing\" multiple assignment to define push cardinality\r\nd, c, b, a = Stack(slice) // ...and the converse which is implicitly Pop()\r\n\r\nNote that this is not an unbalanced assignment. It means that the cardinality of variables on the \"variable side\" determines the group size being added to or removed from the stack. The first example here means \"push four items\" because there are four variables. It might be seen as a weakness that it does not easily generalize to cases with a stack on each side of the assignment operator because there is no place to specify the \"four.\"\r\n\r\n#### Cast to a magical base type\r\n\r\nGO(slice).Push(4) = a, b, c, d // cast\r\n\r\na, b, c, d = GO(slice).Pop(4)\r\n\r\nThe result of the cast here takes the user's data structure to a built-in realm where all of the otherwise namespace polluting method names could be defined. I show Push and Pop, but we could have other compiler-known methods such as Len(), Reverse(), Sort(), etc. without taking name-space and freedom for function options away from the developer.\r\n\r\n#### Extract() as counterpoint to Append()\r\n\r\nslice = Append(slice, a, b, c, d...)\r\n\r\nd, c, b, a = Extract(slice, 4)\r\n\r\nor\r\n\r\nExtract(slice, d, c, b, a)\r\nExtract(slice, d, c, b, a...) // strange overloading of ... here, but maybe ok\r\n\r\n## Performance\r\n\r\nThe existing one-at-a-time redundant bounds checks of stack access cost ~12% of overall runtime in several finely tuned compute-intensive applications using the latest and most efficient versions of the Go compiler. The proposal here seeks to regain this wasted execution time by making a class of redundant bounds tests easy to avoid.\r\n\r\n## Summary\r\n\r\nAdding compiler-aware support for variadic Push and Pop on slices offers code clarity, exposes the structure of sequential accesses to the compiler, makes suppression of redundant bounds checks trivial, and allows more efficient runtime performance.",
	"user": {
		"login": "MichaelTJones",
		"id": 7877285,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "Proposal"
		}
	],
	"comments": 12,
	"closed_at": "2016-08-01T04:27:17Z",
	"created_at": "2016-05-03T18:36:05Z",
	"updated_at": "2016-08-01T04:27:17Z",
	"milestone": {
		"id": 1373555,
		"number": 30,
		"title": "Proposal"
	}
}
