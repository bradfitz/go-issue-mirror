{
	"id": 165171393,
	"body": "Not sure about defer -- I didn't notice that case in the source code.\r\n\r\nDidn't find coverage means that the graph constructed in the assign phase elided the node in the graph, hence it was not seen in the flood phase even though there is code in flood to cover that case.\r\nThis is what I mean by poor separation of concerns and overlap.\r\n\r\nI put it back to line numbers so that I could write a test for it.  Now it looks like this (and I've fixed it up a little more):\r\n\r\n```\r\ngo build -gcflags '-l -m -m' escape_because.go \r\n# command-line-arguments\r\n./escape_because.go:27: (*pair).EqualParts p does not escape\r\n./escape_because.go:33: a escapes to heap\r\n./escape_because.go:33: \tfrom sink at line 17 because assigned to top level variable\r\n./escape_because.go:31: leaking param: p\r\n./escape_because.go:31: \tfrom [3]*int literal at line 32 because array literal element\r\n./escape_because.go:31: \tfrom a at line 32 because assigned\r\n./escape_because.go:31: \tfrom a at line 33 because interface-converted\r\n./escape_because.go:31: \tfrom sink at line 17 because assigned to top level variable\r\n./escape_because.go:41: \u0026u escapes to heap\r\n./escape_because.go:41: \tfrom sink at line 17 because assigned to top level variable\r\n./escape_because.go:40: moved to heap: u\r\n./escape_because.go:41: \u0026u escapes to heap\r\n./escape_because.go:41: \tfrom \u0026u at line 41 because interface-converted\r\n./escape_because.go:41: \tfrom sink at line 17 because assigned to top level variable\r\n./escape_because.go:37: leaking param: q\r\n./escape_because.go:37: \tfrom s at line 38 because assigned\r\n./escape_because.go:37: \tfrom pair literal at line 39 because struct literal element\r\n./escape_because.go:37: \tfrom t at line 39 because assigned\r\n./escape_because.go:37: \tfrom u at line 40 because assigned\r\n./escape_because.go:37: \tfrom \u0026u at line 41 because address-of\r\n./escape_because.go:37: \tfrom \u0026u at line 41 because interface-converted\r\n./escape_because.go:37: \tfrom sink at line 17 because assigned to top level variable\r\n./escape_because.go:46: c escapes to heap\r\n./escape_because.go:46: \tfrom ~r1 at line 44 because return\r\n./escape_because.go:44: leaking param: r to result ~r1 level=-1\r\n./escape_because.go:44: \tfrom []*int literal at line 45 because slice-literal-element\r\n./escape_because.go:44: \tfrom c at line 45 because assigned\r\n./escape_because.go:44: \tfrom c at line 46 because interface-converted\r\n./escape_because.go:44: \tfrom ~r1 at line 44 because return\r\n./escape_because.go:45: []*int literal escapes to heap\r\n./escape_because.go:45: \tfrom c at line 45 because assigned\r\n./escape_because.go:45: \tfrom c at line 46 because interface-converted\r\n./escape_because.go:45: \tfrom ~r1 at line 44 because return\r\n./escape_because.go:49: leaking param: a\r\n./escape_because.go:49: \tfrom append(s, a) at line 50 because appended to slice\r\n./escape_because.go:49: leaking param content: s\r\n./escape_because.go:49: \tfrom *s at line 49 because indirection\r\n./escape_because.go:49: \tfrom append(s, a) at line 50 because appendee slice\r\n./escape_because.go:54: leaking param content: s2\r\n./escape_because.go:54: \tfrom *s2 at line 54 because indirection\r\n./escape_because.go:54: \tfrom append(s1, s2...) at line 55 because appended slice...\r\n./escape_because.go:54: leaking param content: s1\r\n./escape_because.go:54: \tfrom *s1 at line 54 because indirection\r\n./escape_because.go:54: \tfrom append(s1, s2...) at line 55 because appendee slice\r\n./escape_because.go:59: f6 x does not escape\r\n./escape_because.go:59: f6 y does not escape\r\n./escape_because.go:61: f6 \u0026p does not escape\r\n./escape_because.go:61: f6 \u0026p does not escape\r\n./escape_because.go:66: f7 x does not escape\r\n./escape_because.go:74: leaking param: y\r\n./escape_because.go:74: \tfrom ~r2 at line 74 because return\r\n./escape_because.go:74: \tfrom ~r2 at line 74 because returned from recursive function\r\n./escape_because.go:74: moved to heap: x\r\n./escape_because.go:79: \u0026x escapes to heap\r\n./escape_because.go:79: \tfrom y at line 74 because arg to recursive call\r\n./escape_because.go:79: \tfrom ~r2 at line 74 because return\r\n./escape_because.go:79: \tfrom ~r2 at line 74 because returned from recursive function\r\n./escape_because.go:79: \u0026x escapes to heap\r\n./escape_because.go:79: \tfrom y at line 74 because arg to recursive call\r\n./escape_because.go:79: \tfrom ~r2 at line 74 because return\r\n./escape_because.go:82: leaking param content: y\r\n./escape_because.go:82: \tfrom y[0] at line 84 because dot of pointer\r\n./escape_because.go:82: \tfrom ~r2 at line 82 because return\r\n./escape_because.go:82: \tfrom ~r2 at line 82 because returned from recursive function\r\n./escape_because.go:82: moved to heap: x\r\n./escape_because.go:87: \u0026x escapes to heap\r\n./escape_because.go:87: \tfrom ... argument at line 87 because ... arg to recursive call\r\n./escape_because.go:82: leaking param: y to result ~r2 level=1\r\n./escape_because.go:82: \tfrom y[0] at line 84 because dot of pointer\r\n./escape_because.go:82: \tfrom ~r2 at line 82 because return\r\n./escape_because.go:87: f9 ... argument does not escape\r\n./escape_because.go:90: leaking param: y\r\n./escape_because.go:90: \tfrom x[y] at line 91 because key of map put\r\n./escape_because.go:90: leaking param: z\r\n./escape_because.go:90: \tfrom x[y] at line 91 because value of map put\r\n./escape_because.go:90: f10 x does not escape\r\n\u003cautogenerated\u003e:1: leaking param: .this\r\n\u003cautogenerated\u003e:1: \tfrom .this.EqualParts() at line 163 because receiver in indirect call\r\n```\r\n",
	"user": {
		"login": "dr2chase",
		"id": 1928999,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-16T16:46:51Z",
	"updated_at": "2015-12-16T16:46:51Z"
}
