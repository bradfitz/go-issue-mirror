{
	"id": 182828517,
	"number": 17432,
	"state": "open",
	"title": "crypto/tls: add DecryptSessionTicket to Config",
	"body": "There are already multiple ways to set session tickets but they all require key material. At Cloudflare we want to use a remote Keyless-style system.\r\n\r\nI suggest the following interface.\r\n\r\n```go\r\ntype SessionTicketWrapper interface {\r\n    // Wrap returns a session ticket value that can be later passed to Unwrap\r\n    // to recover the content, usually by encrypting it. The ticket will be sent\r\n    // to the client to be stored, and will be sent back in plaintext, so it can\r\n    // be read and modified by an attacker.\r\n    Wrap(cs *ConnectionState, content []byte) (ticket []byte, err error)\r\n\r\n    // Unwrap returns a session ticket contents. The ticket can't be assumed\r\n    // to having been generated by Wrap. \r\n    // If unable to unwrap the ticket, the connection will proceed with a\r\n    // complete handshake.\r\n    Unwrap(chi *ClientHelloInfo, ticket []byte) (content []byte, success bool)\r\n}\r\n```\r\n\r\ncrypto/tls would be responsible of serializing and deserializing the session state.\r\n\r\nThis works cleanly with TLS 1.3 PSK, too, but I wonder if we will need more stuff in the interface to allow it to do replay protection, too. \r\n\r\n/cc @Bren2010 @agl",
	"user": {
		"login": "FiloSottile",
		"id": 1225294,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "NeedsDecision"
		}
	],
	"comments": 3,
	"created_at": "2016-10-13T15:51:14Z",
	"updated_at": "2016-10-18T19:29:01Z",
	"milestone": {
		"id": 2053058,
		"number": 49,
		"title": "Go1.9"
	},
	"reactions": {
		"total_count": 1,
		"+1": 1
	}
}
