{
	"id": 166923967,
	"body": "\u003e Allowed/Disallowed: IIUC, the set of allowed runes is not inverse of the set of disallowed runes. That's why probably.\r\n\r\nAh, yah, that's probably why. I don't think there's a problem with just having a Contains method though; I can't think of a case where we'd actually need the \"disallowed, but not unassigned\" runes (which I'm pretty sure is the only place this matters?)\r\n\r\nI could really go either way on this one and will probably just leave it at contains unless you have strong opinions on it at which point I'll swap it.\r\n\r\n\u003e At the core the Enforce should be a transformer, I agree. However, we should have pre-defined wrappers for String, Bytes, etc.\r\n\r\nYour original API suggestions had a `func (p *Profile) NewTransformer() *Transformer` method; would it be better to do this, or better to just make the profile satisfy the `Transformer` interface itself?\r\n\r\n\u003e Can you give an example when width is required before prepare, when it cannot be used, and for both cases why? Semantically this seems very funky.\r\n\r\nLet's assume you prepare a text label that you're going to show on a users \"profile\" screen. The label contains full-width chracters, because the users language is written vertically.\r\n\r\nWidth mapping (narrowing, specifically) is in the enforcement step of the (as-yet-undefined) profile used for this label. If we do it as part of the preparation step, the user will also have width mapping applied, which will break their vertical layout. The user could just display their raw input and only send the prepared version over the wire, but now they have to store two version of the label (or do prepare every time they send it over the wire, which might be fine, but is still more complication that we've introduced), and they lose the benefit of other things that might be part of the prepare step (eg. let's assume the prepare step also trim's spaces and the user accidentally typed a few spaces after the label when entering the information).\r\n\r\nIt's contrived, but I think it still makes sense. The short of it is: Sometimes the clients need to display something different than the representation that the server will use, so we need both steps.\r\n\r\nNote that I use clients in this example, but it could actually BE the server that generates the data. It might want to use the prepared version for diaplay (eg. on a webapp) and the enforced version for comparison purposes.",
	"user": {
		"login": "SamWhited",
		"id": 512573,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-23T15:27:00Z",
	"updated_at": "2015-12-23T15:36:01Z"
}
