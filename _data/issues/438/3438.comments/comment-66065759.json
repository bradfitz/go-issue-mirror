{
	"id": 66065759,
	"body": "\u003ca id=\"c7\"\u003e\u003c/a\u003eComment 7 by **Ryan.FireBall**:\n\n\u003cpre\u003eThen I suggest we begin a series of gedankenexperiments.\n\nWhat would all the possible use cases be? How would the syntax be restricted? How many\nlicks does it take to get to the center of a Tootsie Pop?\n\nOk, maybe not the last one.\n\nGeneric Programming is in my opinion, one of the things Go definitively must do, at\nleast eventually. But what Go does not need to do, is implement something convoluted\nsuch as C++ templates.\nReflect provides possibility, but it is rather complicated in syntax.\n\nIf at all possible, it'd be pleasurable to be able to implement simpler generic\nfunctions.\n\nThe first simple difference would be that instead of .Call(...)-ing such a value after\nchanging it into a reflect.Value, we simply call() it as-is. The underlying code may not\nnecessarily change, only the apparent syntax.\n\nFor example:\n\nfunc f (a interface{}) int {\n return a()\n}\n\nA panic would occur if a isn't a function which returns an int and takes no arguments.\n\nA better, more complete alternative, would be to create a new type, dynamic, but this\nwould introduce a new keyword.\n\nHere is a possibility for that.\n\nfunc f (a dynamic) int {\n return a()\n}\n\nIn this situation, the function will accept a function which returns an int. This is\nmerely a property of the underlying interface. It also simplifies global variables with\ndynamic types.\n\nConsider:\n\nvar global_v dynamic\n\nIf we use global_v in the code somewhere, then the code will easily recognise that this\nis a dynamic variable and that extra checks need to be done.\n\nIf we use a type variable in another type, the result may be of type dynamic.\n\nConsider:\n\nfunc main () {\n var a int\n var b type\n b = a.(type)\n c := []b\n // c is thus a dynamic, not an array of ints.\n // Although it may function as one, there will be overhead when using it.\n fmt.Println(c.(type).string())\n // \"dynamic[[]int]\"\n}\n\nPossibly move this into the reflect package, by adding special runtime support for\nreflect.Value.\nIf Go were to support for example:\n\nfunc f (a reflect.Value) {\n a()\n}\n\nWhere both any type is casted to reflect.Value (is it already?) and where a() may be\nexpanded to a.Call()\n\nAs you can see, my suggestion all over the place, with no concrete idea at heart. It's\nmore of a general idea that something could be done here to simplify it.\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2012-03-30T20:13:50Z",
	"updated_at": "2014-12-08T10:17:57Z"
}
