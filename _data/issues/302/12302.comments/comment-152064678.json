{
	"id": 152064678,
	"body": "Hi @davecheney, thanks for working on this.  When I was starting to learn about golang, your blog posts and code where very helpful.  So thank you x2!\r\n\r\nHowever, I read this entire thread, and your proposal and I'm confused by it.\r\n\r\n1. Its not clear what problem you are actually solving or who its for.  I say this since my company has multiple complicated use cases: product, services consumed by customers (now requiring bill of materials), developers and lawyers (BOM, license review) and we're just fine with vendoring at the commit level and use gopkg.in major versioning.  With some small tooling around godeps and github, we have automated all our bill of materials and software licensing problems.  Our team is delighted by NOT having ruby-gem dependency nightmare-- in fact we have removed a number of Non-Go tools just to avoid it.  We have never been hampered by the lack of SemVer.  Thats good for us,  but you must have some context that is really different else you wouldn't be writing this.    I'd like to see concrete examples of how this doesnt work for or what has been broken due to the lack of SemVer use is being hamper by the lack of a formal blessing by golang.  Right now this seems really abstract and vague on where this is going.\r\n\r\n2. The use of a \"top-down\" approach and why this needs to discussed in this way.  I don't really understand why formal proposal is needed or how its presence helps or hurts anything.  It would seem incomplete or premature to mandate something this small without know how it fits into the larger picture.\r\n\r\n3. Not clear that SemVer will solve the actual problem for which I'm guessing it's OS vendor packaging issues.  But surely OS vendors have all sorts of issues on how code can be imported into their system, and this is solved by convention and the vendors own requirements, not a language-level decision.  This either is too small to be useful, or incomplete as to evaluate the larger goal.\r\n\r\nGoing through the document, here are some notes I hope you find constructive:\r\n\r\n    In the same way that gofmt defines a single recommended way to format Go source code, this\r\n    proposal establishes a single recommended procedure for releasing the source code for Go programs\r\n    and libraries.\r\n\r\n\r\nI would argue that \"software release and versioning process\" is completely unlike \"gofmt\" (almost 100% adopted), and \"go vet\" (actually only sometimes used).     gofmt is a binary state, while a \"release procedure\" is a human process.  I don't think they are comparable at all.\r\n\r\n\r\n    Releasing software is useful. It separates the every day cut and thrust of software development, patch\r\n    review, and bug triage, from the consumers of the software, a majority of whom are not developers of\r\n    your software and only wish to be concerned with the versions that you tell them are appropriate to\r\n    use.\r\n\r\nThe vast majority of golang projects do this by \"git push\" and don't bother with release versions. So having a SemVer spec will do nothing for all these packages, who are free to make \"versioned releases\" but choose not to.  Who is this proposal for?  What problem are we solving? \r\n\r\n\r\n    A key differentiator between released and unreleased software is the \"version number.\r\n     Version numbers create a distinct identifier that increments at its own pace and under\r\n     different drivers to the internal identifier of the version control system (VCS) or\r\n     development team.\r\n\r\nOnce the change is public on the VCS, it is released. Under SemVer many projects could consider every commit as  a potential new release as it fixes something or the quality is very high.  For many people ,waiting around for a bug fix in a \"formal release\"  is a complete waste, and will want to grab the fix as it happens.   Again there is some assumption in the proposal that I'm missing.\r\n\r\n    The large ecosystem of tools like godeps, glide, govendor, gb, the vendor-spec proposal and dozens\r\n    more, that can use this information to provide, for example, a command that will let users upgrade \r\n    between minor versions, or update to the latest patch released of their dependencies rather than just \r\n    the latest HEAD of the repository.\r\n\r\nand\r\n\r\n    godoc.org could show users the documentation for the version of the package they were using,\r\n    not just whatever is at HEAD.\r\n\r\nI fail to see why this cant be done already, with or without SemVer being used and any tag, with or without proposal.  In fact you claim to working on this now which in some ways shows that the proposal isn't actually necessary.  Or what am I missing?\r\n\r\n    Additionally, operating system distributors such as Debian and Ubuntu strongly prefer to package \r\n    released versions of a library or application, and are currently reduced to doing things like this.\r\n\r\nNo one is \"reduced to doing\" anything.   Debian and Ubuntu are completely free to contact the the owner and ask him to add a release tag.   Or not include the project.   Or make a fork.  This proposal won't make the owner add a release tag.  Numerous people ask repo owners to add license files to solve various compliance issues.  I don't see why this is any different or what this proposal buys us beyond being polite and asking the owner.\r\n\r\nAnd finally\r\n\r\n    Operating system distributions such as Debian, Fedora, Ubuntu, Homebrew, rely on released\r\n    versions of software for their packaging policies. They don't want to pull random git hashes into \r\n    their archives, they want to pull released versions of the code and have release numbers that\r\n    give them a sense of how compatible new versions are with previous version. For example, \r\n    Ubuntu have a policy that we only accept patch releases into our LTS distribution; no major\r\n    version changes, no minor version changes that include new features, only bug fixes.\r\n\r\nIt sounds like OS vendors are the ones with the real problems with the status quo but this is never stated as the main issue.   Is this the main use case, to make it easier for OS distributions?  Thats fine, but then lets just say that.  (and if not, then Im really confused).  My guess is that OS vendors have a number of other requirements for inclusion, licenses, changelogs, security notices, code organization.  I'd love to see that, and see it get adoption.   I recommend OS vendors write up best practices that they want, and do a bottoms-up approach with the repos in question.  They already do this with C libraries, (I'm not as familiar with python, perl, ruby stuff but assume they do it as well.).\r\n\r\nI may digress but  IMHO go is different.  And I think we can do way better than existing language distributions.    The explicit use of VCS means change logs are there for everyone, locally.  Use the Pull requests and cheap branching means makes a \"release process\" really different.  Solving OS issue can be in a number of different ways:  Instead of not-awesome patch files in various containers (deb, rpms) with horrible naming schemes \"1.8.3+ubuntu4\"  OS vendors can fork and do whatever they want and use VCS as the main mechanism.  Even better OS Vendors should really force the issue of SemVer on the _applications_ and that the applications are responsible for (auditable) build manifests, instead of repackaging every known golang library in the universe.  The benefit here is that even closed source applications can benefit.  There is precedence for this with chef, puppet, data dog who ship completely self-contained universes and don't use the OS packages for all the bits and bobs.  I suspect many commercial Java applications do same.  But \"lets start with SemVer\" isn't really enough to have discussion on real problems or solutions to golang packaging.\r\n\r\nOn a more constructive note @crawshaw  and yourself wrote a fantastic idea a tool that automatically generates release numbers based on API changes.  Thats great and useful right now, no matter what happens in the future.  A automatic commit to SemVer is a awesome idea what is way better than the manually ad-hoc disaster we have in every other language.    Whats great about this is making small packages is super easy in golang (e.g. https://github.com/shurcooL/sanitized_anchor_name 16 LOC but imported in many).. I'd hate to have every small developer having to bother with even thinking about what a \"release\" even means here. An automatic tool would help here.  But again I'd love to see the bottoms up approach on this. \r\n\r\nAnd finally I'd be DELIGHTED to work on any of these supply chain issues, such as automatic SemVersioning, and standardized output Bill Of Materials for applications, whatever.  But I don't think a top-down starting with golang saying \"use SemVer, if you do versioning\" buys us much and is the right way to go.  At least as far as the current proposal stands.\r\n\r\nWe may agree to disagree, and I hope my comments aren't too caustic and you found them helpful in some way.. Its always easier to criticize than create, so thank you for creating a most interesting dialog.\r\n\r\nFeel to contact me offline\r\n\r\nregards,\r\n\r\nnickg\r\n",
	"user": {
		"login": "client9",
		"id": 217179,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-10-29T03:35:47Z",
	"updated_at": "2015-10-29T03:35:47Z"
}
