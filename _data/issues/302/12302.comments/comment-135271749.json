{
	"id": 135271749,
	"body": "@davecheney, I guess I didn't express myself clear enough. I agree with you that any kind of automated way of adding versions to the import paths is not the best way to solve backward (in)compatibility problems. Something like libv5, libv6, libv100 is certainly not what I want to see in Go projects. \r\n\r\nMaintaining backward compatibility and using different import path for incompatible versions should be responsibility of package authors. Good example: go/types from Go 1.5 is incompatible with the original version, but it is not a big problem because import paths are different, application developers are free to choose one or another depending on their requirements.\r\n\r\nHowever if a package changes in a backward incompatible way between v1 and v2 and keeps using the same import path then burden of resolving dependency mess is on users of the package. I am not aware of Go examples, but there are plenty in Java world (just because it is more widely used), I mentioned few of them in my previous comments.\r\n\r\nI just wanted to suggest that raising awareness about these problems among package developers would be a good thing.\r\n\r\n\u003e I think java has made a serious mistake by developing more (OSGI) and more (Project Jigsaw) complicated methods of classpath resolution to continue to support multiple versions of a library in the same JVM runtime. This complexity is entirely self inflicted and not something I want to see in a Go dependency management solution.\r\n\r\nMy examples were referring to a single class loader (no OSGI). You will be surprised how many similarities Go and Java have in package/library management. I would say that within a single class loader they are equivalent:\r\n\r\n- Go package import path = Java package name\r\n- Go static compilation = Many java applications come with all dependencies included in the distribution\r\n- Import path rewrite (e.g. hiding 3-rd party packages under internal) = shading (usually via maven-shade-plugin)\r\n- Vendoring = putting jar files that a project depends on in the source control (though it is getting less and less common mainly because of maven)\r\n\r\n\u003e I disagree, as I mentioned about to @thockin this is the smallest possible proposal I can think of to make forward progress. Yes, larger proposals would be more comprehensive, but would take significantly longer to achieve consensus and would then be further delayed by a requirement to be scheduled into the Go release cycle -- do you really want to wait up to a year to see this implemented in a released version of Go ?\r\n\r\nI am just a bit skeptical that the proposal alone would be enough. I might be wrong about that though as Go community seems to be quite united.\r\n\r\n\u003e If you agree with that position, then this proposal boils down to a format for vcs tags that I believe can achieve consensus easily and can be of use immediately for all the tool makers, godoc.org maintainers, and operating system distros, in the Go ecosystem.\r\n\r\nUnfortunately dealing with backward (in)compatibility is not as simple as enforcing semver and vcs tag format. \r\n\r\nVery interesting study of libraries in the maven central repository that contains majority of open source Java libraries: http://avandeursen.com/2014/10/09/semantic-versioning-in-maven-central-breaking-changes/ . Almost 24% of patch updates introduced binary (detectable by tools) incompatibility!\r\n\r\nPlease treat my comments not as arguments against the proposal but as feedback and food for thoughts.",
	"user": {
		"login": "kostya-sh",
		"id": 7126275,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-27T03:17:55Z",
	"updated_at": "2015-08-27T03:17:55Z"
}
