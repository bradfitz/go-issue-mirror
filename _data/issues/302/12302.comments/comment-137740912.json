{
	"id": 137740912,
	"body": "@kostya-sh We are not so far apart.\r\n\r\n* In glide we have a `glide pin` command to use the specific version. For releases you can use it to get the exact commit you want. In development you can be more flexible. This is quite often the case. As one prepares for a release they pin the dependencies and during development you can be more flexible.\r\n* I recently evaluated Go packages looking for the best in both SemVer and more general number schemes because I was wondering the same thing. Packages already exist to deal with sorting, constraints, and matching both ways. I'm interested in SemVer for reasons listed below.\r\n\r\nWhere we differ comes down issues of Developer Experience which I believe are essential to useful package management for the long tail. I don't believe in building the system I will always use but that the long tail of developers I work and collaborate can be successful with. Developer experience is one of the reasons I believe Go as succeeded.\r\n\r\n* Regular expressions are hard for many developers. They screw them up and it's often hard for developers to spot mistakes. For example, several years ago I was working on an open source project with thousands of contributors and hundreds of regular ones. Only a handful of people were really comfortable working on the sections of the codebase with regular expressions. That's why I don't advocate them here. The underlying tools to parse versions and constraints can use them.\r\n* SemVer is widely known and adopted. It has semantic meaning, people know it, and the long tail of developer are already familiar with it or can easily find a resource to team them. That's what makes it appealing. It's useful, accessible, and already understood. When I looked at tags on Go projects (and I looked at a long list of popular go applications and packages) they were all using SemVer. I didn't see one using a different numbering scheme. This is also what the other popular languages package managers use. This has become common place.\r\n* Applications and library packages are going to make major (API breaking) changes in their repos without changing the import path. We can't control them. They are already doing it. This is how projects in other languages work, too. For many of us this is not an issue and we have tools (even in Go) to handle this today. Dealing with major API breaking changes in a sensible way is more an acceptance of what's already happening and working it into our flow.\r\n\r\nI hope this helps you understand where I'm coming from. I'm more about practically enabling the long tail of developers than trying to deal with something theoretical. Versioning is something that's already been learned well through mistakes and success in programming. Let's adopt some existing successes and move on to more interesting problems.\r\n\r\nOr, as a friend of mine put it... [Don't Condemn Go To Repeat Past Mistakes](http://technosophos.com/2015/09/02/dont-let-go-be-condemned-to-repeat-past-mistakes.html)",
	"user": {
		"login": "mattfarina",
		"id": 62991,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-09-04T13:41:29Z",
	"updated_at": "2015-09-04T13:41:29Z"
}
