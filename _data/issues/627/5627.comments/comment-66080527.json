{
	"id": 66080527,
	"body": "\u003ca id=\"c2\"\u003e\u003c/a\u003eComment 2:\n\n\u003cpre\u003eThe code 5g generates for an embedded trampoline is quite a lot bulkier than what is\ngenerated by 6g.  Here is some test code I have been working with:\n\npackage main\n\ntype T struct {\n   U\n}\n\ntype U struct {\n}\n\nfunc (u *U) Write(b []byte) {}\n\nfunc main() {\n\tvar t T\n\tgo t.Write(nil)\n}\n\nHere is the 6g code for (*T).Write\n\n  400ca0:\te9 5b ff ff ff       \tjmpq   400c00 \u0026lt;main.(*U).Write\u0026gt;\n\nHere is the 5g code for (*T).Write\n\n   10d00:\te59a1000 \tldr\tr1, [sl]\n   10d04:\te15d0001 \tcmp\tsp, r1\n   10d08:\t33a01014 \tmovcc\tr1, #20\n   10d0c:\t33a02010 \tmovcc\tr2, #16\n   10d10:\t31a0300e \tmovcc\tr3, lr\n   10d14:\t3b0064fc \tblcc\t2a10c \u0026lt;runtime.morestack\u0026gt;\n   10d18:\te52de014 \tstr\tlr, [sp, #-20]!\n   10d1c:\te59d0018 \tldr\tr0, [sp, #24]\n   10d20:\te5d01000 \tldrb\tr1, [r0]\n   10d24:\te59d0018 \tldr\tr0, [sp, #24]\n   10d28:\te58d0004 \tstr\tr0, [sp, #4]\n   10d2c:\te59d001c \tldr\tr0, [sp, #28]\n   10d30:\te58d0008 \tstr\tr0, [sp, #8]\n   10d34:\te59d0020 \tldr\tr0, [sp, #32]\n   10d38:\te58d000c \tstr\tr0, [sp, #12]\n   10d3c:\te59d0024 \tldr\tr0, [sp, #36]\t; 0x24\n   10d40:\te58d0010 \tstr\tr0, [sp, #16]\n   10d44:\tebffffad \tbl\t10c00 \u0026lt;main.(*U).Write\u0026gt;\n   10d48:\te49df014 \tldr\tpc, [sp], #20\n\nAt the very least, the compiler should be smart enough to recognize the tail call and\nnot open a new frame for the sole purpose of shuffling arguments.  If this optimization\nwas available, genembeddedtramp would be uneccessary as the genwrapper code would be\nsmaller.  This applies to 5g as well as 6g and 8g.\n\nThis experiment yeilded another code generation opportunity.  If I offset U by a word\nthe embedded structure pointer must be adjusted.  Here is what the 5g compiler generates\ntoday:\n\n   10d34:\te3a00004 \tmov\tr0, #4\n   10d38:\te59d1004 \tldr\tr1, [sp, #4]\n   10d3c:\te0811000 \tadd\tr1, r1, r0\n\nThere is no need to materialize a 4 with a move.  This value fits in an immediate on\nevery revision of the ARM architecture.\n\n   ldr r1, [sp, #4]\n   add r1, r1, #4\n\nThis probably merits a separate issue.\u003c/pre\u003e",
	"user": {
		"login": "lexprfuncall",
		"id": 5360361,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-06-04T16:02:47Z",
	"updated_at": "2014-12-22T06:25:49Z"
}
