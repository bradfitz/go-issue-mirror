{
	"id": 225489469,
	"body": "\u003e 1) currently memory never moves anyhow;\r\n\r\nI don't think this is true. If Go object lives on goroutine stack, the stack moves and object moves with the stack.\r\n\r\nIn fact that is what, I think, is happening here.\r\n\r\nI have changed the program to handle syscall error properly first. So I end up with this:\r\n```\r\nc:\\Users\\Alex\\dev\\src\\issues\\issue16035\u003etype main.go\r\npackage main\r\n\r\nimport (\r\n        \"fmt\"\r\n        \"runtime\"\r\n        \"syscall\"\r\n        \"unsafe\"\r\n)\r\n\r\nvar (\r\n        advapi32 = syscall.NewLazyDLL(\"advapi32.dll\")\r\n\r\n        regGetValue = advapi32.NewProc(\"RegGetValueW\")\r\n)\r\n\r\nconst (\r\n        HKEY_LOCAL_MACHINE = 0x80000002\r\n\r\n        RRF_RT_REG_SZ = 0x00000002\r\n)\r\n\r\nfunc RegGetValue(hKey uintptr, lpSubKey *uint16, lpValue *uint16, dwFlags uint32, pdwType *uint32) (string, uint32, error) {\r\n        var buf [1024]uint16\r\n        bufSizeBytes := uint32(1024 * 2)\r\n        runtime.GC() // Everything works correctly if this line is removed\r\n        ret, _, _ := regGetValue.Call(uintptr(hKey), uintptr(unsafe.Pointer(lpSubKey)), uintptr(unsafe.Pointer(lpValue)), uintptr(dwFlags), uintptr(unsafe.Pointer(pdwType)), uintptr(unsafe.Pointer(\u0026buf[0])), uintptr(unsafe.Pointer(\u0026bufSizeBytes)))\r\n        if ret != 0 {\r\n                return \"\", bufSizeBytes, syscall.Errno(ret)\r\n        }\r\n        return syscall.UTF16ToString(buf[:]), bufSizeBytes, nil\r\n}\r\n\r\nfunc main() {\r\n        key, _ := syscall.UTF16PtrFromString(\"SOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Setup\\\\\\\\State\")\r\n        value, _ := syscall.UTF16PtrFromString(\"ImageState\")\r\n        str, _, err := RegGetValue(\r\n                HKEY_LOCAL_MACHINE,\r\n                key,\r\n                value,\r\n                RRF_RT_REG_SZ,\r\n                nil,\r\n        )\r\n        if err != nil {\r\n                fmt.Printf(\"RegGetValue failed: %v\\n\", err)\r\n                return\r\n        }\r\n        fmt.Printf(\"str: %s\\n\", str)\r\n}\r\n\r\nc:\\Users\\Alex\\dev\\src\\issues\\issue16035\u003ehg st\r\n\r\nc:\\Users\\Alex\\dev\\src\\issues\\issue16035\u003e\r\n```\r\n\r\nThen I run the program:\r\n```\r\nc:\\Users\\Alex\\dev\\src\\issues\\issue16035\u003ego run -gcflags=\"-m\" main.go\r\n# command-line-arguments\r\n.\\main.go:28: syscall.Errno(ret) escapes to heap\r\n.\\main.go:22: RegGetValue lpSubKey does not escape\r\n.\\main.go:22: RegGetValue lpValue does not escape\r\n.\\main.go:22: RegGetValue pdwType does not escape\r\n.\\main.go:26: RegGetValue \u0026buf[0] does not escape\r\n.\\main.go:26: RegGetValue \u0026bufSizeBytes does not escape\r\n.\\main.go:26: RegGetValue ... argument does not escape\r\n.\\main.go:30: RegGetValue buf does not escape\r\n.\\main.go:44: err escapes to heap\r\n.\\main.go:47: str escapes to heap\r\n.\\main.go:44: main ... argument does not escape\r\n.\\main.go:47: main ... argument does not escape\r\n\u003cautogenerated\u003e:1: leaking param: .this\r\nstr:\r\n\r\nc:\\Users\\Alex\\dev\\src\\issues\\issue16035\u003ego run -gcflags=\"-m -N\" main.go\r\n# command-line-arguments\r\n.\\main.go:28: syscall.Errno(ret) escapes to heap\r\n.\\main.go:22: RegGetValue lpSubKey does not escape\r\n.\\main.go:22: RegGetValue lpValue does not escape\r\n.\\main.go:22: RegGetValue pdwType does not escape\r\n.\\main.go:26: RegGetValue \u0026buf[0] does not escape\r\n.\\main.go:26: RegGetValue \u0026bufSizeBytes does not escape\r\n.\\main.go:26: RegGetValue ... argument does not escape\r\n.\\main.go:30: RegGetValue buf does not escape\r\n.\\main.go:44: err escapes to heap\r\n.\\main.go:47: str escapes to heap\r\n.\\main.go:44: main ... argument does not escape\r\n.\\main.go:47: main ... argument does not escape\r\n\u003cautogenerated\u003e:1: leaking param: .this\r\nstr: IMAGE_STATE_COMPLETE\r\n\r\nc:\\Users\\Alex\\dev\\src\\issues\\issue16035\u003e\r\n```\r\n(note how program succeeds if I use -N flag).\r\n\r\nThen I changed it slightly, so that `buf` escapes to heap, and run it again:\r\n```\r\nc:\\Users\\Alex\\dev\\src\\issues\\issue16035\u003ehg diff\r\ndiff -r 5a2ff4da45a8 main.go\r\n--- a/main.go   Mon Jun 13 14:33:13 2016 +1000\r\n+++ b/main.go   Mon Jun 13 14:43:34 2016 +1000\r\n@@ -22,6 +22,7 @@\r\n func RegGetValue(hKey uintptr, lpSubKey *uint16, lpValue *uint16, dwFlags uint3\r\n2, pdwType *uint32) (string, uint32, error) {\r\n        var buf [1024]uint16\r\n        bufSizeBytes := uint32(1024 * 2)\r\n+       fmt.Printf(\"%p\\n\", \u0026buf)\r\n        runtime.GC() // Everything works correctly if this line is removed\r\n        ret, _, _ := regGetValue.Call(uintptr(hKey), uintptr(unsafe.Pointer(lpSubKey)), uintptr(unsafe.Pointer(lpValue)), uintptr(dwFlags), uintptr(unsafe.Pointer(pdwType)), uintptr(unsafe.Pointer(\u0026buf[0])), uintptr(unsafe.Pointer(\u0026bufSizeBytes)))\r\n        if ret != 0 {\r\n\r\nc:\\Users\\Alex\\dev\\src\\issues\\issue16035\u003ego run -gcflags=\"-m\" main.go\r\n# command-line-arguments\r\n.\\main.go:25: \u0026buf escapes to heap\r\n.\\main.go:25: \u0026buf escapes to heap\r\n.\\main.go:23: moved to heap: buf\r\n.\\main.go:29: syscall.Errno(ret) escapes to heap\r\n.\\main.go:22: RegGetValue lpSubKey does not escape\r\n.\\main.go:22: RegGetValue lpValue does not escape\r\n.\\main.go:22: RegGetValue pdwType does not escape\r\n.\\main.go:25: RegGetValue ... argument does not escape\r\n.\\main.go:27: RegGetValue \u0026buf[0] does not escape\r\n.\\main.go:27: RegGetValue \u0026bufSizeBytes does not escape\r\n.\\main.go:27: RegGetValue ... argument does not escape\r\n.\\main.go:31: RegGetValue buf does not escape\r\n.\\main.go:45: err escapes to heap\r\n.\\main.go:48: str escapes to heap\r\n.\\main.go:45: main ... argument does not escape\r\n.\\main.go:48: main ... argument does not escape\r\n\u003cautogenerated\u003e:1: leaking param: .this\r\n0xc042066000\r\nstr: IMAGE_STATE_COMPLETE\r\n\r\nc:\\Users\\Alex\\dev\\src\\issues\\issue16035\u003ego run -gcflags=\"-m -N\" main.go\r\n# command-line-arguments\r\n.\\main.go:25: \u0026buf escapes to heap\r\n.\\main.go:25: \u0026buf escapes to heap\r\n.\\main.go:23: moved to heap: buf\r\n.\\main.go:29: syscall.Errno(ret) escapes to heap\r\n.\\main.go:22: RegGetValue lpSubKey does not escape\r\n.\\main.go:22: RegGetValue lpValue does not escape\r\n.\\main.go:22: RegGetValue pdwType does not escape\r\n.\\main.go:25: RegGetValue ... argument does not escape\r\n.\\main.go:27: RegGetValue \u0026buf[0] does not escape\r\n.\\main.go:27: RegGetValue \u0026bufSizeBytes does not escape\r\n.\\main.go:27: RegGetValue ... argument does not escape\r\n.\\main.go:31: RegGetValue buf does not escape\r\n.\\main.go:45: err escapes to heap\r\n.\\main.go:48: str escapes to heap\r\n.\\main.go:45: main ... argument does not escape\r\n.\\main.go:48: main ... argument does not escape\r\n\u003cautogenerated\u003e:1: leaking param: .this\r\n0xc042066000\r\nstr: IMAGE_STATE_COMPLETE\r\n\r\nc:\\Users\\Alex\\dev\\src\\issues\\issue16035\u003e\r\n```\r\n\r\nThis time program succeeds both times. I suspect that compiler is too clever and rearrange this code to keep `buf` on stack if possible. And GC moves `buf` (when it is on stack), before passing `buf`'s old address to the syscall.\r\n\r\n\u003e Could somebody test whether https://golang.org/cl/24031 fixes the problem?\r\n\r\nIt does not fixes the problem as far as I am concerned. The program fails in a similar way as before and only suceeds if I add the `fmt.Printf(\"%p\\n\", \u0026buf)` line.\r\n\r\nAlex",
	"user": {
		"login": "alexbrainman",
		"id": 9796621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-06-13T04:59:39Z",
	"updated_at": "2016-06-13T04:59:39Z"
}
