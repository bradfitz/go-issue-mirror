{
	"id": 121817550,
	"body": "The problem starts in [transform/transform.go (line 571)](https://github.com/golang/text/blob/3eb7007b740b66a77f3c85f2660a0240b284115a/transform/transform.go#L571):\r\n\r\n```go\r\n\t\tnDst, nSrc, err = t.Transform(dst[pDst:], src[:n], pSrc+n == len(s))\r\n```\r\n\r\nAt this point, `dst[pDst:]` will be a zero-length slice. This calls [cases/map.go (lines 135-144)](https://github.com/golang/text/blob/3eb7007b740b66a77f3c85f2660a0240b284115a/cases/map.go#L135-144):\r\n\r\n```go\r\nfunc (t *undUpperCaser) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {\r\n\tc := context{dst: dst, src: src, atEOF: atEOF}\r\n\tfor c.next() {\r\n\t\tupper(\u0026c)\r\n\t}\r\n\t// Standard upper case does not need any lookahead so we can safely not use\r\n\t// the checkpointing mechanism. pDst and pSrc will always point to the\r\n\t// furthest possible position.\r\n\treturn c.pDst, c.pSrc, c.err\r\n}\r\n```\r\n\r\nBut unfortunately `c.next()` will, after two loops, increment `c.pSrc`. See [cases/context.go (lines 73-93)](https://github.com/golang/text/blob/3eb7007b740b66a77f3c85f2660a0240b284115a/cases/context.go#L73-93):\r\n\r\n```go\r\nfunc (c *context) next() bool {\r\n\tc.pSrc += c.sz\r\n\tif c.pSrc == len(c.src) || c.err != nil {\r\n\t\tc.info, c.sz = 0, 0\r\n\t\treturn false\r\n\t}\r\n\tv, sz := trie.lookup(c.src[c.pSrc:])\r\n\tc.info, c.sz = info(v), sz\r\n\tif c.sz == 0 {\r\n\t\tif c.atEOF {\r\n\t\t\t// A zero size means we have an incomplete rune. If we are atEOF,\r\n\t\t\t// this means it is an illegal rune, which we will consume one\r\n\t\t\t// byte at a time.\r\n\t\t\tc.sz = 1\r\n\t\t} else {\r\n\t\t\tc.err = transform.ErrShortSrc\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n```\r\n\r\nBack in transform/transform.go, this means `dst` will grow and then start reading from `pSrc+1`. This is wrong and leads to the letter being skipped.\r\n\r\n--\r\n\r\nI see two solutions. First, if passing an empty `dst` is supposed to result in undefined behavior, then a simple fix is to avoid it by changing [transform/transform.go (line 554)](https://github.com/golang/text/blob/3eb7007b740b66a77f3c85f2660a0240b284115a/transform/transform.go#L554) to:\r\n\r\n```go\r\n\tif pDst+nDst \u003c initialBufSize {\r\n```\r\n\r\n--\r\n\r\nIf instead an empty `dst` should be checked for in a robust way, then `context.next()` should be fixed like so:\r\n\r\n```go\r\nfunc (c *context) next() bool {\r\n\tif len(c.dst) == 0 {\r\n\t\tc.err = transform.ErrShortDst\r\n\t\treturn false\r\n\t}\r\n\tc.pSrc += c.sz\r\n\tif c.pSrc == len(c.src) || c.err != nil {\r\n\t\tc.info, c.sz = 0, 0\r\n\t\treturn false\r\n\t}\r\n\tv, sz := trie.lookup(c.src[c.pSrc:])\r\n\tc.info, c.sz = info(v), sz\r\n\tif c.sz == 0 {\r\n\t\tif c.atEOF {\r\n\t\t\t// A zero size means we have an incomplete rune. If we are atEOF,\r\n\t\t\t// this means it is an illegal rune, which we will consume one\r\n\t\t\t// byte at a time.\r\n\t\t\tc.sz = 1\r\n\t\t} else {\r\n\t\t\tc.err = transform.ErrShortSrc\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n```",
	"user": {
		"login": "chowey",
		"id": 991221,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-07-16T03:35:28Z",
	"updated_at": "2015-07-16T03:35:28Z"
}
