{
	"id": 72176463,
	"body": "There is at least one buf in mem_plan9.go that can lead to memory corruption (the same memory returned by sysAlloc twice).\r\n\r\nThe following line in sysFree:\r\n\tn += (n + memRound) \u0026^ memRound\r\ndoubles n value: n += n\r\n\r\nBut even if you replace it with\r\n\tn = (n + memRound) \u0026^ memRound\r\nIt is still incorrect, because sysAlloc does not round n to page size, but sysFree does. So freeing won't happen for blocks that are not multiple of _PAGESIZE.\r\n\r\nI would do the following. It has much simpler invariants: both bloc and n are always page-rounded:\r\n\r\n```go\r\n--- a/src/runtime/mem_plan9.go\r\n+++ b/src/runtime/mem_plan9.go\r\n@@ -9,21 +9,24 @@ import \"unsafe\"\r\n var bloc uintptr\r\n var memlock mutex\r\n \r\n-const memRound = _PAGESIZE - 1\r\n+func memRound(p uintptr) uintptr {\r\n+       return (p + _PAGESIZE - 1) \u0026^ (_PAGESIZE - 1)\r\n+}\r\n \r\n func initBloc() {\r\n-       bloc = uintptr(unsafe.Pointer(\u0026end))\r\n+       bloc = memRound(uintptr(unsafe.Pointer(\u0026end)))\r\n }\r\n \r\n func sbrk(n uintptr) unsafe.Pointer {\r\n        lock(\u0026memlock)\r\n        // Plan 9 sbrk from /sys/src/libc/9sys/sbrk.c\r\n-       bl := (bloc + memRound) \u0026^ memRound\r\n+       bl := bloc\r\n+       n = memRound(n)\r\n        if brk_(unsafe.Pointer(bl+n)) \u003c 0 {\r\n                unlock(\u0026memlock)\r\n                return nil\r\n        }\r\n-       bloc = bl + n\r\n+       bloc += n\r\n        unlock(\u0026memlock)\r\n        return unsafe.Pointer(bl)\r\n }\r\n@@ -42,7 +45,7 @@ func sysFree(v unsafe.Pointer, n uintptr, stat *uint64) {\r\n        // from tiny/mem.c\r\n        // Push pointer back if this is a free\r\n        // of the most recent sysAlloc.\r\n-       n += (n + memRound) \u0026^ memRound\r\n+       n = memRound(n)\r\n        if bloc == uintptr(v)+n {\r\n                bloc -= n\r\n        }\r\n```\r\n\r\nI see that in your scenario the corruption thing actually happens:\r\n\r\nsysAlloc (65536, 0x275f80)\r\nsbrk(65536)\r\nsbrk return 0x30493000\r\nsysAlloc return 0x30493000\r\n10000\r\n\r\nsysAlloc (65536, 0x275f80)\r\nsbrk(65536)\r\nsbrk return 0x304a3000\r\nsysAlloc return 0x304a3000\r\n\r\nsysFree (0x30493000, 65536, 0x275f80)\r\nsysFree (0x304a3000, 65536, 0x275f80)\r\nsysFree (0x30483000, 65536, 0x275f80)\r\n\r\nThe first sysFree(0x30493000) will move bloc to 0x30493000 even if it is not the last allocated block.\r\n\r\nHowever, this does not seem to explain why brk fails.\r\nAre you sure that brk can be used for shrinking at all? Can you do brk(0x20000000); brk(0x10000000); brk(0x15000000) at startup?\r\n",
	"user": {
		"login": "dvyukov",
		"id": 1095328,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-01-30T09:41:03Z",
	"updated_at": "2015-01-30T09:41:48Z"
}
