{
	"id": 230542502,
	"body": "You can expect the Go GC to use 2X live memory which is what you are\nseeing. You can run your program with GODEBUG=gctrace=1 if you want to\nmonitor the runtime's target heap size.  See https://golang.org/pkg/runtime/\nfor a more details.\n\n\nOn Tue, Jul 5, 2016 at 12:25 PM, carlfn \u003cnotifications@github.com\u003e wrote:\n\n\u003e Please answer these questions before submitting your issue. Thanks!\n\u003e\n\u003e    1.\n\u003e\n\u003e    What version of Go are you using (go version)?\n\u003e    go1.6.2 darwin/amd64\n\u003e    2.\n\u003e\n\u003e    What operating system and processor architecture are you using (go env\n\u003e    )?\n\u003e    OS X Version 10.11.1 (15B42)\n\u003e    3.\n\u003e\n\u003e    What did you do?\n\u003e\n\u003e If possible, provide a recipe for reproducing the error.\n\u003e A complete runnable program is good.\n\u003e A link on play.golang.org is best.\n\u003e\n\u003e I have a binary file that I read into a byte array. Binary file is 2Gb.\n\u003e When it's loaded into mem, the process mem usage is over 6GB. After about 5\n\u003e minutes, the mem usage drops down. Wrote a simple app to reproduce and can\n\u003e do so each time.\n\u003e\n\u003e package main\n\u003e\n\u003e import (\n\u003e     \"flag\"\n\u003e     \"fmt\"\n\u003e     \"io/ioutil\"\n\u003e     \"os\"\n\u003e     \"os/signal\"\n\u003e     \"runtime\"\n\u003e )\n\u003e\n\u003e var fileToRead = flag.String(\"filetoread\", \"\", \"file to load into mem\")\n\u003e\n\u003e func main() {\n\u003e     flag.Parse()\n\u003e\n\u003e     arr, err := func() ([]byte, error) {\n\u003e         file, err := os.Open(*fileToRead)\n\u003e         if err != nil {\n\u003e             panic(err)\n\u003e         }\n\u003e         defer file.Close()\n\u003e\n\u003e         return ioutil.ReadAll(file)\n\u003e     }()\n\u003e     if err != nil {\n\u003e         panic(err)\n\u003e     }\n\u003e\n\u003e     fmt.Printf(\"Read %d bytes\", len(arr))\n\u003e\n\u003e     exitChan := make(chan os.Signal)\n\u003e     signal.Notify(exitChan, os.Interrupt)\n\u003e     \u003c-exitChan\n\u003e }\n\u003e\n\u003e\n\u003e    1.\n\u003e\n\u003e    What did you expect to see?\n\u003e    I would expect the mem usage to be similar to the size of the byte\n\u003e    array allocated\n\u003e    2.\n\u003e\n\u003e    What did you see instead?\n\u003e    When loading a 3GB file, I saw 6.5GB of memory use that stayed that\n\u003e    way for 5-10 minutes. Added runtime.GC() after the printf statement with no\n\u003e    affect. If I call debug.FreeOSMemory(), the memory is released after a few\n\u003e    seconds.\n\u003e\n\u003e â€”\n\u003e You are receiving this because you are subscribed to this thread.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/16269\u003e, or mute the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe/AA7Wn7mFWwvk_W3_CRNse7t_tVmYzyYYks5qSoVzgaJpZM4JFStL\u003e\n\u003e .\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-05T17:17:21Z",
	"updated_at": "2016-07-05T17:17:21Z"
}
