{
	"id": 143723098,
	"number": 14976,
	"state": "closed",
	"title": "cmd/go: use package source hash to detect stale cached compiled packages?",
	"body": "Please answer these questions before submitting your issue. Thanks!\r\n\r\n1. What version of Go are you using (`go version`)?\r\ngo version go1.6 darwin/amd64\r\n\r\n2. What operating system and processor architecture are you using (`go env`)?\r\nGOARCH=\"amd64\"\r\nGOBIN=\"\"\r\nGOEXE=\"\"\r\nGOHOSTARCH=\"amd64\"\r\nGOHOSTOS=\"darwin\"\r\nGOOS=\"darwin\"\r\nGOPATH=\"\"\r\nGORACE=\"\"\r\nGOROOT=\"/usr/local/go\"\r\nGOTOOLDIR=\"/usr/local/go/pkg/tool/darwin_amd64\"\r\nGO15VENDOREXPERIMENT=\"1\"\r\nCC=\"clang\"\r\nGOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fno-common\"\r\nCXX=\"clang++\"\r\nCGO_ENABLED=\"1\"\r\n\r\n\r\n3. What did you do?\r\nI write a main package and a library package and a tester main package.\r\n```\r\nfunc TestMustGoRun2(ot *testing.T){\r\n\tkmgFile.MustDelete(\"testFile\")\r\n\tdefer kmgFile.MustDelete(\"testFile\")\r\n\tkmgFile.MustWriteFileWithMkdir(\"testFile/src/pkgLibA/a.go\",[]byte(`package pkgLibA\r\n\r\nfunc A() string{\r\n\treturn \"A\"\r\n}\r\n`))\r\n\tkmgFile.MustWriteFileWithMkdir(\"testFile/src/pkgMainA/a.go\",[]byte(`package main\r\nimport(\r\n\t\"pkgLibA\"\r\n\t\"fmt\"\r\n)\r\nfunc main(){\r\n\tfmt.Println(pkgLibA.A())\r\n}\r\n`))\r\n\ttesterWithPkg :=func() []byte{\r\n\t\tp:=MustNewProgramV2(map[string]string{\"GOPATH\":kmgFile.MustGetFullPath(\"testFile\")},\"pkgMainA\")\r\n\t\tbuf:=bytes.Buffer{}\r\n\t\tp.mustGoRun(nil,func(cmdSlice []string,env map[string]string){\r\n\t\t\tb:=kmgCmd.CmdSlice(cmdSlice).\r\n\t\t\tMustSetEnvMap(env).\r\n\t\t\tMustRunAndReturnOutput()\r\n\t\t\tbuf.Write(b)\r\n\t\t})\r\n\t\treturn buf.Bytes()\r\n\t}\r\n\ttesterWithPath :=func() []byte{\r\n\t\tp:=MustNewProgramV2(map[string]string{\"GOPATH\":kmgFile.MustGetFullPath(\"testFile\")},\"testFile/src/pkgMainA/a.go\")\r\n\t\tbuf:=bytes.Buffer{}\r\n\t\tp.mustGoRun(nil,func(cmdSlice []string,env map[string]string){\r\n\t\t\tb:=kmgCmd.CmdSlice(cmdSlice).\r\n\t\t\tMustSetEnvMap(env).\r\n\t\t\tMustRunAndReturnOutput()\r\n\t\t\tbuf.Write(b)\r\n\t\t})\r\n\t\treturn buf.Bytes()\r\n\t}\r\n\tkmgTest.Equal(string(testerWithPkg()),\"A\\n\")\r\n\r\n\tkmgFile.MustDelete(\"testFile/pkg\")\r\n\tkmgFile.MustWriteFileWithMkdir(\"testFile/src/pkgLibA/a.go\",[]byte(`package pkgLibA\r\n\r\nfunc A() string{\r\n\treturn \"B\"\r\n}\r\n`))\r\n\tkmgTest.Equal(string(testerWithPkg()),\"B\\n\")\r\n\r\n\tnow:=time.Now()\r\n\ttime.Sleep(now.Round(time.Second).Add(time.Second).Sub(now))\r\n\t// 已知的golang的pkg的缓存bug.(1秒钟后会问题自然解决.)\r\n\tkmgFile.MustWriteFileWithMkdir(\"testFile/src/pkgLibA/a.go\",[]byte(`package pkgLibA\r\n\r\nfunc A() string{\r\n\treturn \"C\"\r\n}\r\n`))\r\n\tkmgTest.Equal(string(testerWithPkg()),\"C\\n\")\r\n\tkmgTest.Equal(string(testerWithPath()),\"C\\n\")\r\n\r\n\tnow=time.Now()\r\n\ttime.Sleep(now.Round(time.Second).Add(time.Second).Sub(now))\r\n\tkmgFile.MustWriteFileWithMkdir(\"testFile/src/pkgLibA/a.go\",[]byte(`package pkgLibA\r\n\r\nfunc A() string{\r\n\treturn \"D\"\r\n}\r\n`))\r\n\tkmgTest.Equal(string(testerWithPath()),\"D\\n\")\r\n\r\n\tkmgFile.MustWriteFileWithMkdir(\"testFile/src/pkgMainA/a.go\",[]byte(`package main\r\nimport(\r\n\t\"pkgLibA\"\r\n\t\"fmt\"\r\n)\r\nfunc main(){\r\n\tfmt.Println(pkgLibA.A(),\"A\")\r\n}\r\n`))\r\n\tkmgTest.Equal(string(testerWithPath()),\"D A\\n\")\r\n\tkmgTest.Equal(string(testerWithPkg()),\"D A\\n\")\r\n}\r\n```\r\nSorry, I missing some library in the code.I think you guys may guess what they are doing.\r\ntesterWithPkg use go install.\r\ntesterWithPath use go run .\r\n\r\n\r\n4. What did you expect to see?\r\nI want to change the pkgLibA code and go run and go install can see the change immediately.\r\n\r\n5. What did you see instead?\r\nI found that I need to add following code or delete pkg directory to make go run and go install notice that I change the pkgLibA code.\r\n```\r\n\tnow=time.Now()\r\n\ttime.Sleep(now.Round(time.Second).Add(time.Second).Sub(now))\r\n```\r\n\r\nI guess your guys use modified time from the Lstat syscall for file content cache verification. I got the same result when I only use Lstat syscall for file content cache verification on darwin.\r\nI found two solutions to get correct behavior to this kind of problem:\r\n* easy to code one: Save the md5 sum of the file content in the cache file,and check them every time you need to check if the cache is valid.\r\n* faster one: Save the md5 sum and the modified time of the file content in the cache file,if you need to check if the cache is valid you need following algorithm:\r\n      * If you have check md5 sum of the file content after the modified time add one second,you can just check modified time from the Lstat syscall, or you need check md5 sum of the file content again.\r\n      * In the most of time, you only need one more md5 sum of the whole file content then the only use Lstat syscall solution. And my computer can do md5 sum with 500MB/s which is faster then ssd disk reading.\r\n      * here is the implement of the algorithm:\r\n```\r\npackage kmgCache\r\nimport (\r\n\t\"time\"\r\n\t\"sync\"\r\n\t\"github.com/bronze1man/kmg/encoding/kmgGob\"\r\n\t\"os\"\r\n\t\"crypto/md5\"\r\n\t\"io\"\r\n\t\"encoding/hex\"\r\n\t\"github.com/bronze1man/kmg/kmgFile\"\r\n)\r\n\r\n// 使用文件绝对路径获取md5,如果文件不存在,会返回 \"\"\r\ntype FileMd5Getter struct{\r\n\timp *fileMd5GetterImp\r\n}\r\nfunc (getter FileMd5Getter) GetMd5ByFullPath(path string) string{\r\n\treturn getter.imp.getMd5ByFullPath__NOLOCK(path)\r\n}\r\nfunc (getter FileMd5Getter) GetMd5ByStatAndFullPath(statAndFullPath kmgFile.StatAndFullPath) string{\r\n\treturn getter.imp.getMd5ByStatAndFullPath__NOLOCK(statAndFullPath)\r\n}\r\ntype FileMd5GetByFullPath func(path string) string\r\n\r\n// 使用缓存方法获取某个文件的md5.\r\n// 由于有各种锁的存在,请不要嵌套使用该函数.\r\n// 此函数在保证正确性的前提下,尽最大努力提高性能.\r\n// 同一个数据库文件,在同一时间只能有一个cb运行.\r\n// 请传入文件绝对路径,避免使用相对路径,减少当前目录的干扰.\r\nfunc FileMd5Get(dbFilePath string,cb func(getter FileMd5Getter)) {\r\n\tgetterImp :=getFileMd5GetterByDbFilePath(dbFilePath)\r\n\tgetterImp.locker.Lock()\r\n\tgetterImp.cacheNow = time.Now()\r\n\tgetterImp.hasChange = false\r\n\toutGetter:=FileMd5Getter{imp: getterImp}\r\n\tcb(outGetter)\r\n\tif getterImp.hasChange{\r\n\t\tkmgGob.MustWriteFile(dbFilePath, getterImp)\r\n\t}\r\n\tgetterImp.locker.Unlock()\r\n}\r\n\r\ntype fileMd5GetterImp struct{\r\n\tCacheInfo map[string]*cacheInfoEntry\r\n\tlocker sync.Mutex\r\n\thasChange bool // 内部的信息是否变化过,以便减少写入成本.\r\n\tcacheNow time.Time\r\n\tinnerBuf []byte\r\n}\r\ntype cacheInfoEntry struct{\r\n\tMTime time.Time\r\n\tMd5 string\r\n\tHasCheckInNextSecond bool // 是否在非同一秒,检查过一次md5\r\n}\r\n\r\n\r\nvar fileMd5GetterMap map[string]*fileMd5GetterImp\r\nvar fileMd5GetterMapLock sync.Mutex\r\nfunc (getter *fileMd5GetterImp) getMd5ByFullPath__NOLOCK(path string) string {\r\n\tfi,err:=os.Lstat(path)\r\n\tif err!=nil{\r\n\t\treturn \"\"\r\n\t}\r\n\treturn getter.getMd5ByStatAndFullPath__NOLOCK(kmgFile.StatAndFullPath{\r\n\t\tFi: fi,\r\n\t\tFullPath: path,\r\n\t})\r\n}\r\nfunc (getter *fileMd5GetterImp) getMd5ByStatAndFullPath__NOLOCK(statAndFullPath kmgFile.StatAndFullPath) string {\r\n\tpath:=statAndFullPath.FullPath\r\n\tfi:=statAndFullPath.Fi\r\n\tvar err error\r\n\tthisEntry := getter.CacheInfo[path]\r\n\tif thisEntry == nil {\r\n\t\tthisEntry = \u0026cacheInfoEntry{}\r\n\t\tthisEntry.MTime = fi.ModTime()\r\n\t\tthisEntry.Md5, err = md5FileWithBuf(path,getter.innerBuf)\r\n\t\tif err != nil {\r\n\t\t\treturn \"\"\r\n\t\t}\r\n\t\tthisEntry.HasCheckInNextSecond = (getter.cacheNow.Sub(thisEntry.MTime)\u003etime.Second) // 如果mtime已经是很久以前的了,就直接标记已经二次检查了.\r\n\t\tgetter.CacheInfo[path] = thisEntry\r\n\t\tgetter.hasChange = true\r\n\t\treturn thisEntry.Md5\r\n\t}\r\n\t// 最初版本,用于确保正确性,(后面使用减少syscall的方式来进行优化,会降低可读性.)\r\n\tfileMtime:=fi.ModTime()\r\n\tif !fileMtime.Equal(thisEntry.MTime){\r\n\t\t// 文件修改时间和储存的文件修改时间 不相同,一定检查md5\r\n\t\tthisEntry.MTime = fileMtime\r\n\t\tthisEntry.Md5, err = md5FileWithBuf(path,getter.innerBuf)\r\n\t\tif err != nil {\r\n\t\t\treturn \"\"\r\n\t\t}\r\n\t\tthisEntry.HasCheckInNextSecond = (getter.cacheNow.Sub(thisEntry.MTime)\u003etime.Second) // 如果mtime已经是很久以前的了,就直接标记已经二次检查了.\r\n\t\tgetter.hasChange = true // 修改时间一定变化过.\r\n\t\treturn thisEntry.Md5\r\n\t}\r\n\tnow:=getter.cacheNow\r\n\tif now.Sub(thisEntry.MTime)\u003ctime.Second{\r\n\t\t// 当前时间和文件修改时间,在同一秒内,(文件修改时间和储存的文件修改时间 相同) 一定检查md5\r\n\t\tmd5, err := md5FileWithBuf(path,getter.innerBuf)\r\n\t\tif err != nil {\r\n\t\t\treturn \"\"\r\n\t\t}\r\n\t\tif md5==thisEntry.Md5 {\r\n\t\t\tgetter.hasChange = true\r\n\t\t}\r\n\t\tthisEntry.Md5 = md5\r\n\t\tthisEntry.HasCheckInNextSecond = false\r\n\t\treturn thisEntry.Md5\r\n\t}\r\n\tif thisEntry.HasCheckInNextSecond==false{\r\n\t\t// 当前是第一次(文件修改时间和储存的文件修改时间 相同,当前时间和文件修改时间,不在同一秒内) 一定检查md5\r\n\t\tthisEntry.MTime = fileMtime\r\n\t\tmd5, err := md5FileWithBuf(path,getter.innerBuf)\r\n\t\tif err != nil {\r\n\t\t\treturn \"\"\r\n\t\t}\r\n\t\tthisEntry.HasCheckInNextSecond = (md5==thisEntry.Md5) // md5 没有变化才设置 当前已经第二次检查过了\r\n\t\tgetter.hasChange = true // 要么 thisEntry.HasCheckInNextSecond 变化,要么 md5==thisEntry.Md5 变化.\r\n\t\tthisEntry.Md5 = md5\r\n\t\treturn thisEntry.Md5\r\n\t}\r\n\t// (文件修改时间和储存的文件修改时间 相同,当前时间和文件修改时间,不在同一秒内,当前不是第一次) 直接使用缓存数据就可以了.\r\n\treturn thisEntry.Md5\r\n}\r\n\r\n\r\nfunc getFileMd5GetterByDbFilePath(dbFilePath string) *fileMd5GetterImp {\r\n\tfileMd5GetterMapLock.Lock()\r\n\tdefer fileMd5GetterMapLock.Unlock()\r\n\tif fileMd5GetterMap==nil{\r\n\t\tfileMd5GetterMap = map[string]*fileMd5GetterImp{}\r\n\t}\r\n\tthisGetter:=fileMd5GetterMap[dbFilePath]\r\n\tif thisGetter!=nil{\r\n\t\treturn thisGetter\r\n\t}\r\n\tthisGetter = \u0026fileMd5GetterImp{}\r\n\terr := kmgGob.ReadFile(dbFilePath, \u0026thisGetter)\r\n\tif err != nil {\r\n\t\t//忽略缓存读取的任何错误\r\n\t\tthisGetter = \u0026fileMd5GetterImp{}\r\n\t}\r\n\tif thisGetter.CacheInfo==nil{\r\n\t\tthisGetter.CacheInfo = map[string]*cacheInfoEntry{}\r\n\t}\r\n\tif thisGetter.innerBuf == nil{\r\n\t\tthisGetter.innerBuf = make([]byte,32*1024)\r\n\t}\r\n\tfileMd5GetterMap[dbFilePath] = thisGetter\r\n\treturn thisGetter\r\n}\r\n\r\n// 使用这个方法减少alloc,提高性能约30%.\r\nfunc md5FileWithBuf(path string,innerBuf []byte) (string,error){\r\n\thash := md5.New()\r\n\tf,err:=os.Open(path)\r\n\tif err!=nil{\r\n\t\treturn \"\",err\r\n\t}\r\n\tdefer f.Close()\r\n\t_,err=io.CopyBuffer(hash,f,innerBuf)\r\n\tif err!=nil{\r\n\t\treturn \"\",err\r\n\t}\r\n\thashB := hash.Sum(innerBuf[0:0])\r\n\thex.Encode(innerBuf[16:],hashB)\r\n\treturn string(innerBuf[16:16+32]),nil\r\n}\r\n```\r\nAs you can see from the example implement code, if you make file content verification to a standalone library , you only need to compute the md5 sum of the file content when the changes,if it does not change,you can use the old md5 sum safely, and the most of the source code files do not change during the develop process.",
	"user": {
		"login": "bronze1man",
		"id": 1107541,
		"type": "User",
		"site_admin": false
	},
	"comments": 5,
	"closed_at": "2016-04-10T03:10:05Z",
	"created_at": "2016-03-26T16:04:14Z",
	"updated_at": "2016-04-10T15:21:11Z",
	"milestone": {
		"id": 1055141,
		"number": 6,
		"title": "Unplanned"
	},
	"reactions": {
		"total_count": 1,
		"+1": 1
	}
}
