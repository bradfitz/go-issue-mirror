{
	"id": 252018974,
	"body": "@odeke-em, not quite.\r\n\r\nMore minimal example: https://play.golang.org/p/RuDNKvAQhT\r\n\r\nWhich says:\r\n\r\n```\r\nfatal error: all goroutines are asleep - deadlock!\r\n\r\ngoroutine 1 [semacquire]:\r\nsync.runtime_notifyListWait(0x107406ac, 0x1)\r\n\t/usr/local/go/src/runtime/sema.go:267 +0x1e0\r\nsync.(*Cond).Wait(0x107406a4, 0x3003bc)\r\n\t/usr/local/go/src/sync/cond.go:57 +0xe0\r\nio.(*pipe).read(0x10740680, 0x10753000, 0x1000, 0x1000, 0x0, 0x0, 0x0, 0x1000)\r\n\t/usr/local/go/src/io/pipe.go:47 +0x3e0\r\nio.(*PipeReader).Read(0x1070a4b8, 0x10753000, 0x1000, 0x1000, 0x1070a4b8, 0x0, 0x0, 0x1000)\r\n\t/usr/local/go/src/io/pipe.go:129 +0x60\r\nbufio.(*Reader).fill(0x107363c0, 0x7881)\r\n\t/usr/local/go/src/bufio/bufio.go:97 +0x260\r\nbufio.(*Reader).Read(0x107363c0, 0x10732b98, 0x2, 0x2, 0x7, 0x0, 0x0, 0x1000)\r\n\t/usr/local/go/src/bufio/bufio.go:209 +0x2c0\r\nio.ReadAtLeast(0x3a07c0, 0x107363c0, 0x10732b98, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0xffd)\r\n\t/usr/local/go/src/io/io.go:307 +0xe0\r\nio.ReadFull(0x3a07c0, 0x107363c0, 0x10732b98, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0)\r\n\t/usr/local/go/src/io/io.go:325 +0x60\r\nnet/http/internal.(*chunkedReader).Read(0x10732b80, 0x1077d730, 0x0, 0x0, 0x7, 0x0, 0x0, 0x7)\r\n\t/usr/local/go/src/net/http/internal/chunked.go:95 +0x2a0\r\nmain.main()\r\n\t/tmp/sandbox227319092/main.go:17 +0x3c0\r\n```\r\n\r\nThe report is that an `io.Reader` is supposed to return as soon as it has anything, without blocking further, and `net/http/internal.(*chunkedReader).Read` doesn't do that.\r\n\r\nSee `src/net/http/internal/chunked.go:95` in the backtrace? That line 95 is the \"ReadFull\" at:\r\n \r\n```go\r\nfunc (cr *chunkedReader) Read(b []uint8) (n int, err error) {\r\n        for cr.err == nil {\r\n                if cr.n == 0 {\r\n                        if n \u003e 0 \u0026\u0026 !cr.chunkHeaderAvailable() {\r\n                                // We've read enough. Don't potentially block                                                                                                                                            \r\n                                // reading a new chunk header.                                                                                                                                                           \r\n                                break\r\n                        }\r\n                        cr.beginChunk()\r\n                        continue\r\n                }\r\n                if len(b) == 0 {\r\n                        break\r\n                }\r\n                rbuf := b\r\n                if uint64(len(rbuf)) \u003e cr.n {\r\n                        rbuf = rbuf[:cr.n]\r\n                }\r\n                var n0 int\r\n                n0, cr.err = cr.r.Read(rbuf)\r\n                n += n0\r\n                b = b[n0:]\r\n                cr.n -= uint64(n0)\r\n                // If we're at the end of a chunk, read the next two                                                                                                                                                     \r\n                // bytes to verify they are \"\\r\\n\".                                                                                                                                                                      \r\n                if cr.n == 0 \u0026\u0026 cr.err == nil {\r\n                        if _, cr.err = io.ReadFull(cr.r, cr.buf[:2]); cr.err == nil {\r\n                                if cr.buf[0] != '\\r' || cr.buf[1] != '\\n' {\r\n                                        cr.err = errors.New(\"malformed chunked encoding\")\r\n                                }\r\n                        }\r\n                }\r\n        }\r\n        return n, cr.err\r\n}\r\n```\r\n\r\nSo we it has data to return, but it's blocking further to make sure the next two bytes are valid. It could instead delay that check if it kept more state.\r\n",
	"user": {
		"login": "bradfitz",
		"id": 2621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-10-06T16:38:55Z",
	"updated_at": "2016-10-06T16:38:55Z"
}
