{
	"id": 234060636,
	"body": "The key thing triggering the bug is the fact that the protobuf dir contains both internal and external tests. This in turn creates a scenario where you have two copies of a single package, each with different priorities, which is where things go wobbly.\r\n\r\nI created a smaller test case to encapsulate the bug:\r\n\r\n```\r\n$GOPATH/issue15738/foo/foo.go:\r\n  package foo\r\n  var globmap = make(map[string]string)\r\n  func Modmap(s1 string, s2 string) {\r\n    globmap[s1] = s2\r\n  }\r\n  func AddOne(x int) int {\r\n\treturn x + 1\r\n  }\r\n  func addThree(x int) int {\r\n\treturn x + 3\r\n  }\r\n\r\n$GOPATH/issue15738/bar/bar.go:\r\n  package bar\r\n  import \"issue15738/foo\"\r\n  func init() {\r\n    foo.Modmap(\"a\", \"b\")\r\n  }\r\n  func AddTwo(x int) int {\r\n\treturn x + 2\r\n  }\r\n\r\n$GOPATH/issue15738/foo/foo_internal_test.go:\r\n  package foo\r\n  import \"testing\"\r\n  func TestLocal(t *testing.T) {\r\n    if addThree(0) != 3 {\r\n       t.Errorf(\"fail\")\r\n    }\r\n  }\r\n\r\n$GOPATH/issue15738/foo/foo_external_test.go:\r\n  package foo_external_test\r\n  import (\r\n\t\"issue15738/bar\"\r\n\t\"issue15738/foo\"\r\n\t\"testing\"\r\n  )\r\n  func TestExternal(t *testing.T) {\r\n    if foo.AddOne(bar.AddTwo(0)) != 3 {\r\n      t.Errorf(\"fail\")\r\n    }\r\n  }\r\n\r\n```\r\nDuring the compilation phase of \"go test\", the builder first builds an object containing the internal test and foo, e.g.\r\n\r\n   gccgo ... -c -o foo_it1.o ./foo.go ./foo_internal_test.go\r\n   ar rc libfoo_itest.a foo_it1.o\r\n\r\nfoo_internal_test.go imports only \"testing\", but \"testing\" has a priority of 8, this means that the priority for foo_it1.o is set to 9.\r\n\r\nNext it reruns the foo compile without the internal test:\r\n\r\n   gccgo ... -c -o foo.o ./foo.go\r\n   ar rc libfoo.a foo.o\r\n\r\nSince foo.go has no imports, foo.o gets a priority of 1. Moving on:\r\n\r\n   gccgo ... -c -o bar.o ./bar.go\r\n   ar rc libbar.a bar.o\r\n\r\nSince bar imports only foo, bar.o is assigned a priority of 2.\r\nNext the external test gets compiled:\r\n\r\n   gccgo ... -c -o foo_ext.o ./foo_external_test.go\r\n   ar rc libfoo_etest.a foo_ext.o\r\n\r\nHere foo_external_test.go imports foo, bar, and testing. Again, since testing has a priority of 8, this means that the priority for foo_it1.o is set to 9. \r\n\r\nThe final link looks like:\r\n\r\n  gccgo -o foo.test testmain.o -Wl,-( -Wl,--whole-archive \\\r\n    libfoo_itest.a libfoo_etest.a libbar.a -Wl,--no-whole-archive -Wl,-)\r\n\r\nThe problem here is that we built \"libbar.a\" against the vanilla version of the foo package (libfoo.a), which contained a version of foo that had priority 1. However when we do to do the final link, we're using a different copy of foo (contained in libfoo_itest.a) that has priority 9. As a result the bar initializer runs before the foo initializer, which is incorrect.\r\n\r\nMy instinct is to try to fix this in \"go test\" as opposed to trying to change gccgo -- gccgo's priority scheme works fine, it's simply the fact that we're compiling the \"bar\" package based on one version of \"foo\", then in the final link we link in a different verison of \"foo\".  I will spend some time looking over the \"go build\" and \"go test\" srcs.\r\n",
	"user": {
		"login": "thanm",
		"id": 12280172,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-20T19:47:10Z",
	"updated_at": "2016-07-20T19:55:11Z"
}
