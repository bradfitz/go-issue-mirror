{
	"id": 234621065,
	"body": "\r\nPossible solutions:\r\n\r\n1. change the build scheme for \"go test\" to be single-build-per-package\r\n\r\n  When compiling a package P, don't do two builds one with the internal test code and one without the internal test code -- instead just produce a single archive library for P that contains the package itself plus the test code, then link other packages against that archive.\r\n\r\n  This scheme has the disadvantage that we could have naming collisions or conflicts as a result of things exported from the test code; for this reason I think it's pretty much a non-starter. Example:\r\n\r\n  p.go:\r\n    package p\r\n      func PFunc() { .. }\r\n\r\n  p_test.go:\r\n    package p\r\n      func Helper() { .. }\r\n\r\nIf some other package \"q\" imports \"p\" with a dot import, this will introduce \"Helper\" into the file scope for \"q\" (meaning that it could collide with some other function).\r\n\r\n\r\n2. Create a command line option for gccgo that allows adding priority skew\r\n\r\n  Since the problem boils down to the fact that importing \"testing\" bumps up the priority of a given package by a constant (somewhere between 0 and 8), then we could add a new \"-fpriority-skew=N\" option that tells gccgo to start with an initial priority of N (not 1) for any package that it is compiling. This option could then be set by the \"go test\" builder.\r\n\r\n  Another possibility along these lines would be something like \"-finject-import=XYZ\", which would tell the compiler \"Hey, I didn't import package XYZ in my source code, but please act as if I did\".  This would have the effect of bumping up the priority of any package K dependent on package J that happens to have internal test code.\r\n\r\n  These proposals seem hacky (any solution that involves adding a new obscure command line option is automatically distasteful in my mind) but it does seem as though it would take care of the issue.\r\n\r\n  A second drawback here is that \"go test\" has smarts to detect cases where packages have already been compiled and don't need to be rebuilt -- this would need to be defeated somehow in order for this scheme to work (which could in some cases greatly increase the time needed to run tests).\r\n\r\n\r\n3. Silently inject ref to testing package during \"go build/test\" compilation\r\n\r\n  Here the idea is that for any random package P we have to compile as part of the build process for \"go test\", we generate a tiny code fragment that looks like\r\n\r\n    package P\r\n    import \"testing\"\r\n\r\n  and then tack that onto the end of the gccgo command line. This has an effect similar to \"-finject-import=XYZ\" described above, but doesn't require any compiler changes or new command line options.\r\n\r\n  Same drawback here as option #2 above with respect to staleness check -- we can't reuse the existing installed copy of package K if K depend on package J that has internal test code.\r\n\r\n\r\n4. Change gccgo to initialize testing first\r\n\r\n  Since this bug revolves around the \"testing\" package, one avenue for fixing it would be to add special-case code to gccgo relating to that package. Specifically: \r\n\r\n     A] when importing the package \"testing\", we ignore the priority it exports (currently 8) and assign it a priority of zero (at least for the purposes of computing the priority of the package we're actually compiling)\r\n\r\n     B] at the point when we're emitting init calls (for the main package), if main imports the testing package (which testmain.go does) then we insure that the call to initialize \"testing\" goes first, before any other package. \r\n\r\n  Taking the \"testing\" package out of the equation when it comes to priorities means that the special \"package plus internal test\" blob that we create will have the same priority as the regular package.\r\n\r\n",
	"user": {
		"login": "thanm",
		"id": 12280172,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-22T18:31:39Z",
	"updated_at": "2016-07-22T18:31:39Z"
}
