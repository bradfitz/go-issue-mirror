{
	"id": 206349520,
	"body": "@hanwen msgNewKeys is not a message that is actually ever read over the wire. It is a hard-coded message in the client/server here:\r\n\r\nhttps://github.com/golang/crypto/blob/master/ssh/handshake.go#L211\r\n\r\nThis has nothing to do with msgNewKeys being emitted twice incorrectly. It has to do with the internal handling of all Kex Packets in `readOnePacket` here:\r\n\r\nhttps://github.com/golang/crypto/blob/master/ssh/handshake.go#L173-L211\r\n\r\nThe two lines you linked above do not show that the client/server synchronize on requesting their key exchanges at the same time. All they show is that the respective client/server requested a key exchange and received the correct response. There is nothing stopping them from both requesting a key exchange.\r\n\r\nUnderstanding the race, you could artificially introduce timing into the production code to get this to fail easier.\r\n\r\nAdding this `time.Sleep` to `server.go` in `serverHandshake` between [these lines](https://github.com/golang/crypto/blob/master/ssh/server.go#L189-L191):\r\n\r\n```\r\n\ts.clientVersion, err = exchangeVersions(s.sshConn.conn, s.serverVersion)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\ttr := newTransport(s.sshConn.conn, config.Rand, false /* not client */)\r\n\ts.transport = newServerTransport(tr, s.clientVersion, s.serverVersion, config)\r\n\r\n\ttime.Sleep(1 * time.Second)\r\n\r\n\tif err := s.transport.requestKeyChange(); err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tif packet, err := s.transport.readPacket(); err != nil {\r\n\t\treturn nil, err\r\n\t} else if packet[0] != msgNewKeys {\r\n\t\treturn nil, unexpectedMessageError(msgNewKeys, packet[0])\r\n\t}\r\n```\r\n\r\nor a similar sleep in `clientHandshake` will cause a failure 100% of the time. That should be sufficient enough for you to reproduce the problem.\r\n\r\nOnce again the issue here is that `readOnePacket` correctly handles all KexInit messages internally, including responding with a KexInit message if one has not already been sent, seen here:\r\n\r\nhttps://github.com/golang/crypto/blob/master/ssh/handshake.go#L308\r\n\r\nThus the server can receive the clients KexInit, respond with a KexInit successfully and then send another KexInit because of disconnect between reading and buffering packets which begins here:\r\n\r\nhttps://github.com/golang/crypto/blob/master/ssh/server.go#L189\r\n\r\nand forcibly requesting a key exchange here:\r\n\r\nhttps://github.com/golang/crypto/blob/master/ssh/server.go#L191\r\n\r\nAlso please note that this timing issue exists in both the client and the server, just in the example above I artificially introduced the timing in the server. I could have just have easily added the `time.Sleep` to `clientHandshake` and received a entirely different error message from the server handshake failing.\r\n\r\nPlease let me know if you have any other questions.",
	"user": {
		"login": "jfmyers9",
		"id": 1035246,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-04-06T12:31:22Z",
	"updated_at": "2016-04-06T12:33:02Z"
}
