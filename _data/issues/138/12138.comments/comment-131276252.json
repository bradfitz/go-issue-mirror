{
	"id": 131276252,
	"body": "So I fixed the scoping issue.  That wasn't the problem that was causing panics; however, I was able to figure out what was.\r\n\r\nThe `C.z_stream` structure was being allocated by cgo.  `zlib` then allocates pointers inside of that struct and the Go GC saw them as invalid (since it had no record of the allocations).  The solution was to only store a pointer to `z_stream` sized data so that the GC wouldn't do pointer inspection on it.\r\n\r\nI assume this is intended behavior for the GC, but it is a real \"gotya\" and should be added to that new cgo documentation that was mentioned.\r\n\r\nFor reference here's the updated (working) code.\r\n\r\ndiff:\r\n```diff\r\n@@ -23,11 +23,16 @@ package zlib\r\n \r\n // #cgo LDFLAGS: -lz\r\n // #include \u003czlib.h\u003e\r\n+// #include \u003cstdlib.h\u003e\r\n //\r\n // // inflateInit is a macro so we need to do this\r\n // int InflateInit(z_streamp s) {\r\n //     return inflateInit(s);\r\n // }\r\n+//\r\n+// z_streamp new_zstream() {\r\n+//     return (z_streamp) calloc(sizeof(z_stream), 1);\r\n+// }\r\n import \"C\"\r\n \r\n import (\r\n@@ -40,7 +45,7 @@ import (\r\n type reader struct {\r\n \tr     io.Reader\r\n \tinbuf []byte\r\n-\ts     C.z_stream\r\n+\ts     *C.z_stream\r\n }\r\n \r\n // NewReader creates a new ReadCloser. Reads from the returned ReadCloser\r\n@@ -50,9 +55,10 @@ type reader struct {\r\n func NewReader(r io.Reader) (io.ReadCloser, error) {\r\n \trd := \u0026reader{\r\n \t\tr: r,\r\n+\t\ts: C.new_zstream(),\r\n \t}\r\n \r\n-\terr := C.InflateInit(\u0026rd.s)\r\n+\terr := C.InflateInit(rd.s)\r\n \tif err != C.Z_OK {\r\n \t\treturn nil, errors.New(\"Could not init inflate.\")\r\n \t}\r\n@@ -69,8 +75,9 @@ func (r *reader) Read(p []byte) (n int, err error) {\r\n \t// output.\r\n \tmaxIn := int64(len(p))\r\n \r\n+\tvar buf *bytes.Buffer\r\n \tif r.inbuf == nil {\r\n-\t\tbuf := bytes.NewBuffer(make([]byte, 0, maxIn))\r\n+\t\tbuf = bytes.NewBuffer(make([]byte, 0, maxIn))\r\n \r\n \t\tnIn, err := io.CopyN(buf, r.r, maxIn)\r\n \t\tif err != nil \u0026\u0026 err != io.EOF {\r\n@@ -96,7 +103,7 @@ func (r *reader) Read(p []byte) (n int, err error) {\r\n \t\tr.s.avail_out = C.uInt(len(out))\r\n \t\tr.s.next_out = (*C.Bytef)(unsafe.Pointer(\u0026out[0]))\r\n \r\n-\t\tret = C.inflate(\u0026r.s, C.Z_NO_FLUSH)\r\n+\t\tret = C.inflate(r.s, C.Z_NO_FLUSH)\r\n \r\n \t\tif ret != C.Z_STREAM_END \u0026\u0026 ret != C.Z_OK {\r\n \t\t\treturn 0, errors.New(\"Could not deflate input.\")\r\n@@ -126,10 +133,12 @@ func (r *reader) Read(p []byte) (n int, err error) {\r\n //\r\n // Calling Close does not close the wrapped io.Reader originally passed to NewReader\r\n func (r *reader) Close() error {\r\n-\terr := C.inflateEnd(\u0026r.s)\r\n+\terr := C.inflateEnd(r.s)\r\n \tif err != C.Z_OK {\r\n \t\treturn errors.New(\"Could not end inflate\")\r\n \t}\r\n \r\n+\tC.free(unsafe.Pointer(r.s))\r\n+\r\n \treturn nil\r\n }\r\n```\r\n\r\nFull code:\r\n\r\n```go\r\n// #cgo LDFLAGS: -lz\r\n// #include \u003czlib.h\u003e\r\n// #include \u003cstdlib.h\u003e\r\n//\r\n// // inflateInit is a macro so we need to do this\r\n// int InflateInit(z_streamp s) {\r\n//     return inflateInit(s);\r\n// }\r\n//\r\n// z_streamp new_zstream() {\r\n//     return (z_streamp) calloc(sizeof(z_stream), 1);\r\n// }\r\nimport \"C\"\r\n\r\nimport (\r\n\t\"bytes\"\r\n\t\"errors\"\r\n\t\"io\"\r\n\t\"unsafe\"\r\n)\r\n\r\ntype reader struct {\r\n\tr     io.Reader\r\n\tinbuf []byte\r\n\ts     *C.z_stream\r\n}\r\n\r\n// NewReader creates a new ReadCloser. Reads from the returned ReadCloser\r\n// read and decompress data from r. The implementation buffers input and\r\n// may read more data than necessary from r. It is the caller's\r\n// responsibility to call Close on the ReadCloser when done.\r\nfunc NewReader(r io.Reader) (io.ReadCloser, error) {\r\n\trd := \u0026reader{\r\n\t\tr: r,\r\n\t\ts: C.new_zstream(),\r\n\t}\r\n\r\n\terr := C.InflateInit(rd.s)\r\n\tif err != C.Z_OK {\r\n\t\treturn nil, errors.New(\"Could not init inflate.\")\r\n\t}\r\n\r\n\treturn rd, nil\r\n}\r\n\r\nfunc (r *reader) Read(p []byte) (n int, err error) {\r\n\tif len(p) == 0 {\r\n\t\treturn 0, nil\r\n\t}\r\n\r\n\t// We can assume that the input will be smaller than\r\n\t// output.\r\n\tmaxIn := int64(len(p))\r\n\r\n\tvar buf *bytes.Buffer\r\n\tif r.inbuf == nil {\r\n\t\tbuf = bytes.NewBuffer(make([]byte, 0, maxIn))\r\n\r\n\t\tnIn, err := io.CopyN(buf, r.r, maxIn)\r\n\t\tif err != nil \u0026\u0026 err != io.EOF {\r\n\t\t\treturn 0, err\r\n\t\t}\r\n\r\n\t\tif nIn == 0 \u0026\u0026 err == io.EOF {\r\n\t\t\treturn 0, io.ErrUnexpectedEOF\r\n\t\t}\r\n\r\n\t\tr.s.avail_in = C.uInt(nIn)\r\n\t\tr.s.next_in = (*C.Bytef)(unsafe.Pointer(\u0026buf.Bytes()[0]))\r\n\t} else {\r\n\t\t// We still have input from the last call\r\n\t\tr.s.avail_in = C.uInt(len(r.inbuf))\r\n\t\tr.s.next_in = (*C.Bytef)(unsafe.Pointer(\u0026r.inbuf[0]))\r\n\t}\r\n\r\n\tvar read int\r\n\tvar ret C.int\r\n\tfor ret != C.Z_STREAM_END {\r\n\t\tout := p[read:]\r\n\t\tr.s.avail_out = C.uInt(len(out))\r\n\t\tr.s.next_out = (*C.Bytef)(unsafe.Pointer(\u0026out[0]))\r\n\r\n\t\tret = C.inflate(r.s, C.Z_NO_FLUSH)\r\n\r\n\t\tif ret != C.Z_STREAM_END \u0026\u0026 ret != C.Z_OK {\r\n\t\t\treturn 0, errors.New(\"Could not deflate input.\")\r\n\t\t}\r\n\r\n\t\tread = len(out) - int(r.s.avail_out)\r\n\r\n\t\tif r.s.avail_out == 0 {\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif ret == C.Z_STREAM_END {\r\n\t\treturn read, io.EOF\r\n\t}\r\n\r\n\tif r.s.avail_in == 0 {\r\n\t\tr.inbuf = nil\r\n\t} else {\r\n\t\tr.inbuf = C.GoBytes(unsafe.Pointer(r.s.next_in), C.int(r.s.avail_in))\r\n\t}\r\n\r\n\treturn read, nil\r\n}\r\n\r\n// Close implements the io.Closer interface\r\n//\r\n// Calling Close does not close the wrapped io.Reader originally passed to NewReader\r\nfunc (r *reader) Close() error {\r\n\terr := C.inflateEnd(r.s)\r\n\tif err != C.Z_OK {\r\n\t\treturn errors.New(\"Could not end inflate\")\r\n\t}\r\n\r\n\tC.free(unsafe.Pointer(r.s))\r\n\r\n\treturn nil\r\n}\r\n```",
	"user": {
		"login": "jtsylve",
		"id": 594165,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-15T01:20:52Z",
	"updated_at": "2015-08-15T01:20:52Z"
}
