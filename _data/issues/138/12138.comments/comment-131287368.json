{
	"id": 131287368,
	"body": "\u003eIn my copy of zlib, z_stream is a pointer type and inflateInit mallocs\r\n\u003ememory and returns the z_stream pointer to it. Perhaps your version is\r\n\u003edifferent.\r\n\r\nIndeed it must be (from zlib.h shipped with OS X) \r\n\r\n```C\r\ntypedef struct z_stream_s {\r\n    Bytef    *next_in;  /* next input byte */\r\n    uInt     avail_in;  /* number of bytes available at next_in */\r\n    uLong    total_in;  /* total nb of input bytes read so far */\r\n\r\n    Bytef    *next_out; /* next output byte should be put there */\r\n    uInt     avail_out; /* remaining free space at next_out */\r\n    uLong    total_out; /* total nb of bytes output so far */\r\n\r\n    char     *msg;      /* last error message, NULL if no error */\r\n    struct internal_state FAR *state; /* not visible by applications */\r\n\r\n    alloc_func zalloc;  /* used to allocate the internal state */\r\n    free_func  zfree;   /* used to free the internal state */\r\n    voidpf     opaque;  /* private data object passed to zalloc and zfree */\r\n\r\n    int     data_type;  /* best guess about the data type: binary or text */\r\n    uLong   adler;      /* adler32 value of the uncompressed data */\r\n    uLong   reserved;   /* reserved for future use */\r\n} z_stream;\r\n\r\ntypedef z_stream FAR *z_streamp;\r\n```\r\n```C\r\nZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));\r\n```\r\nAll the more reason not to make assumptions about library changes.\r\n\r\n\u003eAnd, again, even if it were a struct and it contained pointers initialized\r\n\u003eby zlib, that would be perfectly fine because the Go heap is allowed to\r\n\u003epoint to the C heap.\r\n\r\nWhat about pointers to the Go heap that C adjusts? In the above case the `next_in` pointer is actually adjusted by the call to `inflate`.  So now what the GC would see is a pointer into the middle of a GO allocation that it didn't set.  I'm not familiar enough with the GC internals to know if that's a problem, but the panic suggests that it is.  (Especially since this fix does prevent the panic)\r\n\r\n\u003e Sorry, I was sloppy when I said \"scope.\" In fact, the garbage collector is\r\n\u003e free to free buf the moment after you last mention it in your code, which\r\n\u003e is before the inflate call.\r\n\r\nThat is something I didn't know about the GC!  I wouldn't have assumed that was the case since the reference is still being stored in the variable, but it does make sense.",
	"user": {
		"login": "jtsylve",
		"id": 594165,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-15T03:29:35Z",
	"updated_at": "2015-08-15T03:29:35Z"
}
