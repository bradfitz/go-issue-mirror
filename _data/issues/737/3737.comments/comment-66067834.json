{
	"id": 66067834,
	"body": "\u003ca id=\"c1\"\u003e\u003c/a\u003eComment 1:\n\n\u003cpre\u003eYour algorithm to read the CSV text is flawed because it discards errors. I've revised\nyou code to report an error.\n\npackage main\n\nimport (\n\t\"encoding/csv\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nvar text = `Tag,Action,BalanceTag,Units,DestinationTag,PriceType,PriceValue,Weight\nSOME,TOPUP_RESET,MONETARY,10,*all,,,\nSOME,TOPUP_RESET,SMS,100,*all,,,\nSOME,TOPUP_RESET,INTERNET,1000,*all,,,\nSOME,POSTPAID_RESET,MONETARY,10,*all,,,\nSOME,DEBIT,MONETARY,5,*all,,,\nSOME_1,DEBIT,MINUTES,10,GERMANY_O2,PERCENT,25,10\nSOME_2,TOPUP_RESET,MINUTES,1000,GERMANY,ABSOLUTE,0.2,10\n`\n\nfunc main() {\n\tcsvReader := csv.NewReader(strings.NewReader(text))\n\tfor {\n\t\trecord, err := csvReader.Read()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tlog.Print(record)\n\t}\n}\n\nOutput:\n2012/06/15 10:08:42 [Tag Action BalanceTag Units DestinationTag PriceType PriceValue\nWeight]\n2012/06/15 10:08:42 line 2, column 35: extra delimiter at end of line\nexit status 1\n\nTo fix the reported error, I wrote,\n\npackage main\n\nimport (\n\t\"encoding/csv\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nvar text = `Tag,Action,BalanceTag,Units,DestinationTag,PriceType,PriceValue,Weight\nSOME,TOPUP_RESET,MONETARY,10,*all,,,\nSOME,TOPUP_RESET,SMS,100,*all,,,\nSOME,TOPUP_RESET,INTERNET,1000,*all,,,\nSOME,POSTPAID_RESET,MONETARY,10,*all,,,\nSOME,DEBIT,MONETARY,5,*all,,,\nSOME_1,DEBIT,MINUTES,10,GERMANY_O2,PERCENT,25,10\nSOME_2,TOPUP_RESET,MINUTES,1000,GERMANY,ABSOLUTE,0.2,10\n`\n\nfunc main() {\n\tcsvReader := csv.NewReader(strings.NewReader(text))\n\tcsvReader.TrailingComma = true\n\tfor {\n\t\trecord, err := csvReader.Read()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tlog.Print(record)\n\t}\n}\n\nOutput:\n2012/06/15 10:13:07 [Tag Action BalanceTag Units DestinationTag PriceType PriceValue\nWeight]\n2012/06/15 10:13:07 [SOME TOPUP_RESET MONETARY 10 *all   ]\n2012/06/15 10:13:07 [SOME TOPUP_RESET SMS 100 *all   ]\n2012/06/15 10:13:07 [SOME TOPUP_RESET INTERNET 1000 *all   ]\n2012/06/15 10:13:07 [SOME POSTPAID_RESET MONETARY 10 *all   ]\n2012/06/15 10:13:07 [SOME DEBIT MONETARY 5 *all   ]\n2012/06/15 10:13:07 [SOME_1 DEBIT MINUTES 10 GERMANY_O2 PERCENT 25 10]\n2012/06/15 10:13:07 [SOME_2 TOPUP_RESET MINUTES 1000 GERMANY ABSOLUTE 0.2 10]\n\n\n       Within the header and each record, there may be one or more\n       fields, separated by commas.  Each line should contain the same\n       number of fields throughout the file.  Spaces are considered part\n       of a field and should not be ignored.  The last field in the\n       record must not be followed by a comma.  For example:\n\n       aaa,bbb,ccc\n\n       \u003ca href=\"http://www.ietf.org/rfc/rfc4180.txt\"\u003ehttp://www.ietf.org/rfc/rfc4180.txt\u003c/a\u003e\n\nHowever, the Go csv.Reader type implements a TrailingComma flag which seems to violate\nthe principle of least surprise. Unsurprising default\nbehavior--TrailingComma=false--would allow valid RFC 4180 csv data. However, valid RFC\n4180 csv data is rejected. For example,\n\npackage main\n\nimport (\n\t\"encoding/csv\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nvar text = `aaa,bbb,ccc\nddd,eee,\nggg,hhh,iii\n`\n\nfunc main() {\n\tcsvReader := csv.NewReader(strings.NewReader(text))\n\t// csvReader.TrailingComma = true\n\tfor {\n\t\trecord, err := csvReader.Read()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tlog.Print(record)\n\t}\n}\n\nOutput:\n2012/06/15 10:29:31 [aaa bbb ccc]\n2012/06/15 10:29:31 line 2, column 7: extra delimiter at end of line\nexit status 1\u003c/pre\u003e",
	"user": {
		"login": "peterGo",
		"id": 4561296,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2012-06-15T14:38:56Z",
	"updated_at": "2014-12-08T10:19:41Z"
}
