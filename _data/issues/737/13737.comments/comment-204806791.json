{
	"id": 204806791,
	"body": "So, I'm digging in here and trying to figure out how far to take this. I've come up with 4 options I could implement but none of them are super satisfying.\r\n\r\nWe have the concept of `encoding` in the code base. The obvious but non-working change would be to reuse the current `escape` func for `PathSegmentEscape` with the `encodePath` `encoding`. Doing so, however, would cause all of the `/` in the user's path segment to remain as `/` instead of being turned into `%2F`. This is because the `shouldEscape` func called in `escape` knows about encodePath and expects a full path to be given to it. We also can't just pass the `encodeQueryComponent` mode to `escape` because that's been special cased to return `+` when it sees a space.\r\n\r\nThe first option is to create a special mode called `encodePathSegment` to be used by `escape` and `shouldEscape` and only use it from `PathSegmentEscape`. That new code would never be seen by the other path escaping routines, however. This means we might introduce some inaccuracies about how we treat full paths in `EscapedPath` and `validEncodedPath` versus path segments with PathSegmentPath.  \r\n\r\nA second option is to teach the places calling `escape(..., encodePath)` and `shouldEscape(..., encodePath)` directly that they need to skip over `/` themselves and make `encodePath` really be about path segments and not the full path.  We'd also, of course, have to teach `shouldEscape(..., encodePath)` that `/` should be encoded and the places calling `shouldEscape` would, too. The places that need to be taught are `validEncodedPath`, and `URL.EscapedPath`.\r\n\r\nA third option is for `escape` itself to do the `/` skipping in `encodePath` mode while `shouldEscape` learns to always escape `/` when it sees it with `encodePath`. This would involve `escape` checking for '/' in both of its for-loops before calling `shouldEscape(..., encodePath)` and the other places that call `shouldEscape(..., encodePath)` (just `validEncodedPath`, currently) would have to do the same. It would probably be wise, in this case, to turn the `encodePath` references in `shouldEscape` to `encodePathSegment` and have `escape` only ever call `shouldEscape` with `encodePathSegment` instead of `encodePath`.\r\n\r\nThe last option I came up with is for `PathSegmentEscape` to call `shouldEscape` directly and not use `escape` at all. This would let us special case `/` but at the cost of duplicating the `escape` function's logic for quick returns and hex string length.\r\n\r\nI'm pretty torn on these 4 options. Does anyone have a preference or alternative idea?\r\n\r\n",
	"user": {
		"login": "jmhodges",
		"id": 598,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-04-02T21:26:45Z",
	"updated_at": "2016-04-02T21:26:45Z"
}
