{
	"id": 241755449,
	"body": "The runtime could set up a channel and send a message whenever it completes\na GC. The application could have a heap monitor goroutine (HMG) watching\nthat channel. Whenever the HMG gets a message it inspects the state of the\nheap. To determine the size of the heap the HMG would look at the live heap\nsize and GOGC. If need be it could adjust GOGC so that the total heap does\nnot exceed whatever limit the application finds appropriate. If things are\ngoing badly for the application the HMG can start applying back pressure to\nwhatever part of the application is causing the increase in heap size. The\nHMG would be part of the application so a wide variety of application\nspecific strategies could be implemented.\n\nTrying to pick up the pieces after a failure does not seem doable. Likewise\ndeciding what is \"close to a failure\" is very application specific and a\nglobal metric that potentially involves external OS issues such as\nco-tenancy as well as other issue well beyond the scope of the Go runtime.\nDecisions and actions need to be made well ahead if one expects them to\nreliable prevent an OOM.\n\nI believe this is where we were headed in #14162\n\u003chttps://github.com/golang/go/issues/14162\u003e and this is a recap of some of\nthat discussion.\n\nI would be interested in what useful policy could not be implemented using\nthe HMG mechanism and current runtime mechanisms.\n\n\n\n\n\nOn Tue, Aug 23, 2016 at 1:43 AM, Yves Junqueira \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e For Google's internal needs, it would be nice to have the ability to set a\n\u003e limit to the memory usage.\n\u003e\n\u003e After a limit is set, perhaps the runtime could provide a clear indication\n\u003e that we're under memory pressure and that the application should avoid\n\u003e creating new allocations. Example new runtime APIs that would help:\n\u003e\n\u003e    - func InMemoryPushback() bool; or\n\u003e    - func RegisterPushbackFunc(func(inPushback bool))\n\u003e\n\u003e That would provide a clear signal to the application. *How* exactly\n\u003e that's decided should be an internal implementation decision and not part\n\u003e of the API. An example implementation, to illustrate: if we limit ourselves\n\u003e to the heap size specified by the user, we could trigger GC whenever the\n\u003e used heap is close to the limit. Then we could enter pushback whenever the\n\u003e GC performance (latency or CPU overhead) is outside certain bounds. Apply\n\u003e smoothing as needed.\n\u003e\n\u003e The approach suggested by this API has limitations.\n\u003e\n\u003e For example, it's still possible for an application that is behaving well\n\u003e to do one monstrous allocation after it has checked for the pushback state.\n\u003e This would be common for HTTP and RPC servers that do admittance control at\n\u003e the beginning of the request processing. If the monstrous allocation would\n\u003e bring the memory heap above the limit, Go should probably panic. Since we\n\u003e don't want to change the language to add memory allocation error checks, I\n\u003e think this is fine. And we have no other option :).\n\u003e\n\u003e Another problem is that deciding what is the right time to pushback can be\n\u003e hard. Whatever the runtime implements, some folks may find it too\n\u003e aggressive (pushing back too much, leading to poor resource utilization) or\n\u003e too conservative (pushing back too late, leading to high latency due to\n\u003e excessive GC). I guess the go team could provide a knob similar to GOGC to\n\u003e control the *pushbackiness* of the runtime, if folks are really paranoid\n\u003e about it.\n\u003e\n\u003e â€”\n\u003e You are receiving this because you are subscribed to this thread.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/16843#issuecomment-241632474\u003e, or mute\n\u003e the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AA7Wn-x0kWzbQY0w2nI8daJSWBbIHPWHks5qiohsgaJpZM4Jqa25\u003e\n\u003e .\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-23T14:46:17Z",
	"updated_at": "2016-08-23T14:46:17Z"
}
