{
	"id": 66055671,
	"body": "\u003ca id=\"c13\"\u003e\u003c/a\u003eComment 13:\n\n\u003cpre\u003eThere are two cases:\n\n1) For shift expressions that are _not_ constant expressions (at least one operand is\nnot a constant), the spec rules are mostly clear:\n\n\u003ca href=\"http://golang.org/doc/go_spec.html#Operators\"\u003ehttp://golang.org/doc/go_spec.html#Operators\u003c/a\u003e\n\n\"The right operand in a shift operation must have unsigned integer type or be an untyped\nconstant that can be converted to unsigned integer type.\"\n\"If the left operand of a non-constant shift operation is an untyped constant, the type\nof constant is what it would be if the shift operation were replaced by the left operand\nalone.\"\n\nFurther down it says:\n\n\u003ca href=\"http://golang.org/doc/go_spec.html#Arithmetic_operators\"\u003ehttp://golang.org/doc/go_spec.html#Arithmetic_operators\u003c/a\u003e\n\n\"They implement arithmetic shifts if the left operand is a signed integer and logical\nshifts if it is an unsigned integer.\"\n\nThis implies that the left operand must be of integer type; however, this could be more\nclear in the spec.\n\nSo, these are shifts of the form:\n\nc \u0026lt;\u0026lt; s\n\nwhere s must be of unsigned integer type and c is an untyped constant. The type of (c\n\u0026lt;\u0026lt; s) is clearly defined: it's the type c would get in the current context.\nSpecifically:\n\npackage main\n\nfunc f(x int) {}\nfunc g(x interface{}) {}\nfunc h(x float64) {}\n\nfunc main() {\n\tvar s uint\n\tvar a1 int     = 2.0 \u0026lt;\u0026lt; s // typeof(2.0) is int in this context =\u0026gt; legal shift\n\tvar b1         = 2.0 \u0026lt;\u0026lt; s // typeof(2.0) is float in this context =\u0026gt; illegal shift\n\tvar c1 float64 = 2   \u0026lt;\u0026lt; s\n\tf(2.0 \u0026lt;\u0026lt; s)  // typeof(2.0) is int in this context =\u0026gt; legal shift\n\tg(2.0 \u0026lt;\u0026lt; s)  // typeof(2.0) is float in this context =\u0026gt; illegal shift\n\th(2   \u0026lt;\u0026lt; s)\n\n\t_ = a1\n\t_ = b1\n\t_ = c1\n}\n\n\n2) For shift expressions that _are_ constant expressions, the spec rules are somewhat\nunclear:\n\n\u003ca href=\"http://golang.org/doc/go_spec.html#Constant_expressions\"\u003ehttp://golang.org/doc/go_spec.html#Constant_expressions\u003c/a\u003e\n\n\"Except for shift operations, if the operands of a binary operation are an untyped\ninteger constant and an untyped floating-point constant, the integer constant is\nconverted to an untyped floating-point constant (relevant for / and %)\"\n\nThere is no further reference to the exception, and arguably constant shift expressions\nare underspecified. With respect to the right operand, the rule is specified in the\noperators section above. With respect to the left operand, I believe the same rule can\nand should apply as if the left operand were not constant (basically, the right operand\nof a shift expression never has an impact on the type of the shift expression).\n\nSpecifically:\n\npackage main\n\nfunc f(x int) {}\nfunc g(x interface{}) {}\nfunc h(x float64) {}\n\nfunc main() {\n\tconst c uint = 5\n\tvar a2 int     = 2.0 \u0026lt;\u0026lt; c // typeof(2.0) is int in this context =\u0026gt; legal shift\n\tvar b2         = 2.0 \u0026lt;\u0026lt; c // typeof(2.0) is float in this context =\u0026gt; illegal shift\n\tvar c2 float64 = 2   \u0026lt;\u0026lt; c\n\tf(2.0 \u0026lt;\u0026lt; c)  // typeof(2.0) is int in this context =\u0026gt; legal shift\n\tg(2.0 \u0026lt;\u0026lt; c)  // typeof(2.0) is float in this context =\u0026gt; illegal shift\n\th(2   \u0026lt;\u0026lt; c)\n\n\t_ = a2\n\t_ = b2\n\t_ = c2\n}\n\n\nThus, for the examples in this issue report:\n\nThis should be valid, because the type of 2.0 \u0026lt;\u0026lt; ui is the type of 2.0 which is\nrepresentable as int 2.\n    const ui uint = 5\n    var a int = 2.0 \u0026lt;\u0026lt; ui\n\nThese are correctly valid/invalid:\n   var a = 2 \u0026lt;\u0026lt; 5.0; // valid\n   var b = 5.0 \u0026lt;\u0026lt; 2; // invalid\n\nThis is illegal, because the type of 2 alone in this context is converted to a float64,\nwhich is not an integer type and thus cannot be shifted.\n  const ui uint = 5\n  var a float64 = 2 \u0026lt;\u0026lt; ui\n\n\nSummary:\n- The spec needs to be clearer about constant shift expressions, and it could be clearer\nfor non-constant shifts.\n- 6g has a few bugs with respect to the spec.\n- gccgo appears to implement this correctly, and the above test programs get the correct\nerror messages. (Note that gccgo has a somewhat unrelated bug: if the variables a1, a2,\nb1, b2, etc. are replaced by the blank identifier, it gives misleading error messages;\npresumably in gccgo, _ is \"untyped\").\u003c/pre\u003e",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2011-05-14T00:04:02Z",
	"updated_at": "2014-12-22T05:55:10Z"
}
