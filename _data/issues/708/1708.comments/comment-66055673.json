{
	"id": 66055673,
	"body": "\u003ca id=\"c15\"\u003e\u003c/a\u003eComment 15:\n\n\u003cpre\u003eThere are two cases:\n\n1) For shift expressions that are _not_ constant expressions (at least one operand is\nnot a constant), the spec rules are clear:\n\n\u003ca href=\"http://golang.org/doc/go_spec.html#Operators\"\u003ehttp://golang.org/doc/go_spec.html#Operators\u003c/a\u003e\n\n\"The right operand in a shift operation must have unsigned integer type or be an untyped\nconstant that can be converted to unsigned integer type.\"\n\"If the left operand of a non-constant shift operation is an untyped constant, the type\nof constant is what it would be if the shift operation were replaced by the left operand\nalone.\"\n\nFurther down it says:\n\n\u003ca href=\"http://golang.org/doc/go_spec.html#Arithmetic_operators\"\u003ehttp://golang.org/doc/go_spec.html#Arithmetic_operators\u003c/a\u003e\n\n\"All other arithmetic operators apply to integers only.\" (this includes shift operators)\n\nThese are shifts of the form:\n\nc \u0026lt;\u0026lt; s\n\nwhere s must be of unsigned integer type and c is an untyped constant. The type of (c\n\u0026lt;\u0026lt; s) is clearly defined: it's the type c would get in the current context.\n\n\n2) For shift expressions that _are_ constant expressions, the spec rules are somewhat\nunclear:\n\n\u003ca href=\"http://golang.org/doc/go_spec.html#Constant_expressions\"\u003ehttp://golang.org/doc/go_spec.html#Constant_expressions\u003c/a\u003e\n\n\"Except for shift operations, if the operands of a binary operation are an untyped\ninteger constant and an untyped floating-point constant, the integer constant is\nconverted to an untyped floating-point constant (relevant for / and %)\"\n\nThere is no further reference to the exception, and arguably constant shift expressions\nare underspecified. With respect to the right operand, the rule is specified in the\noperators section above.\n\nIt is unclear what the result type should be given an untyped left operand. It is also\nunclear what the result type should be given a typed left operand due to the special\nrules for non-constant shifts.\n\nCL 4517074 proposes the following clarification for constant shift expressions:\n\n1) If the left operand is untyped (and can be converted into an integer), the result is\nan untyped integer.\n2) If the left operand is typed (it must be an integer type), the result is of the same\ntype.\n\nSpecifically:\n\npackage main\n\nfunc f(x int) {}\nfunc g(x interface{}) {}\nfunc h(x float64) {}\n\nfunc main() {\n\t// non-constant shift expressions\n\tvar s uint\n\tvar a1 int     = 2.0 \u0026lt;\u0026lt; s  // typeof(2.0) is int in this context =\u0026gt; legal shift\n\tvar b1         = 2.0 \u0026lt;\u0026lt; s  // typeof(2.0) is float64 in this context =\u0026gt; illegal shift\n\tvar c1 float64 = 2   \u0026lt;\u0026lt; s  // typeof(2  ) is float64 in this context =\u0026gt; illegal shift\n\tf(2.0 \u0026lt;\u0026lt; s)  // typeof(2.0) is int in this context =\u0026gt; legal shift\n\tg(2.0 \u0026lt;\u0026lt; s)  // typeof(2.0) is float64 in this context =\u0026gt; illegal shift\n\th(2   \u0026lt;\u0026lt; s)  // typeof(2  ) is float64 in this context =\u0026gt; illegal shift\n\tprintln(a1, b1, c1)\n\n\t// constant shift expressions\n\tconst c uint = 5\n\tvar a2 int     = 2.0 \u0026lt;\u0026lt; c  // a2 == 64 (type int)\n\tvar b2         = 2.0 \u0026lt;\u0026lt; c  // b2 == 64 (untyped integer)\n\tvar c2 float64 = 2   \u0026lt;\u0026lt; c  // c2 == 64.0 (type float64)\n\tf(2.0 \u0026lt;\u0026lt; c)  // == f(64)\n\tg(2.0 \u0026lt;\u0026lt; c)  // == g(int(64))\n\th(2   \u0026lt;\u0026lt; c)  // == h(float64(64.0))\n\tprintln(a2, b2, c2)\n}\n\nThus, for the examples in this issue report:\n\nThis is valid because 2.0 is representable as int, ui is an unsigned integer, and the\nexpression is constant.\n    const ui uint = 5\n    var a int = 2.0 \u0026lt;\u0026lt; ui\n\nThese are both valid because all constants involved are representable as unsigned\nintegers, and the expression is constant.\n   var a = 2 \u0026lt;\u0026lt; 5.0; // valid\n   var b = 5.0 \u0026lt;\u0026lt; 2; // valid\n\nThis is valid because 2 is a integer, ui is an unsigned integer, and the expression is\nconstant.\n  const ui uint = 5\n  var a float64 = 2 \u0026lt;\u0026lt; ui\n\n\nCompilers:\n\nIf we accept CL 4517074, both 6g and gccgo have bugs with respect to constant shift\nexpressions which is not surprising given that the spec was not clear.\u003c/pre\u003e",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2011-05-17T20:05:10Z",
	"updated_at": "2014-12-22T05:55:13Z"
}
