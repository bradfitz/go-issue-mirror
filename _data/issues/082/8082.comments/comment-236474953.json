{
	"id": 236474953,
	"body": "I'd be very curious to find out if this proposal may resolve an issue I've hit quite a few times in the past, when wanting to return a concrete type from a method, but being forced to return an interface instead simply to satisfy the type equality requirements of another interface.\r\n\r\nA breif example is given below, which is taken more or less verbatim from an ongoing effort to implement a pure library for interacting with LLVM IR in Go [[1](https://godoc.org/github.com/llir/llvm/ir)].\r\n\r\n(Full GoDoc for the LLVM IR [types](http://godoc.org/github.com/llir/llvm/ir/types) package.)\r\n\r\n```go\r\npackage types\r\n\r\ntype Type interface {\r\n   Equal(u Type) bool\r\n}\r\n\r\n// An Int represents an integer type.\r\ntype Int struct {\r\n   // Integer size in number of bits.\r\n   size int\r\n}\r\n\r\n// Size returns the integer size in numer of bits.\r\nfunc (t *Int) Size() int {\r\n   return t.size\r\n}\r\n\r\n// Equal reports whether t and u are of equal type.\r\nfunc (t *Int) Equal(u Type) bool {\r\n   if u, ok := u.(*Int); ok {\r\n      return t.size == u.size\r\n   }\r\n   return false\r\n}\r\n```\r\n\r\n(Full GoDoc for the LLVM IR [value](http://godoc.org/github.com/llir/llvm/ir/value) package.)\r\n\r\n```go\r\npackage value\r\n\r\nimport \"foo/types\"\r\n\r\n//  A Value represents a computed value that may be used as an operand of other values.\r\ntype Value interface {\r\n   // Type returns the type of the value.\r\n   Type() types.Type\r\n}\r\n```\r\n\r\n(Full GoDoc for the LLVM IR [constant](http://godoc.org/github.com/llir/llvm/ir/constant) package.)\r\n\r\n```go\r\npackage constant\r\n\r\nimport (\r\n   \"math/big\"\r\n\r\n   \"foo/types\"\r\n)\r\n\r\n// An Int represents an integer constant.\r\ntype Int struct {\r\n   val *big.Int\r\n   typ *types.Int\r\n}\r\n\r\n// NOTE: The return type is types.Type, as required to satisfy the value.Value\r\n// interface, but returning *types.Int would be preferable.\r\nfunc (c *Int) Type() Type {\r\n   return c.typ\r\n}\r\n```\r\n\r\nIn the example given above, what I would really like to return from the `Type` method on `*constant.Int` is `*types.Int` rather than `types.Type`, as this would allow direct access to the `Size` method. In other words, I would like to return the concrete type rather than the interface type it satisfies, while still satisfying the `value.Value` interface, which requires a `Type() types.Type` method.\r\n\r\nHas anyone else had to work around similar issues?\r\n\r\nEdit: I realize that this example has been covered in the [FAQ: Why doesn't type T satisfy the Equal interface?](https://golang.org/doc/faq#t_and_equal_interface). My question is then, if this proposal were to be implemented, would that also allow for the above use-case (and consequently mandate an update of the FAQ entry)?",
	"user": {
		"login": "mewmew",
		"id": 1414531,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-01T02:16:53Z",
	"updated_at": "2016-08-01T02:30:27Z"
}
