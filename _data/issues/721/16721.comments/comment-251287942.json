{
	"id": 251287942,
	"body": "@rsc lets take an example that comes up fairly often (for me), lets say you want to sort a set of numbers but you also want to track the original positions of the numbers. \r\n\r\nSo you had a slice like `[]int{5, 2, 3, 1, 4}` and you sorted it to get `[]int{1, 2, 3, 4, 5}` but at the same time, you also wanted to track positions, so in a separate slice you would want `[]int{3, 1, 2, 4, 0}`.\r\n\r\nWith this addition, you would separately declare a `pair` type and a new pair array and copy original array's contents into the new array and initialize positions and then sort them, while defining the appropriate less closure.Something like \r\n\r\n```go\r\na := []int{...}\r\n\r\ntype pair struct {\r\n\tfirst, second int\r\n}\r\n\r\np := make([]pair, len(a))\r\nfor i := 0 ; i \u003c len(a) ; i++ {\r\n\tp[i] = pair{a[i], i}\r\n}\r\n\r\nsort.Slice(p, func (i, j int) bool {\r\n\treturn p[i].first \u003c p[j].first || (p[i].first == p[j].first \u0026\u0026 p[i].second \u003c p[j].second)\r\n})\r\n```\r\n\r\nwhile if we had the option to define a swapper, we can just define another slice, initialize that to positions (0, 1, 2...) and in the swap, swap in both slices.\r\n\r\nsomething like\r\n\r\n```go\r\na := []int{...}\r\n\r\npos := make([]int, len(a))\r\nfor i := 0 ; i \u003c len(a) ; i++ {\r\n\tpos[i] = i\r\n}\r\n\r\nsort.Slice(len(a), func(i, j int) {\r\n\ta[i], a[j] = a[j], a[i]\r\n\tpos[i], pos[j] = pos[j], pos[i]\r\n}, func(i, j int) bool {\r\n\treturn a[i] \u003c a[j] || (a[i] == a[j] \u0026\u0026 pos[i] \u003c pos[j])\r\n})\r\n```\r\n\r\n1. The first reason I am advocating the use of `sort.Search` like semantics   is because `sort.Search` itself is defined only for slices, but the best part about   it is that it can do 6 different operations simply by passing the appropriate closure (https://go-review.googlesource.com/#/c/29131/6/src/sort/example_search_test.go@58). One issue that comes up with doing things differently with sort.Slice is the difference from sort.Search in terms of semantics.\r\n\r\n2. More convenience (for me) means more flexibility, then less code.\r\n\r\n3. Again, the reason `reflect.Swapper` came up in the first place was to support the general case, so you could do\r\n\r\n  ```\r\n  sort.Slice(len(a), reflect.Swapper(a), func(i, j int) { ... })\r\n  ```\r\n\r\n  otherwise I don't think there was any need to have it as a public library function.\r\n\r\n4. another thing that came up in this discussion was the facilities provided by modern text editors\r\n  w.r.t boilerplate code. editors these days have macros and snippets, so you can configure them to\r\n  expand things, like you can define a `swapper` snippet that on a tabstop expands to `func(i, j int) { a[i], a[j] = a[j], a[i] }`\r\n\r\n5. @bradfitz raised a point about purity of the function irrespective of type errors (https://github.com/golang/go/issues/16721#issuecomment-241088463)\r\n\r\n6. Again, and I don't know how much impact it will have, but getting the slice length directly will probably be faster than getting it through reflection\r\n\r\n7. You might think that something like `sort.MakeInterface` solves this, but @bradfitz himself did `genzfunc.go` for performance, the results of which are in the commit message at https://go-review.googlesource.com/#/c/27321/11. Also in case you didn't see this: https://github.com/nieksand/sortgenerics https://news.ycombinator.com/item?id=12602456",
	"user": {
		"login": "suyash",
		"id": 16324837,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-10-04T03:37:26Z",
	"updated_at": "2016-10-04T04:59:10Z"
}
