{
	"id": 102499143,
	"body": "We figured out the remaining problem once worldsema is released after starttheworld. I'm preparing a CL sequence (a cleanup of Rick's prototype fix in CL 10110).\r\n\r\nOur dance involves three parties.\r\n\r\nG1 is running on M1 on P1. P1 has an empty run queue.\r\n\r\nG2/M2 is in a blocked syscall and has lost its P. (The details of this don't matter, it just needs to be in a position where it needs to grab an idle P.)\r\n\r\nGC just started on G3/M3/P3. (These aren't very involved, they just have to be separate from the other G's, M's, and P's.)\r\n\r\n1. GC calls stoptheworld(), which sets sched.gcwaiting to 1.\r\n\r\nG1/M1 begins to enter a syscall:\r\n2. G1/M1 invokes reentersyscall, which sets the P1's status to _Psyscall.\r\n3. G1/M1's reentersyscall observes gcwaiting != 0 and calls entersyscall_gcwait.\r\n4. G1/M1's entersyscall_gcwait blocks acquiring sched.lock.\r\n\r\nBack on GC:\r\n5. stoptheworld cas's P1's status to _Pgcstop, does other stuff, and returns.\r\n6. GC does stuff and then calls starttheworld().\r\n7. starttheworld() calls procresize(), which sets P1's status to _Pidle and puts P1 on the idle list.\r\n\r\nG2/M2 returns from its syscall and takes over P1:\r\n8. G2/M2 returns from its blocked syscall and pulls P1 off the idle list.\r\n9. G2/M2 acquires P1, which sets P1's status to _Prunning.\r\n10. G2/M2 starts a new syscall and invokes reentersyscall, which sets P1's status to _Psyscall.\r\n\r\nBack on G1/M1:\r\n11. G1/M1 finally acquires sched.lock in entersyscall_gcwait.\r\n\r\nAt this point, G1/M1 still thinks it's running on P1. P1's status is _Psyscall, which is consistent with what G1/M1 is doing, but it's _Psyscall because G2/M2 put it in to _Psyscall, not G1/M1. This is basically an ABA race on P1's status.\r\n\r\nThe problem arises because forEachP currently shares stopwait with stoptheworld. G1/M1's entersyscall_gcwait observes the non-zero stopwait set by forEachP, but mistakes it for a stoptheworld. It cas's P1's status from _Psyscall (set by G2/M2) to _Pgcstop and proceeds to decrement stopwait one more time than forEachP was expecting.\r\n\r\nThe plan (prototyped in Rick's CL 10110) is to give forEachP its own stopwait and stopnote that aren't shared with stoptheworld.\r\n\r\nOf course, all of this raises the question of how this worked *before* forEachP existed, since the ABA race on the P status can happen without forEachP. This took me a while to figure out. Here's a sketch:\r\n12. G1/M1's entersyscall_gcwait sees that stopwait is 0 and returns. The syscall happens and returns. G1/M1 invokes exitsyscall, which invokes exitsyscallfast.\r\n13. G1/M1's exitsyscallfast successfully cas's P1's status from _Psyscall to _Prunning (even though this _Psyscall status was set by G2/M2, *not* G1/M1).\r\n14. G1's returns to executing user code, running on P1.\r\n\r\nAnd, finally, back on G2/M2:\r\n15. G2/M2 executes its system call and then calls exitsyscall, which invokes exitsyscallfast.\r\n16. exitsyscallfast tries to cas P1's status from _Psyscall to _Prunning, but *this fails* because P1 is in _Prunning (because G1/M1 is using it).\r\n\r\nIn fact, if the timing is just right, a P could bounce back and forth between two M's this way without ever passing through the idle list again. But this would be okay because only one of them would be executing user code at any given moment.",
	"user": {
		"login": "aclements",
		"id": 2688315,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-05-15T19:20:16Z",
	"updated_at": "2015-05-15T19:20:46Z"
}
