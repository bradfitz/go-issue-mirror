{
	"id": 160835242,
	"number": 16092,
	"state": "open",
	"title": "cmd/compile: complicated bounds check elimination",
	"body": "**1. go version go1.7beta1 windows/amd64**\r\n\r\n**2. \r\nset GOARCH=amd64**\r\nset GOBIN=\r\nset GOEXE=.exe\r\nset GOHOSTARCH=amd64\r\n**set GOHOSTOS=windows**\r\nset GOOS=windows\r\nset GOPATH=F:\\Go\\\r\nset GORACE=\r\nset GOROOT=F:\\Go\r\nset GOTOOLDIR=F:\\Go\\pkg\\tool\\windows_amd64\r\nset CC=gcc\r\nset GOGCCFLAGS=-m64 -mthreads -fmessage-length=0 -fdebug-prefix-map=C:\\Users\\Super\\AppData\\Local\\Temp\\go-build211527254=/tmp/go-build -gno-record-gcc-switches\r\nset CXX=g++\r\nset CGO_ENABLED=1\r\n\r\n**3. Runnable program:**\r\n\r\n```go\r\n// PrimeSpeed project PrimeSpeed.go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n\t\"time\"\r\n\t//    \"unsafe\"\r\n)\r\n\r\nfunc mkCLUT() [65536]byte {\r\n\tvar arr [65536]byte\r\n\tfor i := 0; i \u003c 65536; i++ {\r\n\t\tvar cnt byte = 0\r\n\t\tfor v := (uint16)(i ^ 0xFFFF); v \u003e 0; v \u0026= v - 1 {\r\n\t\t\tcnt++\r\n\t\t}\r\n\t\tarr[i] = cnt\r\n\t}\r\n\treturn arr\r\n}\r\n\r\nvar cnstCLUT [65536]byte = mkCLUT()\r\n\r\nfunc primesTest(top uint) int {\r\n\tlmtndx := (top - 3) \u003e\u003e 1\r\n\tlstw := lmtndx \u003e\u003e 5\r\n\tlmt := lstw + 1\r\n\ttopsqrtndx := (int(math.Sqrt(float64(top))) - 3) \u003e\u003e 1\r\n\tcmpsts := make([]uint32, lstw+1)\r\n\t//    start := uintptr(unsafe.Pointer(\u0026cmpsts[0]))\r\n\t//    step := unsafe.Sizeof(cmpsts[0])\r\n\tfor i := 0; i \u003c= topsqrtndx; i++ {\r\n\t\tif cmpsts[i\u003e\u003e5]\u0026(uint32(1)\u003c\u003cuint(i)) == 0 {\r\n\t\t\tp := (uint(i) \u003c\u003c 1) + 3\r\n\t\t\tfor j := (p*p - 3) \u003e\u003e 1; j \u003c= topi; j += p {\r\n\t\t\t\tcmpsts[j\u003e\u003e5] |= 1 \u003c\u003c (j \u0026 31)\r\n\t\t\t}\r\n\t\t\t//            p := uintptr((uint(i) \u003c\u003c 1) + 3)\r\n\t\t\t//            lmt := uintptr(lmtndx)\r\n\t\t\t//            for j := (p*p - 3) \u003e\u003e 1; j \u003c= lmt; j += p {\r\n\t\t\t//                *(*uint)(unsafe.Pointer(start + step*(j\u003e\u003e5))) |= 1 \u003c\u003c (j \u0026 31)\r\n\t\t\t//            }\r\n\t\t}\r\n\t}\r\n\tmsk := uint32(0xFFFFFFFE) \u003c\u003c (lmtndx \u0026 31)\r\n\tcmpsts[lstw] |= msk\r\n\tcnt := 1\r\n\tfor i := uint(0); i \u003c= lstw; i++ {\r\n\t\tv := cmpsts[i]\r\n\t\tcnt += int(cnstCLUT[v\u00260xFFFF] + cnstCLUT[0xFFFF\u0026(v\u003e\u003e16)])\r\n\t}\r\n\treturn cnt\r\n}\r\n\r\nfunc main() {\r\n\tn := uint(262146)\r\n\r\n\tstrt := time.Now()\r\n\r\n\tsum := 0\r\n\tfor i := 0; i \u003c 1000; i++ {\r\n\t\tsum += primesTest(n)\r\n\t}\r\n\r\n\tend := time.Now()\r\n\r\n\tfmt.Println(\"Found\", sum, \"primes up to\", n, \"in\", end.Sub(strt), \".\")\r\n}\r\n```\r\n\r\nplay.golang.org link:  https://play.golang.org/p/_E5R5JAlGW\r\n\r\n**4. When \"go tool compile -S PrimeSpeed.go \u003e PrimeSpeed.s\" is run**, the inner tight composite number culling loop as quoted below:\r\n\r\n```\r\n\tline 36\t\tfor j := (p*p - 3) \u003e\u003e 1; j \u003c= topi; j += p {\r\n\tline 37\t\t\tcmpsts[j\u003e\u003e5] |= 1 \u003c\u003c (j \u0026 31)\r\n\tline 38\t\t}\r\n```\r\n\r\nlooks like the following assembly code from PrimeSpeed.s:\r\n\r\n```\r\n\t0x00f1 00241 (Main.go:37)\tMOVQ\tR8, CX\r\n\t0x00f4 00244 (Main.go:37)\tSHRQ\t$5, R8\r\n\t0x00f8 00248 (Main.go:37)\tCMPQ\tR8, DX\r\n\t0x00fb 00251 (Main.go:37)\tJCC\t$0, 454\r\n\t0x0101 00257 (Main.go:37)\tMOVL\t(AX)(R8*4), R10\r\n\t0x0105 00261 (Main.go:37)\tMOVQ\tCX, R11\r\n\t0x0108 00264 (Main.go:37)\tANDQ\t$31, CX\r\n\t0x010c 00268 (Main.go:37)\tMOVL\tR9, R12 **;; saves 1 to r12**\r\n\t0x010f 00271 (Main.go:37)\tSHLL\tCX, R9\r\n\t0x0112 00274 (Main.go:37)\tORL\tR10, R9\r\n\t0x0115 00277 (Main.go:37)\tMOVL\tR9, (AX)(R8*4)\r\n\t0x0119 00281 (Main.go:36)\tLEAQ\t3(R11)(DI*2), R8\r\n\t0x011e 00286 (Main.go:37)\tMOVL\tR12, R9 **;; restores 1 to r9 from r12**\r\n\t0x0121 00289 (Main.go:36)\tCMPQ\tR8, BX\r\n\t0x0124 00292 (Main.go:36)\tJLS\t$0, 241\r\n```\r\n\r\n**5. I expected to see**:\r\n\r\n```\r\n\t0x00f1 00241 (Main.go:37)\tMOVQ\tR8, CX\r\n\t0x00f4 00244 (Main.go:37)\tSHRQ\t$5, R8\r\n\t0x00f8 00248 (Main.go:37)\tCMPQ\tR8, DX ;; array bounds check, only if no -B option\r\n\t0x00fb 00251 (Main.go:37)\tJCC\t$0, 454 ;; panic if out of bounds\r\n\t0x0101 00257 (Main.go:37)\tMOVL\t(AX)(R8*4), R10\r\n\t0x0105 00261 (Main.go:37)\tMOVQ\tCX, R11\r\n\t0x0108 00264 (Main.go:37)\tANDQ\t$31, CX\r\n\t                        (Main.go:37)\tMOVL\t$1,R9 **;; IMMEDIATE LOAD OF 1 to R9**\r\n\t                        (Main.go:37)\tSHLL\tCX, R9\r\n\t                        (Main.go:37)\tORL\tR10, R9\r\n\t                        (Main.go:37)\tMOVL\tR9, (AX)(R8*4)\r\n\t                        (Main.go:36)\tLEAQ\t3(R11)(DI*2), R8\r\n\t                        (Main.go:36)\tCMPQ\tR8, BX\r\n\t                        (Main.go:36)\tJLS\t$0, 241\r\n```\r\n\r\nEven better, without recalculating p = 2 * i + 3 thus j += j + 2 * i + 3 inside the inner loop:\r\nIncludes changing order of instructions for processors without OOE:\r\n\r\n```\r\n\t0x00f1 00241 (Main.go:37)\tMOVQ\tR8, R11\r\n\t0x0105 00261 (Main.go:37)\tMOVQ\tR8, CX\r\n\t0x00f4 00244 (Main.go:37)\tSHRQ\t$5, R11\r\n\t0x0108 00264 (Main.go:37)\tANDQ\t$31, CX\r\n\t0x00f8 00248 (Main.go:37)\tCMPQ\tR11, DX ;; array bounds check, only if no -B option\r\n\t0x00fb 00251 (Main.go:37)\tJCC\t$0, 454 ;; panic if out of bounds\r\n\t0x0101 00257 (Main.go:37)\tMOVL\t(AX)(R11*4), R10\r\n\t0x010c 00268 (Main.go:37)\tMOVL\t$1,R9 **;; IMMEDIATE LOAD OF 1 to R9**\r\n\t0x010f 00271 (Main.go:37)\tSHLL\tCX, R9\r\n\t0x0112 00274 (Main.go:37)\tORL\tR10, R9\r\n\t0x0119 00281 (Main.go:36)\tADDL\tR12, R8 **;; ADD PRE-CALCULATED 'p' in R12 to 'j'**\r\n\t0x0115 00277 (Main.go:37)\tMOVL\tR9, (AX)(R11*4)\r\n\t0x0121 00289 (Main.go:36)\tCMPQ\tR8, BX\r\n\t0x0124 00292 (Main.go:36)\tJLS\t$0, 241\r\n```\r\n\r\nThe following is the same loop without bounds checks generated for C/C++ with the Visual Studio compiler (intel assembler format):\r\n\r\n```\r\n\t$Loop:\r\n\t\tmov\tedx, esi\r\n\t\tmov\tecx, esi\r\n\t\tshr\tedx, 5\r\n\t\tand\tecx, 31\t\t\t\t\t; 0000001fH\r\n\t\tmov\teax, 1\r\n\t\tadd\tesi, edi\t\t\t\t\t; add 'p' in edi to 'j'\r\n\t\tshl\teax, cl\r\n\t\tor\tDWORD PTR [ebx+edx*4], eax\r\n\t\tcmp\tesi, ebp\t\t\t\t\t; ebp contains 'topi'\r\n\t\tjbe\tSHORT $Loop\r\n```\r\n\r\nNote that the above uses a total of seven registers for this inner loop, so the same code is generated for x86 and x64 compilations.  Unfortunately, it takes another register to hold the upper array bound for a range check and the x86 architecture can only have seven available; however, it is possible to slightly change the code as follows:\r\n\r\n```\r\n\tline 36            bnds := lstw + 1\r\n\tline 37            k := (p*p - 3) \u003e\u003e 1\r\n\tline 38            for j, w := j, j \u003e\u003e 5; w \u003c= bnds; w = r \u003e\u003e 5 {\r\n\tline 39                cmpsts[w] |= 1 \u003c\u003c (j \u0026 31)\r\n\tline 40                j += p\r\n\tline 41            }\r\n```\r\n\r\nwhich for Visual Studio C/C++ generates the following same number of instructions in the loop:\r\n\r\n```\r\n\t$Loop:\r\n\t\tmov\tecx, edx\r\n\t\tmov\teax, 1\r\n\t\tand\tecx, 31\t\t\t\t\t; 0000001fH\r\n\t\tadd\tedx, edi\t\t\t\t\t; add 'p' in edi to 'j'\r\n\t\tshl\teax, cl\r\n\t\tor\tDWORD PTR [ebx+esi*4], eax\r\n\t**$Start:**\r\n\t\tmov\tesi, edx\r\n\t\tshr\tesi, 5\r\n\t\tcmp\tesi, ebp\t\t\t\t\t**; ebp contains the array length, bnds**\r\n\t\tjb\tSHORT $Loop\t\t\t\t**; this is the same as doing an array bounds check**\r\n```\r\n\r\nand it can be seen that the array bounds check is now done at the same time as the loop completion check; it should be a simple matter to clue the compiler that 'bnds' contains the array length, perhaps by assigning it inside the loop as len(cmpsts) as is done for C# x86 code so that it recognizes that the bounds check is already done.  The start point of the loop could be the line after the \"or\" line at the **$Start**: label or an external check could be implemented to ensure that the bounds check is done for the first loop before the array is accessed as is done for the Visual Studio C/C++ compiler.\r\n\r\nAs demonstrated above, the golang code runs slower than C/C++ code by almost a factor of two on some x86 processors and more than that factor for x86 processors.  It also runs slightly slower than C#/Java for both architectures.",
	"user": {
		"login": "GordonBGood",
		"id": 10696269,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "NeedsFix"
		},
		{
			"name": "Performance"
		}
	],
	"assignee": {
		"login": "randall77",
		"id": 6889504,
		"type": "User",
		"site_admin": false
	},
	"comments": 5,
	"created_at": "2016-06-17T08:16:30Z",
	"updated_at": "2016-10-22T02:50:26Z",
	"milestone": {
		"id": 2053058,
		"number": 49,
		"title": "Go1.9"
	}
}
