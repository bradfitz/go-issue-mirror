{
	"id": 66087949,
	"body": "\u003ca id=\"c3\"\u003e\u003c/a\u003eComment 3:\n\n\u003cpre\u003esven,\n\nAttaching your test case here for posterity. I could not use your dll, it uses\nmsvcr110d.dll that I don't have on my amd64 pc. And I couldn't build it on my 386 pc,\nbecause _beginthread expects __cdecl, not __stdcall function (it, probably, didn't\nmatter for you, if you're on amd64).\n\nAnyway, I think my test is good enough for our purpose. Don't you agree?\n\nI investigated where my test hangs. It is in lockextra, like you said. And it is because\nno free m. cgo does not have that problem, because it sets runtime·needextram to 1 at\nthe start. I don't know why it is limited to cgo only. But if I move it into runtime,\nthen my test PASSes. I suspect your program should work too.\n\nHere is my diff:\n\ndiff --git a/src/pkg/runtime/cgo/iscgo.c b/src/pkg/runtime/cgo/iscgo.c\n--- a/src/pkg/runtime/cgo/iscgo.c\n+++ b/src/pkg/runtime/cgo/iscgo.c\n@@ -12,4 +12,3 @@\n #include \"../runtime.h\"\n \n bool runtime·iscgo = 1;\n-uint32 runtime·needextram = 1;  // create an extra M on first cgo call\ndiff --git a/src/pkg/runtime/crash_test.go b/src/pkg/runtime/crash_test.go\n--- a/src/pkg/runtime/crash_test.go\n+++ b/src/pkg/runtime/crash_test.go\n@@ -105,7 +105,7 @@\n \ttestDeadlock(t, lockedDeadlockSource)\n }\n \n-func TestLockedDeadlock2(t *testing.T) {\n+func testLockedDeadlock2(t *testing.T) {\n \ttestDeadlock(t, lockedDeadlockSource2)\n }\n \ndiff --git a/src/pkg/runtime/proc.c b/src/pkg/runtime/proc.c\n--- a/src/pkg/runtime/proc.c\n+++ b/src/pkg/runtime/proc.c\n@@ -64,7 +64,7 @@\n \n Sched\truntime·sched;\n int32\truntime·gomaxprocs;\n-uint32\truntime·needextram;\n+uint32\truntime·needextram = 1;\n bool\truntime·iscgo;\n M\truntime·m0;\n G\truntime·g0;\t // idle goroutine for m0\ndiff --git a/src/pkg/runtime/syscall_windows_test.go\nb/src/pkg/runtime/syscall_windows_test.go\n--- a/src/pkg/runtime/syscall_windows_test.go\n+++ b/src/pkg/runtime/syscall_windows_test.go\n@@ -240,5 +240,35 @@\n }\n \n func TestCallbackInAnotherThread(t *testing.T) {\n-\t// TODO: test a function which calls back in another thread: QueueUserAPC() or\nCreateThread()\n+\td := GetDLL(t, \"kernel32.dll\")\n+\n+\tf := func(p uintptr) uintptr {\n+\t\treturn p\n+\t}\n+\tr, _, err := d.Proc(\"CreateThread\").Call(0, 0, syscall.NewCallback(f), 123, 0, 0)\n+\tif r == 0 {\n+\t\tt.Fatalf(\"CreateThread failed: %v\", err)\n+\t}\n+\th := syscall.Handle(r)\n+\tdefer syscall.CloseHandle(h)\n+\n+\tswitch s, err := syscall.WaitForSingleObject(h, 100); s {\n+\tcase syscall.WAIT_OBJECT_0:\n+\t\tbreak\n+\tcase syscall.WAIT_TIMEOUT:\n+\t\tt.Fatal(\"timeout waiting for thread to exit\")\n+\tcase syscall.WAIT_FAILED:\n+\t\tt.Fatalf(\"WaitForSingleObject failed: %v\", err)\n+\tdefault:\n+\t\tt.Fatalf(\"WaitForSingleObject returns unexpected value %v\", s)\n+\t}\n+\n+\tvar ec uint32\n+\tr, _, err = d.Proc(\"GetExitCodeThread\").Call(uintptr(h), uintptr(unsafe.Pointer(\u0026ec)))\n+\tif r == 0 {\n+\t\tt.Fatalf(\"GetExitCodeThread failed: %v\", err)\n+\t}\n+\tif ec != 123 {\n+\t\tt.Fatalf(\"expected 123, but got %d\", ec)\n+\t}\n }\n\n\nI had to disable one test. I don't know why, so we have to resolve that.\n\nWe cannot make changes now, not until after Go 1.2 is released. Perhaps this change will\nget accepted. I hope you can use this in the meantime to fix your problem locally.\n\nAlex\u003c/pre\u003e\n\n\n\n\n\nAttachments:\n\n1. \u003ca href=\"https://storage.googleapis.com/go-attachment/6751/3/multithread.go\"\u003emultithread.go\u003c/a\u003e (1138 bytes)\n1. \u003ca href=\"https://storage.googleapis.com/go-attachment/6751/3/multithreaded.zip\"\u003emultithreaded.zip\u003c/a\u003e (6031 bytes)",
	"user": {
		"login": "alexbrainman",
		"id": 9796621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-11-15T01:45:54Z",
	"updated_at": "2014-12-08T10:37:31Z"
}
