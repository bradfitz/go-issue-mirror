{
	"id": 241946463,
	"body": "While there are definitely several ways to encode `bool` (sometimes even 32-bit integers for in-memory representation), it's pretty reasonable to assume that it should only use one byte. I have a few arguments why I think it is reasonable:\r\n\r\n1. I'm making the assumption that `encoding/binary` is primarily for storage and transmission of data, as opposed to memory layout. One byte representation of `bool` is almost exclusively the case for storage and transmission purposes, and it can't be less than one byte (at least not in Go as it'd break the `io.Reader` and `io.Writer` interfaces), nor is there any purpose to making it more bytes. Ordinarily the definition of `bool` is zero and non-zero for `false` and `true`. As @dr2chase points out that may add some complexity to the encoding/decoding process, but not unreasonably so. I also think it'd be fair to go with the most common scenario, where it's only zero and one for `false` and `true`.\r\n\r\n2. Assuming that `bool` would be most commonly used in structs as opposed to on its own or in slices, it's difficult to accommodate the proposed conversion between `uint8` and `bool` without transferring all the fields to another type. The reason being that `encoding/binary` does not allow unexported or unused fields on the struct. In my personal experience with the package, I've had to export structs with `uint8` fields that are then documented with \"1 for true, 0 for false\" at the enduser's expense.\r\n\r\n3. There is previous work in the `encoding/binary` package that sets a precedent for choosing one design even though there may be several. I'm talking about `Varint` which actually uses a proprietary* format instead of any of the commonly available ones such as [VLQ](https://en.wikipedia.org/wiki/Variable-length_quantity). I bring this up because it makes the case that a similar decision could be made for `bool`.\r\n\r\n4. If a byte representation of `bool` can truly not be established, the only remaining option (besides the transfer of struct fields I mentioned earlier) would be to either have a `binary.Bool` type which would have a predetermined binary structure, or to allow an interface for custom encoding, similar to the `json` package. \r\n\r\n*) I say \"proprietary\" because it is specific to the Golang codebase and does not (to my knowledge) adopt any publicly available standard. You may say it's the Google Protocol Buffers implementation, but based on [a design comment](https://golang.org/src/encoding/binary/varint.go?s=744:1300#L16) in the source it may be incompatible since protobuf uses 128-bit varints.",
	"user": {
		"login": "blixt",
		"id": 158591,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-24T03:17:04Z",
	"updated_at": "2016-08-24T03:17:04Z"
}
