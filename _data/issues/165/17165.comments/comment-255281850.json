{
	"id": 255281850,
	"body": "@alexbrainman, why do you say that a syscall.NewCallback-created callback can't be invoked on a new Windows-created thread? I think that should work, and it clearly mostly works. @ianlancetaylor, syscall.NewCallback returns a Windows callback that can be used to invoke the Go code. Underneath it translates to the usual cgo entry points. In particular, when the callback is invoked, it ends up in cgocallback_gofunc (on the stack above), which will take care of borrowing an M appropriately.\n\nBut the borrowing of M's and the profiling of M's by the CPU profiler seem not synchronized enough. This code implements the CPU profiler on Windows:\n\n\tfunc profileloop1(param uintptr) uint32 {\n\t\tstdcall2(_SetThreadPriority, currentThread, _THREAD_PRIORITY_HIGHEST)\n\t\n\t\tfor {\n\t\t\tstdcall2(_WaitForSingleObject, profiletimer, _INFINITE)\n\t\t\tfirst := (*m)(atomic.Loadp(unsafe.Pointer(\u0026allm)))\n\t\t\tfor mp := first; mp != nil; mp = mp.alllink {\n\t\t\t\tthread := atomic.Loaduintptr(\u0026mp.thread)\n\t\t\t\t// Do not profile threads blocked on Notes,\n\t\t\t\t// this includes idle worker threads,\n\t\t\t\t// idle timer thread, idle heap scavenger, etc.\n\t\t\t\tif thread == 0 || mp.profilehz == 0 || mp.blocked {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tstdcall1(_SuspendThread, thread)\n\t\t\t\tif mp.profilehz != 0 \u0026\u0026 !mp.blocked {\n\t\t\t\t\tprofilem(mp)\n\t\t\t\t}\n\t\t\t\tstdcall1(_ResumeThread, thread)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunc profilem(mp *m) {\n\t\tvar r *context\n\t\trbuf := make([]byte, unsafe.Sizeof(*r)+15)\n\t\n\t\ttls := \u0026mp.tls[0]\n\t\tgp := *((**g)(unsafe.Pointer(tls)))\n\t\n\t\t// align Context to 16 bytes\n\t\tr = (*context)(unsafe.Pointer((uintptr(unsafe.Pointer(\u0026rbuf[15]))) \u0026^ 15))\n\t\tr.contextflags = _CONTEXT_CONTROL\n\t\tstdcall2(_GetThreadContext, mp.thread, uintptr(unsafe.Pointer(r)))\n\t\tsigprof(r.ip(), r.sp(), 0, gp, mp)\n\t}\n\n\tfunc sigprof(pc, sp, lr uintptr, gp *g, mp *m) {\n\t\tif prof.hz == 0 {\n\t\t\treturn\n\t\t}\n\t\n\t\t// Profiling runs concurrently with GC, so it must not allocate.\n\t\tmp.mallocing++\n\t\n\t\t... lots of code ...\n\t\t\n\t\tmp.mallocing--\n\t}\n\t\nA borrowed M may migrate between threads. Between the atomic.Loaduintptr(\u0026mp.thread) and the SuspendThread, mp may have moved to a new thread, so that it's in active use. In particular it might be calling malloc, as in the crash stack trace. If so, the mp.mallocing++ in sigprof would provoke the crash.\n\nThose lines are trying to guard against allocation during sigprof. But on Windows, mp is the thread being traced, not the current thread. Those lines should really be using getg().m.mallocing, which is the same on Unix but not on Windows. With that change, it's possible the race on the actual thread is not a problem: the traceback would get confused and eventually return an error, but that's fine. The code expects that possibility.\n\nIt would be nice if we could reproduce the problem, though. It might suffice just to turn on CPU profiling and make a bunch of callbacks from multiple threads simultaneously.",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-10-21T02:57:08Z",
	"updated_at": "2016-10-21T02:57:08Z"
}
