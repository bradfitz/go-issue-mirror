{
	"id": 163830962,
	"body": "\u003e Surely any request with an infinite response is an issue, pipelining or not? The HTTP specs are pretty clear about the ordered serialization of pipelined responses so any client that uses pipelining has to be ready to accept that all requests after a slow request will be delayed too and deal with that.\r\n\r\nAnd we do deal with it. We accept all request as they arrive, but only process them in serial, which fulfills our obligation spec-wise about replying in order.\r\n\r\n\u003e It sounds like your proposal is to not support pipelining and CloseNotifier at the same time, am I understanding correctly?\r\n\r\nDepends what you mean. I'm saying that CloseNotifier would be reworded to guarantee it only works when it actually works today: the last request in a pipeline. So if you wanted to use it reliably, you'd use it on POST requests, or the last GET in a pipeline, or with a GET without any following request. (no pipelining). We would always be in a Read on the client's socket and if they disconnect or send a pipelined request while we have a CloseNotify open, then we send on that CloseNotifier.\r\n\r\nCurrently we don't document, for instance, that if you're using CloseNotifier on a POST request with a large unread Request.Body, CloseNotifier just won't work. \r\n\r\n\u003e I think this amounts to no longer supporting pipelining since the end of the pipeline is signalled by the client by terminating the connection (which the server now won't be able to detect).\r\n\r\nWe detect EOF at the end of request(s) whether they're single, keep-alive serial, or pipelined.\r\n\r\n\u003e You mention that this won't affect browsers because \"it doesn't work on the internet\", but it's used extensively by mobile browsers today (http://www.guypo.com/http-pipelining-big-in-mobile/)\r\n\r\nYou say \"today\" and then reference an article from 2011. Chrome on Android since then often uses the Google Data Compression (opt-in) which uses SPDY or HTTP/2 for non-HTTPS sides. And HTTP/2 adoption is growing a lot in the last year.\r\n\r\nI don't think HTTP/1.1 pipelining ever mattered much and will probably never matter enough.\r\n\r\nWe support it because we have to, and it's easy enough to support, but I don't think we need to support the combination of two fringe features (HTTP pipelining + CloseNotifier) together especially when there's no common API on all operating systems that Go supports to tell us that a FIN arrived from the client. We do set TCP keep-alives in general and will often fire on that, but again there's no common sideband interface for kernels to tell us that a TCP connection failed its heartbeats.\r\n\r\nI'm totally open to suggestions here, but I can't think of anything that works well.\r\n\r\nThe CloseNotifier interface is just too vague and over-promise-y and it's hard to deliver on it, especially without operating system support. We could poll and parse /proc/net/tcp on Linux but that doesn't scale in several ways.\r\n\r\n\u003e Removing pipelining support from go feels like a shame.\r\n\r\nI'm not proposing removing pipelining support.\r\n\r\nIn summary, I'm proposing,\r\n\r\n1) documenting more explicitly when CloseNotifier is expected to work, restricting people's expectations. I would say \"no outstanding data on the connection\", which includes pipelined requests. Then I'd call out pipelined requests and say that to guarantee that clients don't send pipelined requests, only use CloseNotifier for POSTs, etc.\r\n\r\n2) making sure Go is always in a Read call so we can detect whenever new data (or EOF) arrives on the socket and fire any open CloseNotifier channel.\r\n",
	"user": {
		"login": "bradfitz",
		"id": 2621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-11T03:48:34Z",
	"updated_at": "2015-12-11T03:48:34Z"
}
