{
	"id": 172059240,
	"body": "Would this test program perhaps be helpful?  It computes 100 billion random float32s, and bins them by negative-power-of-two-less-than-or-equal (i.e., (1,0.5] ends up in bin 1 ) for bins 1-64.\r\n```\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math/rand\"\r\n)\r\n\r\nfunc main() {\r\n\tvar a [65]uint64\r\n\tfor i := 0; i \u003c 1024; i++ { // 2**10\r\n\t\tfor j := 0; j \u003c 128*1024*1024; j++ { // 2**27\r\n\t\t\tr := rand.Float32()\r\n\t\t\tvar k int\r\n\t\t\tfor k = 0; r \u003c 1.0 \u0026\u0026 k \u003c 64; k++ {\r\n\t\t\t\tr = r + r\r\n\t\t\t}\r\n\t\t\ta[k]++\r\n\t\t}\r\n\t\tfmt.Printf(\"%d\", a[1])\r\n\t\tfor k := 2; k \u003c 65; k++ {\r\n\t\t\tfmt.Printf(\", %d\", a[k])\r\n\t\t}\r\n\t\tfmt.Println()\r\n\t}\r\n}\r\n```\r\n\r\nI ran this for over 100 minutes, the last printed line was:\r\n44090360930, 22045281389, 11022793839, 5511276150, 2755668437, 1377855446, 688902792, 344456207, 172220997, 86117788, 43060011, 21523345, 10767229, 5378922, 2691381, 1346071, 673490, 336577, 168029, 84082, 42097, 21159, 10498, 5206, 2604, 1265, 645, 336, 200, 85, 42, 25, 14, 4, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\r\n\r\nThe reason points near zero are selected less often is by construction.  If we start with points uniform on [0,2\\*\\*63-1], full-precision division by 2\\*\\*63 preserves uniformity, each with probability P0 = 1/2\\*\\*63.  If we then round those to a 53-bit mantissa, the probabilities of [0,2\\*\\*53)/2\\*\\*63 remain unchanged (=P0); they are exactly representable and there is no rounding.  Consider the mapping of points 2\\*\\*53+k for smallish k.  For even k the point is exactly representable and the value appears in the FP64 stream, but for odd k the value must be rounded. 1-\u003e0, 2=2, 3-\u003e4, 4=4, 5-\u003e4, 6=6, 7-\u003e8, 8=8, 9-\u003e8, 10=10 etc. \r\n\r\nSo on the one hand, I see an interesting glitch in uniformity, in that for k = 2, 6, 10, ...  p(2\\*\\*53+k) = P0 but for k = 4, 8, 12, ...  p(2\\*\\*53+k) = 3\\*P0 because of round-to-nearest-zero-if-tie.  (I modified the program above to test this and it appeared right away.  Similarly, the old unfixed code starts dumping hits into the last bucket right away for rand.Float32).\r\n\r\nFor larger powers of two, the difference in even and odd probabilities diminishes.  For p(2\\*\\*54+k) two bits must be dropped and the winners will be k=0,4,8,12,16.  Rounding to the respective values of k:\r\n0: -1, 0,1,2 (-1 = 2\\*\\*54-1 == 2\\*\\*53 + 2\\*\\*53 - 1)\r\n4: 3,4,5\r\n8: 6,7,8,9,10\r\n12: 11,12,13\r\ni.e., instead of 4\\*P0, alternating between 3\\*P0 and 5\\*P0, and for p(2\\*\\*55+k) , 7 and 9 instead of 8, etc. all the way to p(2\\*\\*62+k) where the probabilities will be 1023 and 1025\\*P0 instead of 1024\\*P0.\r\nHere's a demo of the 1:3 ratio between odds and evens:\r\n```\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n\t\"math/rand\"\r\n)\r\n\r\nconst (\r\n\tp53 = float64(1\u003c\u003c53) / (1 \u003c\u003c 63)\r\n\tp54 = float64(1\u003c\u003c54) / (1 \u003c\u003c 63)\r\n)\r\n\r\nfunc main() {\r\n\tvar even uint64\r\n\tvar odd uint64\r\n\r\n\tfor j := 0; j \u003c 128*1024*1024; j++ { // 2**27\r\n\t\tr := rand.Float64()\r\n\t\tif p53 \u003c r \u0026\u0026 r \u003c p54 {\r\n\t\t\ti := math.Float64bits(r)\r\n\t\t\tif i\u00261 == 1 {\r\n\t\t\t\todd++\r\n\t\t\t} else {\r\n\t\t\t\teven++\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"odd,even=%d,%d\\n\", odd, even)\r\n}\r\n```\r\n\r\nTo your original worry/complaint, notice that in general each time half the points drop out, the probability of the remaining points being chosen increases by a factor of two on average.  In the data above, you'd expect to see a glitch, if any, occurring between bucket 10 and bucket 11, and there is none (I checked).\r\n\r\nIt's a bit of a shame we can't do this in RTZ FP mode; it would, however change the stream of bits from the RNG and perhaps cause some sadness.",
	"user": {
		"login": "dr2chase",
		"id": 1928999,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-15T19:22:10Z",
	"updated_at": "2016-01-15T19:22:10Z"
}
