{
	"id": 121770387,
	"body": "Still no progress on a solution. By @mdempsky's request, my notes on my hypotheses and what tests I've tried are below and the code for these tests is at https://go-review.googlesource.com/12277. I'll be away until Monday, so I probably won't make much more progress on this before then.\r\n\r\nOverwritten byte contains the mark bit. Are we screwing up a mark bit write?\r\n\r\n* What manipulates that byte after allocation?\r\n\r\n  * heapBits.setMarked\r\n\r\n    * NO: Atomic or (checked assembly); can't clear bits\r\n\r\n  * heapBits.setMarkedNonAtomic\r\n\r\n    * Only used by sweeping, which SHOULD own the span and never be concurrent with GC.\r\n\r\n    * TEST: Try to reproduce with setMarked instead of setMarkedNonAtomic.\r\n\r\n      * NO: Still occurred (sample 3).\r\n\r\n  * heapBits.setCheckmarked\r\n\r\n    * NO: Checkmarking is not enabled, so we don't reach this code\r\n\r\n  * heapBits.initCheckmarkSpan\r\n\r\n    * NO: Checkmarking is not enabled, so we don't reach this code\r\n\r\n  * heapBits.clearCheckmarkSpan\r\n\r\n    * NO: Checkmarking is not enabled, so we don't reach this code\r\n\r\n* What else manipulates mark bits?\r\n\r\n  * heapBits.initSpan\r\n\r\n    * NO: The preceding span was initialized long before the span with the bad bitmap.\r\n\r\n      * 0x18770000 is the 2028'th LSym in Allsym. The preceding span is LSyms except for , which are Allsyms 13989--14033, so they were allocated long before 0x18770000 (since the list goes from newest to oldest). Further, the span of 0x18770000 consists entirely of LSyms, and 0x18770000 would have been the first one allocated from that span (causing the initSpan).\r\n\r\n        * 0x1876f290 from the previous span is the only object in that span not on Allsym. It's definitely not an LSym. No pointers.\r\n\r\n    * NO: the memclr seems to be right (as does the memclr 386 implementation).\r\n\r\n  * heapBitsSetType\r\n\r\n    * TEST: Check last byte written.\r\n\r\n      * NO: Reproduced twice without this test failing.\r\n\r\n  * heapBitsSetTypeGCProg\r\n\r\n  * heapBitsSweepSpan\r\n\r\n    * Sweep of neighboring span?\r\n\r\n      * Unlikely, but not impossible that a sweep of a neighboring span overflowed. I wouldn't expect it to hit that exact byte of the bitmap, since that's not where the step would take it if it went one over.\r\n\r\n    * Sweep of this span without proper ownership?\r\n\r\n      * heapBitsSweepSpan does do non-atomic writes to this byte.\r\n\r\n      * Could happen if object is allocated (bitmap written), but not marked, sweep runs, sees it's not marked, writes a zero to this byte, and then it gets marked.\r\n\r\n      * Could happen if sweep reads the mark byte before allocation writes the bitmap, then allocation writes the bitmap, then sweep writes a zero byte back out.\r\n\r\n      * Can there be multiple sweepers?\r\n\r\n        * No. Every mSpan_Sweep is protected by a cas(\u0026s.sweepgen), so only one sweeper is sweeping a span at a time.\r\n\r\n      * Can there be a sweeper and an allocator?\r\n\r\n        * TEST: Check sweepgen before and after heapBitsSetType.\r\n\r\n          * NO: Reproduced 10 times (!) without this failure. Did this make it easier to trigger?\r\n\r\n      * Can there be a sweeper and a GC?\r\n\r\n        * TEST: Check sweepgen in greyobject and gcmarknewobject_m.\r\n\r\n          * NO: Reproduced twice without this failure.\r\n\r\n    * TEST: Check that bitp doesn't change across sweep callback.\r\n\r\n      * NO (probably): Reproduced 10 times (!) without this test failing. Did this make it easier to trigger?\r\n\r\n    * TEST: Look for the LSym bitmap pattern and panic before writing.\r\n\r\n      * ???\r\n\r\n* TEST: Skip allocating the first object in 176 byte spans, put a test pattern there, and check the test pattern when sweeping. (Tests for a stray write, which seems very unlikely, but who knows at this point.)\r\n\r\n  * ???",
	"user": {
		"login": "aclements",
		"id": 2688315,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-07-15T22:47:19Z",
	"updated_at": "2015-07-15T23:28:29Z"
}
