{
	"id": 112119177,
	"body": "CC @RLH @aclements See below.\r\n\r\nThe dump with GOTRACEBACK=crash may show us something useful.  It shows a goroutine with this stack trace:\r\n\r\ngoroutine 0 [idle]:\r\nruntime.futex(0xb60570, 0x0, 0x7f7cc17f9de0, 0x0, 0x0, 0x45d4ec, 0x0, 0x186a0, 0x40de34, 0xb60570, ...)\r\n        /home/jacobsa/clients/go/src/runtime/sys_linux_amd64.s:283 +0x23 fp=0x7f7cc17f9db0 sp=0x7f7cc17f9da8\r\nruntime.futexsleep(0xb60570, 0x0, 0x186a0)\r\n        /home/jacobsa/clients/go/src/runtime/os1_linux.go:56 +0xf0 fp=0x7f7cc17f9df8 sp=0x7f7cc17f9db0\r\nruntime.notetsleep_internal(0xb60570, 0x186a0, 0xc2081da800)\r\n        /home/jacobsa/clients/go/src/runtime/lock_futex.go:167 +0x134 fp=0x7f7cc17f9e28 sp=0x7f7cc17f9df8\r\nruntime.notetsleep(0xb60570, 0x186a0, 0xc2081da800)\r\n        /home/jacobsa/clients/go/src/runtime/lock_futex.go:187 +0x71 fp=0x7f7cc17f9e48 sp=0x7f7cc17f9e28\r\nruntime.stopTheWorldWithSema()\r\n        /home/jacobsa/clients/go/src/runtime/proc1.go:568 +0x1e9 fp=0x7f7cc17f9e90 sp=0x7f7cc17f9e48\r\nruntime.systemstack(0xc208020000)\r\n        /home/jacobsa/clients/go/src/runtime/asm_amd64.s:262 +0x7c fp=0x7f7cc17f9e98 sp=0x7f7cc17f9e90\r\nruntime.mstart()\r\n        /home/jacobsa/clients/go/src/runtime/proc1.go:656 fp=0x7f7cc17f9ea0 sp=0x7f7cc17f9e98\r\n\r\nThis goroutine is trying to stop all threads in order to run the stop-the-world phase of a garbage collection.  It tells all running threads to stop and then loops until they do.\r\n\r\nA thread waiting for an ordinary syscall to complete is considered stopped by the GC, because it will stop as soon as the syscall completes and the goroutine calls ExitSyscall.  However, in this case there is  a thread waiting for a raw system call, the call to clone in forkAndExecInChild.  The thread is running, and the GC will wait for it to stop.  However, the thread is waiting for a FUSE thread to run, but all the FUSE threads have been stopped by the GC.  The result is a deadlock.\r\n\r\nIf that theory is correct, then I think we need to add some sort of marker to beforefork in runtime/proc1.go indicating that the GC can consider the thread to be stopped.  Perhaps it would be enough to check for stackguard0 == stackFork in preemptall and stopTheWorldWithSema.  We may not need to do anything else other than add comments, as the forking process never allocates memory, and its next step will be to call entersyscall for readlen.",
	"user": {
		"login": "ianlancetaylor",
		"id": 3194333,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-06-15T15:57:47Z",
	"updated_at": "2015-06-15T15:57:47Z"
}
