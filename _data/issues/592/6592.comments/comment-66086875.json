{
	"id": 66086875,
	"body": "\u003ca id=\"c4\"\u003e\u003c/a\u003eComment 4:\n\n\u003cpre\u003eThanks. \n\nThe first four fields are \"objects in use\", \"bytes in use\", \"total allocated objects\",\n\"total allocated bytes\". Internally, we track total allocated and total freed. The \"in\nuse\" numbers are allocated - freed. The negative in use byte numbers indicate that the\nfreed byte count is bigger than the allocated byte count. It appears that only the byte\ncounts are incorrect. The object counts seem fine.\n\nAll the lines containing 0x3c9a8 are calls to runtime.new, which necessarily allocate\nfixed-size chunks, so all the allocs and frees for each of those should be the same\nsize, so the ratio of #block / # byte should be constant (1 / size).\n\nThat makes it easy to find inconsistent lines:\n\ntr -d '[]:' \u0026lt;heap.txt | grep 0x3c8dc | awk '$1*$4 != $2*$3'\n\nHere are the 10 entries with the largest block sizes:\n\n$ tr -d '[]:' \u0026lt;heap.txt | grep 0x3c8dc | awk '$1*$4 != $2*$3 {print $4/$3, $0}' |\nsort -nr | sed 10q\n2048 96 252408 370 757760 @ 0x3b420 0x3c8dc 0x149f54 0x67ebc 0x6bdc8 0x70c34 0x302e4\n2048 39 109136 192 393216 @ 0x3b420 0x3c8dc 0x149f54 0x59a84 0x670a4 0x675c4 0x302e4\n2048 38 94992 192 393216 @ 0x3b420 0x3c8dc 0x149f54 0x59c00 0x670a4 0x675c4 0x302e4\n1152 5 6752 18 20736 @ 0x3b420 0x3c8dc 0x21aa48 0x1bf928 0x1c9500 0x1c6e64 0xcdf48\n0xd1668 0x302e4\n1152 4 -1920 19 21888 @ 0x3b420 0x3c8dc 0x21aa48 0x1bf928 0x1c995c 0x1c6e64 0xcdf48\n0xd1668 0x302e4\n224 55 12552 193 43232 @ 0x3b420 0x3c8dc 0x153244 0x14e7ac 0x65fe4 0x671e4 0x675c4\n0x302e4\n224 52 13544 193 43232 @ 0x3b420 0x3c8dc 0x153244 0x14b5dc 0x14b514 0x662fc 0x675c4\n0x302e4\n144 71 9136 202 29088 @ 0x3b420 0x3c8dc 0x138068 0x1262a8 0x126454 0x126a74 0x57efc\n0x54738 0x58adc 0x12b214 0x12b708 0x131b10 0x126aac 0x77bb8 0x78f7c 0x57858 0x302e4\n144 67 9808 196 28224 @ 0x3b420 0x3c8dc 0x138068 0x1262a8 0x126454 0x126a74 0x77ae0\n0x77b78 0x78f7c 0x67668 0x302e4\n144 63 8352 182 26208 @ 0x3b420 0x3c8dc 0x138068 0x1262a8 0x126454 0x126c28 0x15aee0\n0x15a75c 0x15d6d8 0x15d868 0x15f780 0x12b214 0x12b708 0x131b10 0x126aac 0x77bb8 0x78f7c\n0x66174 0x671e4 0x675c4 0x302e4\n\nNote especially the three entries with 2048-byte blocks. The in-use byte count is 252408\n(504 mod 2048). So it's not that some blocks are being counted as freed twice. The size\nis wrong for some other reason.\n\nPerhaps the size being passed to MProf_Free is wrong. However, it looks correct, and it\nis correct in many cases, and if it were incorrect, that would mean that sweep would be\nwalking the span using the wrong block size and would cause more serious problems than a\nbad profile.\n\nPerhaps there is a bad atomic operation and the int64 storing the free byte count is\ngetting corrupted. It is strange that the allocated byte count is fine, though.\n\nPerhaps there is memory corruption, but it's strange that it would target this one field\nin this one struct, repeatedly, but nothing else.\n\nPerhaps there is a code generation error, but again it's strange that it works most of\nthe time.\n\nPerhaps if a signal arrives at the wrong time the register being used by this one\ncomputation is smashed, but not the computation of the others. But again, why this one\nfield?\n\nThe size passed to MProf_Free being incorrect really does seem to be the most likely\noption, but again if that were true, more would be broken.\n\nI'm stumped.\n\nI'd very much like to understand this before we cut Go 1.2. It won't hold up the rc2\nrelease candidate, though.\n\nI assume this is arm. What kind of hardware is this? Is it a multiprocessor? What is the\nGOARM setting you are using? Any other relevant details?\u003c/pre\u003e\n\n_Labels changed: added **go1.2maybe**, removed **go1.2**._",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-10-16T19:16:21Z",
	"updated_at": "2014-12-22T06:29:39Z"
}
