{
	"id": 239770080,
	"body": "Yes, your file descriptor is being closed when all references to the\nos.File you created to lock goes out of scope.\n\nOn Mon, 15 Aug 2016, 19:30 galric \u003cnotifications@github.com\u003e wrote:\n\n\u003e i come across a problem and can not find a same issue, using go1.4\n\u003e\n\u003e i used a file lock for process anti-reentry setting it to\n\u003e syscall.LOCK_EX|syscall.LOCK_NB in a function, but this lock would always\n\u003e be auto closed after 2 minutes\n\u003e\n\u003e i have attempted to use an struct member variable to store this file\n\u003e descriptor, but it was closed after 2 minites again\n\u003e\n\u003e i have attempted to use an global variable to store it , and it works.\n\u003e\n\u003e func LockUntilEx(lockfile string) (*os.File, error) {\n\u003e     var mode os.FileMode = 0777\n\u003e     file, err := os.OpenFile(lockfile, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, mode)\n\u003e     if err != nil {\n\u003e         return nil, err\n\u003e     }\n\u003e\n\u003e     err = syscall.Flock(int(file.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)\n\u003e     if err != nil {\n\u003e         return nil, err\n\u003e     }\n\u003e\n\u003e     _, _, errno := syscall.RawSyscall(syscall.SYS_FCNTL, file.Fd(), syscall.F_SETFD, syscall.FD_CLOEXEC)\n\u003e     if errno != 0 {\n\u003e         return nil, errors.New(fmt.Sprintf(\"fail to set FD_CLOEXEC, for \", lockfile))\n\u003e     }\n\u003e     return file, nil\n\u003e }\n\u003e var usefulLock *os.File\n\u003e\n\u003e type TestLock struct {\n\u003e     uselessLock *os.File\n\u003e }\n\u003e\n\u003e func (this *TestLock) Lock() (err error) {\n\u003e     path := \"/tmp/filename\"\n\u003e     this.uselessLock, err = LockUntilEx(path)\n\u003e     if err != nil {\n\u003e         return err\n\u003e     }\n\u003e     return nil\n\u003e }\n\u003e\n\u003e func  Lock() (err error) {\n\u003e     path := \"/tmp/filename\"\n\u003e     uselessLock, err := LockUntilEx(path)\n\u003e     if err != nil {\n\u003e         return err\n\u003e     }\n\u003e     fmt.Println(\"lock succ \", uselessLock)\n\u003e     return nil\n\u003e }\n\u003e\n\u003e func main() {\n\u003e     l := new(TestLock)\n\u003e     if err := l.Lock(); err != nil {\n\u003e         fmt.Println(err)\n\u003e         return\n\u003e     }\n\u003e     for {\n\u003e         fmt.Println(time.Now())\n\u003e         time.Sleep(time.Second)\n\u003e     }\n\u003e }\n\u003e\n\u003e my questions are:\n\u003e 1. is this file descriptor closed by gc? why struct member variable closed\n\u003e and global variable not?\n\u003e 2. is there any suggested way to use file lock\n\u003e\n\u003e â€”\n\u003e You are receiving this because you are subscribed to this thread.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/16700\u003e, or mute the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AAAcAx-V2lOQQBhkNh6_XilT7GqUW-8Hks5qgDGTgaJpZM4JkPRv\u003e\n\u003e .\n\u003e\n",
	"user": {
		"login": "davecheney",
		"id": 7171,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-15T10:10:19Z",
	"updated_at": "2016-08-15T10:10:19Z"
}
