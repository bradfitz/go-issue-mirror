{
	"id": 66089294,
	"body": "\u003ca id=\"c5\"\u003e\u003c/a\u003eComment 5 by **chanxuehong**:\n\n\u003cpre\u003ethanks all of you, my English sucks, for here the process is not very\nunderstanding, can only do so much of that is,\nIf you think I submitted a bit useful, please help me to submit and\ncommunication, thank you. We all want golang better.\nAlso, my submit not modify the bug,  but remove unnecessary statement,\nmodify the judgment order of switch case.\n\n// Copyright 2010 The Go Authors.  All rights reserved.\n\n// Use of this source code is governed by a BSD-style\n\n// license that can be found in the LICENSE file.\n\n\n// Package utf16 implements encoding and decoding of UTF-16 sequences.\n\npackage utf16\n\n\n// The conditions replacementChar==unicode.ReplacementChar and\n\n// maxRune==unicode.MaxRune are verified in the tests.\n\n// Defining them locally avoids this package depending on package unicode.\n\n\nconst (\n\n    replacementChar = '\\uFFFD'     // Unicode replacement character\n\n    maxRune         = '\\U0010FFFF' // Maximum valid Unicode code point.\n\n)\n\n\nconst (\n\n    // 0xd800-0xdc00 encodes the high 10 bits of a pair.\n\n    // 0xdc00-0xe000 encodes the low 10 bits of a pair.\n\n    // the value is those 20 bits plus 0x10000.\n\n    surr1 = 0xd800\n\n    surr2 = 0xdc00\n\n    surr3 = 0xe000\n\n\n    surrSelf = 0x10000\n\n)\n\n\n// IsSurrogate returns true if the specified Unicode code point\n\n// can appear in a surrogate pair.\n\nfunc IsSurrogate(r rune) bool {\n\n    return surr1 \u0026lt;= r \u0026\u0026 r \u0026lt; surr3\n\n}\n\n\n// decodeRune returns the UTF-16 decoding of a surrogate pair.\n\n// the pair r1, r2 is a valid UTF-16 surrogate pair.\n\nfunc decodeRune(r1, r2 rune) rune {\n\n    return (r1-surr1)\u0026lt;\u0026lt;10 | (r2 - surr2) + surrSelf\n\n}\n\n\n// DecodeRune returns the UTF-16 decoding of a surrogate pair.\n\n// If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\n\n// the Unicode replacement code point U+FFFD.\n\nfunc DecodeRune(r1, r2 rune) rune {\n\n    if surr1 \u0026lt;= r1 \u0026\u0026 r1 \u0026lt; surr2 \u0026\u0026 surr2 \u0026lt;= r2 \u0026\u0026 r2 \u0026lt; surr3 {\n\n        return decodeRune(r1, r2)\n\n    }\n\n    return replacementChar\n\n}\n\n\n// encodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\n\n// surrSelf \u0026lt;= r \u0026\u0026 r \u0026lt;= maxRune\n\nfunc encodeRune(r rune) (r1, r2 rune) {\n\n    r -= surrSelf\n\n    return surr1 + r\u0026gt;\u0026gt;10, surr2 + r\u00260x3ff\n\n}\n\n\n// EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\n\n// If the rune is not a valid Unicode code point or does not need encoding,\n\n// EncodeRune returns U+FFFD, U+FFFD.\n\nfunc EncodeRune(r rune) (r1, r2 rune) {\n\n    if r \u0026lt; surrSelf || r \u0026gt; maxRune {\n\n        return replacementChar, replacementChar\n\n    }\n\n    return encodeRune(r)\n\n}\n\n\n// Encode returns the UTF-16 encoding of the Unicode code point sequence s.\n\nfunc Encode(s []rune) []uint16 {\n\n    n := len(s)\n\n    for _, v := range s {\n\n        if v \u0026gt;= surrSelf {\n\n            n++\n\n        }\n\n    }\n\n\n    a := make([]uint16, n)\n\n    n = 0\n\n    var r1, r2 rune\n\n    for _, v := range s {\n\n        switch {\n\n        case 0 \u0026lt;= v \u0026\u0026 v \u0026lt; surr1, surr3 \u0026lt;= v \u0026\u0026 v \u0026lt; surrSelf:\n\n            a[n] = uint16(v)\n\n            n++\n\n        case surrSelf \u0026lt;= v \u0026\u0026 v \u0026lt;= maxRune:\n\n            r1, r2 = encodeRune(v)\n\n            a[n] = uint16(r1)\n\n            a[n+1] = uint16(r2)\n\n            n += 2\n\n        default:\n\n            a[n] = uint16(replacementChar)\n\n            n++\n\n        }\n\n    }\n\n    return a[:n]\n\n}\n\n\n// Decode returns the Unicode code point sequence represented\n\n// by the UTF-16 encoding s.\n\nfunc Decode(s []uint16) []rune {\n\n    sLen := len(s)\n\n    a := make([]rune, sLen)\n\n    n := 0\n\n    var r uint16\n\n    for i := 0; i \u0026lt; sLen; i++ {\n\n        switch r = s[i]; {\n\n        case r \u0026lt; surr1, surr3 \u0026lt;= r:\n\n            // normal rune\n\n            a[n] = rune(r)\n\n            n++\n\n        case surr1 \u0026lt;= r \u0026\u0026 r \u0026lt; surr2 \u0026\u0026 i+1 \u0026lt; sLen \u0026\u0026\n\n            surr2 \u0026lt;= s[i+1] \u0026\u0026 s[i+1] \u0026lt; surr3:\n\n            // valid surrogate sequence\n\n            a[n] = decodeRune(rune(r), rune(s[i+1]))\n\n            i++\n\n            n++\n\n        default:\n\n            // invalid surrogate sequence\n\n            a[n] = replacementChar\n\n            n++\n\n        }\n\n    }\n\n    return a[:n]\n\n}\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-12-16T13:36:44Z",
	"updated_at": "2014-12-22T06:30:51Z"
}
