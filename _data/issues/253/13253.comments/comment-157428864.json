{
	"id": 157428864,
	"body": "I worked on a similar problem (enhancing array/matrix support) for Java, but did not reach a conclusive answer.  One thing similar in both Go and Java is the numerous requests for extensions along multiple feature axes.  For example (I've *'d the ones I've used over the years, and arguably I also worked with matrices of constructive reals):\r\n\r\n- element type (Java primitives\\*, complex, quaternions, rationals, constructive reals, polynomials\\*)\r\n- layout (dense\\*, sparse, triangular, banded, k-diagonal)\r\n- distribution (flat memory\\*, numa, networked)\r\n- access patterns (random\\*, iterative\\*, fork-join\\*)\r\n- bulk operations (per-element\\*, multiplication\\*, eliminations\\*, convolution [with what edge conditions?])\r\n- aliasing (transposition\\*, sub-matrix\\*, glued matrix, permuted matrix\\*)\r\n\r\nI may not have picked the best names for the feature axes.  My goal was to come up with something that was good enough by default that \"ordinary\" users would pick it for their own bulk operations (basic linear algebra stuff, there was a machine learning team in Burlington happy to make feature requests along those lines) while still enabling people who knew how to do specialized stuff to use it and get good performance and then export that work to the \"ordinary users\" crowd.  This might include \"matrix on a GPU\", this might include \"specialized decomposition\".  I didn't finish -- this was exploratory, both in the direction of features and performance.\r\n\r\nOne problem I ran into for Java (which already has generics) is that the type system prevents you from writing a library that supports extensions in multiple axes -- i.e., don't think that if you add generics to Go, all will be solved.  You may not be able to say what you want, and this may be part of the motivation for loading this onto slices, because slices get to be polymorphic.\r\n\r\nThe impression I get from this is that perhaps asking for language extensions in the direction of \"features I want\" is the wrong approach, because we'll quickly run into limits and the type system will thwart us at every turn.  Instead, is it possible to do this with some sort of a generator, or a family of interacting generators?  Would this work better if we added particular optimizations to the compiler (e.g., good loop invariant code motion and reduction in strength)?  Is there something missing from the language that would make this work better, that we should be asking for instead of just a bullet list of features?  What makes me suggest this is that specialized code generation seemed to always pop up as a necessary component of these things.  In Java it had to happen at the last minute (or a little later -- in practice getting full performance required multiple recompilations) but there's no reason it could not happen ahead of time.\r\n",
	"user": {
		"login": "dr2chase",
		"id": 1928999,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-17T16:51:32Z",
	"updated_at": "2015-11-17T16:51:32Z"
}
