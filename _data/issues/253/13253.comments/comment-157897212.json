{
	"id": 157897212,
	"body": "Some quick thoughts.\r\n\r\nOverview\r\nThe general idea I think is good if Go is okay with that level of complexity. It supports the most common case of resizing, which is on linear slices, and allows downslicing, which is a common case. \r\n\r\nOf course, this also brings inconsistencies. Slicing only works upwards, not downwards. You can \"downslice\", but only along one of the dimensions. However, these are inherent in any proposal that keeps slices unstrided and allows views on rectangles.\r\n\r\nDetails:\r\nAccess/assignment\r\nI think the address overloading is confusing, as it obscures the dimension of the addressee and thus the output of the address. I would rather see it as \r\n// t is a [,,]T\r\nt[:, :, :] --\u003e returns [,,]T\r\nt[0, :, :] --\u003e returns [,]T\r\nt[0,1,:] --\u003e returns  []T\r\nt[0,1,2] --\u003e returns T\r\n\r\nThis is more clear. The number of commas in the address is the number of dimensions -1, and the number of : is the dimension of the returned type. Colons must be continuous, which is also easy to asses.\r\n\r\nCapacity:\r\nThe implementation of the type needs to be something like \r\n````\r\nstruct {\r\n    array *T\r\n    length [N]int\r\n    capacity [N]int\r\n    stride [N-1]int\r\n}\r\n````\r\nin order to support views (see my above discussion). The consequence of this is that if len and cap still return an int, both a dims and a capDims are needed. At that point, it's not clear what utility the single return len and cap serve. This is especially true since cap can be computed from the [N]int, and it's not clear what len actually means as far as views are concerned.\r\n\r\nRange:\r\nIf the extra complexity is desired, the \"N\" element range is consistent. The difficulty with it is that there is a tricky difference between\r\n````\r\nfor i, v := range s \r\n````\r\nif s is a []int or a [,]int. Both loop over all of the elements, both return two integers, but v is something very different in the two cases. It seems like this could result in tricky bugs. The same is true for an N dimensional table and an N-1 dimensional []int. I can't speak for other domains, but there is probably at least a 10:1 ratio with \"loop over a single dimension\" vs. \"loop over all elements\". It's not clear to me that the extra complexity and edge case is worth it. \r\n\r\nIn single dimensions range is tricky. Currently range returns a copy of the element in all cases. In your proposal, it instead returns a reference to a subset. No other case works like that. Similarly, under your proposal, it is only possible to range over the \"rows\" of a slice. There does not appear to be a way to range over the columns. Lastly, constructing a table/slice header is significantly enough more expensive  than doing an access, which would likely limit use in real code. For these reasons, it seems to me like my proposal for range is more pragmatic. \r\n\r\nSlice expressions:\r\nIt feels to me like 'reshaping' expressions should look more different than slicing expressions, as the behavior is quite different. Specifically, if I have mistaken a []T for a [,]T, the expression s[:4,:4] returns a [,]T for both cases, and it again seems easy to be wrong and not told otherwise. In go, one generally has to be noisy about changing the type of a piece of data, and this case does not feel like an exception. Some alternatives are:\r\n- reshape([]T, int...) which returns a [,...]T where the number of integers must be \u003e2 and known at compile time.\r\n- []T.([m,n]T) or []T.([m,n,p]T), like an interface assertion, which would return a [,]T with lengths/capacities of [2]int{m,n}.\r\nIn all cases, I would prefer that the expression be a runtime panic of len(T) != m*n(*p), that is, the slice being resized must have the correct length to be resized exactly.\r\n\r\nConclusion:\r\nIt seems like allowing a \"restriding\" behavior as suggested by Ian, and a \"subslicing\" behavior as you suggest make a complete story for multidimensional data. They allow the common case of reshaping []T into some kind of n-d slice, and they allow for copy-free \"views\" of continuous data elements.\r\n\r\nFor the reasons expressed above, I would learn toward adding those features to my proposal, and keeping my semantics for len and range. \r\n\r\nFinding a good syntax for restriding seems to be an open issue.",
	"user": {
		"login": "btracey",
		"id": 3680859,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-18T23:25:13Z",
	"updated_at": "2015-11-18T23:25:13Z"
}
