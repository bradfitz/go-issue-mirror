{
	"id": 158446260,
	"body": "\"but I hope this is something the compiler can easily handle\"\r\n\r\nI'd love to get to that in a timely fashion, but I'm currently attending to the hairy details (signed integer overflow is a thing) of bounds check elimination.\r\n\r\nFrom where I sit the interesting question -- both for performance and for capability -- is whether the last dimension is contiguous or not.  (I think any requirement of row-to-row contiguity is a mistake; I think Dan Kortschak's block-diagonal example is compelling, and fork-join-parallelism generates similarly non-contiguous-row aliased submatrices.)  I'm assuming that people view the potential for aliasing of sub-things as a feature (because they view not-aliasing of sub-things as a performance problem).\r\n\r\nIf you assume that the compiler is doing a modest amount of optimization (and 1.6 does not yet, and 1.7 might not reach this bar) -- and by this I mean\r\n1. recognizing that it does not need to reload stride variables within a loop\r\n2. bounds-check-elimination where obvious\r\n3. reduction-in-strength of indexing operations\r\nthen within iterative-accessing loops, if you happen to have a contiguous last dimension, the cost will be low-to-zero (add loop-invariant register that contains a one versus add constant 1, and in both cases iterative access has the same cache locality).\r\n\r\nWhere this will cost is in compilers that don't yet have that much optimization in them, or for random access to tables.  What would normally be\r\n```table.array[i*table.stride[0] + j]```\r\nwill become\r\n```table.array[i*table.stride[0] + j*table.stride[1]]```\r\n\r\nGiven that random access also requires bounds checks (more or less, sometimes we can get clever with the modulus operator) and given that if it's truly \"random\" there's probably something else going on, plus if it's random and large then it's not in cache, I'm not sure I want to commit to this (premature?) optimization because we're that worried about performance.  There are other optimizations that deal with this cost if it turns out to be widespread and significant -- if it's a hot loop with table.stride[0] == 1, then we multiversion the compiled code.  (This is a more out-there optimization because of costs if applied willy-nilly, but it's not conceptually hard at all -- easier than reduction-in-strength and bounds-check elimination for example)\r\n\r\nIt seems to me that this boils down to a tradeoff between a few features.  On the one hand, we have the ability to represent both row and column-major tables, and to (for example) alias a 1-dimensional table onto the diagonal of a 2-d table.  On the other hand, we have the ability to regard access to the last dimension as if it were access to a slice -- and it could be a slice -- which gives us the ability to reuse some existing slice-handling code.\r\n",
	"user": {
		"login": "dr2chase",
		"id": 1928999,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-20T16:12:05Z",
	"updated_at": "2015-11-20T20:35:22Z"
}
