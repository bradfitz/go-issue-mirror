{
	"id": 158071192,
	"body": "\u003e I do not know what you mean by \"address overloading\". I have left away of the proposal the case of mixing single and multiple indices for brevity.\r\n\r\nI just meant I find the multiple options confusing. I think it's clearer to have the syntax be different for slices of slices and tables, but that could just be me. \r\n\r\n\u003e While cap gives you the total number of elements you are storing, len tells you how many you can actually use. The utility of cap is indeed quite limited, but it is there to let you know if a flat operation will require an allocation or not.\r\n\r\nYes, but the multi-dimensional capacity is there to let you know if a multi-dimensional operation will need an allocation or not. In your example\r\n````\r\nvar a [16]float64\r\nm44 := a[:4,:4]  // {array: a, dim: [4, 4], stride: [4], capacities [4,4]}\r\nm22 := m44[1:3,1:3]  // {array: a[5], dim: [2, 2], stride: [4], capacities [3,3]}\r\n````\r\nFor example, I can now perform\r\n````\r\nm23 := m22[:, :3]  // dim [2,3], capacities[3,3], stride[4]\r\n````\r\nto expand the columns (for instance). The capacities are needed to say if this \"extension slice\" is within bounds. Similar, a multi-dimensional capacity is needed  in order to support 3-element slicing.\r\n\r\n\u003e This case would return two integers in case s is a []int, but not if it is a [,]int. It would return an int and a []int. To get both indices you would use for i, j, _ := range s\r\n\r\nI agree that solves my concern, but I don't think it's tenable. Every other range action has the last element be optional, not required. This would create an inconsistency in the language.\r\n\r\n\u003e To iterate over the elements in the column you would slice a column and iterate over all the elements (for i, _, v := range m[:,nc:nc+1]) or would index in a row\r\n\r\nI think you mean\r\n````\r\nfor _, j, v := range m[:, nc:nc+1]\r\n````\r\nYes, I agree that that does range over a column, I did not see that trick earlier. However, it does not solve the problem highlighted in my proposal which is allowing range to work even for tables of length 0. Here, I have to slice to a particular column, so if there are no columns the operation will panic. If I want to loop over an arbitrary column, I will need something like\r\n````\r\nif len(m)[1] != 0 {\r\n        for _, j, _ := range m[:, 0:1]\r\n}\r\n````\r\nThis may not be as big of a problem in your range syntax as you can range over a row without worry, i.e. something like\r\n````\r\nfor i := range m {\r\n   for _, j, _ := range m[:, i:i+1] {\r\n````\r\nloops over every column row-wise and works for any since. I'm not sure, especially since enabling this requires both range syntaxes. \r\n\r\n\u003e The problems here are the same as when we do a[:5] and a can be an array or a slice.\r\n\r\nIt's true, but a slice is already a sliced array. For both arrays and slices, a[:5] gives you the first 5 elements of that entity, and thus has the same conceptual meaning.  With s[:4,:4],  if s is a slice it gives you all of the same elements, just now in a different looking form. If s is already a table, it gives you a shorter or longer view of the elements. The operations are conceptually different, even though there is overlapping syntax. ",
	"user": {
		"login": "btracey",
		"id": 3680859,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-19T14:21:02Z",
	"updated_at": "2015-11-19T14:21:19Z"
}
