{
	"id": 229813520,
	"body": "Agreed there. That is exactly why I would  propose non-gc memory management\nas a workaround for situations where this illusion is undesirable or even\ndangerous.\nOn 1 Jul 2016 12:57 am, \"Dave Cheney\" \u003cnotifications@github.com\u003e wrote:\n\n\u003e Fundamentally, the role of a garbage collector is to present to the\n\u003e programmer the illusion of an infinite free store.\n\u003e\n\u003e If that illusion is broken, is seems reasonable to abort the program.\n\u003e\n\u003e \u003e On 1 Jul 2016, at 08:42, Beoran \u003cnotifications@github.com\u003e wrote:\n\u003e \u003e\n\u003e \u003e Fundamentally, the whole point of a garbage collector is that the\n\u003e programmer doesn't have to worry about allocating nor freeing memory. The\n\u003e problem is that a garbage collector can't do anything sensible when it runs\n\u003e out of memory except trying a sweep. If that fails, there's no way to\n\u003e decide what to do since the allocation that failed could have come from\n\u003e anywere.\n\u003e \u003e\n\u003e \u003e The only way to avoid this is to allocate and free the memory manually.\n\u003e I could imagine the unsafe package gaining a few extra functions to do\n\u003e this, such as unsafe.Allocate(), unsafe.Free().\n\u003e \u003e\n\u003e \u003e —\n\u003e \u003e You are receiving this because you are subscribed to this thread.\n\u003e \u003e Reply to this email directly, view it on GitHub, or mute the thread.\n\u003e \u003e\n\u003e\n\u003e —\n\u003e You are receiving this because you commented.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/14162#issuecomment-229811645\u003e, or mute\n\u003e the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe/AAEWeRNkmh5bPXlQ1QwVKtaMjeaD0dPWks5qREmsgaJpZM4HP1lM\u003e\n\u003e .\n\u003e\n",
	"user": {
		"login": "beoran",
		"id": 71289,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-06-30T23:06:22Z",
	"updated_at": "2016-06-30T23:06:22Z"
}
