{
	"id": 229811645,
	"body": "Fundamentally, the role of a garbage collector is to present to the programmer the illusion of an infinite free store.\n\nIf that illusion is broken, is seems reasonable to abort the program.\n\n\u003e On 1 Jul 2016, at 08:42, Beoran \u003cnotifications@github.com\u003e wrote:\n\u003e \n\u003e Fundamentally, the whole point of a garbage collector is that the programmer doesn't have to worry about allocating nor freeing memory. The problem is that a garbage collector can't do anything sensible when it runs out of memory except trying a sweep. If that fails, there's no way to decide what to do since the allocation that failed could have come from anywere.\n\u003e \n\u003e The only way to avoid this is to allocate and free the memory manually. I could imagine the unsafe package gaining a few extra functions to do this, such as unsafe.Allocate(), unsafe.Free().\n\u003e \n\u003e â€”\n\u003e You are receiving this because you are subscribed to this thread.\n\u003e Reply to this email directly, view it on GitHub, or mute the thread.\n\u003e \n",
	"user": {
		"login": "davecheney",
		"id": 7171,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-06-30T22:55:46Z",
	"updated_at": "2016-06-30T22:55:46Z"
}
