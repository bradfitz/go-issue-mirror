{
	"id": 67309028,
	"body": "1. Right. As of 1.4 any X86 platform without AESNI and all other platforms are vulnerable.\r\n\r\n2. I want to say up front that I am not a crypto hacker.\r\n\r\n3. The guarantee I am referring to is that some effort was expended to give the X86 platforms with AESNI a cryptographic based hash used in the implementation  of map. That means it's much harder, if not impossible, to generate a (large) set of keys that produce identical hashes.  \r\n\r\n4. The primary concern here is \"hash-flooding DoS\" attacks that drive an map/hash table insert of N items from O(N) to O(N^2). See the slides in #3, the code there, and read these:\r\nhttp://www.rootsecure.net/content/downloads/pdf/dos_via_algorithmic_complexity_attack.pdf\r\nhttps://131002.net/siphash/siphash_slides.pdf\r\n\r\n5. Note the last paper was written in 2003. These attacks have been known for a long time and just ignored. Differential cryptanalysis was \"discovered\" in the 1980's, known to IBM since 1974, and known to the NSA before that. So the basis for these attacks is at least 45+ years old! See the Wikipedia.\r\n\r\n6. If you read my OP there is a pointer to:\r\nhttps://131002.net/siphash/\r\nOn that page note \"C++ program to find universal (key-independent) multicollisions for CityHash64\"\r\nRun the program and see how trivial it is to generate multi collisions. It's a very portable piece of C code. You type \"make\" and it just compiles. Let me do it for you:\r\n\r\n    leb@hula:~/gotest/src/github.com/tildeleb/hashland/citycollisions % make\r\n    g++ citycollisions.cc city.cc -o citycollisions -O3\r\n    g++ citycollisions.cc city.cc -o citycollisions_ascii -DASCII -O3\r\n    leb@hula:~/gotest/src/github.com/tildeleb/hashland/citycollisions % ./citycollisions 4 \r\n    128-bit key 1e20798f100c668c499d50fb660caabc\r\n    CityHash64( 8e69324ad2a005ff2148534148202020, 16 ) = b85d70a55a402013\r\n    CityHash64( 7ae31886221136ba2148534148202021, 16 ) = b85d70a55a402013\r\n    CityHash64( a9a6b9c6888e94ff2148534148202022, 16 ) = b85d70a55a402013\r\n    CityHash64( 85fdcf8310e3e9552148534148202023, 16 ) = b85d70a55a402013\r\nthe program runs instantly and will generate as many collisions as you need.\r\n\r\n7. I am sure that khi's algorithm which is based on CityHash and XXHash is subject to the same differential crypto attacks used against Murmur3 and CityHash but I can't generate such an attack myself (yet).\r\n\r\n8. Google must have some cryptographers on staff. The AESNI hash functions used by map should be reviewed and vetted by someone with crypto credentials and then peer reviewed. The `Hash32()` and `Hash64()` variants only do 3 rounds using 2 alternating rounds keys. That's not many rounds. `Hash()` and `HashStr()` do a variable number of rounds based on the key length with a minimum of 5 rounds, again using 2 alternating round keys. It might be that more rounds or more round keys are called for, More rounds will slow it down. Adding more rounds keys probably won't delta cache effects which I wouldn't expect for small deltas of more round keys.\r\n\r\n9. While I don't have the numbers to back it up yet I suspect that SipHash with assembler benchmarks very close to AESNI on the same machines. If that's the case, I think I still vote for SIpHash over AES with special instructions.",
	"user": {
		"login": "tildeleb",
		"id": 834628,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-12-17T11:19:25Z",
	"updated_at": "2014-12-17T11:26:55Z"
}
