{
	"id": 162338740,
	"number": 16186,
	"state": "closed",
	"title": "Instead of dreaming about Generics, why not improve the existing system of types?",
	"body": "Below is my thoughts about that problem/\r\nThe term `desugaring` means a valid source code in the Go language of the current version.\r\nThe names of built-in functions are `fictitious` and are only for the understanding of the operation of the algorithm.\r\n\r\n```go\r\nvar a [6]int\r\nvar s []int\r\nvar m map[string]int\r\n```\r\n\r\n```go\r\n// [6] - Array with length 6\r\n// int - Element type\r\nvar a [6]int\r\n```\r\n\r\n```go\r\n// [] - Array without length (slice)\r\n// int - Element type\r\nvar s []int\r\n```\r\n\r\n```go\r\n// map - Type specifier `map`\r\n// [string] - Key type `string`\r\n// [int] - Element type `int`\r\nvar m map[string]int\r\n```\r\n\r\n```go\r\n// Foo - Type specifier `Foo`\r\n// [string, int] - Arguments types `string` and `int`\r\nvar foo Foo[string, int]\r\n```\r\n\r\nAssume we want implement alternative to `slice` and use it similar to use the slice:\r\n\r\n```go\r\nvar slice []int\r\nvar alternative Slice[int]\r\n```\r\n\r\n```go\r\n// Syntactic sugar\r\n// This type cannot be instantiated w/o type arguments\r\ntype Slice[E] struct {\r\n  slice []E\r\n  some  bool\r\n}\r\n```\r\n\r\n```go\r\n// Desugaring\r\ntype Slice struct {\r\n  slice []interface{}\r\n  some  bool\r\n}\r\n\r\n```\r\n\r\n```go\r\n// Syntactic sugar\r\n// The `XYZ` is a name (identifier) of the type parameter\r\n// for the method `NewSlice` (it also has an index '0')\r\nfunc NewSlice[XYZ](length int) *Slice[XYZ] {\r\n  // Syntactic sugar\r\n  s := \u0026Slice[XYZ]{}\r\n\r\n  // Syntactic sugar\r\n  s.slice = make([]XYZ, length)\r\n\r\n  s.some = some\r\n return s\r\n}\r\n```\r\n\r\n```go\r\n// Desugaring\r\nfunc NewSlice(typeArgs []*_type, length int) *Slice {\r\n\r\n  // s := \u0026Slice[XYZ]{}\r\n  __typ0 = make_parametrized_type((*_type)(Slice), typeArgs[0])\r\n  s := newobject(__typ0)\r\n\r\n  // s.slice = make([]XYZ, length)\r\n  __typ1 = make_slice_type(typeArgs[0]) // typeArgs[0] is `elem type`\r\n  s.slice = make_slice_by_elem_type(__typ1, length)\r\n\r\n  s.some = some\r\n  return s\r\n}\r\n```\r\n\r\nThe '[]' is not valid identifier but must be allowed in the method declaration name.\r\n\r\n```go\r\n// Syntactic sugar\r\n// The `E` is a name of the first type parameter of `Slice`\r\n// and available in the method of the receiver of the type `Slice`\r\nfunc (s *Slice) [](index int) E {\r\n  return s.slice[index]  \r\n}\r\n```\r\n\r\n```go\r\n// Desugaring\r\n// This is a method of the parametrized type `Slice` and it must\r\n// be able to return the value of any type.\r\n// So we always using `interface{}` to return value of any type\r\n// This is often called as the `boxing` value\r\n//\r\n// This means that the compiler should after a return silently\r\n// unbox a value\r\nfunc (s *Slice) [](index int) interface{} {\r\n  return s.slice[index] // Value was `boxed` automatically\r\n}\r\n```\r\n\r\nThat is, after the call:\r\n\r\n```go\r\nvar data Slice[int]\r\n// ...\r\n// Syntactic sugar\r\ni := data[5]\r\n```\r\n\r\n```go\r\n// Desugaring\r\n// Type of the 'i' was obtained from the above source code\r\nvar i int\r\n// Pseudo code for call method '[]'\r\n__temp0 := data.[](5)\r\nunbox(__temp0, \u0026i)\r\n```\r\n\r\nAnd also, as example:\r\n\r\n```go\r\n// Syntactic sugar\r\nfunc (s *Slice) []=(index int, val E) {\r\n  // This is only for the code complexity\r\n  var v E\r\n  v = val\r\n  s.slice[index] = v\r\n}\r\n```\r\n\r\n```go\r\n// Desugaring\r\nfunc (s *Slice) []=(index int, val interface{}) {\r\n  // Begin of the `type safety block`\r\n\r\n  // Obtain the receiver type\r\n  // Eg. Slice with typeArgs is [string], that is Slice[string]\r\n  __typ0 := elem_type_of_receiver_ptr(s)\r\n\r\n  // Validate every method argument with the receiver type arguemnts\r\n  // In our case this is a paramater `val E`\r\n  validate_argument_by_type_arg(val, __typ0.typeArgs[0])\r\n\r\n  // End of the `type safety block`\r\n\r\n  var v interface{}\r\n  v = val\r\n  s.slice[index] = v\r\n}\r\n```\r\n\r\nAnd other similar procedures...\r\n\r\nP.S.\r\n\r\nIf this is impossible then why?\r\n- There are no resources\r\n- There is no need\r\n- It is a heresy\r\n\r\nI don't think the the following procedures are very bad in the reusable parameterized methods:\r\n- unbox\r\n- elem_type_of_receiver_ptr\r\n- validate_argument_by_type_arg\r\n- make_slice_type\r\n- make_slice_by_elem_type\r\n- make_parametrized_type\r\n- etc\r\n\r\nAlso what can be wrong with the following type notation?\r\n\r\n```go\r\nvar foo Foo[string, int, bool]\r\n```\r\n\r\nSorry, for the mistakes in the examples that can found.",
	"user": {
		"login": "mezoni",
		"id": 2311549,
		"type": "User",
		"site_admin": false
	},
	"comments": 3,
	"closed_at": "2016-06-26T20:02:19Z",
	"created_at": "2016-06-26T17:51:39Z",
	"updated_at": "2016-06-27T15:38:54Z",
	"reactions": {
		"total_count": 1,
		"+1": 1
	}
}
