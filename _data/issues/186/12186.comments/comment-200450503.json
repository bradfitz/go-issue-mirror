{
	"id": 200450503,
	"body": "If //binary (maybe //go:nobuild or something) is seen then the .a file is\nnever rebuilt.  Period.  You as the vendor would have source code that does\nnot have //binary in it.  Presumably you would have a release mechanism\nthat built the release with the .go files with //go:nobuild.\n\nYou could also include documentation so godoc would continue to provide\nsomething useful.\n\nPerhaps your source is\n\n// Package mine does my stuff\npackage main\n\n// Data contains something.\ntype Data struct {\n        Stuff string\n}\n\n// Result contains a result.\ntype Result struct {\n        OtherStuff string\n}\n\n// MySecretSauce returns an incredible transformation of x, or an error\nfunc MySecretSauce(x *Data) (*Result, error) {\n        code we dont want to release\n        ...\n}\n\n// internalRoutine is something you don't need to know about\nfunc internalRoutine(x *Data, r *Result) error {\n        code we dont want to release\n        ...\n}\n\n\nYou might release a source file of:\n\npackage main\n//go:norbuild\n\n\nOr perhaps something with documentation:\n\n// Package mine does my stuff\npackage main\n\n// go:nobuild\n\n// Data contains something.\ntype Data struct {\n        Stuff string\n}\n\n// Result contains a result.\ntype Result struct {\n        OtherStuff string\n}\n\n// MySecretSauce returns an incredible transformation of x, or an error\nfunc MySecretSauce(x *Data) (*Result, error) {\n        return nil, nil\n}\n\n\nIn any event, the .go file is purely informational and the Go command will\nnever try to build a package with //go:nobuild in the source (even if the\n.a file is missing).  The .go file would still need to be a legitimate Go\nfile.\n\nThis is only one of many possible ways to indicate to the compiler that\nthis is a binary release and should not be built.\n\nOn Tue, Mar 22, 2016 at 8:38 AM, Benoit Sigoure \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e When //binary is found on a package, what do you envision the expected\n\u003e behavior of the Go compiler to be? If the .a needs to be rebuilt and the\n\u003e sources are available, it builds them and puts a special annotation in the\n\u003e .a, such that if it thinks it needs to rebuild the .a but the existing .a\n\u003e has that annotation it doesn't actually try to rebuild it? Is that along\n\u003e the lines of what you had in mind?\n\u003e\n\u003e â€”\n\u003e You are receiving this because you commented.\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/12186#issuecomment-199870050\u003e\n\u003e\n",
	"user": {
		"login": "pborman",
		"id": 5115933,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-03-23T17:23:46Z",
	"updated_at": "2016-03-23T17:23:46Z"
}
