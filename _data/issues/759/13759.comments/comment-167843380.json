{
	"id": 167843380,
	"body": "Here is one approach that doesn't perturb the GC and its data structures\nvery much and focuses the additional work only on objects with a proven\npartial deadlock after eliminating all objects not involved in such cycles.\n\nDistinguish all objects being waited on and their associated Goroutines. Do\nnot mark and trace these Goroutine's roots. Otherwise perform the normal\ntransitive mark to completion. Inspect the waited on object and the\nassociated Goroutine one at a time. If the object is marked, it is\nreachable from an unblocked Goroutine. Trace the objects reachable from the\nGoroutine associated with the marked blocking object. This is repeated\nuntil all non perma-blocked Goroutines are discovered and traced.\nCorrectness, completion, and termination proofs could probably be based on\nthe various distributed termination proofs in the literature.\n\nAt this point untraced Goroutines are blocked on objects that are only\nreachable from perma-blocked Goroutines. Furthermore the objects involved\nin the interesting dependencies are reachable yet unmarked at this point.\nThis focuses the work on the interesting objects and interesting Goroutines.\n\nThese Goroutines and associated objects are revealed to the user.\nConstructing the who depends on whom graph could also happen but I haven't\nthought that through completely.\n\nTo continue trace the perma-blocked Goroutines and finish the GC cycle.\n\nThis approach solves the problem of having to maintain all paths to the\nblocked object. All the algorithm needs is to know that there is at least\none non-local path to the blocking object from a non perma-blocked\nGoroutine and this approach provides that single bit of information.\n\nUsing GC for these types of things is a great idea.\n\n\n\n\n\n\n\n\n\nOn Mon, Dec 28, 2015 at 7:26 PM, Richard Fliam \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e The Proposal\n\u003e\n\u003e Deadlock's make programs fail. Partial deadlocks (where a subset of the\n\u003e goroutines in a system are deadlocked) are difficult to find and debug.\n\u003e While predicting the occurrences of these deadlocks is not computable,\n\u003e detecting them when they occur is. Adding in a partial deadlock detector\n\u003e would be a powerful tool in debugging our concurrent programs.\n\u003e\n\u003e Like the race detector, a flag-able deadlock detector would use\n\u003e environment variables to log, or exit on detected deadlocks. The deadlock\n\u003e detector would *not* detect all deadlocks, or potential deadlocks, only a\n\u003e subset of those that are occurring.\n\u003e\n\u003e The goal of this proposal is to see if such a feature is desirable, and\n\u003e present a plausible implementation. If it is desirable a detailed design\n\u003e doc will follow.\n\u003e Is this the Halting Problem?\n\u003e\n\u003e No. If the necessary conditions are met\n\u003e \u003chttps://en.wikipedia.org/wiki/Deadlock#Necessary_conditions\u003e the program\n\u003e will not continue.\n\u003e Proposed Implementation High Level\n\u003e\n\u003e In short the proposed implementation is to \"hook\" into the garbage\n\u003e collector, and use it's mark phase to build a wait-for graph\n\u003e \u003chttps://en.wikipedia.org/wiki/Wait-for_graph\u003e. Then use Tarjan's\n\u003e algorithm\n\u003e \u003chttps://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\u003e\n\u003e to find deadlock cycles. That is the strongly connect components with no\n\u003e edges to non deadlocked components.\n\u003e More Detailed\n\u003e\n\u003e As go uses a *mark-sweep* garbage collector most of the computationally\n\u003e expensive work necessary for dead lock detection is *already being done*.\n\u003e Here is how the proposed detector would work (in very high level terms):\n\u003e\n\u003e    1. At the beginning of the mark phase all goroutines in a wait state\n\u003e    are examined, along with the object they are waiting on.\n\u003e    2. As objects are marked (colored black or gray) from the various\n\u003e    roots, if the object is one one of the \"waited on\" resources, it can be\n\u003e    added as an edge in our wait for graph.\n\u003e    3. Any resource which is not referenced from another root will be\n\u003e    added as an edge to a \"nothing\" node.\n\u003e    4. At the end of the mark phase (e.g. post stop the world) run\n\u003e    Tarjan's (or similar) to determine the strongly connected components.\n\u003e    5. If we have a strongly connected component with no edges to a non\n\u003e    deadlocked component, the involved goroutines are deadlocked.\n\u003e\n\u003e Notes\n\u003e\n\u003e I have intentionally glossed over:\n\u003e\n\u003e    - Dealing with timers (interruptible waits) and globally referenced\n\u003e    resources\n\u003e    - That an object referenced by multiple roots may contain a reference\n\u003e    to a waited on object in another root (paths to the waited on object would\n\u003e    have to be stored and examined when previously colored nodes are addressed)\n\u003e    - Send and receive mechanics on channels for simplicity's sake.\n\u003e\n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/13759\u003e.\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-29T17:52:59Z",
	"updated_at": "2015-12-29T17:52:59Z"
}
