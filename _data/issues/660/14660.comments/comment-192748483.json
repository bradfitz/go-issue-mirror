{
	"id": 192748483,
	"body": "This is maybe a bit out of place for this particular issue, but I think it would be worth considering a different Context implementation ([strawman benchmark]( https://gist.github.com/riannucci/4bbf625872d33648ed49)) before it gets included in the stdlib.\r\n\r\nIn that benchmark, I compare a bogus map+lock \"caching\" context implementation to the default implementation. Even with as few as 10 items, there's a noticeable improvement (%-wise, not in absolute terms. I realize we're talking nanoseconds here) on lookups into the cached version. For contexts deeper than 10 items, there's a noticeable improvement. The construction overhead is similar, but I think with a non-bogus implementation the map version could be even faster for overhead than the linked list one.\r\n\r\nI think there's an opportunity to have Context be a *struct-with-hidden-fields instead of an interface, which would afford the opportunity to build a faster implementation of it (e.g. by having .WithValue be a struct method instead of a package method that can be smart about chaining, or a .WithValues to avoid the linked-list-building overhead when adding multiple items to the context at the same time) and by possibly adding a .Compact method to compactify an existing Context to make subsequent lookups fast. It's not possible to build these things in a clean fashion with the current interface-based implementation (since the only way for the context to see up the chain is to actually do lookups, and the only way to know the lookup keys is to wait for some user code to provide them).\r\n\r\nI'm mostly thinking about the pattern of:\r\n\r\n```go\r\nfunc MyHTTPHandler(rw ResponseWriter, r *Request) {\r\n  c := context.Background()\r\n  // WithValue 10-30 services/contextful things here... this number will likely grow\r\n  // as context becomes even more prevalently used.\r\n\r\n  // 100's of lookups into c here... if it were compacted here then all the lookups\r\n  // would be O(1).\r\n  myActualHandler(c, rw, r) \r\n}\r\n```\r\n\r\nWhich, I think, is a pretty common pattern (I don't have data on hand for this assumption, however).\r\n\r\nIn general, for most stdlib-type libraries, there would simply be competition for the best implementation. But I think that the community is rallying around a single Context implementation (because it's THE way to build composable/stackable libraries which are loosely coupled). There can't really be an alternate implementation that doesn't stem from the stdlib (or `x/`) that has any hope for survival (since everything needs to adopt the stdlib one to actually be used by anything). To be clear: I think it's GOOD for the community to standardize here, I just think it might be worth considering a slightly speedier implementation before cooking it into the `1.x` API compatibility guarantee.\r\n\r\nNote that the `WithTimeout` and `WithDeadline` package functions are well-served by the interface implementation right now: it allows e.g. mocking of the clock. Some similarly mockable interface would need to be built for that functionality, but AFAIK that mocking requirement doesn't really apply to WithValue.\r\n\r\nedit: typo",
	"user": {
		"login": "riannucci",
		"id": 133821,
		"type": "User",
		"site_admin": false
	},
	"reactions": {
		"total_count": 2,
		"+1": 2
	},
	"created_at": "2016-03-05T21:49:46Z",
	"updated_at": "2016-03-06T07:22:09Z"
}
