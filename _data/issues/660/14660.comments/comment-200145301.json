{
	"id": 200145301,
	"body": "My main concern here is presenting clear advice about structs. The standard library should demonstrate the idiomatic best practices for using context, or else no one else will use context idiomatically either. That said, I do agree with Brad that - if done clearly - we can relax the struct prohibition a bit.\r\n\r\nBrad wrote:\r\n\r\n\u003e While we've told people not to add contexts to structs, I think that guidance is over-aggressive. The real advice is not to store contexts. They should be passed along like parameters. But if the struct is essentially just a parameter, it's okay. I think this concern can be addressed with package-level documentation and examples.\r\n\r\nI think this is correct. net.Dialer and exec.Cmd are clearly \"parameter structs\" in that from the start they contained things that only made sense for a single operation (Deadline for net.Dialer, results like Process for exec.Cmd).\r\n\r\nFor sql.DB, overloading the args ...interface{} list seems pretty hacky, but the alternative is a whole new parallel API, which is almost as bad. If we're going to do that, though, it seems like maybe it should be the last arg instead of the first. At least then any references to positional arguments continue to use the same indexes, and it avoids the context being a middle argument in calls to functions that take 'query string, args ...interface{}'.\r\n\r\nLet's leave os.File out of it for now. Most operating systems don't support timeouts on file reads anyway, and os.File.IO seems very clearly _storage_ of a context.\r\n\r\nA field 'Context context.Context' is fine. I do wonder if maybe Context should be in package io. I've suggested this before but I don't remember if there was a reason it can't be done. It's not about reader/writer io but it's certainly almost always some kind of input or output operation, and io.Context is not so stuttery.\r\n\r\nThe biggest problem is going to be http.Request. Once you know that Contexts must only be passed in parameter-like structs, that implies http.Request must be a parameter-like struct and so the answer to @kr's excellent question has to be that you make a shallow copy of the entire request to pass along a different context, as Brad said. I think this will surprise people. It's actually already the case that http.Request is parameter-like and that programs should only be modifying copies of the http.Request, not the original, but Context will make that even more important, and it will be a surprise. It will need very clear documentation.\r\n\r\nBut it seems OK to go forward with. I had been hoping to ask @Sajmani what his thoughts were in person, but I have not gotten a chance yet. So I will ask here: Sameer, how does this all look to you?\r\n\r\nThanks. \r\n\r\nP.S. I wonder if we should employ the race detector here as well. When run under the race detector, the http server could kick off two goroutines for each request instead of one. Specifically, serverHandler.ServeHTTP could replace:\r\n\r\n        handler.ServeHTTP(rw, req)\r\n\r\nwith\r\n\r\n        var c chan http.Request\r\n        if raceEnabled {\r\n                c = make(chan http.Request)\r\n                go func() {\r\n                        c \u003c- *req\r\n                }()\r\n        }\r\n        handler.ServeHTTP(rw, req)\r\n        if raceEnabled {\r\n                \u003c-c\r\n        }\r\n\r\nIt's a little heavy but so is the race detector generally. The coordination on the channel makes sure that when serverHandler.ServeHTTP returns there are no pending uses of the request, but the copying of the request into the channel will conflict with any write to a field of req during handler.ServeHTTP, which should report races in handles that overwrite the original req's Context field (or others). In practice some fields are OK to write (for example fields lazily initialized, like FormValues), so this exact code won't work but the general idea of reading from unmodifiable fields in a separate goroutine under the race detector seems like it should be able to serve as a mechanical check that people are doing the right thing. Of course any common middleware layers that already make their own copies of an http.Request and then pass that further down the chain would need to add this pattern too. I don't know of any instances of that in the standard library.",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-03-23T03:00:24Z",
	"updated_at": "2016-03-23T03:00:24Z"
}
