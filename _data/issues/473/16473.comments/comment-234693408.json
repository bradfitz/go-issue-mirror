{
	"id": 234693408,
	"body": "This appears to be a portability problem in the C code that was added in https://golang.org/cl/20351.  This pure C program fails with a segmentation violation at the same point (when calling `CFEqual`).\r\n\r\nCC @hinman \r\n\r\nI don't know what this code does and I don't plan to look at this further.\r\n\r\n    #include \u003cstdio.h\u003e\r\n    #include \u003cCoreFoundation/CoreFoundation.h\u003e\r\n    #include \u003cSecurity/Security.h\u003e\r\n\r\n    int FetchPEMRoots(CFDataRef *pemRoots) {\r\n\t    // Get certificates from all domains, not just System, this lets\r\n\t    // the user add CAs to their \"login\" keychain, and Admins to add\r\n\t    // to the \"System\" keychain\r\n\t    SecTrustSettingsDomain domains[] = { kSecTrustSettingsDomainSystem,\r\n\t\t\t\t\t\t kSecTrustSettingsDomainAdmin,\r\n\t\t\t\t\t\t kSecTrustSettingsDomainUser };\r\n\r\n\t    int numDomains = sizeof(domains)/sizeof(SecTrustSettingsDomain);\r\n\t    if (pemRoots == NULL) {\r\n\t\t    return -1;\r\n\t    }\r\n\r\n\t    CFMutableDataRef combinedData = CFDataCreateMutable(kCFAllocatorDefault, 0);\r\n\t    for (int i = 0; i \u003c numDomains; i++) {\r\n\t\t    CFArrayRef certs = NULL;\r\n\t\t    // Only get certificates from domain that are trusted\r\n\t\t    OSStatus err = SecTrustSettingsCopyCertificates(domains[i], \u0026certs);\r\n\t\t    if (err != noErr) {\r\n\t\t\t    continue;\r\n\t\t    }\r\n\r\n\t\t    int numCerts = CFArrayGetCount(certs);\r\n\t\t    for (int j = 0; j \u003c numCerts; j++) {\r\n\t\t\t    CFDataRef data = NULL;\r\n\t\t\t    CFErrorRef errRef = NULL;\r\n\t\t\t    SecCertificateRef cert = (SecCertificateRef)CFArrayGetValueAtIndex(certs, j);\r\n\t\t\t    if (cert == NULL) {\r\n\t\t\t\t    continue;\r\n\t\t\t    }\r\n\t\t\t    // We only want to add Root CAs, so make sure Subject and Issuer Name match\r\n\t\t\t    CFDataRef subjectName = SecCertificateCopyNormalizedSubjectContent(cert, \u0026errRef);\r\n\t\t\t    if (errRef != NULL) {\r\n\t\t\t\t    CFRelease(errRef);\r\n\t\t\t\t    continue;\r\n\t\t\t    }\r\n\t\t\t    CFDataRef issuerName = SecCertificateCopyNormalizedIssuerContent(cert, \u0026errRef);\r\n\t\t\t    if (errRef != NULL) {\r\n\t\t\t\t    CFRelease(subjectName);\r\n\t\t\t\t    CFRelease(errRef);\r\n\t\t\t\t    continue;\r\n\t\t\t    }\r\n\t\t\t    Boolean equal = CFEqual(subjectName, issuerName);\r\n\t\t\t    CFRelease(subjectName);\r\n\t\t\t    CFRelease(issuerName);\r\n\t\t\t    if (!equal) {\r\n\t\t\t\t    continue;\r\n\t\t\t    }\r\n\r\n\t\t\t    // Note: SecKeychainItemExport is deprecated as of 10.7 in favor of SecItemExport.\r\n\t\t\t    // Once we support weak imports via cgo we should prefer that, and fall back to this\r\n\t\t\t    // for older systems.\r\n\t\t\t    err = SecKeychainItemExport(cert, kSecFormatX509Cert, kSecItemPemArmour, NULL, \u0026data);\r\n\t\t\t    if (err != noErr) {\r\n\t\t\t\t    continue;\r\n\t\t\t    }\r\n\r\n\t\t\t    if (data != NULL) {\r\n\t\t\t\t    CFDataAppendBytes(combinedData, CFDataGetBytePtr(data), CFDataGetLength(data));\r\n\t\t\t\t    CFRelease(data);\r\n\t\t\t    }\r\n\t\t    }\r\n\t\t    CFRelease(certs);\r\n\t    }\r\n\t    *pemRoots = combinedData;\r\n\t    return 0;\r\n    }\r\n\r\n    int main() {\r\n      CFDataRef data = NULL;\r\n      FetchPEMRoots(\u0026data);\r\n      printf(\"%p\\n\", data);\r\n    }\r\n",
	"user": {
		"login": "ianlancetaylor",
		"id": 3194333,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-23T02:14:06Z",
	"updated_at": "2016-07-23T02:14:06Z"
}
