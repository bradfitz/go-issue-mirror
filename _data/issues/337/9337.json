{
	"id": 52073087,
	"number": 9337,
	"state": "open",
	"title": "cmd/compile: enhancements to the gc inliner and optimizer",
	"body": "**Background**\r\nI recently tried optimizing some hash functions in Go to find out what is possible without resorting to using assembler. I knew gc had an \"inliner\" but I didn't have any experience with it. I spent some time reading the \"inl.c\" code.\r\n\r\n**Summary**\r\nGo's inliner seems to work well and I got speed increase of 30% on some hash functions using it. However, the way it is currently configured and controlled effectively turns if off for most cases. Most users won't figure out how to set the `level` (-gcflags=\"-l -l -l -l -l -l -m\") and even less will be willing to recompile the tool chain to change the *hard coded* `hairiness` variable set to more than 40. The inliner would be more effective if it could handle closures and variadic functions. Finally, a simple idiom recognizer would allow a simple function such as `rot()` to be turned into a single instruction. Taken together these  changes could yield significant performance improvements to certain kinds of Go packages.\r\n\r\nHere are my impressions, suggestions, and requests:\r\n\r\nA simple code example is here, it's just one one Jenkin's Hash functions:\r\nhttps://play.golang.org/p/rmDG7MR5F9\r\nThis comes from:\r\nhttps://github.com/tildeleb/hashland/blob/master/jenkins/jenkins.go\r\nThe main project is:\r\nhttps://github.com/tildeleb/hashland/\r\n\r\n**Observations and Impressions**\r\n1. The inliner works pretty well but you need to add the following flags to build to get it work:\r\n`go build -gcflags=\"-l -l -l -l -l -l -m\"`\r\n\r\n2. .The inliner has  budget for the complexity of functions it is willing to inline. The variable is called `hairiness`. It is current set to 40 and that's not very hairy. In the example above. I had to break `mix()` and `final()` into 3 functions of two lines each, to get them to inline. 40 really seems like a very small budget to me. Hard coding a parameter like this is just wrong.\r\n\r\n3. Currently closures can't be inlined. Using the example above, that means the closures `mix()` and `final()` which close over the hash state variables a, b, and c need to moved out of the function \"HashWords\". Since the state variables a, b, and c are lo longer closed over they need to be passed to and returned from the `mix()` and `final() functions`. For example:\r\n`a, b, c = mix(a, b, c)`. If all hash functions had 3 state variables that might be OK.\r\n\r\nHowever, other more advanced hash functions have more state. For example in Jenkin's SpookyV2 I had to write:\r\n`h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11 = Mix(inul, h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11)`\r\n\r\nWhich I hope we can all agree is out of control and is why I believe why closures are the preferred solution to many inlining based use cases.\r\n\r\nThe downside of the closures is that if you have multiple versions of a hash function that use the same mix() and final() code, those closures need to be duplicated inside the top level functions.\r\n\r\nAgain, I prefer the closures. The source code is cleaner, easier to read, and probably easier to optimize because the optimizer doesn't need to optimize out the calling and return stack push/pop sequences to get good code quality.\r\n\r\n4. Go needs an idiom recognizer. Consider the example again. The function `rot(x, k)` gets inlined but it doesn't generate a rot insturction. Other compilers are able to do this. Actually, I think a case can be made to add a rotate (no carry)  operator (`\u003e\u003e\u003e` or `\u003c\u003c\u003c`) to the language for this particular case, but that's another \"issue\" as they say. BTW Go generates about 22 instructions to get the rotate done.\r\n\r\n5. Variadic functions aren't inlined. I am considering proposing the following as a new interface for hash functions that would be complementary to the current hash streaming interface.\r\n\r\n\t`Hash32(b []byte, seeds ...uint32) uint32`  \r\n\t`Hash64(b []byte, seeds ...uint64) uint64`  \r\n\t`Hash128(b []byte, seeds ...uint64) (uint64, uint64)`  \r\n\t`Hash(in []byte, out []byte, seeds ...uint64) []byte`  \r\n\r\nBecause of this I would like to see inlining of variadic functions.\r\n\r\nFWIW I still have to benchmark this vs other alternative calling sequences.\r\n\r\n**Suggestions**\r\n\r\n1. Increase the default \"hairiness\" from 40. 40 really isn't very much. Set the default \"level\" to a value higher that 0 or 1.\r\n\r\n2. Optimizer command line flags.\r\nIn the short term add temporary native command line flags to set `hairiness` and `level.` I know the Go team eschews command line flags but some control over the optimization process has been around since the unix epoch and is probably inevitable.\r\n\r\nFor example:\r\n`% go build -ilbudget=120 illevel=6`\r\n\r\n3. Extend the inliner to inline closures and variadic functions.\r\n\r\n4. Over the medium term add a simple idiom recognizer so common idioms such as `rot` in the example above can be turned into single instructions, really (2-3 instructions counting the `MOVQ` to the registers instead of the 20+ now generated to get a rot.\r\n\r\n5. Consider adding a rot operator to the language.",
	"user": {
		"login": "tildeleb",
		"id": 834628,
		"type": "User",
		"site_admin": false
	},
	"comments": 23,
	"created_at": "2014-12-16T04:42:20Z",
	"updated_at": "2016-04-25T19:13:50Z",
	"milestone": {
		"id": 1055141,
		"number": 6,
		"title": "Unplanned"
	}
}
