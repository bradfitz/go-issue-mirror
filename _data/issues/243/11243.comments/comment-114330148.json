{
	"id": 114330148,
	"body": "Here is a small patch base on tip commit 71859efceb21a3f8098716ad8cf0964571be7bc5, only tested in ubuntu vivid amd64. It offer GetAffinity/SetAffinityAddAffinity for setup affinity of one pid(thread id in multi-thread process) and new field \"Affinitys   []int\" in type SysProcAttr struct to setup affinity when using os/exec.Cmd. Hope this get Go better.\r\n\r\nhttp://play.golang.org/p/EUUhXsOudU\r\n```\r\npackage main\r\n\r\nimport \"os/exec\"\r\n\r\nfunc main() {\r\n\t// exe a program to run on cpu 0, 1, 2\r\n\tcmd := \u0026exec.Cmd{\r\n\t\tPath: \"/usr/bin/stress\",\r\n\t\tSysProcAttr: \u0026syscall.SysProcAttr{\r\n\t\t\tAffinitys: []int{0, 1, 2},\r\n\t\t},\r\n\t}\r\n\terr := cmd.Start()\r\n\tif err != nil {\r\n\t\tpanic(err.Error())\r\n\t}\r\n\tcmd.Wait()\r\n}\r\n``` \t\r\n\r\nThe patch.\r\n\r\n```\r\n--- src/syscall/exec_linux.go.orig\r\n+++ src/syscall/exec_linux.go\r\n@@ -19,6 +19,7 @@\r\n }\r\n \r\n type SysProcAttr struct {\r\n+\tAffinitys   []int          // CPU affinitys.\r\n \tChroot      string         // Chroot.\r\n \tCredential  *Credential    // Credential.\r\n \tPtrace      bool           // Enable tracing.\r\n@@ -44,6 +45,71 @@\r\n func runtime_BeforeFork()\r\n func runtime_AfterFork()\r\n \r\n+const ptrSize = 4 \u003c\u003c (^uintptr(0) \u003e\u003e 63) // unsafe.Sizeof(uintptr(0)) but an ideal const\r\n+\r\n+// GetAffinity return cpu list of pid\r\n+func GetAffinity(pid uintptr) ([]int, error) {\r\n+\tvar mask [1024 / 64]uintptr\r\n+\tvar ret = make([]int, 0)\r\n+\tif pid \u003c= 0 {\r\n+\t\tpid, _, _ = RawSyscall(SYS_GETPID, 0, 0, 0)\r\n+\t}\r\n+\t// size of uintptr is 8, in amd64\r\n+\tv1, _, err := RawSyscall(SYS_SCHED_GETAFFINITY, pid, uintptr(len(mask)*8), uintptr(unsafe.Pointer(\u0026mask[0])))\r\n+\tif err != 0 {\r\n+\t\treturn ret, err\r\n+\t}\r\n+\tnmask := mask[:v1/ptrSize]\r\n+\tidx := 0\r\n+\tfor _, v := range nmask {\r\n+\t\tfor i := 0; i \u003c 64; i++ {\r\n+\t\t\tct := int32(v \u0026 1)\r\n+\t\t\tv \u003e\u003e= 1\r\n+\t\t\tif ct \u003e 0 {\r\n+\t\t\t\tret = append(ret, idx)\r\n+\t\t\t}\r\n+\t\t\tidx++\r\n+\t\t}\r\n+\t}\r\n+\treturn ret, nil\r\n+}\r\n+\r\n+// SetAffinity attend the cpu list to pid,\r\n+// note: SetAffinity apply to thread ID only,\r\n+// to fully control one process, call SetAffinity for all thread of the process.\r\n+// use os.GetThreadIDs() to get all thread of the process\r\n+func SetAffinity(pid uintptr, cpus []int) error {\r\n+\tvar mask [1024 / 64]uintptr\r\n+\tif pid \u003c= 0 {\r\n+\t\tpid, _, _ = RawSyscall(SYS_GETPID, 0, 0, 0)\r\n+\t}\r\n+\tfor _, cpuIdx := range cpus {\r\n+\t\tcpuIndex := uint(cpuIdx)\r\n+\t\tmask[cpuIndex/64] |= 1 \u003c\u003c (cpuIndex % 64)\r\n+\t}\r\n+\t_, _, err := RawSyscall(SYS_SCHED_SETAFFINITY, pid, uintptr(len(mask)*8), uintptr(unsafe.Pointer(\u0026mask[0])))\r\n+\tif err != 0 {\r\n+\t\treturn err\r\n+\t}\r\n+\treturn nil\r\n+}\r\n+\r\n+// AddAffinity attend one cpu to list of pid\r\n+// note: AddAffinity apply to thread ID only,\r\n+// to fully control one process, call SetAffinity for all thread of the process\r\n+// use os.GetThreadIDs() to get all thread of the process\r\n+func AddAffinity(pid uintptr, cpuIdx int) error {\r\n+\tif pid \u003c= 0 {\r\n+\t\tpid, _, _ = RawSyscall(SYS_GETPID, 0, 0, 0)\r\n+\t}\r\n+\tcpus, e1 := GetAffinity(pid)\r\n+\tif e1 != nil {\r\n+\t\treturn e1\r\n+\t}\r\n+\tcpus = append(cpus, cpuIdx)\r\n+\treturn SetAffinity(pid, cpus)\r\n+}\r\n+\r\n // Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.\r\n // If a dup or exec fails, write the errno error to pipe.\r\n // (Pipe is close-on-exec so if exec succeeds, it will be closed.)\r\n@@ -63,6 +129,7 @@\r\n \t\tnextfd int\r\n \t\ti      int\r\n \t\tp      [2]int\r\n+\t\tmask   [1024 / 64]uintptr\r\n \t)\r\n \r\n \t// Record parent PID so child can test if it has died.\r\n@@ -117,6 +184,19 @@\r\n \t}\r\n \r\n \t// Fork succeeded, now in child.\r\n+\r\n+\t// setup cpu affinity when required\r\n+\tif sys.Affinitys != nil {\r\n+\t\tupid, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)\r\n+\t\tfor _, cpuIdx := range sys.Affinitys {\r\n+\t\t\tcpuIndex := uint(cpuIdx)\r\n+\t\t\tmask[cpuIndex/64] |= 1 \u003c\u003c (cpuIndex % 64)\r\n+\t\t}\r\n+\t\t_, _, err1 = RawSyscall(SYS_SCHED_SETAFFINITY, upid, uintptr(len(mask)*8), uintptr(unsafe.Pointer(\u0026mask[0])))\r\n+\t\tif err1 != 0 {\r\n+\t\t\tgoto childerror\r\n+\t\t}\r\n+\t}\r\n \r\n \t// Wait for User ID/Group ID mappings to be written.\r\n \tif sys.UidMappings != nil || sys.GidMappings != nil {\r\n```",
	"user": {
		"login": "wheelcomplex",
		"id": 1411633,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-06-23T02:08:34Z",
	"updated_at": "2015-06-23T02:08:34Z"
}
