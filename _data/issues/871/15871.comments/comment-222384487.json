{
	"id": 222384487,
	"body": "Welcome!\r\n\r\n@minux and @ALTree are right that there is extremely low probability of such a change in the Go language. That might be ok, though, depending on what your goals are, exactly.\r\n\r\nYou mentioned \"improving the Go language\". You could do that in many ways that don't involve *changing* the language itself. A language is much more than the spec--it's also the quality of the implementation, the quality of the documentation, the quality and size and openness of the community, it's the breadth and quality and richness of the open source libraries available for it. Those are all meaningful places to contribute. And some of those involving working on the compiler and the runtime; it just means that your focus would be on either improving those or documenting them. The improvements could e.g. be bug fixes, making things faster (either the compiler or the compiled code), making things simpler, making the code more readable, making the code better tested. The documentation could come in the form of comments in the source code or (say) blog posts about your exploration.\r\n\r\nYou also mentioned specifically \"extending the Go programming language\". You could still do this, as long as you understand that it's unlikely to be absorbed into the language itself. (This is actually true for most languages; though Go is perhaps particularly resistant to change and expansion, adding to a language is a big deal in general and not a step taken lightly.) Undertaking such a project would probably teach you a lot, would provide interesting materials for blog posts, and would very likely expose areas in which the current implementation is underdocumented, fragile, buggy, etc. And contributing back documentation improvements, bug reports, and blog posts would be of value to the project and the community.\r\n\r\nIf you want to experiment more with the make identifier, take a look at src/cmd/compile/internal/walk.go and grep for OMAKE and makemap. You could add a field to the internal map representation (src/runtime/hashmap.go) and try connecting the two. There are assumptions in the compiler about the runtime layout of maps and vice versa. These should be documented, but if they're not, or the documentation is unclear or outdated, please [send fixes](https://golang.org/doc/contribute.html). Note that we're in a release freeze now, though, so any changes of any kind are unlikely to go in for a couple of months.\r\n\r\nIf you want to experiment with concurrent map implementations, there are many options. One interesting, fairly recent one is hopscotch hashing, which (I believe) is relatively straightforward to implement and admits (I believe) of relatively straightforward fine-grained concurrency protection. Your best bet is probably to implement it outside of the runtime, for a particular map type (say map[string]int).\r\n\r\nAnother random idea if you're interested in data structures and language runtimes would be to experiment with using probabilistic data structures such as count-min-sketch based top-k/heavy-hitters to do profiling instead of [the overflow-log-based approach currently in use](http://research.swtch.com/pprof).\r\n\r\nHope this helps a bit. If you have questions about the implementation details of the runtime or compiler or stdlib, the best place to ask is golang-dev. If you have questions about using Go, about Go code you're writing (e.g. requests for help, API input, design input, etc.), the best place to ask is golang-nuts. And this issue is probably a good place to continue discussing how your project plans interact with the Go project.\r\n\r\nAlso, two quick inline comments to what went above:\r\n\r\n\u003e Are there any other arguments as well that can supplied to it? I've never actually seen anyone use a capacity hint for map, but it makes sense that there is one.\r\n\r\nIf you are asking this, then you probably haven't read [the Go language specification](https://golang.org/ref/spec). You should really, really go read that first if you're thinking about working on or changing the language. It's short and comprehensible.\r\n\r\n\u003e The core language is more or less frozen. Finished. Done. It has been for a few years.\r\n\r\nTo highlight one key sentence from that link: \"A significant reason for declaring the language done is to cut off a never-ending stream of tinkering that would accumulate over time into significant complexity and drag down the language.\" This is true even when each individual change might seem like a good idea in isolation.\r\n\r\n",
	"user": {
		"login": "josharian",
		"id": 67496,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-05-29T21:41:32Z",
	"updated_at": "2016-05-29T21:41:32Z"
}
