{
	"id": 160655731,
	"body": "@tkadauke Thanks very much for sending the simplified program. Austin and I were able to reproduce it on multiple machines. I'm sorry to say that it's not a runtime bug, at least not directly. Your program wraps sys_poll like this:\r\n\r\n\tconst (\r\n\t\tPOLLIN   = 0x0001\r\n\t\tPOLLPRI  = 0x0002\r\n\t\tPOLLOUT  = 0x0004\r\n\t\tPOLLERR  = 0x0008\r\n\t\tPOLLHUP  = 0x0010\r\n\t\tPOLLNVAL = 0x0020\r\n\t)\r\n\t\r\n\ttype PollFd struct {\r\n\t\tfd      int32\r\n\t\tevents  int16\r\n\t\trevents int16\r\n\t}\r\n\t\r\n\tfunc sys_poll(files []*os.File, timeout uint) (int, error) {\r\n\t\tfds := make([]PollFd, 0, len(files))\r\n\t\r\n\t\tfor _, file := range files {\r\n\t\t\tfds = append(fds, PollFd{\r\n\t\t\t\tfd:     int32(file.Fd()),\r\n\t\t\t\tevents: POLLIN | POLLERR | POLLHUP,\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tr1, _, e := syscall.Syscall(syscall.SYS_POLL, uintptr(unsafe.Pointer(\u0026fds[0])), uintptr(len(fds)), uintptr(timeout))\r\n\t\r\n\t\tif e != 0 {\r\n\t\t\treturn int(r1), os.NewSyscallError(\"poll\", e)\r\n\t\t}\r\n\t\r\n\t\treturn int(r1), nil\r\n\t}\r\n\r\nThe problem is that nothing refers to fds after the syscall.Syscall arguments are prepared, so the compiler does not record fds as live during the system call. While the system call is blocked, the garbage collector can come along and reclaim the memory pointed at by fds. Then when the kernel is ready to return a result, it writes POLLIN (0x0001) into, say, fds[0].revents, which ends up overwriting the top 16 bits of a 64-bit word with 0x0001, in a block of memory that has already been freed and is sitting on a free list. That is how we end up in the crash with what looks like a valid pointer except for the 0x0001000000000000 high bit.\r\n\r\nIf you change the code to use fds again after the syscall.Syscall, it will be marked live for the duration of the call and will therefore stay valid for the kernel to write to.\r\n\r\nOne way to do this is to add something like this to your package:\r\n\r\n\tvar useGlobal uintptr\r\n\t\r\n\tfunc use(x unsafe.Pointer) {\r\n\t\tatomic.StoreUintptr(\u0026useGlobal, uintptr(x))\r\n\t}\r\n\r\nand then after the syscall.Syscall, add a call\r\n\r\n\tuse(unsafe.Pointer(\u0026fds[0]))\r\n\r\nto keep fds live during the syscall.Syscall. This is basically what package syscall itself does, although there func use is implemented in assembly.\r\n\r\nWith a change like this, Austin and I were both able to run the sample program for over an hour, when it used to crash after a few minutes.\r\n\r\nI've been thinking about what we should do in general here. At the least we need better documentation about how to use syscall.Syscall, but perhaps we can make this kind of thing less necessary. I'm going to leave this issue to track that work. \r\n\r\nThanks very much for the report. I'm sad it wasn't (or doesn't appear to be) the runtime bug we're chasing in the other reports, but it's still certainly something we need to address.",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-30T15:07:43Z",
	"updated_at": "2015-11-30T15:07:43Z"
}
