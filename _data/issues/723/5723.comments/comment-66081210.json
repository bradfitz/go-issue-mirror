{
	"id": 66081210,
	"body": "\u003ca id=\"c11\"\u003e\u003c/a\u003eComment 11:\n\n\u003cpre\u003eToday's scorecard:\n\n1) Rob's split stack overflow.\n\nDmitriy points out that it was goroutine 9 that had the overflow. That's great. However,\nthe stack trace does not make sense. First, Rob did not have any pending changes to\npackage syscall or package runtime. Second, the runtime did recognize the goroutine as\npart of the problem, so it included [fp=xxx] annotations to dump the frame pointers. It\ndoes this if m-\u003ethrowing \u0026\u0026 gp == m-\u003ecurg. That's the same test showframe uses to decide\nto include internal runtime call frames. But they are missing from that goroutine stack.\nA real program would have called runtime.entersyscall from syscall.Syscall, yet that\nframe is missing. Also, entersyscall would not have been enough to eat up the 0x500 or\nso bytes remaining on the stack at that point.\n\nNo, the stack being shown for goroutine 9 is completely bogus. It is being dumped by\ntracebackothers, which uses gp-\u003esched as the initial frame information. But in the case\nof a running goroutine, gp-\u003esched is stale. It records the pc and sp of the most recent\nsaving of gp-\u003esched, which happened during a call to syscall.Syscall some time ago, and\nthat call is over. The rest of the stack trace may be accurate, since it was read\ndirectly from the stack memory, but we don't know what's below, what used up the 0x590\nbytes between the fp we have information for and the bottom of the stack. What we'd\nreally like to know are morebuf.sp and morepc, and they are not printed.\n\nAt the least we need to make the printing here actually print useful information. But I\nstill think we should be able to puzzle through what might have been happening on the\nstack to use up the remaining space. Just don't get misled by the syscall.Syscall frame.\n\n2) My index bounds checks not appearing.\n\nNo progress has been made on this. I have not gotten any real programming done today. It\nis possible that this is the same problem as (3) - the last record I have of rebuilding\nthat machine's Go tree was June 13 at 12:20 or so California time. Before that it had\nbeen not since before Go 1.1 (April 29). What I don't know is whether I observed the\nmissing stacks before or after 12:20.\n\n3) My bad behavior from runtime.Stack in a Go 1.1 program\n\nThis was caused by a bug fixed in CL 9307045. Because there was no issue filed about it,\nwe did not consider it for Go 1.1.1, so Go 1.1.1 still suffers from the bug. I created\n\u003ca href=\"https://golang.org/issue/5724\"\u003eissue #5724\u003c/a\u003e so that we put it into Go 1.1.2.\u003c/pre\u003e",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-06-18T00:37:56Z",
	"updated_at": "2014-12-08T10:31:18Z"
}
