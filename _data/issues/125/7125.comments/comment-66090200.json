{
	"id": 66090200,
	"body": "\u003ca id=\"c1\"\u003e\u003c/a\u003eComment 1:\n\n\u003cpre\u003eThe PublicSuffix interface of net/http is used by\nnet/http/cookiejar to determine the public suffix of a\ndomain name. RFC 6265 governs cookie handling and\ndescribes how domain names should be canonicalized\n(section 5.1.2) and how such names are matched (section\n5.1.3). It is thus just natural to require http.PublicSuffix\nto work properly with this format of domain names.\n\nCL 47560044 requires that any type implementing\nhttp.PublicSuffix has to work properly with this format.\nI assume this is consensus? \n\nRestricting cookie setting is tricky and a naive compare\nif cookieDomain == PublicSuffix(requestDomain) { reject }\nis doomed to fail. Admittedly some of these failures\ncan be avoided if PublicSuffix behaves clever like:\n  PublicSuffix(\"example.co.uk\") == \"co.uk\"\n  PublicSuffix(\"example.co.uk.\") == \"co.uk.\"  // FQDN\n  PublicSuffix(\"eXaMple.Co.uK\") == \"Co.uK\"\n  PublicSuffix(\"www.shishi.xn--fiqs8s\") == \"shishi.xn--fiqs8s\"  // 中国 punycoded \n  PublicSuffix(\"www.shishi.中国\") == \"shishi.中国\"\n\nI would argue that our implementation of PublicSuffix in\ngo.net/publicsuffix _should_ behave in the above clever way.\nMaybe for security reasons and for sure as a convenience\nto the users. But I do not see why this fancy behaviour should\nbe contracted in the standard library where http.PublicSuffix\nlives. Especially as this cleverness/convenience does not\nsafeguard against attacks on a really broken jar or a too naive\nHTTP client implementation. \n\nNigel's main objection was \"...how to approach domain\ncanonicalization and cookies so that it's always right, not\njust almost always right.\"\nDomain canonicalization and cookies is done in the interplay\nof http, normally a cookie jar and a public suffix list.\nAll three must agree on how to interact. Currently package\nhttp exposes the raw (un-canonicalized) domain names in URLs\nand in cookies. Package cookiejar handles canonicalization\n(but doesn't expose these canonical domain names). Cookiejar\nrelies on http.PublicSuffix accepting lowercase, punycoded,\ndotless domain names and return values in the same format.\nBeside strange name resolution on Linux cookiejar works\nproperly. I believe this to be a sensible approach which is\n\"always right\". And I admit I do not see which approach to\ndomain canonicalization would give this \"always right\", other\nthan just doing it properly: No behaviour of http.PublicSuffix\nalone will totally prevent mishandling of cookies.\nI do not see how a consensus on domain canonicalization\nwill provide us with a solution that \"always works\", even\nin conjunction with a naive (broken or deliberately wrong)\nHTTP client implementation.\n\nThe public suffix (or more often the eTLD+1 based\non this suffix) is used for stuff like sorting domains,\nsearch of domains or highlight relevant parts of a domain.\nShould the contract for http.PublicSuffix cover such uses?\nSorting becomes easier if the returned public suffix is\ncanonicalized (any form) but searching and highlighting\nseem easier if PublicSuffix exhibits the \"clever\" behavior.\nAnd if there is no obvious right format for the returned\npublic suffix I don't think that any additional behaviour\nof http.PublicSuffix should be contracted.\n\nMy understanding of an interface contract was that each\ntype implementing that interface must work like described\non the documented input but may allow additional input values.\nAs PublicSuffix is an interface in the standard library I\nthink it should be pretty minimal so that it can be implemented\neasily. Minimal not only in the number of methods but also\nin the range of allowed input values.\nMaybe I got this totally wrong, in which case please correct me.\n\nI thus think that it is sensible to do the following:\n- Require that http.PublicSuffix works on lowercase,\n  punycoded, trailing-dot-less domain names and...\n- ...returns the public suffix in the same format.\n- Document that it is the callers responsibility to\n  provide the domain in the required format.\n- Augment the implementation in go.net/publicsuffix\n  to allow additional domain forms and have the\n  return value in the format of the input.\n\nThe first two points are CL 47560044, the third point\nwas missing. The fourth point would be a different CL.\n\nWith this it would be:\n- Simple for a user to provide his own conforming implementation\n  of http.PublicSuffix (as the range of required input values is\n  limited) which can be used properly with net/http/cookiejar.\n- Users of go.net/publicsuffix benefit from its clever behaviour:\n  If you want to sort on lowercase IDN just call publicsuffix.List's\n  PublicSuffix with with lowercased IDNs and if you want\n  to highlight the eTLD+1 as entered in the address bar just\n  pass in the domain to publicsuffix.EffectiveTLDPlusOne.\n- And a \"naive HTTP client implementation\" which does\n  non-RFC-6265-style cookie domain handling will benefit\n  from our clever go.net/publicsuffix list which mitigates\n  some security issues.\n\nIf someone insists on providing his own jar and his own\npublic suffix list and his jar and his public suffix list do\nnot work properly together he might get issues with cookies\nbeing sent to wrong domains. But as explained above: I do\nnot see how to help him in this scenario.\u003c/pre\u003e",
	"user": {
		"login": "vdobler",
		"id": 701382,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-01-14T22:49:47Z",
	"updated_at": "2014-12-08T10:39:38Z"
}
