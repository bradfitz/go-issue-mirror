{
	"id": 169952557,
	"body": "There are three practically interesting synchronization patterns wrt memory ordering (in increasing order of required synchronization):\r\n\r\n(A) \"Stop flag\", no associated data, requires no memory ordering (only atomicity and visibility):\r\n\r\n```go\r\n// goroutine 1\r\nfor atomic.Load(\u0026stop) == 0 {...}\r\n\r\n// goroutine 2\r\natomic.Store(\u0026stop, 1)\r\n```\r\n\r\n(B) Producer-consumer, there is associated data so it requires acquire/release pair, but synchronization is weak and causal (no barriers on x86) (this is comment 15, program 1):\r\n\r\n```go\r\n// goroutine 1 (producer)\r\ndata = 42\r\natomic.Store(\u0026ready, 1)\r\n\r\n// goroutine 2 (consumer)\r\nif atomic.Load(\u0026ready) != 0 {\r\n    assert(data == 42)\r\n}\r\n```\r\n\r\n(C) Dekker/Peterson mutual exclusion, no associated data per se (but can be combined with (B)), strong synchronization (loads and stores allow to achieve global consensus, requires barriers on x86)  (this is comment 15, program 2):\r\n\r\n```go\r\n// goroutine 1\r\natomic.Store(\u0026X, 1)\r\nr1 = atomic.Load(\u0026Y)\r\n\r\n// goroutine 2\r\natomic.Store(\u0026Y, 1)\r\nr2 = atomic.Load(\u0026X)\r\n\r\n// afterwards\r\nif r1 == 0 \u0026\u0026 r2 == 0 {\r\n  panic(\"broken\")\r\n}\r\n```\r\n\r\nAnd IRIW (independent reads of independent writes) is a completely different pattern: goroutine 1 writes X, goroutine 2 writes Y, goroutine 3 loads X and Y, goroutine 4 loads Y and X. Goroutines 3 and 4 must agree on order of stores to X and Y. This is not practically interesting.\r\n\r\nI afraid we can't discard case (C). That's a fundamental pattern. We used it in sigqueue (with sig.mask and sig.kick being A and B); in sync.Waitgroup (with wg.counter and wg.waiters being A and B); in runtime semaphores (with addr and root.nwait being A and B); in several places in netpoll and runtime scheduler. Things will break if we take out that barrier.\r\n\r\nI have three points regarding data races.\r\n(1) Giving any meaningful semantics to data races will compromise performance and is close to impossible for gccgo and llgo. It is not as \"you either see old value or new value\". Compilers generally rely on absence of data races and there is at least one known case when gcc generates non-atomic stores for word-sized variables (stores of 64-bit immediates are done as two separate stores). Or consider that we replace a memset loop with REP STOSB, that will break any atomicity. Or consider the following code:\r\n\r\n```go\r\nfunc foo(x int) {\r\n  *p = x\r\n}\r\n```\r\n\r\nyou would expect this to be atomic, right?\r\nNow add:\r\n\r\n```go\r\nfunc bar(y int) {\r\n  y |= *p \u0026 ^flags\r\n  foo(y)\r\n}\r\n```\r\n\r\nafter inlining this becomes:\r\n\r\n```go\r\ny |= *p \u0026 ^flags\r\n*p = y\r\n```\r\n\r\nwhich can be reasonably compiled as (same 2 memory access, less register pressure):\r\n\r\n```go\r\n*p \u0026= ^flags\r\n*p |= y\r\n```\r\n\r\nThat's a real example from Linux kernel. It is basically impossible to prove that something like this won't happen to any of your stores.\r\nNow you could say that, \"value of a variable that is subject to data races becomes undefined but other variables are unaffected\".\r\nThis is not necessary true as well. Consider that a racy variable is involved in index operation (do a bounds check, then evict the value due to register pressure, reload, index); or in control flow (jump tables, uh), or that compiler assumes that a variable contains the value that we've just stored into it, e.g.:\r\n\r\n```go\r\nx = a\r\ny = a\r\n```\r\n\r\ncompiled as:\r\n\r\n```go\r\nx = a\r\ny = x\r\n```\r\n\r\nbecause there is register pressure, a is spilled or discarded, and recomputing address of a is more expensive than recomputing address of x.\r\n\r\nConcurrent compacting GC can also have unpredictable effects in presence of data race. E.g. Sapphire can produce chatter stores in presence of races.\r\n\r\n(2) Giving only part of guarantees (only word-sized variables) is not useful. Especially for large-scale programs. It is not that you know that you have only one data races in a large-scale program and it happens to be on a stats counter. You don't know where are the races and how many are there. If you forgot a mutex lock, you can as well have a data race on a map. Then all bets are off.\r\n\r\n(3) Giving no guarantees to programs with races on specification level does not prohibit us from giving any guarantees as QoI attribute. In fact, I think it was a mistake for Java to mix these two levels. Lots of Java code is now sprinkled with data races. Reasoning about such code is hard. Race detection tooling is impossible. And authors are formally right, they are relying on language spec.\r\n",
	"user": {
		"login": "dvyukov",
		"id": 1095328,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-08T10:05:23Z",
	"updated_at": "2016-01-08T10:05:59Z"
}
