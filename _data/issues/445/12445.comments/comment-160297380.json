{
	"id": 160297380,
	"body": "There are certainly whole classes of concurrent GC algorithms for which\nthis will not work. GC's using a variation of a Brooks' pointer, such as\nproposed for the Red Hat LLVM based GC as well as Sapphire style\ncollectors. Currently Go does not use these techniques.\n\n\nOn Sat, Nov 28, 2015 at 4:17 AM, Dan Kortschak \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e That does not do what the linked code does. We want to return whether\n\u003e there is an i,j and x,y such that a[i + j*stride] and b[x + y*stride]\n\u003e address the same variable. However it does suggest a possible solution.\n\u003e\n\u003e // offset returns the number of float64 values b[0] is after a[0].\n\u003e func offset(a, b []float64) int {\n\u003e     a0 := unsafe.Pointer(\u0026a[0])\n\u003e     b0 := unsafe.Pointer(\u0026b[0])\n\u003e\n\u003e     if a0 == b0 {\n\u003e         return 0\n\u003e     }\n\u003e     if uintptr(a0) \u003c uintptr(b0) {\n\u003e         return int((uintptr(b0) - uintptr(a0)) / unsafe.Sizeof(float64(0)))\n\u003e     }\n\u003e     return -int((uintptr(a0) - uintptr(b0)) / unsafe.Sizeof(float64(0)))\n\u003e }\n\u003e\n\u003e and the family friendly version (this on is more tenuous since it depends\n\u003e on values passed back from a reflect call):\n\u003e\n\u003e // offset returns the number of float64 values b[0] is after a[0].\n\u003e func offset(a, b []float64) int {\n\u003e     va0 := reflect.ValueOf(a).Index(0)\n\u003e     vb0 := reflect.ValueOf(b).Index(0)\n\u003e\n\u003e     if va0.UnsafeAddr() == vb0.UnsafeAddr() {\n\u003e         return 0\n\u003e     }\n\u003e     if va0.UnsafeAddr() \u003c vb0.UnsafeAddr() {\n\u003e         return int((vb0.UnsafeAddr() - va0.UnsafeAddr()) / sizeOfFloat64)\n\u003e     }\n\u003e     return -int((va0.UnsafeAddr() - vb0.UnsafeAddr()) / sizeOfFloat64)\n\u003e }\n\u003e\n\u003e These are then used in the functions also linked above.\n\u003e\n\u003e Note that it is OK for our use case for the offset to be used after a\n\u003e possible GC move since if a and b are part of the same allocation they move\n\u003e together and so the offset remains valid, and if they are not, an offset\n\u003e cannot become indicative of an overlap.\n\u003e\n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/12445#issuecomment-160265825\u003e.\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-28T13:53:10Z",
	"updated_at": "2015-11-28T13:53:10Z"
}
