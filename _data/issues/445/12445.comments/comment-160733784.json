{
	"id": 160733784,
	"body": "Technically I think we understand each other.\n\nShort term expanding the semantics of unsafe will lead to more and\nincreasingly clever uses of unsafe and that will lead to an increase in\ncorner case bugs. Clever uses of unsafe coupled with an increasing\nsophisticated runtime that depends on the type system being safe is the\nroad to pain.\n\nLong term expanding the semantics of unsafe will lead to technical debt and\ncut off possible solutions that moving objects might solve. Some of the\npossible problems include fragmented memory and poor spatial locality\ncomplicated by deeper caches and various as yet undefined NUMA\narchitectures. We lack visibility on how important these things will be in\nthe future and whether the advantages of allowing Go to grow in unsafe ways\ntoday outweighs the accumulated technical debt.\n\nI think we should spend some time and see if we can come up with solutions\nthat lead to less use of unsafe instead of more.\n\n\nOn Sun, Nov 29, 2015 at 2:57 PM, Matthew Dempsky \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e @RLH \u003chttps://github.com/RLH\u003e Thanks. I understand the idea that under a\n\u003e moving GC that a single \"pointer value\" (in the Go spec/language sense)\n\u003e might at a given time have multiple bit patterns at the machine\n\u003e implementation level, and so this complicates the implementation of Go\n\u003e pointer equality.\n\u003e\n\u003e However, we seem to have different interpretations of the spec's uintptr(unsafe.Pointer(\u0026s))\n\u003e + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(\u0026s.f)) guarantee (which\n\u003e I'll emphasize again is currently written using *integer* equality, not\n\u003e *pointer* equality). It sounds like you interpret the guarantee is\n\u003e precisely worded and only holds when \u0026s and \u0026s.f are all locally visible to\n\u003e the compiler so it can be satisfied via CSE optimizations, whereas I've\n\u003e instead interpreted it generalizes to examples like this (even assuming no\n\u003e inlining/cross-package compiler optimizations):\n\u003e\n\u003e package pkg\n\u003e\n\u003e import \"unsafe\"\n\u003e\n\u003e type S struct { E, F int }\n\u003e\n\u003e func Func(p, q unsafe.Pointer) bool {\n\u003e     return uintptr(p) + unsafe.Offsetof(S{}.F) == uintptr(q)\n\u003e }\n\u003e\n\u003e .\n\u003e\n\u003e package main\n\u003e\n\u003e import (\n\u003e     \"unsafe\"\n\u003e     \"./pkg\"\n\u003e )\n\u003e\n\u003e func main() {\n\u003e     var s pkg.S\n\u003e     if !pkg.Func(unsafe.Pointer(\u0026s), unsafe.Pointer(\u0026s.F)) {\n\u003e         panic(\"spec violation\")\n\u003e     }\n\u003e }\n\u003e\n\u003e So at the very least I think it's worth deciding/clarifying which\n\u003e interpretation of the spec is intended.\n\u003e\n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/12445#issuecomment-160461460\u003e.\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-30T19:30:24Z",
	"updated_at": "2015-11-30T19:30:24Z"
}
