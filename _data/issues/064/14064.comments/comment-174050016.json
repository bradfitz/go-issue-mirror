{
	"id": 174050016,
	"body": "This is hard to reproduce because we need the thread to lose the CPU between releasing the lock and sleeping on the semaphore. So to make it easier, I modified the sync package to optionally artificially introduce a delay of 1s in the spot we care about. This is controlled by `sync.ForceWait`.\r\n\r\nThe code below will result in a deadlock.\r\n\r\nNote that if we remove the extra waiter altogether the code runs to completion after the 1s wait.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n        \"runtime\"\r\n        \"sync\"\r\n        \"time\"\r\n)\r\n\r\nfunc main() {\r\n        var m sync.Mutex\r\n        cond := sync.NewCond(\u0026m)\r\n\r\n        // Start a waiter.\r\n        ch := make(chan struct{})\r\n        sync.ForceWait = true\r\n        go func() {\r\n                runtime.LockOSThread()\r\n                m.Lock()\r\n                ch \u003c- struct{}{}\r\n                cond.Wait()\r\n                m.Unlock()\r\n\r\n                ch \u003c- struct{}{}\r\n        }()\r\n\r\n        \u003c-ch\r\n        m.Lock()\r\n        m.Unlock()\r\n\r\n        // We know that the waiter is in the cond.Wait() call because we\r\n        // synchronized with it, then acquired/released the mutex it was\r\n        // holding when we synchronized.\r\n\r\n        go func() {\r\n                cond.Broadcast()\r\n        }()\r\n\r\n        // Sleep before we wait to give Broadcast a chance to wait for the waiter.\r\n        time.Sleep(20 * time.Millisecond)\r\n\r\n        // Start the extra waiter, without the forced wait.\r\n        sync.ForceWait = false\r\n        go func() {\r\n                m.Lock()\r\n                cond.Wait()\r\n                m.Unlock()\r\n        }()\r\n\r\n        // This will only be satisfied when the first waiter wakes up. We'll\r\n        // deadlock if it never wakes up.\r\n        \u003c-ch\r\n}\r\n```\r\n\r\nBelow is the diff to sync:\r\n\r\n```diff\r\ndiff --git a/src/runtime/sema.go b/src/runtime/sema.go\r\nindex b54621b..0ea5d63 100644\r\n--- a/src/runtime/sema.go\r\n+++ b/src/runtime/sema.go\r\n@@ -291,3 +291,8 @@ func syncsemcheck(sz uintptr) {\r\n                throw(\"bad syncSema size\")\r\n        }\r\n }\r\n+\r\n+//go:linkname sleep sync.runtime_Usleep\r\n+func sleep(us uint32) {\r\n+       usleep(us)\r\n+}\r\ndiff --git a/src/sync/cond.go b/src/sync/cond.go\r\nindex 0aefcda..a9f7b4b 100644\r\n--- a/src/sync/cond.go\r\n+++ b/src/sync/cond.go\r\n@@ -10,6 +10,8 @@ import (\r\n        \"unsafe\"\r\n )\r\n \r\n+var ForceWait = false\r\n+\r\n // Cond implements a condition variable, a rendezvous point\r\n // for goroutines waiting for or announcing the occurrence\r\n // of an event.\r\n@@ -60,6 +62,11 @@ func (c *Cond) Wait() {\r\n                race.Enable()\r\n        }\r\n        c.L.Unlock()\r\n+\r\n+       if ForceWait {\r\n+               runtime_Usleep(1000000)\r\n+       }\r\n+\r\n        runtime_Syncsemacquire(\u0026c.sema)\r\n        c.L.Lock()\r\n }\r\ndiff --git a/src/sync/runtime.go b/src/sync/runtime.go\r\nindex c66d2de..8874b18 100644\r\n--- a/src/sync/runtime.go\r\n+++ b/src/sync/runtime.go\r\n@@ -45,3 +45,5 @@ func runtime_canSpin(i int) bool\r\n \r\n // runtime_doSpin does active spinning.\r\n func runtime_doSpin()\r\n+\r\n+func runtime_Usleep(usec uint32)\r\n```",
	"user": {
		"login": "wedsonaf",
		"id": 7494395,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-22T21:10:36Z",
	"updated_at": "2016-01-22T21:10:36Z"
}
