{
	"id": 66050926,
	"body": "\u003ca id=\"c1\"\u003e\u003c/a\u003eComment 1:\n\n\u003cpre\u003eI suspect these two goroutines are fighting.\n\npanic PC=0x7f37348730a8\nthrow+0x3e /home/pakin/goroot/src/pkg/runtime/runtime.c:83\n\tthrow(0xffffffff, 0x469c00)\nreadylocked+0x69 /home/pakin/goroot/src/pkg/runtime/proc.c:252\n\treadylocked(0x469c00, 0x339)\nready+0x2a /home/pakin/goroot/src/pkg/runtime/proc.c:233\n\tready(0x7f3735725ea0, 0x4066eb)\nsemwakeup+0x70 /home/pakin/goroot/src/pkg/runtime/sema.c:58\n\tsemwakeup(0x7f3735725ea0, 0x61d41)\nsemrelease+0x3a /home/pakin/goroot/src/pkg/runtime/sema.c:139\n\tsemrelease(0x42da78, 0x100000000)\ngc+0x1b8 /home/pakin/goroot/src/pkg/runtime/mgc0.c:319\n\tgc(0x42da78, 0x20)\nmallocgc+0x1ca /home/pakin/goroot/src/pkg/runtime/malloc.c:95\n\tmallocgc(0x7f3700000000, 0x0, 0x0, 0x0, 0x7f37348731d8, ...)\nmal+0x3f /home/pakin/goroot/src/pkg/runtime/malloc.c:236\n\tmal(0x10, 0x100000000)\n\n\ngoroutine 6 [1]:\ngosched+0x4e /home/pakin/goroot/src/pkg/runtime/proc.c:513\n\tgosched()\nsemsleep2+0x16 /home/pakin/goroot/src/pkg/runtime/sema.c:94\n\tsemsleep2()\nsemacquire+0x9c /home/pakin/goroot/src/pkg/runtime/sema.c:123\n\tsemacquire(0x7f3734c74000, 0x7f3734c74000)\ngc+0xab /home/pakin/goroot/src/pkg/runtime/mgc0.c:289\n\tgc(0x42da78, 0x7f3734c74048)\nrunfinq+0xed /home/pakin/goroot/src/pkg/runtime/mgc0.c:357\n\trunfinq()\ngoexit /home/pakin/goroot/src/pkg/runtime/proc.c:145\n\tgoexit()\n\n\nI suspected that perhaps the semaphore algorithm was wrong,\nbut I retranslated it into SPIN (below) and it doesn't find any bugs.\n\nNot seeing the problem with GOGC=off doesn't quite implicate\nthe garbage collector, beacuse if you turn off the garbage collector\nyou avoid the semaphore code too.\n\n\n/*\nflag e +\nrm -f semago.p.trail\nspin -a semago.p\ngcc -DSAFETY -DREACH -DMEMLIM'='500 -o pan pan.c\npan -i\ntest -f semago.p.trail \u0026\u0026 pan -r semago.p.trail\n# rm pan.* pan\n*/\n\n/* Model for sema.cgo as of 2010/04/06. */\n\n/* locks */\n\ninline lock(x)\n{\n\tatomic { x == 0; x = 1 }\n}\n\ninline unlock(x)\n{\n\tassert x == 1;\n\tx = 0\n}\n\n/* proc.c */\n\n#define N 3\n\nbit schedlock;\n\nbyte status[N];\n#define Grunning 1\n#define Grunnable 2\n#define Gwaiting 3\n\nbit readyonstop[N];\nbit g_m[N];\t/* g-\u0026gt;m != nil */\n\ninline gosched()\n{\n\t/* scheduler() */\n\tlock(schedlock);\n\tassert g_m[_pid];\n\tg_m[_pid] = 0;\n\tassert status[_pid] == Gwaiting;\n\tif\n\t:: readyonstop[_pid] -\u0026gt;\n\t\treadyonstop[_pid] = 0;\n\t\tstatus[_pid] = Grunnable;\n\t:: else\n\tfi;\n\tunlock(schedlock);\n\n\t/* wait for wakeup */\n\tatomic {\n\t\tschedlock == 0 \u0026\u0026 status[_pid] == Grunnable;\n\t\tschedlock = 1;\n\t\treadyonstop[_pid] = 0;\n\t\tstatus[_pid] = Grunning;\n\t\tassert !g_m[_pid];\n\t\tg_m[_pid] = 1;\n\t\tunlock(schedlock)\n\t}\n}\n\ninline readylocked(p)\n{\n\tif\n\t:: g_m[p] -\u0026gt;\n\t\tprintf(\"g_m[%d]\\n\", p);\n\t\treadyonstop[p] = 1\n\t:: else -\u0026gt;\n\t\tassert status[p] == Gwaiting;\n\t\tstatus[p] = Grunnable;\n\tfi\n}\n\ninline ready(p)\n{\n\tlock(schedlock);\n\treadylocked(p);\n\tunlock(schedlock)\n}\n\n/* sema.cgo */\n\nbyte value;\nbit listlock;\nbit onlist[N];\t/* on the list */\nbit s_g[N];\t/* s-\u0026gt;g != nil */\n\ninline semqueue()\n{\n\tlock(listlock);\n\tassert !onlist[_pid];\n\tonlist[_pid] = 1;\n\tunlock(listlock)\n}\n\ninline semdequeue()\n{\n\tlock(listlock);\n\tassert onlist[_pid];\n\tonlist[_pid] = 0;\n\tunlock(listlock)\n}\n\ninline semwakeup()\n{\n\tlock(listlock);\n\ti = 0;\n\tdo\n\t:: i \u0026lt; N -\u0026gt;\n\t\tif\n\t\t:: onlist[i] \u0026\u0026 s_g[i] -\u0026gt;\n\t\t\ts_g[i] = 0;\n\t\t\tready(i);\n\t\t\tbreak\n\t\t:: else\n\t\tfi;\n\t\ti++\n\t:: else -\u0026gt; break\n\tod;\n\t/* reset i to reduce state space */\n\ti = 0;\n\tunlock(listlock)\n}\n\ninline semsleep1()\n{\n\tlock(listlock);\n\tassert !s_g[_pid];\n\ts_g[_pid] = 1;\n\tunlock(listlock)\n}\n\ninline semsleepundo1()\n{\n\tlock(listlock);\n\tif\n\t:: s_g[_pid] -\u0026gt;\n\t\ts_g[_pid] = 0\n\t:: else -\u0026gt;\n\t\tassert readyonstop[_pid];\n\t\treadyonstop[_pid] = 0\n\tfi;\n\tunlock(listlock)\n}\n\ninline semsleep2()\n{\n\tstatus[_pid] = Gwaiting;\n\tgosched()\n}\n\ninline cansemacquire(quick)\n{\n\tatomic {\n\t\tif\n\t\t:: value \u0026gt; 0 -\u0026gt;\n\t\t\tprintf(\"quick\\n\");\n\t\t\tvalue--;\n\t\t\tquick = 1\n\t\t:: else -\u0026gt;\n\t\t\tquick = 0\n\t\tfi\n\t}\n}\n\ninline semacquire()\n{\n\tcansemacquire(quick);\n\tif\n\t:: quick -\u0026gt;\n\t\tquick = 0;\n\t:: else -\u0026gt;\n\t\tsemqueue();\n\t\tdo\n\t\t:: skip -\u0026gt;\n\t\t\tsemsleep1();\n\t\t\tcansemacquire(quick);\n\t\t\tif\n\t\t\t:: quick -\u0026gt;\n\t\t\t\tquick = 0;\n\t\t\t\tsemsleepundo1();\n\t\t\t\tbreak\n\t\t\t:: else -\u0026gt; skip\n\t\t\tfi;\n\t\t\tsemsleep2()\n\t\tod;\n\t\tsemdequeue();\n\t\tsemwakeup();\n\tfi\n}\n\ninline semrelease()\n{\n\tvalue++;\n\tsemwakeup()\n}\n\nactive[N] proctype acquire()\n{\n\tbyte i;\n\tbit quick;\n\n\tg_m[_pid] = 1;\n\tstatus[_pid] = Grunning;\n\n\tsemacquire();\n\tsemrelease();\n\tsemacquire();\n\tsemrelease();\n\tprintf(\"%d finished\\n\", _pid);\n\tskip\n}\n\nactive proctype kickoff()\n{\n\tbyte i;\n\n\tsemrelease();\n\tskip\n}\n\n/*\n * If this guy, the highest-numbered proc, sticks\n * around, then everyone else sticks around.  \n * This makes sure that we get a state line for\n * everyone in a proc dump.  \n */\nactive proctype dummy()\n{\nend:\t0;\n}\u003c/pre\u003e\n\n\n_Owner changed to **r...@golang.org**._\n\n_Status changed to **Accepted**._",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2010-04-07T08:07:39Z",
	"updated_at": "2014-12-22T05:51:27Z"
}
