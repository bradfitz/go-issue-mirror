{
	"id": 193532967,
	"body": "@crawshaw, I understand the constraints for your project, but you don't need 1%. You need many%. We're certainly not going to pay a 2500% cost in link time for 50% binary size reduction, so I don't think we should pay a 50% cost in link time for 1% binary size reduction. I remain happy to work with you to find other ways to reduce space, but there are many competing interests in this project, and we can't overfit to the one goal of binary size elimination at significant cost to the other goals of compile and link time.\r\n\r\nPut another way, suppose you'd come to us and said \"I can make the linker 33% faster at the cost of making binaries 1% larger.\" That would be an obvious win. Basically everyone would be cheering. The CL in question does the opposite.\r\n\r\nSuffix arrays in particular have significant time cost, significant memory cost, and significant code complexity cost. The suggestions being made on this issue are that we pay an even greater code complexity cost to reduce the time and hopefully memory cost (though no one seems to be even talking about that). This seems to me excessive for 1% binary size. I am sure there are ways to get that 1% and more, without the triple whammy of costs incurred by suffix arrays. So let's work on other ways to get that 1% instead. But not by resorting to other complex things, such as LZ77.\r\n\r\nThis is the classic compiler writer's trap, which you see over and over again:\r\n\r\n1. Do something terribly inefficient.\r\n2. Do something terribly complex to clean up the inefficiency.\r\n\r\nAs an experiment, the suffix array is great: it shows that the Go toolchain is doing something terribly inefficient. Instead of debating various options for step 2, we should instead be focusing on not doing step 1 in the first place.\r\n\r\nLet's use juju as an example like the CL does: what are the actual duplicated strings? Where do they come from? From the CL it sounds like the duplicated strings are the string field for the reflect.Type struct implementations. How much smaller does the binary get if you just don't put any string there at all? Forget the fact that the binary won't run, just how much is saved by not writing those strings? If it's not significant, then what else is also contributing to the win for deduplication? Characterizing what is being deduplicated is the first step. If the deduplication is winning primarily due to the reflect.Type strings, that says to me that we need to do a better job not generating them in the first place. They are there for debugging, and they are undeniably convenient, but the vast majority of them are never looked at. A precise characterization of the storage cost of that convenience might make clear that the cost is too high and that we should deal with the complexity of generating those strings at run-time as needed.",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-03-08T00:57:17Z",
	"updated_at": "2016-03-08T00:57:17Z"
}
