{
	"id": 196334827,
	"body": "The GC will use as much CPU as is available. If your program is basically\nidle, which it appears to be, the GC will use the idle CPU and CPU load\nwill naturally go up. If your application is active and load is already\nhigh then the GC will limit its load to 25% of GOMAXPROCS. The mark and\nscan phase is concurrent, it is unclear how it is adversely affecting your\nidle application.\n\n\nOn Mon, Mar 14, 2016 at 1:54 AM, Dieter Plaetinck \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e Hello,\n\u003e while running the program at\n\u003e https://github.com/raintank/raintank-metric/tree/master/metric_tank\n\u003e I'm seeing excessive time spent in mark-and-scan on go 1.6\n\u003e (STW pauses are fine and ~1ms)\n\u003e I used https://circleci.com/gh/raintank/raintank-metric/507 in the below\n\u003e description.\n\u003e\n\u003e ./metric_tank --version\n\u003e metrics_tank (built with go1.6, git hash 8897ef4f8f8f1a2585ee88ecadee501bfc1a4139)\n\u003e go version go1.6 linux/amd64\n\u003e $uname -a #on the host where the app runs\n\u003e Linux metric-tank-3-qa 3.19.0-43-generic #49~14.04.1-Ubuntu SMP Thu Dec 31 15:44:49 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\n\u003e\n\u003e I know the app is currently not optimized for GC workload: while i've\n\u003e gotten allocations down in various parts of the program there are currently\n\u003e probably about a million or more live pointers referencing pieces of data.\n\u003e I was going to work on optimizing this when Dave Cheney suggested there's a\n\u003e problem with the runtime and I should file a bug (\n\u003e https://groups.google.com/forum/#!topic/golang-nuts/Q0rXKYjy1cg)\n\u003e I'm seeing MAS times of 15s and more cpu time, 2000~2500 ms clock time. (8\n\u003e core system) for a heap of about 6.5GB\n\u003e Here's the log with gctrace and schedtrace enabled:\n\u003e https://gist.githubusercontent.com/Dieterbe/18453451c5af0cdececa/raw/9c4f2abd85bb7a815c6cda5c1828334d3d29817d/log.txt\n\u003e\n\u003e at http://dieter.plaetinck.be/files/go/mt3-qa-gc-vs-no-gc.zip you'll find\n\u003e a zip containing this log, the binary, a cpu profile taken during gc run\n\u003e 1482, and a cpu and heap profile in between run 1482 and 1483\n\u003e\n\u003e I also have these two dashboards that seem useful. (they both end just\n\u003e after the spike induced by GC run 1482)\n\u003e\n\u003e https://snapshot.raintank.io/dashboard/snapshot/MtLqvc4F6015zbs4iMQSPzfizvG7OQjC\n\u003e shows memory usage, GC runs and STW pause times. it also shows that\n\u003e incoming load (requests) of the app is constant so this conveys to me that\n\u003e any extra load is caused by GC, not by changing workload\n\u003e\n\u003e https://snapshot.raintank.io/dashboard/snapshot/c2zwTZCF7BmfyzEuGF6cHN9GX9aM1V99\n\u003e this shows the system stats. note the cpu spikes corresponding to the GC\n\u003e workload.\n\u003e\n\u003e let me know if there's anything else I can provide,\n\u003e thanks,\n\u003e Dieter.\n\u003e\n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/14812\u003e.\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-03-14T14:32:08Z",
	"updated_at": "2016-03-14T14:32:08Z"
}
