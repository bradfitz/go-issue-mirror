{
	"id": 242135325,
	"body": "Thanks for the comments @yiyus  . It's a good conversation to have.\r\n\r\n\u003e It would be difficult to explain such a limitation to someone coming from Python, Fortran or Matlab, for example.\r\n\r\nIn Matlab, such slicing creates a copy, so the behavior in Go is going to be surprising no matter what.\r\n\r\nCould you give some examples in Fortran? I've only worked in old Fortran codebases. In BLAS and LAPACK, for instance, data arrays are contiguous, as in this proposal. Many of the operations do work on column vectors, of course, but that is implemented by explicitly passing the stride and doing the strided indexing manually. See the implementation of Dasum https://github.com/gonum/blas/blob/master/native/level1double.go#L91 or http://www.netlib.org/lapack/explore-html/de/d05/dasum_8f_source.html\r\n\r\nPython does have the behavior you propose. Do you know how they deal with it? I suspect that they have to make a copy of the array before passing it to Lapack. I tried to read the source, but I when I got to the call for `_makearray`, I get lost in the c code for the `array` function and in ` wrap = getattr(a, \"__array_prepare__\", new.__array_wrap__)`\r\n\r\nI ask because the goals of Go are different than those of python/matlab/julia. Go will never have the syntactic flexibility of these languages. The benefit of Go is having a consistent language across users, and having a language that is possible to implement efficiently. In Matlab, the tradeoff is to allow really easy access to columns, even if that means a silent copy. In python, it's likely okay to sacrifice performance opportunities for syntactic ease -- python is not a fast language in general. Just because it's the right choice for those languages doesn't mean it's the right choice for Go -- the definition of \"not a problem\" is different.\r\n\r\n------\r\n\r\nI agree that we want to be able to perform operations on the data in columns, and I also agree that in some cases we want to do that copy-free. There is a problem with my proposal at the moment, one cannot extract a single column of a table. A few of us offline have been discussing this. The solution is to also add an `unshape` function that can take a table, and return the linear data.\r\n````\r\nfunc unshape([,*]T) ([]T, [N-1]int)\r\n````\r\nwhere `[,*]T` is shorthand for a table of dimension `N`, and the returned values are the underlying linear data of the table, and the strides in the dimension. With this function, one can extract a specific column of data, copy-free. Updating gonum/matrix, for instance, we would have\r\n\r\n````\r\ntype Dense [,]float64\r\n\r\ntype Vector struct {\r\n    data []float64\r\n    stride int\r\n}\r\n\r\nfunc (d Dense) ColView(i int) Vector{\r\n      data, stride := unshape(d)\r\n      return Vector {\r\n           data: data[i:],\r\n           stride: stride,\r\n     }  \r\n}\r\n````\r\nThe returned vector is a copy-free view on the column.\r\n\r\nPersonally, I think this meaningfully meets your desirata. You can use a `Vector` anywhere you \"need something that is a vector\", and you can use a `[]T` anywhere else.\r\n\r\n------\r\n\r\nThere are two costs to strided slices. The first is having two types that are basically the same thing. The second is the lost of optimization opportunities. It seems possible to me that strided slices are much harder to optimize than contiguous ones, especially in the area of SIMD. If SIMD optimizations are too difficult to implement, then Go is never going to be competitive with C and Fortran. It seems like there could still be this tension with where to use strided slices and contiguous slices.\r\n\r\nI guess I'm playing the role of champion against strided slices. In that role, what I want to see is:\r\n\r\n1) An argument for why the `Vector` type is insufficient, making strided slices necessary. Such an argument should keep in mind\r\n    a) Assuming inlining, accessing through a `Vector` is just as expensive as accessing a strided slice\r\n    b) As far as I understand, the storage costs for a strided slice are identical to the storage costs of a `Vector`\r\n\r\n2) An explanation why a future Go compiler will still be able to implement SIMD operations, even understanding the goals of Go for fast compile times and small binaries\r\n\r\n3) Rules of thumb on when to use a strided slice and when to use a contiguous one. Should the entirety of gonum change? Thus, anytime I would have had a `[]float64`, I should instead have a `[']float64` (or whatever the syntax is)? If not... clearly it should be `type Vector [']float64`. Should `gonum/floats` use `[']float64` or `[]float64`? Should there also be a duplicate \"stridedfloats\" package? What about the weights of a categorical random variable (https://github.com/gonum/stat/blob/master/distuv/categorical.go#L15)?\r\n\r\n----\r\n@griesemer Your post came in the middle of me writing mine. Should I update the proposal to add  `unshape` operation? I think it's necessary for the proposal to be useful.",
	"user": {
		"login": "btracey",
		"id": 3680859,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-24T16:55:29Z",
	"updated_at": "2016-08-24T16:55:29Z"
}
