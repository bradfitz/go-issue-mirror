{
	"id": 66098051,
	"body": "\u003ca id=\"c3\"\u003e\u003c/a\u003eComment 3:\n\n\u003cpre\u003eThe long-term fix may well be the removal of LookupFieldOrMethod in favor of selection\nsets (decision pending, but there are higher-priority items to be dealt with at the\nmoment).\n\nThat said, I looked into changing the semantics of this function to not automatically\nindirect an incoming pointer type *T when looking for methods. There are multiple issues\nwith such a change:\n\n1) Per the spec, methods are attached to the base type of a receiver type. In case of a\npointer receiver, the base type is the pointer's base (or element) type. That is, to\nfind methods on (unnamed) pointer types *T, one has to indirect to T. That indirect\ncould me hidden, but it makes using the function more complicated (see below).\n\n2) LookupFieldOrMethod actually doesn't know what it is going to find (and the callers\nof this function may not know what they are looking for, either). In other words, the\nselector x.f may denote a field or a method. Only _after_ we have found a field or\nmethod do we know whether we should or should not have indirected in the first place.\n(As a related matter, if we don't find anything, and we have a named pointer, we will\nneed to indirect that named pointer and try again, but throw away the result if it's a\nmethod, because Go automatically indirects pointers to fields, but _not_ pointers to\nmethods).\n\n3) Let's assume we are looking up a method x.m, where x is a non-pointer type T, and m\nis a method with receiver *T. If LookupField were to lookup m based on T, if would have\nto return nil as a result, because m is not in the method set of T. However, per the\nspec: \"If x is addressable and \u0026x's method set contains m, x.m() is shorthand for\n(\u0026x).m()\"; that is, in this case we would have to look up m again, this time with *T as\nthe incoming type. We could avoid that by always starting with *T if x is a addressable,\nand it would work even if m is a field (because of the automatic indirection for\nfields). But such an approach would require different calls to LookupFieldOrMethod\ndepending on whether we have an addressable or non-addressable x. That is fine, but it\nis more complicated than the current implementation where LookupFieldOrMethod is\nfactored out (see calls.go:305) and the result values are sufficient to make the various\ncase distinctions.\n\nThe best fix might be to document this function better.\u003c/pre\u003e",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-08-26T19:39:14Z",
	"updated_at": "2014-12-08T10:47:39Z"
}
