{
	"id": 236210349,
	"body": "It sounds like your goal is to have different Git configuration in the repositories that `go get` clones, compared to the other Git repositories on your system. I've tried to explain below why that's not a typical case, but in any event, I think it should be doable by writing a `post-checkout` hook:\r\n\r\n```\r\ngit config --global core.hooksPath E:\\hooks\r\n```\r\n\r\n```\r\n#!/bin/sh\r\nif [[ \"$GIT_DIR\" = E:\\src\\Go* ]]; then\r\ngit config user.email \"goemail@corp.com\"\r\nfi\r\n```\r\n\r\n\u003e It could make sure it knows user.name and user.email prior to attempting operations that may require them, and request whatever is missing ahead of time interactively, or\r\n\r\nGit is already doing this check, as you pointed out by showing the output of \"git pull\". I don't think it's worth duplicating this check in `go get`. There are probably a hundred other configurations that cause errors too, should we duplicate all of Git's logic in `go get`?\r\n\r\n\u003e It could alter the way it pulls code to enforce the default configuration it's currently just expecting to exist (--rebase=false for pull and I think --checkout for submodule update), or\r\n\r\nSetting `--rebase=false` doesn't prevent a commit from being created, and even if it did, people have preferences for rebase vs. merge. (You yourself, even, since you have `pull.rebase` set.) I think perhaps there's a disconnect in what `go get` is for. If you think of it solely as a package manager, then yeah, it makes a lot of sense to enforce a single, working, Git configuration. But `go get` is not just a package manager - it's a tool for managing your GOPATH, where user-written code also lives. Consider, for instance, if a user `go get`s a package, edits the code and commits locally, and then tries to update. Clearly, we should be using the user's preference for rebase vs. merge here - we shouldn't force them to use a merge (by passing `--rebase=false`). It is very common for users to directly manipulate the Git repositories in GOPATH.\r\n\r\n\u003e It could behave more or less like it does now but provide preferences (environment variables, I guess?) that users could set that would then be set in local git configs after an initial clone, or\r\n\r\nI don't see why those preferences need to be anywhere other than where they are now, `.git/config`. As I tried to explain above, the Git repositories that go clones are not special in any way.\r\n\r\n\u003e It could just look for a \"template\" config file in $GOPATH to merge into local configs\r\n\r\nDitto, this is already the purpose of `.git/config`, why invent another config file?",
	"user": {
		"login": "quentinmit",
		"id": 115761,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-29T15:23:25Z",
	"updated_at": "2016-07-29T15:23:25Z"
}
