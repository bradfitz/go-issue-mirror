{
	"id": 66055741,
	"body": "\u003ca id=\"c4\"\u003e\u003c/a\u003eComment 4 by **tarmigan**:\n\n\u003cpre\u003eOK I have instrumented src/pkg/bufio/bufio.go with the following (sorry cut-n-paste may\nlose formatting):\n\ndiff --git a/src/pkg/bufio/bufio.go b/src/pkg/bufio/bufio.go\nindex eaae8bb..ad168f1 100644\n--- a/src/pkg/bufio/bufio.go\n+++ b/src/pkg/bufio/bufio.go\n@@ -9,6 +9,7 @@ package bufio\n \n import (\n        \"bytes\"\n+       \"fmt\"\n        \"io\"\n        \"os\"\n        \"strconv\"\n@@ -86,6 +87,8 @@ func NewReader(rd io.Reader) *Reader {\n \n // fill reads a new chunk into the buffer.\n func (b *Reader) fill() {\n+       t := b.w\n+\n        // Slide existing data to beginning.\n        if b.r \u003e 0 {\n                copy(b.buf, b.buf[b.r:b.w])\n@@ -99,6 +102,9 @@ func (b *Reader) fill() {\n        if e != nil {\n                b.err = e\n        }\n+       if b.w \u003e 4096 {\n+               fmt.Println(\"WTF\", len(b.buf), b.r, b.w, n, t)\n+       }\n }\n \n // Peek returns the next n bytes without advancing the reader. The bytes stop\n@@ -249,6 +255,11 @@ func (b *Reader) Buffered() int { return b.w - b.r }\n // ReadSlice returns err != nil if and only if line does not end in delim.\n func (b *Reader) ReadSlice(delim byte) (line []byte, err os.Error) {\n        // Look in buffer.\n+       if b.r-1 \u003e len(b.buf) || b.w-1 \u003e len(b.buf) {\n+               fmt.Println(len(b.buf), b.r, b.w)\n+               return line, os.NewError(\"Bufio problem\")\n+       }\n+\n        if i := bytes.IndexByte(b.buf[b.r:b.w], delim); i \u003e= 0 {\n                line1 := b.buf[b.r : b.r+i+1]\n                b.r += i + 1\n\n\nMy program no longer panics, and when I run my program I see lines like\nWTF 4096 1871 8192 4096 1871\n4096 1871 8192\n\nWTF 4096 2978 8192 4096 2978\n4096 2978 8192\n \nso something is going wrong in  func (b *Reader) fill().  Looks like funny things happen\non b.rd.Read(buf[START:]) when START == len(buf).\n\nBut I'm also not sure how b.r != 0.  The \"slide\" should be setting b.r = 0 and b.w -=\nb.r.  Is someone else messing with b.r behind our back?\n\n[...]\n\nOK, I've now changed to this patch (edited context slightly by hand to allow you to read\nthe flow of fill() better):\n\ndiff --git a/src/pkg/bufio/bufio.go b/src/pkg/bufio/bufio.go\nindex eaae8bb..06c4764 100644\n--- a/src/pkg/bufio/bufio.go\n+++ b/src/pkg/bufio/bufio.go\n@@ -9,6 +9,7 @@ package bufio\n \n import (\n        \"bytes\"\n+       \"fmt\"\n        \"io\"\n        \"os\"\n        \"strconv\"\n@@ -86,12 +87,16 @@ func NewReader(rd io.Reader) *Reader {\n \n // fill reads a new chunk into the buffer.\n func (b *Reader) fill() {\n+       w := b.w\n+       r := b.r\n        // Slide existing data to beginning.\n        if b.r \u003e 0 {\n                copy(b.buf, b.buf[b.r:b.w])\n                b.w -= b.r\n                b.r = 0\n        }\n+       w2 := b.w\n+       r2 := b.r\n \n        // Read new data.\n        n, e := b.rd.Read(b.buf[b.w:])\n        b.w += n\n        if e != nil {\n                b.err = e\n        }\n+       if b.w \u003e 4096 {\n+               fmt.Println(\"WTF\", len(b.buf), cap(b.buf), n, b.r, b.w, r, w, r2, w2)\n+       }\n }\n \n // Peek returns the next n bytes without advancing the reader. The bytes stop\n@@ -249,6 +257,11 @@ func (b *Reader) Buffered() int { return b.w - b.r }\n // ReadSlice returns err != nil if and only if line does not end in delim.\n func (b *Reader) ReadSlice(delim byte) (line []byte, err os.Error) {\n        // Look in buffer.\n+       if b.r-1 \u003e len(b.buf) || b.w-1 \u003e len(b.buf) {\n+               fmt.Println(len(b.buf), b.r, b.w)\n+               return line, os.NewError(\"Bufio problem\")\n+       }\n+\n        if i := bytes.IndexByte(b.buf[b.r:b.w], delim); i \u003e= 0 {\n\n\nI get this as the output:\nWTF 4096 4096 4096 1772 8192 1772 1772 0 0\n4096 1772 8192\n\nWTF 4096 4096 4096 1301 8192 1301 1301 0 0\n4096 1301 8192\n\nMapping that last one by hand:\nlen(b.buf) == cap(b.buf) == n == 4096 which looks OK\nr2 == w2 == 0 so the slide seems have happened OK\nr == w == 1301  OK maybe it's a clue that they are the same.\nb.r == 1301, but, but it was just 0!\nb.w == 8192 but, but 0+4092 != 8192\n\nI'm stumped, but maybe the disassembly has the answer.\n\nThanks,\nTarmigan\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2011-04-22T08:19:45Z",
	"updated_at": "2014-12-08T10:09:36Z"
}
