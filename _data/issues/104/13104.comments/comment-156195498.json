{
	"id": 156195498,
	"body": "Agreed.  Too late. :-(\n\nThe details of an up-arrow mapping are *not* part of the SSH protocol.  Its\nbetter to think of SSH like a serial line (8-bit).  It passes byte streams\nunmolested (mostly) between two parties.\n\nThe fact that one of those parties is an environment running perhaps in a\nterminal that can parse certain sequences of bytes as e.g. an up arrow\nkeypress, or as a command to clear the screen, is a private negotiation\ndone between the two parties communicating over SSH.  Typically in the case\nof the server, this means the program that is forked by the server.  (E.g.\nyour editor.)\n\nFor UNIX, as I'm sure you're aware, this involves setting a $TERM variable,\nand using a database (terminfo/termcap) that expresses these capabilities.\nBut the thing that looks up the fields in the database is *not* the ssh\nserver (or client), but rather any interactive program that such server\nspawns.\n\n(NB: For something like a program running on a Windows console, this is not\nused at all.  That's a very very different environment, and control data\nlike extended key codes and window management operations are sent out of\nband.)\n\nScanning briefly at the SSH server code, I have to confess I have no idea\nwhy we have this code here.  It doesn't look like the SSH server implements\na shell, or anything like that.  But maybe I'm missing something?\n\nSo, all this said, given the unfortunate precedent, I'm ok with extending\nthe scope of x/term to include this type of handling.  I think it becomes\nsomething like curses or curses-lite (or tcell or termbox) to be useful --\nthe interfaces exposed by ssh Terminal are just plain *wrong*, and I\nwouldn't like to see those interfaces promulgated further.\n\nThat said, there are a *few* interfaces there that are nice.\nReadPassword() is a nice/good interface.  That can be done entirely without\nthis logic.   The only \"escape\" sequences it needs to understand are CTRL-H\n(backspace) and *perhaps* CTRL-U (delete back to beginning of line).  Those\naren't even escape sequences properly.  I'm not convinced that even this is\nnecessary.  I think it should be possible to do this entirely without\nescape sequences by just disabling echo.  (Meaning I don't think full raw\nmode is required to prompt for passwords.)\n\nAs I think about this, it feels like there are really several different\npackages here:\n\na) x/tty -- low level termio/console mode setting stuff.  This is the most\nbasic functionality and the thing that cannot be done without using either\ncgo or help from the runtime.   A reasonable argument can be made for this\nto live in x/os.  I prefer it separate, but as long as the *interfaces* are\nagnostic I'm happy to see this limited scope stuff live in x/os.  This\ncould include the low level stuff for serial ports too, since historically\nthese are frequently linked together with termios.\n\nb) x/term - building upon the above, adding support for echoing with\nattributes, getting terminal size, setting cursor location, etc.  Sort of\ntermbox or tcell functionality.  This is where a terminfo parser for\nexample would live, and where the knowledge of manipulation of Windows\nconsoles would live.  This provides the abstraction of different terminal\ntypes, etc.  This is equivalent to the low level terminfo handling on UNIX\n(though it would need to have an interface that also supports out-of-band\nmetainformation like Windows consoles use.)\n\nc) x/prompt -- this could involve both a simplistic password prompter, but\nalso a readline or editline replacement, with command history and so\nforth.  This would make it possible to build nice CLIs with an interactive\nline-editing mode, etc.  This could be built upon x/term.\n\nd) x/tui -- this is a full blown TUI package, with windows or view ports,\netc.  It would build upon x/tty and x/term.  In tcell I have a package that\ndoes this called tcell/views  -- its somewhat limited but it does have\nwidget layering and scrollable view ports, etc.  This is sort of the full\ncurses type functionality.\n\nNow I'll point out that its probably quite reasonable for b, c, and\n*especially* d to be implemented as 3rd party packages.  Indeed, there are\ntwo packages that have already done this -- termbox and tcell -- for b \u0026 d.\n (Other packages that do c exist, but they do it via cgo and libeditline or\nlibreadline usually, I think.)\n\nWhat's really become obvious is that the name is *important* because it\nhelps define the *scope*, and I think that we need to resolve the scope\nbefore getting to fixated on the name. :-)\n\n - Garrett\n\nOn Thu, Nov 12, 2015 at 9:51 AM, mattn \u003cnotifications@github.com\u003e wrote:\n\n\u003e terminal code in ssh package should be internal package or private\n\u003e methods. but too late.\n\u003e\n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/13104#issuecomment-156182504\u003e.\n\u003e\n",
	"user": {
		"login": "gdamore",
		"id": 1295229,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-12T18:35:43Z",
	"updated_at": "2015-11-12T18:35:43Z"
}
