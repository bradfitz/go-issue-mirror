{
	"id": 134462731,
	"number": 14374,
	"state": "closed",
	"title": "x/net/http2: `http.Server.Serve` doesn't serve http2 traffic",
	"body": "* What version of Go are you using (go version)?\r\n\r\n1.6\r\n\r\n* What operating system and processor architecture are you using?\r\n\r\nDarwin, AMD64\r\n\r\n* What did you do?\r\n\r\nI'm trying to pass a tls `net.Listener` to [`http.Server.Serve`](https://github.com/golang/go/blob/release-branch.go1.6/src/net/http/server.go#L2107-L2139) but the server didn't run on http2.\r\n\r\nSee below code:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"crypto/tls\"\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"net\"\r\n\t\"net/http\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\tcrt := \"YOUR_CRT\"\r\n\tkey := \"YOUR_KEY\"\r\n\r\n\tmux := http.NewServeMux()\r\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\r\n\t\tfmt.Fprintf(w, \"hello\\n\")\r\n\t})\r\n\r\n\tss := \u0026http.Server{\r\n\t\tAddr:    \":8080\",\r\n\t\tHandler: mux,\r\n\t}\r\n\r\n\terr := listenAndServeTLS(ss, []byte(crt), []byte(key))\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n}\r\n\r\n// listenAndServeTLS is equivalent to http.Server.ListenAndServeTLS\r\n// but loads cert and key as []byte instead of files\r\nfunc listenAndServeTLS(srv *http.Server, cert, key []byte) error {\r\n\taddr := srv.Addr\r\n\tif addr == \"\" {\r\n\t\taddr = \":https\"\r\n\t}\r\n\r\n\tconfig := cloneTLSConfig(srv.TLSConfig)\r\n\tif !strSliceContains(config.NextProtos, \"http/1.1\") {\r\n\t\tconfig.NextProtos = append(config.NextProtos, \"http/1.1\")\r\n\t}\r\n\r\n\tvar err error\r\n\tconfig.Certificates = make([]tls.Certificate, 1)\r\n\tconfig.Certificates[0], err = tls.X509KeyPair(cert, key)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\r\n\tln, err := net.Listen(\"tcp\", addr)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\r\n\ttlsListener := tls.NewListener(tcpKeepAliveListener{ln.(*net.TCPListener)}, config)\r\n\treturn srv.Serve(tlsListener)\r\n}\r\n\r\n// tcpKeepAliveListener sets TCP keep-alive timeouts on accepted\r\n// connections. It's used by ListenAndServe and ListenAndServeTLS so\r\n// dead TCP connections (e.g. closing laptop mid-download) eventually\r\n// go away.\r\ntype tcpKeepAliveListener struct {\r\n\t*net.TCPListener\r\n}\r\n\r\nfunc (ln tcpKeepAliveListener) Accept() (c net.Conn, err error) {\r\n\ttc, err := ln.AcceptTCP()\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\ttc.SetKeepAlive(true)\r\n\ttc.SetKeepAlivePeriod(3 * time.Minute)\r\n\treturn tc, nil\r\n}\r\n\r\nfunc strSliceContains(ss []string, s string) bool {\r\n\tfor _, v := range ss {\r\n\t\tif v == s {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}\r\n\r\n// cloneTLSConfig returns a shallow clone of the exported\r\n// fields of cfg, ignoring the unexported sync.Once, which\r\n// contains a mutex and must not be copied.\r\n//\r\n// The cfg must not be in active use by tls.Server, or else\r\n// there can still be a race with tls.Server updating SessionTicketKey\r\n// and our copying it, and also a race with the server setting\r\n// SessionTicketsDisabled=false on failure to set the random\r\n// ticket key.\r\n//\r\n// If cfg is nil, a new zero tls.Config is returned.\r\nfunc cloneTLSConfig(cfg *tls.Config) *tls.Config {\r\n\tif cfg == nil {\r\n\t\treturn \u0026tls.Config{}\r\n\t}\r\n\treturn \u0026tls.Config{\r\n\t\tRand:                     cfg.Rand,\r\n\t\tTime:                     cfg.Time,\r\n\t\tCertificates:             cfg.Certificates,\r\n\t\tNameToCertificate:        cfg.NameToCertificate,\r\n\t\tGetCertificate:           cfg.GetCertificate,\r\n\t\tRootCAs:                  cfg.RootCAs,\r\n\t\tNextProtos:               cfg.NextProtos,\r\n\t\tServerName:               cfg.ServerName,\r\n\t\tClientAuth:               cfg.ClientAuth,\r\n\t\tClientCAs:                cfg.ClientCAs,\r\n\t\tInsecureSkipVerify:       cfg.InsecureSkipVerify,\r\n\t\tCipherSuites:             cfg.CipherSuites,\r\n\t\tPreferServerCipherSuites: cfg.PreferServerCipherSuites,\r\n\t\tSessionTicketsDisabled:   cfg.SessionTicketsDisabled,\r\n\t\tSessionTicketKey:         cfg.SessionTicketKey,\r\n\t\tClientSessionCache:       cfg.ClientSessionCache,\r\n\t\tMinVersion:               cfg.MinVersion,\r\n\t\tMaxVersion:               cfg.MaxVersion,\r\n\t\tCurvePreferences:         cfg.CurvePreferences,\r\n\t}\r\n}\r\n```\r\n\r\nWhen I curled it:\r\n\r\n```\r\n$ curl https://localhost:8080 -k -v --http2\r\n* Rebuilt URL to: https://localhost:8080/\r\n*   Trying 127.0.0.1...\r\n* Connected to localhost (127.0.0.1) port 8080 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH\r\n* successfully set certificate verify locations:\r\n*   CAfile: /opt/boxen/homebrew/etc/openssl/cert.pem\r\n  CApath: none\r\n* TLSv1.2 (OUT), TLS header, Certificate Status (22):\r\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\r\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\r\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\r\n* TLSv1.2 (OUT), TLS change cipher, Client hello (1):\r\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\r\n* TLSv1.2 (IN), TLS change cipher, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384\r\n* ALPN, server accepted to use http/1.1\r\n* Server certificate:\r\n*        subject: C=US; ST=California; L=San Francisco; O=Heroku; OU=Heroku API; CN=Midgard; emailAddress=api@heroku.com\r\n*        start date: Oct 30 17:30:09 2015 GMT\r\n*        expire date: Mar 13 17:30:09 2017 GMT\r\n*        issuer: C=US; ST=California; L=San Francisco; O=Heroku; OU=Heroku API; CN=Midgard; emailAddress=api@heroku.com\r\n*        SSL certificate verify result: self signed certificate (18), continuing anyway.\r\n\u003e GET / HTTP/1.1\r\n\u003e Host: localhost:8080\r\n\u003e User-Agent: curl/7.47.1\r\n\u003e Accept: */*\r\n\u003e\r\n\u003c HTTP/1.1 200 OK\r\n\u003c Date: Thu, 18 Feb 2016 02:09:44 GMT\r\n\u003c Content-Length: 5\r\n\u003c Content-Type: text/plain; charset=utf-8\r\n\u003c\r\n* Connection #0 to host localhost left intact\r\nhello%\r\n```                                                                                                        \r\n\r\nI compared line by line my implementation of `listenAndServeTLS` with [`http.Sever.ListenAndServeTLS`](https://github.com/golang/go/blob/release-branch.go1.6/src/net/http/server.go#L2245-L2279). The difference is I didn't call [`srv.setupHTTP2()`](https://github.com/golang/go/blob/release-branch.go1.6/src/net/http/server.go#L2253-L2255). But it should be called in [`http.Server.Serve`](https://github.com/golang/go/blob/release-branch.go1.6/src/net/http/server.go#L2113-L2115) again. However, if I changed the code to `http.Server.ListenAndServeTLS`, the server ran on http2. \r\n\r\n* What did you expect to see?\r\n\r\nI expected the server to run on http2 with `http.Sever.Serve`.\r\n\r\n* What did you see instead?\r\n\r\nThe server ran on http1/1\r\n",
	"user": {
		"login": "jingweno",
		"id": 169064,
		"type": "User",
		"site_admin": false
	},
	"comments": 9,
	"closed_at": "2016-02-18T02:59:21Z",
	"created_at": "2016-02-18T02:25:25Z",
	"updated_at": "2016-06-29T22:37:16Z"
}
