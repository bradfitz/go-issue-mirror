{
	"id": 66057003,
	"body": "\u003ca id=\"c6\"\u003e\u003c/a\u003eComment 6 by **mt4swm**:\n\n\u003cpre\u003eSeeing it also on Linux/386 (golang tip revision), when\nusing index/suffixarray on quite large data (e.g. 4MB\ntext). Qsufsort internally creates a temporarily\ninverted array `inv' of the same size as the suffix array\n(\u003ca href=\"http://golang.org/src/pkg/index/suffixarray/qsufsort.go?h=inv#L37)\"\u003ehttp://golang.org/src/pkg/index/suffixarray/qsufsort.go?h=inv#L37)\u003c/a\u003e.\nIt appears not to be freed after runtime.GC(), which --\nin case of multiple search indices -- can sum up to a quite\nlarge amount of data.\n\nI created a minimal version of the program, which allocates \ntemporary slices in a loop. The effect only shows up if \"fmt\" is\nimported, and slices \u003e= 4MB are allocated. It vanishes if \"println\" is\nused instead (as in #3), or smaller slices are allocated.\n\nThere is also an effect of \"saturation\" visible:\n\tNothing is freed up to an amount of 165MB, then the\n\tsum of allocated memory remains stable, i.e. on each\n\tGC run 4MB are freed:\n\n  gc1: 0+0+0 ms 0 -\u003e 0 MB 104 -\u003e 102 (104-2) objects 40 pointer lookups (29 size, 11 addr)\n  gc2: 0+0+0 ms 4 -\u003e 4 MB 273 -\u003e 233 (275-42) objects 242 pointer lookups (159 size, 83 addr)\n  gc3: 0+0+0 ms 4 -\u003e 4 MB 233 -\u003e 233 (275-42) objects 243 pointer lookups (159 size, 84 addr)\n  gc4: 0+0+0 ms 8 -\u003e 8 MB 235 -\u003e 235 (277-42) objects 247 pointer lookups (160 size, 87 addr)\n  gc5: 0+0+0 ms 12 -\u003e 12 MB 237 -\u003e 237 (279-42) objects 260 pointer lookups (161 size, 99 addr)\n  ...\n  gc41: 8+1+0 ms 157 -\u003e 157 MB 309 -\u003e 309 (351-42) objects 1130 pointer lookups (197 size, 933 addr)\n  gc42: 13+0+0 ms 161 -\u003e 161 MB 311 -\u003e 311 (353-42) objects 1132 pointer lookups (198 size, 934 addr)\n  gc43: 5+0+0 ms 165 -\u003e 165 MB 313 -\u003e 313 (355-42) objects 1133 pointer lookups (199 size, 934 addr)\n  gc44: 18+0+0 ms 169 -\u003e 165 MB 315 -\u003e 314 (357-43) objects 1134 pointer lookups (200 size, 934 addr)\n  gc45: 11+0+0 ms 169 -\u003e 165 MB 315 -\u003e 314 (358-44) objects 1134 pointer lookups (200 size, 934 addr)\n  ...\n  gc81: 20+0+0 ms 169 -\u003e 165 MB 315 -\u003e 314 (394-80) objects 1134 pointer lookups (200 size, 934 addr)\n  gc82: 16+0+0 ms 169 -\u003e 165 MB 315 -\u003e 314 (395-81) objects 1134 pointer lookups (200 size, 934 addr)\n  In use: 173596448 337231104\n\nBy applying some debug output to runtime/mgc0.c I noticed that\nit detected 41 pointers (41*4MB = 164MB) to the beginning of\nthe slice buffers while \"consulting span table\".\u003c/pre\u003e\n\n\n\n\n\nAttachments:\n\n1. \u003ca href=\"https://storage.googleapis.com/go-attachment/1925/6/test.go\"\u003etest.go\u003c/a\u003e (420 bytes)",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2011-09-11T13:27:34Z",
	"updated_at": "2014-12-08T10:10:35Z"
}
