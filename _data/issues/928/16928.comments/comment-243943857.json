{
	"id": 243943857,
	"body": "On Wed, Aug 31, 2016 at 5:28 PM, strikerdw \u003cnotifications@github.com\u003e wrote:\n\n\u003e Hello, I'm the Derek Williams Bishop referred to. I'm a hardware guy and I\n\u003e know how to spell Go, but that's most of what I know about Go. But I am the\n\u003e Power ISA memory model expert, so what I say here and in other emails will\n\u003e be slanted towards how the hardware works at the machine instruction level.\n\u003e There's doubtless some translation to be had from that world-view into Go.\n\u003e\n\u003e Above, ianlancetaylor says:\n\u003e\n\u003e *I believe there is room for debate once you understand that goroutines\n\u003e are not preempted at arbitrary points, but only at well understood and\n\u003e agreed upon points.*\n\u003e\n\u003e Possibly yes. Can you give me some idea what these agreed upon and well\n\u003e understood points guarantee? Some of the usual hygiene that has to happen\n\u003e at context switches might be avoidable based on these conditions, but\n\u003e before I can have an opinion I need to know what guarantees those points\n\u003e give you.\n\u003e\nThose points are at most function call prologues (a few specially chosen\nruntime functions opt out of allowing preemption).\nIn Go, all registers are callee-save so no registers are live at these\npoints, except the stack pointer and any arch-specific things like thread\npointer and zero register.\n\n\u003e And randall77 says:\n\u003e\n\u003e\n\u003e\n\u003e\n\u003e\n\u003e *In addition to what Ian said, the Go scheduler uses synchronization\n\u003e operations to move a Goroutine from one P (one OS thread) to another. So\n\u003e the Go scheduler guarantees that after a goroutine stops, it will make sure\n\u003e all of its state gets to the new processor before the goroutine is started\n\u003e again.*\n\u003e\n\u003e Interesting. can you explain what synchronization operations those are?\n\u003e\n\u003e They might fix things, but I can't tell because I have no idea what they\n\u003e are.\n\u003e\n\u003e I apologize for my ignorance here. Once I have some idea what these things\n\u003e are and if they fix this, I'll be in a better position to comment.\n\u003e\n There's a lock around the global run queue (src/runtime/lock_futex.go).\nProcessors also put and take work from per-P queues using atomic load +\ncompare and swap (src/runtime/proc.go:runqget, for example).\n\n\u003e Thanks,\n\u003e\n\u003e Derek\n\u003e\n\u003e â€”\n\u003e You are receiving this because you were mentioned.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/16928#issuecomment-243942064\u003e, or mute\n\u003e the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AGkgIHBW0FNcXaQ2ogewa06qCCd5fboVks5qlhw3gaJpZM4Jw0w5\u003e\n\u003e .\n\u003e\n",
	"user": {
		"login": "randall77",
		"id": 6889504,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-09-01T00:41:00Z",
	"updated_at": "2016-09-01T00:41:00Z"
}
