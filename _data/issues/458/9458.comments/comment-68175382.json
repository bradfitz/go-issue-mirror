{
	"id": 68175382,
	"body": "\u003e I think the fact that the Playground and my local machine produce different results is a bit scary, and really mars Go's generally excellent platform independence, given that it is extremely subtle. Tests using only pure builtin functions on my machine could fail on someone else's just because they have a different hostarch, version, or anything at all. This isn't something obviously bad like relying on data races happening to resolve correctly, or using unsafe to do uintptr nonsense.\r\n\r\nRelying on `append` to overallocate by a particular amount *is* obviously bad (to me at least).\r\n\r\n\u003e in fact the only real warning flag is that if you're a pro at reading specs you'll note that the spec doesn't guarantee anything about append's exact behavior, only specifying \"sufficiently large\".\r\n\r\nIn addition to the spec, all of the following documents describe `append` in full detail, such that the reader should understand that the destination may be reused or a new, larger array allocated:\r\n\r\n* Godoc (http://golang.org/pkg/builtin/#append)\r\n* The Go Tour (http://tour.golang.org/moretypes/11)\r\n* Effective Go (https://golang.org/doc/effective_go.html#append)\r\n\r\nSo however the newbie Gopher learns about append s/he should learn about this behavior.\r\n\r\nIt's true that there's no giant red warning box, but neither is there for integer overflow, data races, etc.\r\n\r\n \u003e Personally, I tend not to use append for anything too complex, and I never rely on slices sharing buffers (or pointers to slice elements) in code that uses append unless I'm in explicit control over the capacity at all times due to the general difficulty in reasoning about this sort of thing.\r\n\r\nI haven't found this to be much of a problem, in practice. The main thing to look out for is:\r\n\r\n```\r\nb = append(a, x)\r\n// do things with both a and b\r\n```\r\n\r\nThis is easy to spot and it doesn't end up being a source of bugs for me. 90%+ of the usages of append are of the form `a = append(a, x)` anyway, so this danger doesn't arise.\r\n\r\n\u003e However, I think this means chained appends are far too Dangerousâ„¢,\r\n\r\nWhat exactly do you mean by chaining, and why do you think that it is particularly prone to this problem?\r\n\r\n\u003e Slices could very easily accidentally overwrite each other's memory spaces too if this isn't consistent (you were relying on append making a new slice, but under a different compiler's slice growth rules it secretly had sufficient cap).\r\n\r\nThis is just a bad assumption, and again I don't think it happens often in the real world.\r\n\r\nIn any case, I don't think there's anything to be changed in the spec here; at most this would be a documentation update (in Effective Go, the tour, ...).",
	"user": {
		"login": "cespare",
		"id": 318501,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-12-27T10:59:28Z",
	"updated_at": "2014-12-27T11:01:23Z"
}
