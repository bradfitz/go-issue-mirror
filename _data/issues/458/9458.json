{
	"id": 52953689,
	"number": 9458,
	"state": "closed",
	"title": "spec: possible danger w.r.t. slices and append",
	"body": "I was looking at the spec, and noticed that no exact rules are given for the underlying behavior of slices, especially with regard to append. This seems sensible at first. After all, a compiler targeting an environment with extreme memory constraints can be free to not grow the buffer as greedily as the current compiler (which I believe is *2 or closer to *1.5 for very large slices).\r\n\r\nHowever, this causes undefined behavior for pointers to individual slice values, or slices you expect to share an underlying buffer. Take this example:\r\n\r\n        a := []int{}\r\n\ta = append(a,1)\r\n\tb := append(a,1)\r\n\tb[0] = 3\r\n\ta[0] = 0\r\n\tfmt.Println(a, b)\r\n\r\nhttp://play.golang.org/p/ob0psGicA3\r\n\r\nOn the playground, appending to an empty slice initializes the capacity to 2. This means that this will print \"[0] [0 1]\", because a and b share a buffer under those slice expansion rules. However, on my machine (64-bit Windows, go 1.4) an empty slice grows to a capacity of 1, and thus this prints \"[0] [3 1]\". The behavior is entirely different. There's no guarantee they share a memory space or that the way capacity grows the buffer is consistent. This seems like a simple fix for the case where capacity=0, but there are a lot of places this could happen. What if my theoretical compiler rules for target `theoretical-embedded-system` use additive expansion because of the memory constraints? It's allowed as per the spec.\r\n\r\nWhile I completely understand what's happening, in my opinion this is Dangerous™. Nothing really mentions this -- `go vet` doesn't catch it, effective Go doesn't mention it, in fact the only real warning flag is that if you're a pro at reading specs you'll note that the spec doesn't guarantee anything about append's exact behavior, only specifying \"sufficiently large\". To review:\r\n\r\n\u003e If the capacity of s is not large enough to fit the additional values, append allocates a new,\r\n\u003e sufficiently large underlying array that fits both the existing slice elements and the additional\r\n\u003e values. Otherwise, append re-uses the underlying array.\r\n\r\nI think the fact that the Playground and my local machine produce different results is a bit scary, and really mars Go's generally excellent platform independence, given that it is extremely subtle. Tests using only pure builtin functions on my machine could fail on someone else's just because they have a different hostarch, version, or anything at all. This isn't something obviously bad like relying on data races happening to resolve correctly, or using unsafe to do uintptr nonsense. Nor is it anything weird or obviously platform specific like relying on files or syscalls existing.\r\n\r\nPersonally, I tend not to use append for anything too complex, and I never rely on slices sharing buffers (or pointers to slice elements) in code that uses append unless I'm in explicit control over the capacity at all times due to the general difficulty in reasoning about this sort of thing. However, I think this means chained appends are far too Dangerous™, and I was wondering whether it necessitated either fixing or explicit clarification that this is intentional in the spec. \r\n\r\nKeep in mind that the problem here isn't just slices **diverging** either. Slices could very easily accidentally overwrite each other's memory spaces too if this isn't consistent (you were relying on append making a new slice, but under a different compiler's slice growth rules it secretly had sufficient cap). While it won't cause C-level buffer overflow memory corruption bugs, it's still pretty bad.\r\n\r\nAt the very least, I think if we keep the non-guarantee about expansion rules this way (and there are good reasons to), it needs to have a big warning label. Preferably somewhere newbies will see it.\r\n\r\nThis is possibly related to the spec clarification issue about \"reference-like properties\":\r\nhttps://github.com/golang/go/issues/5083",
	"user": {
		"login": "Jragonmiris",
		"id": 3078382,
		"type": "User",
		"site_admin": false
	},
	"comments": 7,
	"closed_at": "2014-12-28T23:45:26Z",
	"created_at": "2014-12-27T10:04:44Z",
	"updated_at": "2016-02-02T15:25:00Z"
}
