{
	"id": 160766160,
	"number": 16085,
	"state": "closed",
	"title": "Proposal: Ignore tags in struct type conversions",
	"body": "**Abstract**\r\nThis document proposes to relax struct conversions such that struct tags are ignored. An alternative to the proposal is to add a new function reflect.StructCopy that could be used instead.\r\n\r\n**1. Background**\r\nThe spec (https://codereview.appspot.com/1698043) and corresponding implementation change (https://golang.org/cl/1667048) submitted almost exactly six years ago made struct tags (https://golang.org/ref/spec#Struct_types) an integral part of a struct type by including them in the definition of struct type identity (https://golang.org/ref/spec#Type_identity) and indirectly in struct type conversions (https://golang.org/ref/spec#Conversions).\r\n\r\nIn retrospect, this change may have been overly restrictive with respect to its impact on struct conversions, given the way struct tag use has evolved over the years. A common scenario is the conversion of struct data coming from, say a database, to an _equivalent_ (identical but for its tags) struct that can be JSON-encoded, with the JSON encoding defined by the respective struct tags. For an example of such a type, see https://github.com/golang/text/blob/master/unicode/cldr/xml.go#L6.\r\n\r\nThe way struct conversions are defined, it is not currently possible to convert a value from one struct type to an equivalent one. Instead, every field must be copied manually, which leads to more source text, and less readable and possibly less efficient code. The code must also be adjusted every time the involved struct types change.\r\n\r\nhttps://github.com/golang/go/issues/6858 discusses this in more detail. rsc@golang and r@golang suggest that we might be able to relax the rules for structs such that struct tags are ignored for conversions, but not for struct identity.\r\n\r\n**2. Proposal**\r\nThe spec states a set of rules for conversions. The following rules apply to conversions of struct values (among others):\r\n\r\nA non-constant value x can be converted to type T if:\r\n- x's type and T have identical underlying types\r\n- x's type and T are unnamed pointer types and their pointer base types have identical underlying types\r\n\r\nThe proposal is to change these two rules to:\r\n\r\nA non-constant value x can be converted to type T if:\r\n- x's type and T have identical underlying types _if struct tags are ignored (recursively)_\r\n- x's type and T are unnamed pointer types and their pointer base types have identical underlying types _if struct tags are ignored (recursively)_\r\n\r\nAdditionally, package reflect is adjusted (Type.ConvertibleTo, Value.Convert) to match this language change.\r\n\r\nIn other words, type identity of structs remains unchanged, but for the purpose of struct conversions, type identity is relaxed such that struct tags are ignored.\r\n\r\n**3. Impact**\r\nThis is is a backward-compatible language change since it loosens an existing restriction: Any existing code will continue to compile with the same meaning (*), and some code that currently is invalid will become valid.\r\n\r\nPrograms that manually copy all fields from one struct to another struct with identical type but for the (type name and) tags, will be able to use a single struct conversion instead.\r\n\r\nMore importantly, with this change two different (type) views of the same struct value become possible via pointers of different types. For instance, given:\r\n\r\n\ttype jsonPerson struct {\r\n\t\tname `json:\"name\"`\r\n\t}\r\n\r\n\ttype xmlPerson struct {\r\n\t\tname `xml:\"name\"`\r\n\t}\r\n\r\nwe will be able to access a value of *jsonPerson type\r\n\r\n\tperson := new(jsonPerson)\r\n\t// some code that populates person\r\n\r\nas a *Txml:\r\n\r\n\talias := (*xmlPerson)(\u0026person)\r\n\t// some code that uses alias\r\n\r\nThis may eliminate the need to copy struct values just to change the tags.\r\n\r\nType identity and conversion tests are also available programmatically, via the reflect package. The operations of Type.ConvertibleTo and Value.Convert will be relaxed for structs with different (or absent) tags:\r\n\r\nType.ConvertibleTo will return true for some arguments where it currently returns false. This may change the behavior of programs depending on this method.\r\n\r\nValue.Convert will convert struct values for which the operation panicked before. This will only affect programs that relied on (recovered from) that panic.\r\n\r\n(*) r@golang points out that a program that is using tags to prevent (accidental or deliberate) struct conversion would lose that mechanism. Interestingly, package reflect appears to make such use (see type rtype), but iant@golang points out that one could obtain the same effect by adding differently typed zero-sized fields to the respective structs.\r\n\r\n**4. Discussion**\r\nFrom a language spec point of view, changing struct type identity (rather than struct conversions only) superficially looks like a simpler, cleaner, and more consistent change: For one, it simplifies the spec, while only changing struct conversions requires adding an additional rule.\r\n\r\niant@golang points out (https://github.com/golang/go/issues/11661) that leaving struct identity in place doesn’t make much difference in practice: It is already impossible to assign or implicitly convert between two differently named struct types. Unnamed structs are rare, and if accidental conversion is an issue, one can always introduce a named struct.\r\n\r\nOn the other hand, runtime type descriptors (used by reflect.Type, interfaces, etc) are canonical, so identical types have the same type descriptor. The descriptor provides struct field tags, so identical types must have identical tags. Thus we cannot at this stage separate struct field tags from the notion of type identity.\r\n\r\nTo summarize: Relaxing struct conversions only but leaving struct type identity unchanged is sufficient to enable one kind of data conversion that is currently overly tedious, and it doesn’t require larger and more fundamental changes to the run time. The change may cause a hopefully very small set of programs, which depend on package reflect’s conversion-related API, to behave differently.\r\n\r\n**5. Open question**\r\nShould tags be ignored at the top-level of a struct only, or recursively all the way down? For instance, given:\r\n\r\n```\r\ntype T1 struct {\r\n\tx int\r\n\tp *struct {\r\n\t\tname string `foo`\r\n\t}\r\n}\r\n\r\ntype T2 struct {\r\n\tx int\r\n\tp *struct {\r\n\t\tname string `bar`\r\n\t}\r\n}\r\n\r\nvar t1 T1\r\n```\r\n\r\nShould the conversion T2(t1) be legal? If tags are only ignored for the fields of T1 and T2, conversion is not permitted since the tags attached to the type of the p field are different. Alternatively, if tags are ignored recursively, conversion is permitted.\r\n\r\nOn the other hand, if the types were defined as:\r\n\r\n```\r\ntype T1 struct {\r\n\tx int\r\n\tp *P1\r\n}\r\n\r\ntype T2 struct {\r\n\tx int\r\n\tp *P2\r\n}\r\n\r\n```\r\nwhere P1 and P2 are identical structs but for their tags, the conversion would not be permitted either way since the p fields have different types and thus T1 and T2 have different underlying types.\r\n\r\nThe proposal suggests to ignore tags recursively, “all the way down”. This seems to be the more sensible approach given the stated goal, which is to make it easier to convert from one struct type to another, equivalent type with different tags. For a typical example where this matters, see https://play.golang.org/p/U73K50YXYk.\r\n\r\nFurthermore, it is always possible to prevent unwanted conversions by introducing named types, but it would not be possible to enable those conversions otherwise.\r\n\r\nOn the other hand, the current implementation of reflect.Value.Convert will make recursive ignoring of struct tags more complicated and expensive. crawshaw@golang points out that one could easily use a cache inside the reflect package if necessary for performance.\r\n\r\n**6. Implementation**\r\nTentative CL forthcoming, including spec, compiler, go/types, and reflect changes.\r\n\r\n**7. Alternatives to the language change**\r\nEven a backward-compatible language change needs to meet a high bar before it can be considered. It is not yet clear that this proposal satisfies that criteria.\r\n\r\nOne alternative is to do nothing. That has the advantage of not breaking anything and also doesn’t require any implementation effort on the language/library side. But it means that in some cases structs have to be explicitly converted through field-by-field assignment.\r\n\r\nAnother alternative that actually addresses the problem is to provide a library function. For instance, package reflect could provide a new function\r\n\r\n```\r\nfunc CopyStruct(dst, src Value, mode Mode)\r\n```\r\n\r\nwhich could be used to copy struct values that have identical types but for struct tags. A mode argument might be used to control deep or shallow copy, and perhaps other modalities. A deep copy (following pointers) would be a useful feature that the spec change by itself does not enable.\r\n\r\nThe cost of using a CopyStruct function instead of a direct struct conversion is the need to create two reflect.Values, invoking CopyStruct, and (inside CopyStruct) the cost to verify type identity but for tags. Copying the actual data needs to be done both in CopyStruct but also with a direct (language-based) conversion. The type verification is likely the most expensive step but identity of struct types (with tags ignored) could be cached. On the other hand, adonovan@golang points out that the added cost may not matter in significant ways since these kinds of struct copies often sit between a database request and an HTTP response.\r\n\r\nThe functional difference between the proposed spec change and a new reflect.CopyStruct function is that with CopyStruct an actual copy has to take place (as is the case now). The spec change on the other hand permits both approaches: a (copying) conversion of struct values, or pointers to different struct types that point to the same struct value via a pointer conversion. The latter may eliminate a copy of data in the first place.",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "Proposal"
		},
		{
			"name": "Proposal-Accepted"
		}
	],
	"assignee": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"comments": 17,
	"closed_at": "2016-10-04T17:26:17Z",
	"created_at": "2016-06-16T21:32:56Z",
	"updated_at": "2016-10-04T21:06:54Z",
	"milestone": {
		"id": 1373555,
		"number": 30,
		"title": "Proposal"
	},
	"reactions": {
		"total_count": 9,
		"+1": 9
	}
}
