{
	"id": 169242317,
	"number": 16588,
	"state": "open",
	"title": "net/http: Cannot set default 'h2' and other NextProto handler concurrently",
	"body": "Please answer these questions before submitting your issue. Thanks!\r\n\r\n1. What version of Go are you using (`go version`)?\r\n\r\n1.7rc4\r\n\r\n2. What operating system and processor architecture are you using (`go env`)?\r\n\r\n(Code only)\r\n\r\n3. What did you do?\r\n\r\nTook a dive through code trying to work out how to do this.\r\n\r\nHere's what I believe the problem to be, although maybe this is purely a documentation bug.\r\n\r\nLet's say you want to use the built-in `h2` handling but also define your own handler for your own protocol. According to the documentation:\r\n```\r\n        // TLSNextProto optionally specifies a function to take over\r\n        // ownership of the provided TLS connection when an NPN\r\n        // protocol upgrade has occurred.  The map key is the protocol\r\n        // name negotiated. The Handler argument should be used to\r\n        // handle HTTP requests and will initialize the Request's TLS\r\n        // and RemoteAddr if not already set.  The connection is\r\n        // automatically closed when the function returns.\r\n        // If TLSNextProto is nil, HTTP/2 support is enabled automatically.\r\n```\r\nSo far so good. But what about if `TLSNextProto` isn't nil? When a `Server` starts serving (via `Serve()`), according to the method comments:\r\n```\r\n// For HTTP/2 support, srv.TLSConfig should be initialized to the\r\n// provided listener's TLS Config before calling Serve. If \r\n// srv.TLSConfig is non-nil and doesn't include the string \"h2\" in\r\n// Config.NextProtos, HTTP/2 support is not enabled.\r\n```\r\nOK, so this appears to indicate that one should specify a `NextProtos` field in the provided `tls.Config` including `h2`, which is fine. But now let's dig into the code.\r\n\r\nIn function `setupHTTP2_Serve()` it calls a once object to set up the defaults:\r\n```go\r\nfunc (srv *Server) setupHTTP2_Serve() error {\r\n        srv.nextProtoOnce.Do(srv.onceSetNextProtoDefaults_Serve)\r\n        return srv.nextProtoErr\r\n}\r\nfunc (srv *Server) onceSetNextProtoDefaults_Serve() {\r\n        if srv.shouldConfigureHTTP2ForServe() {\r\n                srv.onceSetNextProtoDefaults()\r\n        }\r\n}\r\n```\r\nLet's look at whether it should configure:\r\n```go\r\n// shouldDoServeHTTP2 reports whether Server.Serve should configure\r\n// automatic HTTP/2. (which sets up the srv.TLSNextProto map)\r\nfunc (srv *Server) shouldConfigureHTTP2ForServe() bool {\r\n        if srv.TLSConfig == nil {\r\n                // Compatibility with Go 1.6:\r\n                // If there's no TLSConfig, it's possible that the user just\r\n                // didn't set it on the http.Server, but did pass it to\r\n                // tls.NewListener and passed that listener to Serve.\r\n                // So we should configure HTTP/2 (to set up srv.TLSNextProto)\r\n                // in case the listener returns an \"h2\" *tls.Conn.\r\n                return true\r\n        }\r\n        // The user specified a TLSConfig on their http.Server.\r\n        // In this, case, only configure HTTP/2 if their tls.Config\r\n        // explicitly mentions \"h2\". Otherwise http2.ConfigureServer\r\n        // would modify the tls.Config to add it, but they probably already\r\n        // passed this tls.Config to tls.NewListener. And if they did,\r\n        // it's too late anyway to fix it. It would only be potentially racy.\r\n        // See Issue 15908.\r\n        return strSliceContains(srv.TLSConfig.NextProtos, http2NextProtoTLS)\r\n}\r\n```\r\nSo if we've put `h2` into our `tls.Config.NextProtos` then we return true, meaning we should be configuring HTTP/2 automatically. So now let's look at the defaults function:\r\n```go\r\n// onceSetNextProtoDefaults configures HTTP/2, if the user hasn't\r\n// configured otherwise. (by setting srv.TLSNextProto non-nil)\r\n// It must only be called via srv.nextProtoOnce (use srv.setupHTTP2_*).\r\nfunc (srv *Server) onceSetNextProtoDefaults() {\r\n        if strings.Contains(os.Getenv(\"GODEBUG\"), \"http2server=0\") {\r\n                return\r\n        }\r\n        // Enable HTTP/2 by default if the user hasn't otherwise\r\n        // configured their TLSNextProto map.\r\n        if srv.TLSNextProto == nil {\r\n                srv.nextProtoErr = http2ConfigureServer(srv, nil)\r\n        }\r\n}\r\n```\r\nThe problem is the check for `srv.TLSNextProto == nil`. The code here doesn't act according to any of the previous documentation; on the user facing side it doesn't explicitly say that HTTP/2 will be activated in this case but doesn't state that this is a case in which it _won't_ be, unlike other cases. The `shouldConfigureHTTP2ForServe()` check indicates that in fact we *should* be activating HTTP/2 support because we've explicitly enabled it...but then it isn't.\r\n\r\nI'm guessing that the reason behind this is that you don't want to clobber a user-set value for `h2` in `NextProtos`, but since the built-in function isn't exported, there is no way that I can see to specify a custom protocol *and* have the connection use Go's built-in HTTP/2 handling.\r\n\r\nAs it stands it seems like my only option as a user is to modify that map after I've called `Serve` and let the default `h2` handler be propagated into it. This will probably work, but seems like a bad idea and potentially racy since once `Serve` is called reads will be performed on the map.\r\n\r\nMy suggestion is that the check for `srv.TLSNextProto == nil` should instead be checking for either `nil` or checking whether the map already contains a value for `h2`, and if not, adding the default handling.",
	"user": {
		"login": "jefferai",
		"id": 28627,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "Documentation"
		}
	],
	"comments": 7,
	"created_at": "2016-08-03T21:47:15Z",
	"updated_at": "2016-08-03T23:18:59Z",
	"milestone": {
		"id": 1709363,
		"number": 38,
		"title": "Go1.8"
	}
}
