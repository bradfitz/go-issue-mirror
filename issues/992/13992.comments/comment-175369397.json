{
	"id": 175369397,
	"body": "It says you are allocating a 256 MB slice. Is that true? \r\n\r\nOn a 32-bit system, especially one co-existing with C code as in Android, there's just not that much address space to go around. The Android L runtime ART reserves its own virtual memory quite aggressively, so Go often can't get much more. What happened here is that Go asked for 256 MB for its heap bitmap (mostly that will never be mapped, it's just virtual address space), 2 MB for its span array, and some amount for its own memory. That amount is unclear: we try 512 MB, and if that fails then 256 MB, and if that fails then 128 MB. It's hard to say what finally worked here, but the kernel found the memory we wanted and gave it to us at 0x8123a000 or so, resulting in a heap base of 0x9143a000. Then when we asked for the 256 MB later, the OS gave us 0x60f2f000 (1626533888), which was below the heap base and therefore unusable to us. We need it to be in the 2 GB starting at the original arena base to be able to address it in our heap bitmap.\r\n\r\nThe code that goes through this in runtime/malloc.go says:\r\n\r\n\t\t// On a 32-bit machine, we can't typically get away\r\n\t\t// with a giant virtual address space reservation.\r\n\t\t// Instead we map the memory information bitmap\r\n\t\t// immediately after the data segment, large enough\r\n\t\t// to handle another 2GB of mappings (256 MB),\r\n\t\t// along with a reservation for an initial arena.\r\n\t\t// When that gets used up, we'll start asking the kernel\r\n\t\t// for any memory anywhere and hope it's in the 2GB\r\n\t\t// following the bitmap (presumably the executable begins\r\n\t\t// near the bottom of memory, so we'll have to use up\r\n\t\t// most of memory before the kernel resorts to giving out\r\n\t\t// memory before the beginning of the text segment).\r\n\t\t//\r\n\t\t// Alternatively we could reserve 512 MB bitmap, enough\r\n\t\t// for 4GB of mappings, and then accept any memory the\r\n\t\t// kernel threw at us, but normally that's a waste of 512 MB\r\n\t\t// of address space, which is probably too much in a 32-bit world.\r\n\r\n\t\t// If we fail to allocate, try again with a smaller arena.\r\n\t\t// This is necessary on Android L where we share a process\r\n\t\t// with ART, which reserves virtual memory aggressively.\r\n\t\tarenaSizes := []uintptr{\r\n\t\t\t512 \u003c\u003c 20,\r\n\t\t\t256 \u003c\u003c 20,\r\n\t\t\t128 \u003c\u003c 20,\r\n\t\t}\r\n\r\n\t\tfor _, arenaSize := range arenaSizes {\r\n\t\t\tbitmapSize = _MaxArena32 / (sys.PtrSize * 8 / 4)\r\n\t\t\tspansSize = _MaxArena32 / _PageSize * sys.PtrSize\r\n\r\nThe comment is somewhat out of date. In fact the code is reserving 256 MB of heap bitmap when it only needs to reserve 128 MB. We halved the footprint without updating the calculation of bitmapSize on that next-to-last line. It's too late for Go 1.6 but we could do one of two things in Go 1.7:\r\n\r\n(1) Halve the bitmapSize, since that's all we need for _MaxArena32 = 2GB.\r\n\r\n(2) Double _MaxArena32. That's what the \"Alternatively ...\" comment above is suggesting, but there the assumption is it will require 512 MB of bitmap. Now that bitmaps are half as big, we can keep using the same 256 MB we're already reserving and use it to describe the entire 4 GB space, letting us eliminate this class of crash entirely.\r\n\r\nI suspect we should do (2). But again it will need to wait for Go 1.7.",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-27T03:26:43Z",
	"updated_at": "2016-01-27T03:26:43Z"
}
