{
	"id": 123826559,
	"body": "Oh boy, this is quite a long thread with a lot to talk about. here goes!\r\n\r\n-------------------------------\r\n\r\n@nigeltao original post\r\n\r\nYour design is in good company: this is pretty much how GTK+ works; the name of its lower layer is GDK.\r\n\r\nWhat I learned from my own UI package attempt is that the way operating systems give you events and the way Go cahnnels work don't line up fully. With a Go channel, a transaction is considered complete once the message is received, and the code that produces the message can continue operating regardless of what the receiver does. But with a traditional GUI system, the system expeccts that you handle a message fully before asking for another one, and will generate input, painting, and timer events according to that design. In practice, things may seem to work at first, but unless you have an \"okay, done with this one\" channel for everything, you're eventually going to fall into the trap I fell in with the first version of my package ui: needing to introduce such a channel for painting events and everything deadlocking as a result. I also don't know how x/mobile handles it.\r\n\r\nOf course, I could be wrong and this could be a non-issue if done right; only experimentation will tell. (Until then, I've decided to separate my own package ui from Go as much as possible, with the intention of avoiding conflicts between the Go runtime and what the C world expects.) There is definitely room for experimentation here (experimentation I am very interested in).\r\n\r\nNext, here is a very very important question. Or rather, two questions whose importance is mutual. Using \"shiny.low\" to refer to the lower layer and \"shiny.high\" to refer to the higher layer:\r\n\r\n1. Will a shiny.low.Window map solely to a top-level window (such as the one your web browser runs in) or to an arbitrary region of the screen that has its own independent event handling?\r\n2. Will each shiny.high.Widget have its own shiny.low.Window?\r\n\r\nIf you answer \"the latter\" to 1 and \"yes\" to 2, the GTK+ project has done this in the past and [found that it doesn't really work well on X11](https://people.gnome.org/~alexl/flicker.ogg). The link is to a video that shows a window being resized in GTK+ 2 and the massive flicker that resulted as the widgets were redrawn. (Windows and OS X don't have this problem as much because of heavy optimization and API design tricks in the former's case and a similar design to what I'm about to say in the latter.) You may find it more performant to chop up a shiny.low.Window into each shiny.high.Widget's parts and mux out events that way. GTK+ 3 has switched to this model.\r\n\r\nAnother thing is that for the widget library, you would need more than just a text rendering library; you would also need a full vector graphics library. I know the old code.google.com freetype package had one built in, but I'm not sure how comprehensive it is for the purposes of a GUI package. That also leaves open the question of theming.\r\n\r\nThreading is another issue. Windows and OS X (I don't know about the other Unix display servers) assume that all your UI operations exist on the same thread; OS X goes even further by saying that it must be the very first thread the OS creates (though there is an undocumented function to change it; I have yet to list the full side effects). I'm aware of `runtime.LockOSThread()` and that might be the solution you'll want to go for. (The future of my package ui will lie in having the GUI thread be a C thread that Go knows nothing about, and that uses other methods of communicating with other threads. In my [early experiments](https://github.com/andlabs/irksome) this seems to work fine as well.)\r\n\r\nThat being said, I would be happy to contribute to this project if it did exist; I could even possiby (no promises, just a thought) prototype the low level part this weekend using code that I already have in my ui and libui projects. skelterjohn has also tried something like this with his go.wde (the low layer) and go.uik (the high layer) projects; possibly using some of that code might also help.\r\n\r\nOne big question that looms in my mind is how cgo, moving garbage collection, and arrays and slices will work, since it isn't very well defined (as far as I'm aware, anyway). At some point we're going to have to feed Go data blobs to C. I should have stated this in that one issue; I'm really not against moving garbage collectors so long as the ability to safely feed large amounts of data to the C world in a well-defined manner is provided (or the rules for doing so defined).\r\n\r\n-------------------------------\r\n\r\n@crawshaw\r\n\r\nSee what I said above about how to map a low-level window to a high-level widget. I'm not sure how this will conflict with golang.org/x/mobile's needs... And in fact, wouldn't having a single end-all-be-all OpenGL package be the logical conclusion of this?",
	"user": {
		"login": "andlabs",
		"id": 718242,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-07-22T18:54:46Z",
	"updated_at": "2015-07-22T18:55:29Z"
}
