{
	"id": 142029961,
	"number": 14874,
	"state": "closed",
	"title": "proposal: cmd/compile: compiler-emitted itab symbols",
	"body": "I am writing this after the fact, as I already have a proposed patch set out for review. Sorry about that.\r\n\r\nitab structures are currently always generated by the runtime. This leads to inefficiencies when converting between a known type and a known interface - the generated code could be more efficient if it could know the itab address, but it can't if the itab is generated by the runtime, so we end up generating more complicated code that calls typ2Itab and caches the result.\r\n\r\nI propose having the compiler generate itab structures when the go code converts between a known type and a known interface, so that the generated itabs can be taken as constant addresses in the generated code. The runtime will register these structures into its itab hash tables at init time, and is still capable of creating more on the fly if required during conversions from one interface type to another.\r\n\r\nsample code:\r\n```go\r\npackage p\r\n\r\ntype I interface {\r\n        F()\r\n}\r\n\r\ntype T struct{ i int }\r\n\r\nfunc (t T) F() {}\r\n\r\nfunc T2I(t T) I   { return t }\r\nfunc TP2I(t *T) I { return t }\r\n```\r\n\r\ncompiled with master at fc6bcdee7926925efc1305ad17d8b784e0e071fa:\r\n```\r\n\"\".T2I t=1 size=128 args=0x18 locals=0x40\r\n\t0x0000 00000 (src/t2i.go:11)\tTEXT\t\"\".T2I(SB), $64-24\r\n\t0x0000 00000 (src/t2i.go:11)\tMOVQ\t(TLS), CX\r\n\t0x0009 00009 (src/t2i.go:11)\tCMPQ\tSP, 16(CX)\r\n\t0x000d 00013 (src/t2i.go:11)\tJLS\t113\r\n\t0x000f 00015 (src/t2i.go:11)\tSUBQ\t$64, SP\r\n\t0x0013 00019 (src/t2i.go:11)\tFUNCDATA\t$0, gclocals·790e5cc5051fc0affc980ade09e929ec(SB)\r\n\t0x0013 00019 (src/t2i.go:11)\tFUNCDATA\t$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)\r\n\t0x0013 00019 (src/t2i.go:11)\tMOVQ\t\"\".t+72(FP), AX\r\n\t0x0018 00024 (src/t2i.go:11)\tMOVQ\tAX, \"\".autotmp_0000+56(SP)\r\n\t0x001d 00029 (src/t2i.go:11)\tLEAQ\ttype.\"\".T(SB), AX\r\n\t0x0024 00036 (src/t2i.go:11)\tMOVQ\tAX, (SP)\r\n\t0x0028 00040 (src/t2i.go:11)\tLEAQ\ttype.\"\".I(SB), AX\r\n\t0x002f 00047 (src/t2i.go:11)\tMOVQ\tAX, 8(SP)\r\n\t0x0034 00052 (src/t2i.go:11)\tLEAQ\tgo.itab.\"\".T.\"\".I(SB), AX\r\n\t0x003b 00059 (src/t2i.go:11)\tMOVQ\tAX, 16(SP)\r\n\t0x0040 00064 (src/t2i.go:11)\tLEAQ\t\"\".autotmp_0000+56(SP), AX\r\n\t0x0045 00069 (src/t2i.go:11)\tMOVQ\tAX, 24(SP)\r\n\t0x004a 00074 (src/t2i.go:11)\tMOVQ\t$0, 32(SP)\r\n\t0x0053 00083 (src/t2i.go:11)\tPCDATA\t$0, $0\r\n\t0x0053 00083 (src/t2i.go:11)\tCALL\truntime.convT2I(SB)\r\n\t0x0058 00088 (src/t2i.go:11)\tMOVQ\t48(SP), CX\r\n\t0x005d 00093 (src/t2i.go:11)\tMOVQ\t40(SP), DX\r\n\t0x0062 00098 (src/t2i.go:11)\tMOVQ\tDX, \"\".~r1+80(FP)\r\n\t0x0067 00103 (src/t2i.go:11)\tMOVQ\tCX, \"\".~r1+88(FP)\r\n\t0x006c 00108 (src/t2i.go:11)\tADDQ\t$64, SP\r\n\t0x0070 00112 (src/t2i.go:11)\tRET\r\n\t0x0071 00113 (src/t2i.go:11)\tNOP\r\n\t0x0071 00113 (src/t2i.go:11)\tCALL\truntime.morestack_noctxt(SB)\r\n\t0x0076 00118 (src/t2i.go:11)\tJMP\t0\r\n\trel 5+4 t=14 +0\r\n\trel 32+4 t=13 type.\"\".T+0\r\n\trel 43+4 t=13 type.\"\".I+0\r\n\trel 55+4 t=13 go.itab.\"\".T.\"\".I+0\r\n\trel 84+4 t=6 runtime.convT2I+0\r\n\trel 114+4 t=6 runtime.morestack_noctxt+0\r\n\"\".TP2I t=1 size=112 args=0x18 locals=0x20\r\n\t0x0000 00000 (src/t2i.go:12)\tTEXT\t\"\".TP2I(SB), $32-24\r\n\t0x0000 00000 (src/t2i.go:12)\tMOVQ\t(TLS), CX\r\n\t0x0009 00009 (src/t2i.go:12)\tCMPQ\tSP, 16(CX)\r\n\t0x000d 00013 (src/t2i.go:12)\tJLS\t98\r\n\t0x000f 00015 (src/t2i.go:12)\tSUBQ\t$32, SP\r\n\t0x0013 00019 (src/t2i.go:12)\tFUNCDATA\t$0, gclocals·0b86ef39f3fed835f14ba5f4d7c62fa2(SB)\r\n\t0x0013 00019 (src/t2i.go:12)\tFUNCDATA\t$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)\r\n\t0x0013 00019 (src/t2i.go:12)\tMOVQ\tgo.itab.*\"\".T.\"\".I(SB), CX\r\n\t0x001a 00026 (src/t2i.go:12)\tTESTQ\tCX, CX\r\n\t0x001d 00029 (src/t2i.go:12)\tJEQ\t$0, 51\r\n\t0x001f 00031 (src/t2i.go:12)\tMOVQ\tCX, \"\".~r1+48(FP)\r\n\t0x0024 00036 (src/t2i.go:12)\tMOVQ\t\"\".t+40(FP), CX\r\n\t0x0029 00041 (src/t2i.go:12)\tMOVQ\tCX, \"\".~r1+56(FP)\r\n\t0x002e 00046 (src/t2i.go:12)\tADDQ\t$32, SP\r\n\t0x0032 00050 (src/t2i.go:12)\tRET\r\n\t0x0033 00051 (src/t2i.go:12)\tLEAQ\ttype.*\"\".T(SB), AX\r\n\t0x003a 00058 (src/t2i.go:12)\tMOVQ\tAX, (SP)\r\n\t0x003e 00062 (src/t2i.go:12)\tLEAQ\ttype.\"\".I(SB), AX\r\n\t0x0045 00069 (src/t2i.go:12)\tMOVQ\tAX, 8(SP)\r\n\t0x004a 00074 (src/t2i.go:12)\tLEAQ\tgo.itab.*\"\".T.\"\".I(SB), CX\r\n\t0x0051 00081 (src/t2i.go:12)\tMOVQ\tCX, 16(SP)\r\n\t0x0056 00086 (src/t2i.go:12)\tPCDATA\t$0, $0\r\n\t0x0056 00086 (src/t2i.go:12)\tCALL\truntime.typ2Itab(SB)\r\n\t0x005b 00091 (src/t2i.go:12)\tMOVQ\t24(SP), CX\r\n\t0x0060 00096 (src/t2i.go:12)\tJMP\t31\r\n\t0x0062 00098 (src/t2i.go:12)\tNOP\r\n\t0x0062 00098 (src/t2i.go:12)\tCALL\truntime.morestack_noctxt(SB)\r\n\t0x0067 00103 (src/t2i.go:12)\tJMP\t0\r\n\trel 5+4 t=14 +0\r\n\trel 22+4 t=13 go.itab.*\"\".T.\"\".I+0\r\n\trel 54+4 t=13 type.*\"\".T+0\r\n\trel 65+4 t=13 type.\"\".I+0\r\n\trel 77+4 t=13 go.itab.*\"\".T.\"\".I+0\r\n\trel 87+4 t=6 runtime.typ2Itab+0\r\n\trel 99+4 t=6 runtime.morestack_noctxt+0\r\ngo.itab.\"\".T.\"\".I t=33 dupok size=8\r\ngo.itab.*\"\".T.\"\".I t=33 dupok size=8\r\n```\r\n\r\nCompiled with above plus the proposed changes:\r\n```\r\n\"\".T2I t=1 size=112 args=0x18 locals=0x38\r\n\t0x0000 00000 (src/t2i.go:11)\tTEXT\t\"\".T2I(SB), $56-24\r\n\t0x0000 00000 (src/t2i.go:11)\tMOVQ\t(TLS), CX\r\n\t0x0009 00009 (src/t2i.go:11)\tCMPQ\tSP, 16(CX)\r\n\t0x000d 00013 (src/t2i.go:11)\tJLS\t101\r\n\t0x000f 00015 (src/t2i.go:11)\tSUBQ\t$56, SP\r\n\t0x0013 00019 (src/t2i.go:11)\tFUNCDATA\t$0, gclocals·790e5cc5051fc0affc980ade09e929ec(SB)\r\n\t0x0013 00019 (src/t2i.go:11)\tFUNCDATA\t$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)\r\n\t0x0013 00019 (src/t2i.go:11)\tMOVQ\t\"\".t+64(FP), AX\r\n\t0x0018 00024 (src/t2i.go:11)\tMOVQ\tAX, \"\".autotmp_0000+48(SP)\r\n\t0x001d 00029 (src/t2i.go:11)\tLEAQ\ttype.\"\".T(SB), AX\r\n\t0x0024 00036 (src/t2i.go:11)\tMOVQ\tAX, (SP)\r\n\t0x0028 00040 (src/t2i.go:11)\tLEAQ\tgo.itab.\"\".T.\"\".I(SB), AX\r\n\t0x002f 00047 (src/t2i.go:11)\tMOVQ\tAX, 8(SP)\r\n\t0x0034 00052 (src/t2i.go:11)\tLEAQ\t\"\".autotmp_0000+48(SP), AX\r\n\t0x0039 00057 (src/t2i.go:11)\tMOVQ\tAX, 16(SP)\r\n\t0x003e 00062 (src/t2i.go:11)\tMOVQ\t$0, 24(SP)\r\n\t0x0047 00071 (src/t2i.go:11)\tPCDATA\t$0, $0\r\n\t0x0047 00071 (src/t2i.go:11)\tCALL\truntime.convT2I(SB)\r\n\t0x004c 00076 (src/t2i.go:11)\tMOVQ\t40(SP), CX\r\n\t0x0051 00081 (src/t2i.go:11)\tMOVQ\t32(SP), DX\r\n\t0x0056 00086 (src/t2i.go:11)\tMOVQ\tDX, \"\".~r1+72(FP)\r\n\t0x005b 00091 (src/t2i.go:11)\tMOVQ\tCX, \"\".~r1+80(FP)\r\n\t0x0060 00096 (src/t2i.go:11)\tADDQ\t$56, SP\r\n\t0x0064 00100 (src/t2i.go:11)\tRET\r\n\t0x0065 00101 (src/t2i.go:11)\tNOP\r\n\t0x0065 00101 (src/t2i.go:11)\tCALL\truntime.morestack_noctxt(SB)\r\n\t0x006a 00106 (src/t2i.go:11)\tJMP\t0\r\n\trel 5+4 t=14 +0\r\n\trel 32+4 t=13 type.\"\".T+0\r\n\trel 43+4 t=13 go.itab.\"\".T.\"\".I+0\r\n\trel 72+4 t=6 runtime.convT2I+0\r\n\trel 102+4 t=6 runtime.morestack_noctxt+0\r\n\"\".TP2I t=1 size=32 args=0x18 locals=0x0\r\n\t0x0000 00000 (src/t2i.go:12)\tTEXT\t\"\".TP2I(SB), $0-24\r\n\t0x0000 00000 (src/t2i.go:12)\tNOP\r\n\t0x0000 00000 (src/t2i.go:12)\tNOP\r\n\t0x0000 00000 (src/t2i.go:12)\tFUNCDATA\t$0, gclocals·0b86ef39f3fed835f14ba5f4d7c62fa2(SB)\r\n\t0x0000 00000 (src/t2i.go:12)\tFUNCDATA\t$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)\r\n\t0x0000 00000 (src/t2i.go:12)\tLEAQ\tgo.itab.*\"\".T.\"\".I(SB), AX\r\n\t0x0007 00007 (src/t2i.go:12)\tMOVQ\tAX, \"\".~r1+16(FP)\r\n\t0x000c 00012 (src/t2i.go:12)\tMOVQ\t\"\".t+8(FP), AX\r\n\t0x0011 00017 (src/t2i.go:12)\tMOVQ\tAX, \"\".~r1+24(FP)\r\n\t0x0016 00022 (src/t2i.go:12)\tRET\r\n\trel 3+4 t=13 go.itab.*\"\".T.\"\".I+0\r\ngo.itab.\"\".T.\"\".I t=34 dupok size=40\r\n\t0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n\trel 0+8 t=1 type.\"\".I+0\r\n\trel 8+8 t=1 type.\"\".T+0\r\ngo.itablink.\"\".T.\"\".I t=9 dupok size=8\r\n\t0x0000 00 00 00 00 00 00 00 00                          ........\r\n\trel 0+8 t=1 go.itab.\"\".T.\"\".I+0\r\ngo.itab.*\"\".T.\"\".I t=34 dupok size=40\r\n\t0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\r\n\trel 0+8 t=1 type.\"\".I+0\r\n\trel 8+8 t=1 type.*\"\".T+0\r\ngo.itablink.*\"\".T.\"\".I t=9 dupok size=8\r\n\t0x0000 00 00 00 00 00 00 00 00                          ........\r\n\trel 0+8 t=1 go.itab.*\"\".T.\"\".I+0\r\n```\r\n\r\nThe generated code for T2I is now slightly simpler because it has one less constant argument to convT2I to push on the stack - this saves 12 bytes of code for each place that converts T to I, at the cost of having the compiler generate an itab (once) which takes 32 bytes + 8 per interface method.\r\n\r\nThe generated code for TP2I is now much simpler, just moving the (known) itab pointer and the T pointer into the returned iface. In this simple case, this saves so much code that it pays for the itab size on the first use. In a more complex function, I suspect the benefits will be less but there should be an overall size reduction either way.\r\n\r\nI am also seeing a ~1.2% size reduction for the bin/{gen,go,gofmt} binaries and a ~1.0% size reduction for the pkg/tool/linux_amd64/* binaries.\r\n\r\nI do not have meaningful benchmarking numbers to report at this point (my results are way too noisy for such a small expected change).",
	"user": {
		"login": "walken-google",
		"id": 17941188,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "Proposal"
		}
	],
	"assignee": {
		"login": "walken-google",
		"id": 17941188,
		"type": "User",
		"site_admin": false
	},
	"comments": 13,
	"closed_at": "2016-03-29T07:04:25Z",
	"created_at": "2016-03-19T05:40:40Z",
	"updated_at": "2016-03-29T07:04:25Z",
	"milestone": {
		"id": 1414133,
		"number": 31,
		"title": "Go1.7"
	},
	"reactions": {
		"total_count": 3,
		"+1": 3
	}
}
