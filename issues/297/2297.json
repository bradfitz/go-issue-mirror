{
	"id": 51279016,
	"number": 2297,
	"state": "closed",
	"title": "cmd/gc: reduce init load",
	"body": "\u003cpre\u003einit should not be doing so much work.\n\nForwarded conversation\nSubject: [golang-dev] 386 GC problems\n------------------------\n\nFrom: Dmitry Vyukov \u0026lt;dvyukov@google.com\u0026gt;\nDate: Tue, Aug 30, 2011 at 03:50\nTo: golang-dev@googlegroups.com\nCc: ushakov@google.com\n\n\nHi,\nI've created a testing program that imports all standard packages, then allocates 2 GB\nin equally sized blocks, then executes GC and then checks how many of the blocks are\nfreed (source code is below, but it also requires patching mgc0.c to not do GC until\nmanually triggered).\nOn Mac/386 it says that 90%(!) of 1MB blocks are not freed (there may be some\nmeasurement error, but I think not that big).\nI've investigated the problem, and it turned out that basically all blocks are pinned by\nvarious tables in data segment of the program (after adding some debug output to mgc0.c\nand merging it with nm output I can see what symbols cause problems).\nI think most cases can be fixed by turning static arrays into dynamic slices. For\nexample, after applying the following patch:\n------------------------------------------------------------\ndiff -r 7fec8679f10d src/pkg/math/pow10.go\n--- a/src/pkg/math/pow10.go Fri Aug 26 17:45:19 2011 -0400\n+++ b/src/pkg/math/pow10.go Tue Aug 30 11:29:47 2011 +0400\n@@ -4,12 +4,18 @@\n \n package math\n \n+import (\n+ \u0026quot;sync\u0026quot;\n+)\n+\n // This table might overflow 127-bit exponent representations.\n // In that case, truncate it after 1.0e38.\n-var pow10tab [70]float64\n+var pow10tab []float64\n+var pow10tabOnce sync.Once\n \n // Pow10 returns 10**e, the base-10 exponential of e.\n func Pow10(e int) float64 {\n+ pow10tabOnce.Do(pow10tabInit)\n  if e \u0026lt;= -325 {\n  return 0\n  } else if e \u0026gt; 309 {\n@@ -26,7 +32,8 @@\n  return Pow10(m) * Pow10(e-m)\n }\n \n-func init() {\n+func pow10tabInit() {\n+ pow10tab = make([]float64, 70)\n  pow10tab[0] = 1.0e0\n  pow10tab[1] = 1.0e1\n  for i := 2; i \u0026lt; len(pow10tab); i++ {\n------------------------------------------------------------\n3 additional 1MB blocks get freed. Or when I use 16-byte blocks, 70(!) additional blocks\nget freed, that basically means that every float64 pins a heap object.\nBefore submitting any changes, I would like to know as to whether you think it (turning\nstatic arrays into dynamic slices) is the right approach or not. Potentially it also\nreduces exec size and/or startup times, fortunately sync.Once is quite fast now :)\n\n------------------------------------------------------------\n// the testing utility\npackage main\n\nimport (\n\u0026quot;flag\u0026quot;\n\u0026quot;fmt\u0026quot;\n\u0026quot;os\u0026quot;\n\u0026quot;runtime\u0026quot;\n)\nimport (\n_ \u0026quot;container/heap\u0026quot;\n_ \u0026quot;container/list\u0026quot;\n_ \u0026quot;container/ring\u0026quot;\n_ \u0026quot;container/vector\u0026quot;\n_ \u0026quot;flag\u0026quot;\n_ \u0026quot;json\u0026quot;\n_ \u0026quot;path\u0026quot;\n_ \u0026quot;strings\u0026quot;\n_ \u0026quot;unsafe\u0026quot;\n_ \u0026quot;crypto\u0026quot;\n_ \u0026quot;fmt\u0026quot;\n_ \u0026quot;log\u0026quot;\n_ \u0026quot;rand\u0026quot;\n_ \u0026quot;sync\u0026quot;\n_ \u0026quot;url\u0026quot;\n_ \u0026quot;archive/tar\u0026quot;\n_ \u0026quot;archive/zip\u0026quot;\n_ \u0026quot;csv\u0026quot;\n_ \u0026quot;go/ast\u0026quot;\n_ \u0026quot;go/build\u0026quot;\n_ \u0026quot;go/doc\u0026quot;\n_ \u0026quot;go/parser\u0026quot;\n_ \u0026quot;go/printer\u0026quot;\n_ \u0026quot;go/scanner\u0026quot;\n_ \u0026quot;go/token\u0026quot;\n_ \u0026quot;go/typechecker\u0026quot;\n_ \u0026quot;go/types\u0026quot;\n_ \u0026quot;mail\u0026quot;\n_ \u0026quot;reflect\u0026quot;\n_ \u0026quot;syscall\u0026quot;\n_ \u0026quot;utf16\u0026quot;\n_ \u0026quot;asn1\u0026quot;\n_ \u0026quot;debug/dwarf\u0026quot;\n_ \u0026quot;debug/elf\u0026quot;\n_ \u0026quot;debug/gosym\u0026quot;\n_ \u0026quot;debug/macho\u0026quot;\n_ \u0026quot;debug/pe\u0026quot;\n_ \u0026quot;gob\u0026quot;\n_ \u0026quot;math\u0026quot;\n_ \u0026quot;regexp\u0026quot;\n_ \u0026quot;syslog\u0026quot;\n_ \u0026quot;utf8\u0026quot;\n_ \u0026quot;big\u0026quot;\n_ \u0026quot;hash\u0026quot;\n_ \u0026quot;mime\u0026quot;\n_ \u0026quot;rpc\u0026quot;\n_ \u0026quot;tabwriter\u0026quot;\n_ \u0026quot;websocket\u0026quot;\n_ \u0026quot;bufio\u0026quot;\n_ \u0026quot;ebnf\u0026quot;\n_ \u0026quot;html\u0026quot;\n_ \u0026quot;net\u0026quot;\n_ \u0026quot;runtime\u0026quot;\n_ \u0026quot;template\u0026quot;\n_ \u0026quot;xml\u0026quot;\n_ \u0026quot;encoding/ascii85\u0026quot;\n_ \u0026quot;encoding/base32\u0026quot;\n_ \u0026quot;encoding/base64\u0026quot;\n_ \u0026quot;encoding/binary\u0026quot;\n_ \u0026quot;encoding/git85\u0026quot;\n_ \u0026quot;encoding/hex\u0026quot;\n_ \u0026quot;encoding/pem\u0026quot;\n_ \u0026quot;http\u0026quot;\n_ \u0026quot;netchan\u0026quot;\n_ \u0026quot;scanner\u0026quot;\n_ \u0026quot;testing\u0026quot;\n_ \u0026quot;bytes\u0026quot;\n_ \u0026quot;exec\u0026quot;\n_ \u0026quot;image\u0026quot;\n_ \u0026quot;old/template\u0026quot;\n_ \u0026quot;smtp\u0026quot;\n_ \u0026quot;time\u0026quot;\n_ \u0026quot;cmath\u0026quot;\n_ \u0026quot;exp/datafmt\u0026quot;\n_ \u0026quot;exp/gui\u0026quot;\n_ \u0026quot;exp/gui/x11\u0026quot;\n_ \u0026quot;exp/norm\u0026quot;\n_ \u0026quot;exp/regexp/syntax\u0026quot;\n_ \u0026quot;exp/template/html\u0026quot;\n_ \u0026quot;index/suffixarray\u0026quot;\n_ \u0026quot;os\u0026quot;\n_ \u0026quot;sort\u0026quot;\n_ \u0026quot;try\u0026quot;\n_ \u0026quot;compress/bzip2\u0026quot;\n_ \u0026quot;compress/flate\u0026quot;\n_ \u0026quot;compress/gzip\u0026quot;\n_ \u0026quot;compress/lzw\u0026quot;\n_ \u0026quot;compress/zlib\u0026quot;\n_ \u0026quot;expvar\u0026quot;\n_ \u0026quot;io\u0026quot;\n_ \u0026quot;patch\u0026quot;\n_ \u0026quot;strconv\u0026quot;\n_ \u0026quot;unicode\u0026quot;\n)\nfunc main() {\nflagSize := flag.Int(\u0026quot;size\u0026quot;, 0, \u0026quot;alloc block size in bytes (must be a\npower of 2)\u0026quot;)\nflagMem := flag.Int(\u0026quot;mem\u0026quot;, 0, \u0026quot;total mem to allocate in MB\u0026quot;)\nflag.Parse()\nif *flagSize \u0026lt;= 0 || *flagSize\u0026amp;(*flagSize-1) != 0 || *flagMem \u0026lt;= 0 {\nflag.PrintDefaults()\nos.Exit(1)\n}\nsz := uintptr(*flagSize)\ncnt := *flagMem * 1024 * 1024 / (*flagSize)\na0 := runtime.MemStats.Mallocs - runtime.MemStats.Frees\nfor i := 0; i \u0026lt; cnt; i++ {\np := make([]byte, sz)\nfunc(p []byte) {\n}(p)\n}\na1 := runtime.MemStats.Mallocs - runtime.MemStats.Frees - a0\nruntime.GC()\na2 := runtime.MemStats.Mallocs - runtime.MemStats.Frees - a0\nfmt.Printf(\u0026quot;%.2f%% pinned (%d)\\n\u0026quot;, float64(a2)*100/float64(a1), a2)\nfmt.Printf(\u0026quot;%dMB wasted\\n\u0026quot;, a2*100*uint64(*flagMem)/a1)\n}\n\n----------\nFrom: Russ Cox \u0026lt;rsc@golang.org\u0026gt;\nDate: Tue, Aug 30, 2011 at 07:57\nTo: golang-dev@googlegroups.com\nCc: ushakov@google.com\n\n\nYou don't have to use sync.Once to move things into the heap.\nIt would suffice to change one line:\n\nvar pow10tab [70]float64\n\nto\n\nvar pow10tab = make([]float64, 70)\n\nHowever, this is not the right approach anyway.  You're letting\nan implementation concern limit the way you use the language.\nThat's almost never the right long-term strategy.  It's definitely\na problem we need to address but making people change their\ncode to work around it is not the way.\n\nRuss\n\n----------\nFrom: Dmitry Vyukov \u0026lt;dvyukov@google.com\u0026gt;\nDate: Tue, Aug 30, 2011 at 08:29\nTo: rsc@golang.org\nCc: golang-dev@googlegroups.com, ushakov@google.com\n\n\nI understand your point, and that's why I am asking.\nHowever, I guess there is no simple way to fix it on GC level\n(otherwise it would be already fixed). Moreover, it's not about user's\ncode, it's about standard library code (I perfectly understand that\nusers can create similar tables, but I think it's not quite common for\nGo programs to create static tables of floats). Moreover, maybe it's a\nbetter way to do it GC problem aside, data segment of the program is\n250k + increased GC time for scanning of it + increased startup time\n(I see ±15ms startup penalty for the program). In either case, the\nissue renders Go basically useless on 386 for a lot of programs.\nWDYT?\n\n----------\nFrom: Russ Cox \u0026lt;rsc@golang.org\u0026gt;\nDate: Tue, Aug 30, 2011 at 09:02\nTo: Dmitry Vyukov \u0026lt;dvyukov@google.com\u0026gt;\nCc: golang-dev@googlegroups.com, ushakov@google.com\n\n\nI think we need a better solution than avoiding\ncertain parts of the Go language.\n\nRuss\n\n----------\nFrom: Ian Lance Taylor \u0026lt;iant@google.com\u0026gt;\nDate: Tue, Aug 30, 2011 at 09:21\nTo: Dmitry Vyukov \u0026lt;dvyukov@google.com\u0026gt;\nCc: rsc@golang.org, golang-dev@googlegroups.com, ushakov@google.com\n\n\nI'm not Russ but I think this should just be fixed in the\ncompiler/linker.  In gccgo I don't scan the entire data segment for\npointers.  Instead, at program startup time all global variables which\nmay contain pointers are registered, and the GC scans those.  This\napproach is not optimal, but it does avoid this problem, since of course\na variable of type [70]float need not be registered.\n\nUsing 6l/8l we can do better.  There is no implied ordering of global\nvariables, so the linker can order all the global variables which may\ncontain pointers together, and define symbols to mark the start and end\nof this memory area.  Then we change mark in runtime/mgc0.c to use those\nsymbols rather than scanning the entire data segment (minus mheap) as it\ndoes today.\n\nIan\n\n----------\nFrom: Dmitry Vyukov \u0026lt;dvyukov@google.com\u0026gt;\nDate: Tue, Aug 30, 2011 at 10:45\nTo: rsc@golang.org\nCc: golang-dev@googlegroups.com, ushakov@google.com\n\n\nNothing to object to.\n\n----------\nFrom: Dmitry Vyukov \u0026lt;dvyukov@google.com\u0026gt;\nDate: Tue, Aug 30, 2011 at 10:53\nTo: Ian Lance Taylor \u0026lt;iant@google.com\u0026gt;\nCc: rsc@golang.org, golang-dev@googlegroups.com, ushakov@google.com\n\n\nIf we move in the direction of preciser GC, for heap objects we can use the GC bitmap in\nsome way (per-word bitNoPointers). But that still does not solve the problem for static\ndata (it is not covered by the bitmap), so we need a separate solution for static data\nin either case. Initially I was thinking about a separate data section, but it's\nessentially the same as yours. Both are beyond my capabilities.\u003c/pre\u003e",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		}
	],
	"assignee": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"comments": 7,
	"closed_at": "2014-12-08T10:12:21Z",
	"created_at": "2011-09-23T14:13:58Z",
	"updated_at": "2016-06-24T19:35:16Z",
	"milestone": {
		"id": 1067207,
		"number": 14,
		"title": "Go1.2"
	}
}
