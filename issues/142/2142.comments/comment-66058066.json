{
	"id": 66058066,
	"body": "\u003ca id=\"c16\"\u003e\u003c/a\u003eComment 16:\n\n\u003cpre\u003eHere's a story from the trenches that could be considered.\n\nWe have been running Go services under systemd on Linux. We have also been using the\nsystemd support for cgroups to limit the memory these processes can allocate.\n\nThere was some discussion on systemd-devel:\n\n\u003ca href=\"http://lists.freedesktop.org/archives/systemd-devel/2012-March/004802.html\"\u003ehttp://lists.freedesktop.org/archives/systemd-devel/2012-March/004802.html\u003c/a\u003e\n\u003ca href=\"http://lists.freedesktop.org/archives/systemd-devel/2012-March/004811.html\"\u003ehttp://lists.freedesktop.org/archives/systemd-devel/2012-March/004811.html\u003c/a\u003e\n\u003ca href=\"http://lists.freedesktop.org/archives/systemd-devel/2012-March/004826.html\"\u003ehttp://lists.freedesktop.org/archives/systemd-devel/2012-March/004826.html\u003c/a\u003e\n\u003ca href=\"http://lists.freedesktop.org/archives/systemd-devel/2012-March/004810.html\"\u003ehttp://lists.freedesktop.org/archives/systemd-devel/2012-March/004810.html\u003c/a\u003e\n\u003ca href=\"http://lists.freedesktop.org/archives/systemd-devel/2012-March/004823.html\"\u003ehttp://lists.freedesktop.org/archives/systemd-devel/2012-March/004823.html\u003c/a\u003e\n\u003ca href=\"http://www.kernel.org/doc/Documentation/cgroups/memory.txt\"\u003ehttp://www.kernel.org/doc/Documentation/cgroups/memory.txt\u003c/a\u003e\n\nAs far as we understand memory.txt, cgroups memory limits accounts mapped files under\nsome conditions, so it doesn't work for limiting a Go process that should have a small\nheap but be able to map terabytes of files. As far as I can tell, RSS limits aren't\nimplemented on Linux.\n\nWe see the following kinds of programs:\n\n1. Go programs that don't map files\n2. Go programs that call cgo libraries (that might leak)\n3. Go programs that map files\n4. Go programs that call cgo libraries and map files\n\nSome programs must simply never hit their memory limits under normal operation. Some\nprograms that interact with connections from many other programs must potentially be\nable to throttle or later reject work depending on how close to their memory limit they\nare.\n\nFor pure Go programs that don't map files, you can use cgroups. You can even use both\nthe hard memory limit and a soft memory limit and using an eventfd (see memory.txt) or\nreading your limits you can throttle back or cancel actions in your service to limit its\nmemory. Currently you need to keep both these limits a bit below 16 GB to avoid hitting\nthe heap limit.\n\nAny kind of program that maps files is tricky. You can't use cgroups for these kinds of\nprograms in general. It can be useful to limit the Go heap, but depending on the\nservice, you might want to do different things when you go over the soft limit. You\ndon't necessarily want an infinite hard limit. Eventually the kernel's OOM killer might\nkill you, but it might kill someone else first.\n\nGo+leaking cgo+mapped files is the hardest. The best you can do here is probably to fix\nthe leaks and then just limit the Go part.\n\nFinally, this leads me to my proposal. Once the 16 GB limit is lifted (which allows apps\nto potentially grow huge heaps), it might be useful to be able to instruct the runtime\nto still limit the heap to cater for cases where cgroups can't help you.\n\nIt's probably a bit sucky to do it via environment variables or flags understood by all\nGo programs (kind of like the JVM -Xmx stuff), so people that want it can do their own\nflags and call runtime functions.\n\nI think a soft limit in the runtime is also useful (maybe with some kind of channel API,\nlike you can get with the cgroups eventfd thing) as it allows goroutines handling\ntransactions to temporarily pause work (maybe inside a select that combines a limit\nchecker, ticker, and other channels) when you go over the soft limit, but before the\nruntime starts failing allocations due to hitting the hard limit.\n\nP.S. the cgroups code for reading limits looks something like this. We haven't done\nanything with the eventfds yet. This code assumes that the limits don't change while the\nprogram is running.\n\nfunc MemoryLimit() int64 {\n\treturn memoryLimit\n}\n\nfunc MemorySoftLimit() int64 {\n\treturn memorySoftLimit\n}\n\nfunc MemoryUsage() int64 {\n\tusageStr := readLine(memoryUsagePath)\n\tn, err := strconv.ParseUint(usageStr, 0, 64)\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn int64(n)\n}\n\nvar memoryLimit int64\nvar memorySoftLimit int64\nvar memoryUsagePath string\n\nfunc init() {\n\tvar path string\n\tlines := readLines(\"/proc/self/cgroup\")\n\tfor _, line := range lines {\n\t\tif !strings.Contains(line, \":memory:\") {\n\t\t\tcontinue\n\t\t}\n\t\tparts := strings.Split(line, \":\")\n\t\tif len(parts) != 3 {\n\t\t\tcontinue\n\t\t}\n\t\tpath = \"/sys/fs/cgroup/memory\" + parts[2]\n\t}\n\tif len(path) == 0 {\n\t\treturn\n\t}\n\n\tsoftLimitStr := readLine(path + \"/memory.soft_limit_in_bytes\")\n\tn, err := strconv.ParseUint(softLimitStr, 0, 64)\n\tif err == nil {\n\t\tmemorySoftLimit = int64(n)\n\t}\n\n\tlimitStr := readLine(path + \"/memory.limit_in_bytes\")\n\tn, err = strconv.ParseUint(limitStr, 0, 64)\n\tif err == nil {\n\t\tmemoryLimit = int64(n)\n\t}\n\n\tmemoryUsagePath = path + \"/memory.usage_in_bytes\"\n}\u003c/pre\u003e",
	"user": {
		"login": "alberts",
		"id": 409689,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2012-09-06T06:55:16Z",
	"updated_at": "2014-12-08T10:11:31Z"
}
