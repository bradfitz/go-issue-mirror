{
	"id": 66049515,
	"body": "\u003ca id=\"c4\"\u003e\u003c/a\u003eComment 4 by **RichardHightower**:\n\n\u003cpre\u003eDear Project Member,\n\nI disagree. This was something for the issue list. I say this because it was fixed\nbefore Go was officially 1.0. You got it wrong. It works now. So you fixed it. So it was\na bug. \n\nSecond... when you search for Go polymorphism this page is the first thing that shows\nup. So everyone thinks Go is broken and the project member 3 is a bit of a jerk who wont\nfix it.\n\nThis means that you should address the issue a little better. If you want to build a\ncommunity.\nSince you didn't, I will.\n\n\u0026lt;pre\u0026gt;\npackage main\nimport \"fmt\";\n\ntype Fruit interface {\n\tName() string;\n\tEat() int;\n}\n\ntype FruitImpl struct {\n\tcalories int;\n}\nfunc (f *FruitImpl) Name() string { return \"Fruit\"; }\nfunc (f *FruitImpl) Eat() int {\n\tfmt.Println(\"Inside Eat(), Name is\", f.Name(), \"calories=\", f.calories);\n\tc := f.calories;\n\tf.calories = 0;\n\treturn c;\n}\n\ntype Apple struct { *FruitImpl; }\nfunc (a *Apple) Name() string { return \"Apple\"; }\n\ntype Banana struct { *FruitImpl; }\nfunc (b *Banana) Name() string { return \"Banana\"; }\n\nfunc main() {\n\ta := \u0026Apple { \u0026FruitImpl{100} };\n\tb := \u0026Banana { \u0026FruitImpl{200} };\n\tfmt.Println(\"Apple Name is\", a.Name());\n\tfmt.Println(\"Banana Name is\", b.Name());\n\tfruits := [2]Fruit{a,b};\n\tfor i := 0; i \u0026lt; 2; i++ {\n\t\tfruits[i].Eat();\n\t}\n}\n\n\u0026lt;/pre\u0026gt;\n\nThe above works as expected in Go 1.0.\n\nThe output is:\n\n\u0026lt;pre\u0026gt;\nApple Name is Apple\nBanana Name is Banana\nInside Eat(), Name is Fruit calories= 100\nInside Eat(), Name is Fruit calories= 200\n\n\u0026lt;/pre\u0026gt;\n\nYou can see that Apple name is Apple so the method override worked.\nYou can see that Banana name is Banana so the method override worked.\nBut when you are inside of the method you are not dealing with the interface so you\ndon't get what you expect. You are dealing with FruitImpl. Go does not support type\ninheritance. You can inherit behavior and data but not type. Thus FruitImpl is calling\nName() on FruitImp as you would expect in Go.\n\nI think I have a fix for you, although, three years late.\n\nRead these articles which explain Go in Java terminology....\n\u003ca href=\"http://rick-hightower.blogspot.com/2013/01/java-guide-to-go-programming-article-1.html\"\u003ehttp://rick-hightower.blogspot.com/2013/01/java-guide-to-go-programming-article-1.html\u003c/a\u003e\n\u003ca href=\"http://rick-hightower.blogspot.com/2013/01/java-guide-to-go-programming-article-2.html\"\u003ehttp://rick-hightower.blogspot.com/2013/01/java-guide-to-go-programming-article-2.html\u003c/a\u003e\n\u003ca href=\"http://rick-hightower.blogspot.com/2013/01/java-guide-to-go-programming-article-3.html\"\u003ehttp://rick-hightower.blogspot.com/2013/01/java-guide-to-go-programming-article-3.html\u003c/a\u003e\n\u003ca href=\"http://rick-hightower.blogspot.com/2013/01/java-guide-to-go-programming-article-4.html\"\u003ehttp://rick-hightower.blogspot.com/2013/01/java-guide-to-go-programming-article-4.html\u003c/a\u003e\n\nIn short, Go does support polymorphism, data inheritance and behavior inheritance.\nPolymorphism is only achieved through Go interfaces not structs.\n\n\nYou are sharing the Eat() from Fruit.\nYou are sharing get polymorphic behavior for Name().\nYou are able to do a form of method overriding for Name() albeit through the Fruit\ninterface not through the struct types.\n\n\u0026lt;pre\u0026gt;\npackage main\n\nimport \"fmt\"\n\ntype Fruit interface {\n\tName() string\n\tEat() int\n}\n\ntype FruitImpl struct {\n\tcalories int\n\tname     string //\u0026lt;--- added this\n}\n\nfunc (f *FruitImpl) Name() string { return f.name; }\nfunc (f *FruitImpl) Eat() int {\n\tfmt.Println(\"Inside Eat(), Name is\", f.name, \"calories=\", f.calories) //\u0026lt;--changed this\n\tc := f.calories\n\tf.calories = 0\n\treturn c\n}\n\ntype Apple struct{ *FruitImpl }\nfunc (a *Apple) Name() string { return \"Apple\" }\n\ntype Banana struct{ *FruitImpl }\nfunc (b *Banana) Name() string { return \"Banana\" }\n\n\nfunc main() {\n\ta := \u0026Apple{\u0026FruitImpl{100, \"apple\"}}\n\tb := \u0026Banana{\u0026FruitImpl{200, \"banna\"}}\n\tfmt.Println(\"Apple Name is\", a.Name())\n\tfmt.Println(\"Banana Name is\", b.Name())\n\tfruits := [2]Fruit{a, b}\n\tfor i := 0; i \u0026lt; 2; i++ {\n\t\tfruits[i].Eat()\n\t}\n}\n\n\u0026lt;/pre\u0026gt;\n\nThe output is:\n\n\u0026lt;pre\u0026gt;\nApple Name is Apple\nBanana Name is Banana\nInside Eat(), Name is apple calories= 100\nInside Eat(), Name is banna calories= 200\n\u0026lt;/pre\u0026gt;\n\nYou are sharing the Eat() from Fruit.\nYou are sharing get polymorphic behavior for Name().\n\nIf you code to interfaces, then what you want to do is typically a bad design decision\nanyway. But if you must do something like this, then you can do a type like method\noverride using functions as first class objects.\n\n\u0026lt;pre\u0026gt;\npackage main\n\nimport \"fmt\"\n\ntype Fruit interface {\n\tName() string\n\tEat() int\n}\n\ntype FruitImpl struct {\n\tcalories int\n\tname func (f *FruitImpl) string \n}\n\nfunc (f *FruitImpl) Name() string { \n\treturn f.name(f); \n}\n\nfunc (f *FruitImpl) Eat() int {\n\tnameFunc:=f.name\n\tfmt.Println(\"Inside Eat(), Name is\", nameFunc(f), \"calories=\", f.calories) //\u0026lt;--changed this\n\tc := f.calories\n\tf.calories = 0\n\treturn c\n}\n\ntype Apple struct{ *FruitImpl }\ntype Banana struct{ *FruitImpl }\n\nfunc main() {\n\ta := \u0026Apple{\u0026FruitImpl{100, func (a *FruitImpl) string { return \"Apple\" }}}\n\tb := \u0026Banana{\u0026FruitImpl{200, func (b *FruitImpl) string { return \"Banana\" }}}\n\tfmt.Println(\"Apple Name is\", a.Name())\n\tfmt.Println(\"Banana Name is\", b.Name())\n\tfruits := [2]Fruit{a, b}\n\tfor i := 0; i \u0026lt; 2; i++ {\n\t\tfruits[i].Eat()\n\t}\n}\n\n\u0026lt;/pre\u0026gt;\n\nThe internal polymorphic behavior is sort of a crutch and more of an edge case of\npolymorphism, but as you can see, it can be supported by Go as shown above.\n\nThe output now matches your desired result.\n\u0026lt;pre\u0026gt;\nApple Name is Apple\nBanana Name is Banana\nInside Eat(), Name is Apple calories= 100\nInside Eat(), Name is Banana calories= 200\n\u0026lt;/pre\u0026gt;\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-01-16T23:11:25Z",
	"updated_at": "2014-12-22T05:45:19Z"
}
