{
	"id": 66049259,
	"body": "\u003ca id=\"c8\"\u003e\u003c/a\u003eComment 8 by **cck3737**:\n\n\u003cpre\u003eThinking about the id (should it increment, be random) lead to the notes in comment 7\nwith respect to DNS spoofing issues and some of the protections that a client should\ntake.  But the patch in Comment 7 is insufficient as the id will be non-random.   The\nimplementation in comment 7 calls rand without setting the seed and thus is a fixed\nsequence (of random numbers :-)).   While often this will work around the 2wire\nproblem as most programs will result in multiple DNS requests--the 2wire will allow a\nsequence like 0x1234, 0x1111, 0x1234, but not 0x1234, 0x1234; but there may still be\nunexpected  failures.\n\nThe best solution for Linux and such would be to get some bits from /dev/urandom to\nseed the rng but that's OS dependent code that doesn't belong here.\n\nSomething like below would leave things in a slightly better position, but is ugly\n(and attackable if ts can be inferred to resolution); would likely be, at best, an\ninterim patch; and only satisfies one of several requirements needed to protect\nagainst DNS spoofing (cf. draft-hubert-dns-anti-spoofing-00 - Measures to prevent DNS\nspoofing).\n\ndiff -r 75168d77b51d src/pkg/net/dnsclient.go\n--- a/src/pkg/net/dnsclient.go  Fri Dec 18 17:24:58 2009 -0800\n+++ b/src/pkg/net/dnsclient.go  Fri Dec 18 21:25:38 2009 -0800\n@@ -17,6 +17,8 @@\n import (\n        \"once\"\n        \"os\"\n+       \"rand\"\n+       \"time\"\n )\n\n // DNSError represents a DNS lookup error.\n@@ -44,7 +46,18 @@\n                return nil, \u0026DNSError{\"name too long\", name, \"\"}\n        }\n        out := new(_DNS_Msg)\n-       out.id = 0x1234\n+       {\n+               // fudge a seed by using low order bits of nanoseconds (mask upper by\nshifting t2, fill out bottom using bits in the middle t3 )\n+               // (less than ms resolution would likely cause this to fall over)\n+               // not safe, not optimal; best to access /dev/urandom but\n+               // that's not OS independent (probably belongs in a package like rand)\n+               t := time.Nanoseconds()\n+               t2 := time.Nanoseconds() % (100 * 1000 * 1000)\n+               t3 := time.Nanoseconds() % (100 * 1000 * 1000) / 1000\n+               sval := t + t2\u0026lt;\u0026lt;32 + t3\n+               myrand := rand.New(rand.NewSource(sval))\n+               out.id = uint16(myrand.Uint32()) // random to minimize spoof\n+       }\n        out.question = []_DNS_Question{\n                _DNS_Question{name, _DNS_TypeA, _DNS_ClassINET},\n        }\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2009-12-19T05:27:45Z",
	"updated_at": "2014-12-22T05:45:07Z"
}
