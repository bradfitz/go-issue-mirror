{
	"id": 66049264,
	"body": "\u003ca id=\"c9\"\u003e\u003c/a\u003eComment 9 by **charlie.c.kim**:\n\n\u003cpre\u003eCleaner version:\ndiff -r affe0f093696 src/pkg/net/dnsclient.go\n--- a/src/pkg/net/dnsclient.go  Wed Dec 23 22:08:49 2009 -0800\n+++ b/src/pkg/net/dnsclient.go  Thu Dec 24 01:27:38 2009 -0800\n@@ -17,6 +17,8 @@\n import (\n        \"once\"\n        \"os\"\n+       \"rand\"\n+/*     \"time\" */\n )\n\n // DNSError represents a DNS lookup error.\n@@ -37,6 +39,84 @@\n\n const noSuchHost = \"no such host\"\n\n+var drandStream *rand.Rand     // persist stream\n+\n+// return byte array of at least bits bits\n+// Should a version of this exist in os.?\n+func _GetRandBits(bits int) ([]byte, os.Error) {\n+       bytcnt := ( bits + 7 ) / 8 // Get right # of bytes\n+       randfile, err := os.Open(\"/dev/urandom\", os.O_RDONLY, 0)\n+       if err != nil {\n+               // fallback to /dev/random for FreeBSD, etc.?\n+               // maybe should disallow on Linux\n+               // prob. need diff. path for Windows\n+               if e, ok := err.(*os.PathError); ok \u0026\u0026 e.Error == os.ENOENT {\n+                       randfile, err = os.Open(\"/dev/random\", os.O_RDONLY, 0)\n+                       if err != nil {\n+                               return nil, err;\n+                       }\n+               } else {\n+                       return nil, err\n+               }\n+       }\n+       defer randfile.Close()\n+       bytes := make([]byte, bytcnt)\n+       n, err := randfile.Read(bytes)\n+       if err != nil {\n+               return nil, err\n+       }\n+       if n \u0026lt; bytcnt {\n+               return nil, err\n+       }\n+       return bytes, nil\n+}\n+\n+func getRandId() (uint16, os.Error) {\n+       if drandStream == nil  {\n+               var sval int64;\n+               bytes, err := _GetRandBits(64)\n+               if err != nil {\n+/*\n+// disable for now\n+                       // could be fallback position - don't want to fail DNS due to\nproblems seeding rand\n+                       // but few \"supported\" systems should have an issue with\nGetRandBits...\n+                       // note: this may be one of the few cases wehre it is better\nto contiuously reseed\n+                       // (so initial seed (which is guessable +/- some variance)\ncannot be \"matched\"\n+                       // bsed on observed valuse)\n+                       // fudge a seed by using low order bits of nanoseconds (mask\nupper by\n+                       // shifting t2, fill out bottom using bits in the middle t3 )\n+                       // (less than ms resolution would likely cause this to fall over)\n+                       // not safe, not optimal; best to access /dev/urandom but\n+                       // that's not OS independent (probably belongs in a package\nlike rand)\n+                       t := time.Nanoseconds()\n+                       t2 := time.Nanoseconds() % (100 * 1000 * 1000)\n+                       t3 := time.Nanoseconds() % (100 * 1000 * 1000) / 1000\n+                       sval = t + t2\u0026lt;\u0026lt;32 + t3\n+*/\n+                       return 0, err;\n+               } else {\n+                       // better way?\n+                       sval = int64(bytes[0])\u0026lt;\u0026lt;56 | int64(bytes[1])\u0026lt;\u0026lt;48 |\nint64(bytes[2])\u0026lt;\u0026lt;40 | int64(bytes[3])\u0026lt;\u0026lt;32 |\n+                               int64(bytes[4])\u0026lt;\u0026lt;24 | int64(bytes[5])\u0026lt;\u0026lt;16 |\nint64(bytes[6])\u0026lt;\u0026lt;8 | int64(bytes[7])\n+\n+               }\n+               drandStream = rand.New(rand.NewSource(sval))\n+       }\n+       return uint16(drandStream.Uint32()), nil;\n+}\n+\n+func compareQuestions(outq, inq []_DNS_Question) os.Error {\n+       if (len(outq) != len(inq)) {\n+               return os.EINVAL;\n+       }\n+       for i := 0; i \u0026lt; len(outq); i++ {\n+               if inq[i].Name != outq[i].Name || inq[i].Qtype != outq[i].Qtype ||\ninq[i].Qclass != outq[i].Qclass {\n+                       return os.EINVAL;\n+               }\n+       }\n+       return nil;\n+}\n+\n // Send a request on the connection and hope for a reply.\n // Up to cfg.attempts attempts.\n func _Exchange(cfg *_DNS_Config, c Conn, name string) (m *_DNS_Msg, err os.Error) {\n@@ -44,7 +124,10 @@\n                return nil, \u0026DNSError{\"name too long\", name, \"\"}\n        }\n        out := new(_DNS_Msg)\n-       out.id = 0x1234\n+       out.id, err = getRandId()\n+       if err != nil {\n+               return nil, err;\n+       }\n        out.question = []_DNS_Question{\n                _DNS_Question{name, _DNS_TypeA, _DNS_ClassINET},\n        }\n@@ -54,6 +137,8 @@\n                return nil, \u0026DNSError{\"internal error - cannot pack message\", name, \"\"}\n        }\n\n+       a := c.RemoteAddr()\n+\n        for attempt := 0; attempt \u0026lt; cfg.attempts; attempt++ {\n                n, err := c.Write(msg)\n                if err != nil {\n@@ -63,7 +148,12 @@\n                c.SetReadTimeout(1e9) // nanoseconds\n\n                buf := make([]byte, 2000) // More than enough.\n-               n, err = c.Read(buf)\n+               var addr *UDPAddr;\n+               uc, ok := c.(*UDPConn);\n+               if !ok {\n+                       return nil, os.EINVAL;\n+               }\n+               n, addr, err = uc.ReadFromUDP(buf)\n                if isEAGAIN(err) {\n                        err = nil\n                        continue\n@@ -76,10 +166,20 @@\n                if !in.Unpack(buf) || in.id != out.id {\n                        continue\n                }\n+               // must have remote addr available..\n+               // must match incoming\n+               if a == nil || c.RemoteAddr().String() != addr.String() {\n+                       return nil, os.EINVAL; // toss error\n+               }\n+               // should compare question section\n+               err = compareQuestions(out.question, in.question);\n+               if err != nil {\n+                       return nil, os.EINVAL;\n+               }\n                return in, nil\n        }\n        var server string\n-       if a := c.RemoteAddr(); a != nil {\n+       if a != nil {\n                server = a.String()\n        }\n        return nil, \u0026DNSError{\"no answer from server\", name, server}\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2009-12-24T09:12:00Z",
	"updated_at": "2014-12-22T05:45:09Z"
}
