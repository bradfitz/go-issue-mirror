{
	"id": 66085157,
	"body": "\u003ca id=\"c11\"\u003e\u003c/a\u003eComment 11 by **kin.wilson.za**:\n\n\u003cpre\u003e1. By syscall.Syscall transparently catering for cdecl and stdcall external calls,\nperhaps a false sense of security exists with NewCallback. \n2. Human nature being what it is the \"don't-read-the-manual\" group is probably much\nlarger than group who do. \n3. The Stdcall vs CDecl issue is arcane to a lot of people.\n\nI give an example of incorrect use of NewCallback for a CDecl callback in [1]. The\nprogram runs successfully and the calls-back do as they should. (The dlls GObject and\nGtk can be found in any windows system set up to use pprof with dot/Graphviz)\n\nThere may already be many programs in the wild doing the same thing.\n\nWhy the program doesn't fail is quite simple. Go program calls dll which in turn calls\nthe Go callback. Go callback should cut its arguments from the stack before returning\nbut doesn't. As most callbacks are a simple give and take operation, the dll and the Go\ncaller, by virtue of sp restoration don't even notice.\n\nFor enumeration type callbacks, where Go calls dll and dll has N\u0026gt;1 conversations with\nthe Go callback, the intra-dll stack integrity becomes a problem.\n\nI include a demonstration dll [2][3], caller go package [4][5] and output [6.1][6.2][6.3]\n\n[6.1] shows that calls with 2-9 arguments can be called a varying number of times by the\ndll without failure. The threshold for each arity is different.\n[6.2] shows the threshold of arity-3to9 being broken by 1 in each case.\n\n[6.3] shows the effect of changing the optimization of the dll on the arity-2 callback,\nwhich otherwise didn't fail.\n\nIt is my recommendation that you:\n\t- add NewCallbackCDecl\nor\t- strongly redocument NewCallback\nor\t- remove NewCallback\n\nGlad I found out how to call Go from Go! :)\n\n============== [1] example.go ===============\npackage main\n\nimport u \"unsafe\"\nimport f \"fmt\"\nimport s \"syscall\"\n\nvar (\n\tdo = s.MustLoadDLL(\"libgobject-2.0-0.dll\")\n\tdg = s.MustLoadDLL(\"libgtk-win32-2.0-0.dll\")\n\n\tg_signal_connect_data          = do.MustFindProc(\"g_signal_connect_data\")\n\tgtk_button_new_with_label      = dg.MustFindProc(\"gtk_button_new_with_label\")\n\tgtk_container_add              = dg.MustFindProc(\"gtk_container_add\")\n\tgtk_container_set_border_width = dg.MustFindProc(\"gtk_container_set_border_width\")\n\tgtk_init                       = dg.MustFindProc(\"gtk_init\")\n\tgtk_main                       = dg.MustFindProc(\"gtk_main\")\n\tgtk_main_quit                  = dg.MustFindProc(\"gtk_main_quit\")\n\tgtk_widget_show                = dg.MustFindProc(\"gtk_widget_show\")\n\tgtk_window_new                 = dg.MustFindProc(\"gtk_window_new\")\n\n\tgtk_widget_destroy = dg.MustFindProc(\"gtk_widget_destroy\").Addr()\n)\n\ntype void *struct{} // for bogus return values\n\nfunc deleteEvent(a1, a2, a3 uintptr) uintptr {\n\tf.Println(\"delete event occurred with args\", a1, a2, a3)\n\treturn 0\n}\n\nfunc destroy(a1, a2 uintptr) (_ void) {\n\t// actually void return but syscall demands a return !!!\n\tf.Println(\"destroy event occurred with args\", a1, a2)\n\tgtk_main_quit.Call()\n\treturn\n}\n\nfunc hello(a1, a2 uintptr) (_ void) {\n\t// actually void return but syscall demands a return !!!\n\tf.Println(\"clicked event occurred with args\", a1, a2)\n\treturn\n}\n\nfunc cstring(i string) uintptr {\n\tr, _ := s.BytePtrFromString(i)\n\treturn (uintptr)(u.Pointer(r))\n}\n\nfunc main() {\n\tdefer do.Release()\n\tdefer dg.Release()\n\tgtk_init.Call(0, 0)\n\tncb := s.NewCallback // Should be s.NewCallbackCDecl\n\tW, _, _ := gtk_window_new.Call(0)\n\t//g_signal_connect(A,B,C,D) :-\n\t//\tg_signal_connect_data(A,B,C,D,0,0).\n\tg_signal_connect_data.Call(\n\t\tW, cstring(\"delete-event\"), ncb(deleteEvent), 123, 0, 0)\n\tg_signal_connect_data.Call(\n\t\tW, cstring(\"destroy\"), ncb(destroy), 456, 0, 0)\n\tgtk_container_set_border_width.Call(W, 30)\n\tB, _, _ := gtk_button_new_with_label.Call(\n\t\tcstring(\"           Hello World             \"))\n\tclicked := cstring(\"clicked\")\n\tg_signal_connect_data.Call(\n\t\tB, clicked, ncb(hello), 789, 0, 0)\n\t//g_signal_connect_swapped(A,B,C,D) :-\n\t//\tg_signal_connect_data(A,B,C,D,0,2).\n\tg_signal_connect_data.Call(\n\t\tB, clicked, gtk_widget_destroy, W, 0, 2)\n\tgtk_container_add.Call(W, B)\n\tgtk_widget_show.Call(B)\n\tgtk_widget_show.Call(W)\n\tgtk_main.Call()\n}\n============== [2] faux.c ===============\n// __cdecl is default\ntypedef void (*ccb2)(int,int);\ntypedef void __stdcall (*stdcb2)(int,int);\n\ntypedef void (*ccb3)(int,int,int);\ntypedef void __stdcall (*stdcb3)(int,int,int);\n\ntypedef void (*ccb4)(int,int,int,int);\ntypedef void __stdcall (*stdcb4)(int,int,int,int);\n\ntypedef void (*ccb5)(int,int,int,int,int);\ntypedef void __stdcall (*stdcb5)(int,int,int,int,int);\n\ntypedef void (*ccb6)(int,int,int,int,int,int);\ntypedef void __stdcall (*stdcb6)(int,int,int,int,int,int);\n\ntypedef void (*ccb7)(int,int,int,int,int,int,int);\ntypedef void __stdcall (*stdcb7)(int,int,int,int,int,int,int);\n\ntypedef void (*ccb8)(int,int,int,int,int,int,int,int);\ntypedef void __stdcall (*stdcb8)(int,int,int,int,int,int,int,int);\n\ntypedef void (*ccb9)(int,int,int,int,int,int,int,int,int);\ntypedef void __stdcall (*stdcb9)(int,int,int,int,int,int,int,int,int);\n\nvoid c2(ccb2 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2);\n\t}\n}\n\nvoid std2(stdcb2 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2);\n\t}\n}\n\nvoid c3(ccb3 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3);\n\t}\n}\n\nvoid std3(stdcb3 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3);\n\t}\n}\n\nvoid c4(ccb4 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4);\n\t}\n}\n\nvoid std4(stdcb4 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4);\n\t}\n}\n\nvoid c5(ccb5 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4,5);\n\t}\n}\n\nvoid std5(stdcb5 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4,5);\n\t}\n}\n\nvoid c6(ccb6 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4,5,6);\n\t}\n}\n\nvoid std6(stdcb6 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4,5,6);\n\t}\n}\n\nvoid c7(ccb7 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4,5,6,7);\n\t}\n}\n\nvoid std7(stdcb7 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4,5,6,7);\n\t}\n}\n\nvoid c8(ccb8 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4,5,6,7,8);\n\t}\n}\n\nvoid std8(stdcb8 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4,5,6,7,8);\n\t}\n}\n\nvoid c9(ccb9 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4,5,6,7,8,9);\n\t}\n}\n\nvoid std9(stdcb9 f, int n) {\n\tint i;\n\tfor(i=0;i\u0026lt;n;i++){\n\t\tf(1,2,3,4,5,6,7,8,9);\n\t}\n}\n============== [3] makedlls.bat ===============\ngcc -shared -s -o faux.dll faux.c\ngcc -shared -s -o fauxO2.dll -O2 faux.c\n============== [4] test.go ===============\npackage test\n============== [5] test_test.go ===============\npackage test\n\nimport (\n\t. \"fmt\"\n\t. \"syscall\"\n\t\"testing\"\n)\n\n/*\n//bug?\n//you can have:\nfunc a() (_ int) { return }\n//or:\nvar b = func() (_ int) { return }\n//but not:\nfunc c() {\n\tvar d = func() (_ int) { return }\n}\n*/\n\n//Callbacks must have a return!!! Unfortunate but true.\ntype void *struct{}\n\nconst dll = \"faux.dll\"\n\nfunc test(n uintptr, extc, extstd string, ca, stda uintptr) {\n\td := MustLoadDLL(dll)\n\tdefer d.Release()\n\td.MustFindProc(extstd).Call(stda, n)\n\tPrintln(\"Stdcall done\")\n\td.MustFindProc(extc).Call(ca, n)\n\tPrintln(\"CDecl done\")\n}\n\nfunc TestCallbackIsUsed(t *testing.T) {\n\tn := uintptr(1)\n\tc := func(i1, i2 int) void {\n\t\tPrintln(\"in callback\")\n\t\tif i1+i2 != 3 || i1 != i2-1 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tca := NewCallbackCDecl(c)\n\ts := func(i1, i2 int) void {\n\t\tPrintln(\"in callback\")\n\t\tif i1+i2 != 3 || i1 != i2-1 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tstda := NewCallback(s)\n\tPrintln(dll, n, \"x 2-arg correctly using NewCallbackCDecl\")\n\ttest(n, \"c2\", \"std2\", ca, stda)\n}\n\nfunc TestNx2(t *testing.T) {\n\tn := uintptr(10000)\n\tc := func(i1, i2 int) void {\n\t\tif i1+i2 != 3 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tca := NewCallback(c)\n\ts := func(i1, i2 int) void {\n\t\tif i1+i2 != 3 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tstda := NewCallback(s)\n\tPrintln(dll, n, \"x 2-arg incorrectly using NewCallback\")\n\ttest(n, \"c2\", \"std2\", ca, stda)\n}\n\nfunc TestNx3(t *testing.T) {\n\tn := uintptr(3)\n\tc := func(i1, i2, i3 int) void {\n\t\tif i1+i2+i3 != 6 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tca := NewCallback(c)\n\ts := func(i1, i2, i3 int) void {\n\t\tif i1+i2+i3 != 6 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tstda := NewCallback(s)\n\tPrintln(dll, n, \"x 3-arg CDecl incorrectly using NewCallback\")\n\ttest(n, \"c3\", \"std3\", ca, stda)\n}\n\nfunc TestNx4(t *testing.T) {\n\tn := uintptr(5)\n\tc := func(i1, i2, i3, i4 int) void {\n\t\tif i1+i2+i3+i4 != 10 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tca := NewCallback(c)\n\ts := func(i1, i2, i3, i4 int) void {\n\t\tif i1+i2+i3+i4 != 10 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tstda := NewCallback(s)\n\tPrintln(dll, n, \"x 4-arg CDecl incorrectly using NewCallback\")\n\ttest(n, \"c4\", \"std4\", ca, stda)\n}\n\nfunc TestNx5(t *testing.T) {\n\tn := uintptr(2)\n\tc := func(i1, i2, i3, i4, i5 int) void {\n\t\tif i1+i2+i3+i4+i5 != 15 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tca := NewCallback(c)\n\ts := func(i1, i2, i3, i4, i5 int) void {\n\t\tif i1+i2+i3+i4+i5 != 15 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tstda := NewCallback(s)\n\tPrintln(dll, n, \"x 5-arg CDecl incorrectly using NewCallback\")\n\ttest(n, \"c5\", \"std5\", ca, stda)\n}\n\nfunc TestNx6(t *testing.T) {\n\tn := uintptr(7)\n\tc := func(i1, i2, i3, i4, i5, i6 int) void {\n\t\tif i1+i2+i3+i4+i5+i6 != 21 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tca := NewCallback(c)\n\ts := func(i1, i2, i3, i4, i5, i6 int) void {\n\t\tif i1+i2+i3+i4+i5+i6 != 21 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tstda := NewCallback(s)\n\tPrintln(dll, n, \"x 6-arg CDecl incorrectly using NewCallback\")\n\ttest(n, \"c6\", \"std6\", ca, stda)\n}\n\nfunc TestNx7(t *testing.T) {\n\tn := uintptr(6)\n\tc := func(i1, i2, i3, i4, i5, i6, i7 int) void {\n\t\tif i1+i2+i3+i4+i5+i6+i7 != 28 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tca := NewCallback(c)\n\ts := func(i1, i2, i3, i4, i5, i6, i7 int) void {\n\t\tif i1+i2+i3+i4+i5+i6+i7 != 28 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tstda := NewCallback(s)\n\tPrintln(dll, n, \"x 7-arg CDecl incorrectly using NewCallback\")\n\ttest(n, \"c7\", \"std7\", ca, stda)\n}\n\nfunc TestNx8(t *testing.T) {\n\tn := uintptr(1)\n\tc := func(i1, i2, i3, i4, i5, i6, i7, i8 int) void {\n\t\tif i1+i2+i3+i4+i5+i6+i7+i8 != 36 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tca := NewCallback(c)\n\ts := func(i1, i2, i3, i4, i5, i6, i7, i8 int) void {\n\t\tif i1+i2+i3+i4+i5+i6+i7+i8 != 36 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tstda := NewCallback(s)\n\tPrintln(dll, n, \"x 8-arg CDecl incorrectly using NewCallback\")\n\ttest(n, \"c8\", \"std8\", ca, stda)\n}\n\nfunc TestNx9(t *testing.T) {\n\tn := uintptr(8)\n\tc := func(i1, i2, i3, i4, i5, i6, i7, i8, i9 int) void {\n\t\tif i1+i2+i3+i4+i5+i6+i7+i8+i9 != 45 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tca := NewCallback(c)\n\ts := func(i1, i2, i3, i4, i5, i6, i7, i8, i9 int) void {\n\t\tif i1+i2+i3+i4+i5+i6+i7+i8+i9 != 45 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tstda := NewCallback(s)\n\tPrintln(dll, n, \"x 9-arg CDecl incorrectly using NewCallback\")\n\ttest(n, \"c9\", \"std9\", ca, stda)\n}\n\nfunc TestLooped1x9(t *testing.T) {\n\td := MustLoadDLL(dll)\n\tdefer d.Release()\n\tdc := d.MustFindProc(\"c9\").Addr()\n\tc := func(i1, i2, i3, i4, i5, i6, i7, i8, i9 int) void {\n\t\tif i1+i2+i3+i4+i5+i6+i7+i8+i9 != 45 {\n\t\t\tt.Error(\"bad input\")\n\t\t}\n\t\treturn nil\n\t}\n\tca := NewCallback(c)\n\tn := 10000\n\tPrintln(dll, n, \"iterations of 1 x 9-arg CDecl incorrectly using NewCallback\")\n\tfor i := 0; i \u0026lt; n; i++ {\n\t\tSyscall(dc, 2, ca, 1, 0)\n\t}\n}\n============== [6.1] test output faux.dll ===============\n=== RUN TestCallbackIsUsed\n../faux.dll 1 x 2-arg correctly using NewCallbackCDecl\nin callback\nStdcall done\nin callback\nCDecl done\n--- PASS: TestCallbackIsUsed (0.17 seconds)\n=== RUN TestNx2\n../faux.dll 10000 x 2-arg incorrectly using NewCallback\nStdcall done\nCDecl done\n--- PASS: TestNx2 (0.02 seconds)\n=== RUN TestNx3\n../faux.dll 3 x 3-arg CDecl incorrectly using NewCallback\nStdcall done\nCDecl done\n--- PASS: TestNx3 (0.00 seconds)\n=== RUN TestNx4\n../faux.dll 5 x 4-arg CDecl incorrectly using NewCallback\nStdcall done\nCDecl done\n--- PASS: TestNx4 (0.00 seconds)\n=== RUN TestNx5\n../faux.dll 2 x 5-arg CDecl incorrectly using NewCallback\nStdcall done\nCDecl done\n--- PASS: TestNx5 (0.00 seconds)\n=== RUN TestNx6\n../faux.dll 7 x 6-arg CDecl incorrectly using NewCallback\nStdcall done\nCDecl done\n--- PASS: TestNx6 (0.00 seconds)\n=== RUN TestNx7\n../faux.dll 6 x 7-arg CDecl incorrectly using NewCallback\nStdcall done\nCDecl done\n--- PASS: TestNx7 (0.00 seconds)\n=== RUN TestNx8\n../faux.dll 1 x 8-arg CDecl incorrectly using NewCallback\nStdcall done\nCDecl done\n--- PASS: TestNx8 (0.00 seconds)\n=== RUN TestNx9\n../faux.dll 8 x 9-arg CDecl incorrectly using NewCallback\nStdcall done\nCDecl done\n--- PASS: TestNx9 (0.00 seconds)\n=== RUN TestLooped1x9\n../faux.dll 10000 iterations of 1 x 9-arg CDecl incorrectly using NewCallback\n--- PASS: TestLooped1x9 (0.00 seconds)\nPASS\nok  \tgithub.com/tHinqa/goIssue6338/test\t0.312s\n============== [6.2] test output faux.dll failures ===============\n=== RUN TestNx3\n../faux.dll 4 x 3-arg CDecl incorrectly using NewCallback\nStdcall done\nfatal error: malloc/free - deadlock\n[signal 0xc0000005 code=0x1 addr=0x2f0 pc=0x41ab28]\n\n=== RUN TestNx4\n../faux.dll 6 x 4-arg CDecl incorrectly using NewCallback\nStdcall done\nfatal error: malloc/free - deadlock\n[signal 0xc0000005 code=0x1 addr=0x2f0 pc=0x41ab28]\n\n=== RUN TestNx5\n../faux.dll 3 x 5-arg CDecl incorrectly using NewCallback\nStdcall done\n!!!!!!!!!!!! No failure occurs !!!!!!!!!!!!! Program simply exited\n\n=== RUN TestNx6\n../faux.dll 8 x 6-arg CDecl incorrectly using NewCallback\nStdcall done\nfatal error: malloc/free - deadlock\n[signal 0xc0000005 code=0x1 addr=0x2f0 pc=0x41ab28]\n\n=== RUN TestNx7\n../faux.dll 7 x 7-arg CDecl incorrectly using NewCallback\nStdcall done\nfatal error: malloc/free - deadlock\n[signal 0xc0000005 code=0x1 addr=0x2f0 pc=0x41ab28]\n\n=== RUN TestNx8\n../faux.dll 2 x 8-arg CDecl incorrectly using NewCallback\nStdcall done\nfatal error: malloc/free - deadlock\n[signal 0xc0000005 code=0x1 addr=0x2f0 pc=0x41ab28]\n\n=== RUN TestNx9\n../faux.dll 9 x 9-arg CDecl incorrectly using NewCallback\nStdcall done\nfatal error: malloc/free - deadlock\n[signal 0xc0000005 code=0x1 addr=0x2f0 pc=0x41ab28]\n============== [6.3] test output fauxO2.dll ===============\n=== RUN TestNx2\n../fauxO2.dll 10000 x 2-arg incorrectly using NewCallback\nStdcall done\nexit status -1073741819\nFAIL\tgithub.com/tHinqa/goIssue6338/test\t0.359s\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-09-22T19:05:42Z",
	"updated_at": "2014-12-22T06:28:35Z"
}
