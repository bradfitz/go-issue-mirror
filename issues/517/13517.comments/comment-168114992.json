{
	"id": 168114992,
	"body": "\u003e 1 library == 1 repository doesn't make sense in Go.\r\n\r\nI've been reflecting on this basic idea (which is at the core of the disagreement here) more over the course of the day, and feel that I can say this much: the fact that Go does have such clear boundaries around its packages, and parsing dependency information can be done fast and unambiguously, is an interesting and important property to consider for Go package management.\r\n\r\nThere's validity to the notion that other langs have landed on \"repo as lib\" as a way of establishing a boundary when the language itself doesn't have a strong opinion. And, since Go does boundaries well on its own, we needn't rely on the repository for that. This is clearly true, as evidenced by the various examples @kardianos and @ardan-bkennedy et. all have offered in the thread.\r\n\r\nMy issue, though, is that I think folks are interpreting that \"needn't\" as a \"shouldn't\" - as evidenced by the quote I pulled from @kardianos. It's [a logical fallacy](https://en.wikipedia.org/wiki/Denying_the_antecedent), even - just because Go doesn't need repos to help define API boundaries doesn't mean that repos should just be treated as dumb code shipping containers. 1 library == 1 repository absolutely *can* make sense for Go. Literally thousands of repositories adhere to that pattern. It's just not the *only* feasible way of grouping code.\r\n\r\nThe 'kit' repo case, and the package-level vendoring that their use could entail, is one case that a 'complete' Go package management solution must either directly support, or at least not preclude. But it's putting the cart before the horse to focus on it now. The general, base case is easily grabbing lots of different repositories, at tight or flexible version ranges, and locking those resolutions into place for reproducible builds.\r\n\r\nThat entails versioning schemes - again, a repository property, not a code property - not just locking to a commit hash. Dependency lock-in is real, and this (emphasis mine):\r\n\r\n\u003e  I find it much faster than dealing with a handwritten build file. It does so package by package, so you only get the packages you need, locked in **exactly as you want them**.\r\n\r\n[Isn't really true.](https://github.com/golang/go/issues/12302#issuecomment-135294057) I almost never have enough information to be certain that the revision locked in is the one and only one that will work.  What I *want* is to specify a range of acceptable versions, have the machine pick a version for me that meets those constraints, and THEN only change the locked-in version when a) I tell it to or b) I add a new dependency that creates a broken diamond, and some wiggle room is needed to resolve it. Locks are necessary, but not sufficient; without version range constraints to loosen things up when needed, locks are like overtightened screws.",
	"user": {
		"login": "sdboyer",
		"id": 21599,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-31T03:25:02Z",
	"updated_at": "2015-12-31T04:33:03Z"
}
