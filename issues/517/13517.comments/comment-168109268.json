{
	"id": 168109268,
	"body": "@Crell Thanks for your input.\r\n\r\nYour (3) points (semver, build file, lock file) is a very succinct description of what you see. Thanks.\r\n\r\nJava, PHP, .NET have libraries and programs. Go has packages and the distinction is important. It is also important to note that every single go file (not package, not project, not repo) is entirely self describing in terms of dependencies. But I do get what you are saying.\r\n\r\nIf you are looking for a central package index, I find godoc.org very useful.\r\n\r\n1 library == 1 repository doesn't make sense in Go. As before, go doesn't have libraries. Here is an example of a single repo: https://godoc.org/golang.org/x/crypto . I really don't see a need to break out each of these packages into its own repository. Or maybe it is a library? If so, they are almost entirely independent from each other (ssh, bcrypt).\r\n\r\nOr you can take https://godoc.org/github.com/youtube/vitess/go/sync2 , a useful package I've used in the past. Granted, it is part of the vitess youtube repo, but it isn't in an internal directory and it works well. I copy it to a vendor folder for non-main package using a tool, I don't want the rest of vitess, just that. So have I sinned? `go get` works with my package, it is pinned, upstream can change all it wants and I don't care. I've vetted the code I bring in and re-test it. At this point my package \"owns\" it. What if they release a security update? Well, if we have a standard lock file, finding packages that use the tainted revision should be simple for machines to do (I sure don't want to check by hand, I've got tools for that).\r\n\r\nI think there could be value found in creating a build file, though I'd prefer to just work with a CLI tool. I think there could be value found in using semver (I'm certainly not against using semver).  But practically, I don't run into the issues you are describing with go when using simple existing tools, (godep, glock, govendor). In other words, I find the tools are largely adequate. But I find that each tool writes down the same thing: package, revision. Just in a different machine format.\r\n\r\nYou mention the compiler is smart. It actually is better than that. Using https://godoc.org/go/parser and friends, you can quickly read the top of the go files and build a dependency tree with just the source! This is actually what govendor does. If you run \"govendor add +external\" it writes down all your packages and copies them to your vendor folder. You don't have to check in files in the vendor folder, but you can. I find it much faster than dealing with a handwritten build file. It does so package by package, so you only get the packages you need, locked in exactly as you want them.\r\n\r\nHonest question, were you ever able to do anything like that in PHP?\r\n\r\nI appreciate your viewpoint. But I'm struggling to apply them to go.\r\n",
	"user": {
		"login": "kardianos",
		"id": 755121,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-31T01:49:24Z",
	"updated_at": "2015-12-31T01:49:24Z"
}
