{
	"id": 169085276,
	"body": "@Crell I agree that applications should pin/copy and \"libraries\" (packages) should use version ranges. I agree that it is good if packages are released.\r\n\r\nThe difference is static analysis and GOPATH.\r\n\r\nIf the application should pin dependencies, then a design file isn't required for application, just the revision and specific version it uses.\r\n\r\nIf the \"library\" should contain version ranges it should have a version range for each dependency it uses. Now let me constrain the problem of version ranges into two categories: (1) \"I want my package to use a compatible API\", and (2) \"I want my package to use all the required features it needs\". (Remember your engineering design class, user stories must not contain a technical implementation or technical requirements). In Go you can denote API compatibility with either a unique import path or a \"major\" release tag. In order to satisfy compatibility, you cannot remove a feature or API once added. If package authors choose to give a unique path to each \"major\" release, the feature set is a function of the statically knowable API or just the revision time. If a package author just uses a tag, then all we need to know is what the version tag is currently to know the major version we need. And if we can just use the current version as a range spec, then that is machine discoverable, again removing the need for a human editable design file.\r\n\r\n`govendor` already pins revisions for end applications. It would be simple to inform `govendor` that this is a \"library\" and just write down what is in the environment, including revisions and any versions package authors have provided. The versions it uses should automatically give any end application using it more first-hand information.\r\n\r\nIf a package author really had an exceptional amount of knowledge of a needed package version range or wanted to blacklist a particular version, it would be trivial to add a field with a well defined interpretation of that field for human use that could be presented to any down-stream users of the package.\r\n\r\nThe main difference between glide and what I'm proposing here is I'm letting the machine do more of the work. If you *want* to write the design file yourself for everything, that seems silly to me, but again fine. I continue to see no technical reason why we could not write versions and version ranges to the same file.\r\n",
	"user": {
		"login": "kardianos",
		"id": 755121,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-05T18:10:11Z",
	"updated_at": "2016-01-05T18:10:11Z"
}
