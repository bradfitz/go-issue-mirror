{
	"id": 183432463,
	"body": "\u003e I finished reading the article you wrote. I'm having a hard time getting past the \"LOLZ CATZ\" tone in it.\r\n\r\nThere are a variety of strategies out there for getting people to read almost 13000 words. You get to make your stylistic choices, I get to make mine. The substantive points remain.\r\n\r\n\u003e For instance, I believe Dave's proposal was not accepted not because people don't want to encourage semver, but because it wasn't actionable by the any mainline go tool.\r\n\r\nI think that's an inference you made, not something I said. I simply said that it failed; I didn't say why.\r\n\r\n\u003e I commend Dave for the proposal, but presenting Dave as the valiant hero who was shot down without good cause doesn't do anyone any good.\r\n\r\nI've amended the wording there to be explicit that it failed because it lacked concrete outcomes, but again, I don't think I actually said that. What I DID say was that it probably wasn't incorrect that it failed.\r\n\r\nThe valiant-ness refers to the willingness to jump into what was sure to be a fractious discussion. I'd ascribe the same to you for this thread, even though I don't agree with your approach.\r\n\r\n\u003e A tool should and can work with any size of repo, monorepo or microrepos.\r\n\r\nAnd I said as much. In fact, I was quite careful about saying it. What I said was that monorepos were harmful for _sharing_ - not that they should be neglected by a tool.\r\n\r\n\u003e Using a dvcs to download source code doesn't limit the ability to work with individual packages.\r\n\r\nNot much to say here except that I don't think you really understood the constraints presented in the article.\r\n\r\n\u003e Who uses a package manager is greatly determined by the language itself. For instance, in users of programs written in go shouldn't ever touch a package manager, they should touch end binaries. Developers of a given project should think about package managers, but only when updating dependencies. This is much different than PHP, Python , or Ruby.\r\n\r\nThe differences are not so big, as...well, the entire article more or less lays out. But directly to your point: Cargo/Rust.\r\n\r\nBut again, now for the third time, this isn't inconsistent with what I wrote. Right from the outset, I indicated that `go get`, being an LPM, is a tool at least in part for end users. The issue is having an LPM that's not underpinned by a PDM - the developer tool.\r\n\r\n\u003e In go, the build system will never know anything about the package manager, as it is the package manager's responsibility to put packages in the correct location for the build system, just as the compiler knows nothing about the build system.\r\n\r\nAgain, now for the fourth time...this is basically the text on one of the captions.\r\n\r\n\u003e I'm not a fan of JSON, but it is in the std lib where TOML is not (nor has it reached 1.0 yet). And YAML is sooo much more than a static configuration file, the spec is huge and extremely hard to implement. If you want to have a chance at someday integrating with the go tool, I would recommend against using YAML.\r\n\r\nYep. That's why I didn't touch this in the Go section, but only in the general section. @bradfitz [outlined this preference a year ago](https://groups.google.com/forum/#!topic/golang-dev/nMWoEAG55v8%5B1-25%5D). It doesn't change my stance on what the right general decision is, of course, but it's a relatively minor issue that would have distracted from main the point.\r\n\r\nIronically, using a *non* stdlib library for tooling is the kind of thing having a proper PDM would make easier.\r\n\r\n\u003e Some of your points don't seem to be founded in actual issues: you have paragraph emotionally targeting people who don't think we need reproducible builds.\r\n\r\nI do indeed. In part for levity, and in part because, as I was explicit about in paragraph three, the article is targeted at more than just Go. So yes, that _is_ an actual issue - just not for Go.\r\n\r\n\u003e In the Go ecosystem I don't see that attitude to begin with, so even aside from your tone, there isn't anything to be argued there: we all want reproducible builds at some level depending on our exact needs.\r\n\r\nNor do I see that attitude. ...and, also, I said as much in the article:\r\n\r\n\u003e While thereâ€™s some appreciation of the need for harm reduction, too much focus has been on reducing harm through reproducible builds, and not enough on mitigating the risks and uncertainties developers grapple with in day-to-day work.\r\n\r\nThe value of including it all, even the stuff that doesn't immediately narrowly apply to your particular language of concern, is that it can help expand your perspective on what the overall problem looks like. Which was the high-level goal of the article.\r\n\r\n\u003e You do offer a good summary of different issues present in specifying version ranges and a good point in that the developer can treat them as a suggestion and override them.\r\n\r\nThanks. I'm glad you found that useful.\r\n\r\n\u003e I don't see this issue going forward and will probably close it soon.\r\n\r\nThat's a shame; per the article, my sense is that we could indeed make incremental progress by defining a proper lock file. Perhaps it would be best to start a clean issue for that, though.",
	"user": {
		"login": "sdboyer",
		"id": 21599,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-02-12T18:03:58Z",
	"updated_at": "2016-02-12T18:10:54Z"
}
