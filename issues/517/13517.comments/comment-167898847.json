{
	"id": 167898847,
	"body": "@kardianos thanks for sharing your use cases. That helps me better understand where you're coming from. I have some comments on there.\r\n\r\n* For (2) there are problems when you fetch versions at a package level rather than a repo level. For example, if you fetch 2 packages in the repo at two different versions and they rely on a 3rd common package from the repo. Which version do you use there? And, this concept breaks atomic tested commits for the imported repo.\r\n* What tooling does machine analysis based on commit ids for vulnerabilities? Tools I'm aware of, such as [David for node.js](https://david-dm.org) do analysis based on versions and version ranges (e.g., `^1.2.3`). It's easier to know the latest non-vulnerable version number and evaluate if a version is after that than to know the last non-vulnerable commit id (hash) and if the current one is after that. With version numbers you don't need the complete commit history.\r\n* What kind of dependency usage (3) are you looking to map? You can already map the dependency graph today on godoc.org. For example, see the [kubernetes apiserver package](https://godoc.org/github.com/kubernetes/kubernetes/pkg/apiserver?import-graph). With a lock file you can't really map versions required within the tree because you've stepped past that to the single commit in use for the tree. So, what kind of mapping are you looking to do that requires this?\r\n\r\nI don't have a proposal for `go:generate`. That's still something to be worked out. It's one of the things we've not worked out making it premature to have a solution.\r\n\r\nPackage management in most programming language ecosystems have settled on one tool. Rust has Cargo. PHP has Composer (formerly Pear was used). Node.js has npm. You get the idea. The Go ecosystem has become quite divided. The tooling supplied by Godep (a longtime solution) was insufficient for many. Now the ecosystem is fractured and a wide array of solutions are being worked on in order to meet all the use cases people have. If the vendoring setup you talked about worked for the masses GB and Glide would not be gaining the following they are and there would have been no call for them in the first place. Those are just two of the many tools being created.\r\n\r\nTrying to push this solution in without adapting to meet the needed use cases for many could cause further community issues. Package management has become a hot topic. Many of the elements of the `go` toolchain nailed it so there wouldn't be a need to debate things. Package management is something we need to get right for the majority of developers or not bring into the `go` tool.\r\n\r\n@kardianos Could you possibly expand on you this spec would be needed for my [use cases](http://github.com/mattfarina/pkg/tree/master/use_cases)? Then I could see how it would fit into the broader package management situation.",
	"user": {
		"login": "mattfarina",
		"id": 62991,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-29T23:22:59Z",
	"updated_at": "2015-12-29T23:22:59Z"
}
