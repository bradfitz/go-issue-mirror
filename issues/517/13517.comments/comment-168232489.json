{
	"id": 168232489,
	"body": "\u003e I'm hearing two design preferences:\r\n\r\nI'm not quite sure that captures it - if \"not to copy into your repository\" means not use vendor/, then that's definitely not what I'm pushing for. If it means \"not to commit in the vendor dir\", then while that's my personal preference, a tool should be agnostic on that front.\r\n\r\nI think the use of the word \"copy\" here, though, points at the core of our disagreement. It presupposes a repository has been fetched and is available locally somewhere (presumably in the `GOPATH`). If I understand your perspective correctly, you think this is fine because you consider the fetching more or less irrelevant. You don't care where it comes from, so long as you can get the desired revision in the right place.\r\n\r\nI disagree with this perspective, because I think retrieval is an integral part of the responsibilities of a package manager (which are basically: specification, retrieval, and on-disk arrangement, managed with respect to changes over time). These responsibilities end up being tied together *not because it is impossible to do it a different way*, but because joining them together lets the package manager control all the relevant state at every step of the process. Playing with other peoples' state is the source of most complexity fractals I've encountered.\r\n\r\n\u003e In your examples, you put the version spec in the design file and the revisions in the lock file. If the tools you used copied the version spec and any other needed information into the lock file, then you would only need the one file when comparing versions.\r\n\r\nYes, that's a possible approach. It's also one that I've learned to avoid the hard way, because it creates ambiguities that are hard to think about in the abstract, but quite painful as soon as you try to implement. You end up forcing the user to resolve the issues with arcane command switches, when a better design could have just avoided the problem in the first place. (Again, more specifics in the article I'm working on - an out-of-context example is not very useful)\r\n\r\n\u003e In consulting, I often see users define use cases that made sense in their previous paradigm (old software or on paper), but isn't fully valid in the new paradigm (new software). But that doesn't mean the use cases were without reason.\r\n\r\nSure, of course, that's always an important perspective to consider. But the reasonable capabilities of tooling based on the lockfile-only spec you're proposing are a strict subset of those that can be achieved by a more robust, project-oriented, versioning-aware package management tool (like glide). For this to hold, you have to be able to cover those use cases at least roughly as easily as a more robust tool would. @mattfarina has mentioned his collected, albeit still probably incomplete set of [use cases](https://github.com/mattfarina/pkg/tree/master/use_cases) repeatedly, but I've yet to see you address them. (Unless I've missed it? In which case, sorry)\r\n\r\n\u003e My question is, is there design room to enable both methods in the same file format?\r\n\r\nWell, since yours can be a strict subset of a fuller package manager, I don't really see the point in that? And also, see my earlier comment about playing with other peoples' state, and my earlier earlier comment about how poorly shared formats worked for ruby's environment managers. But most importantly, no, lock files without manifests is harmful, so it's a non-starter.\r\n\r\nSo, basically...probably not.\r\n\r\n\u003e When I see version ranges for puppet and ruby and other systems, I gag.\r\n\r\nThey're not a panacea. And yes, people often use them wrong. But that doesn't make them inappropriate as *part* of a solution.\r\n\r\n\u003e Diamond dependencies: You example 2.4.{x,y,z}, which version do we use? When you go to update or add a package, right now my answer is to prompt the developer what to do. That may not be the right answer, but I would need to see data in go that that isn't.\r\n\r\nIt's not the right answer. The right answer is providing enough flexibility in a specification, via a version range, that the system can *try* to resolve it for you automatically, tell you that it did, and then you can verify and make sure that it's correct. By giving up and asking the user to resolve it, you're requiring the person likely to have the *least* relevant knowledge to find the correct, or at least an acceptable, answer. Version ranges are far, far from perfect, but they at least allow the intermediate package authors to encode some of their knowledge about what versions of the conflicting dep are *likely* to work. The end user still has to verify that the choice made was acceptable and correct, but with version ranges, they can a) get some help and b) send a patch back to the intermediate dependency if the range turns out to be wrong.\r\n\r\nThis is the approach that most package managers that take a stab at this problem have arrived at. The onus is not on us to provide an example in Go; the onus is on you to demonstrate that Go is substantively different in the ways that make it not apply here.\r\n",
	"user": {
		"login": "sdboyer",
		"id": 21599,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-31T18:26:22Z",
	"updated_at": "2015-12-31T18:36:32Z"
}
