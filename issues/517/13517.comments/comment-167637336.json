{
	"id": 167637336,
	"body": "First, I'm glad we're entertaining this conversations and thanks to @kardianos for putting in a bunch of work on this.\r\n\r\nI have a number of concerns over the data structure outlined here. I believe it is insufficient for our needs. Let me explain.\r\n\r\n1. In [some venues this has been called a lockfile](https://github.com/gopheracademy/gopheracademy-web/pull/161#issuecomment-166060815). But, the Revision property can be multiple things including a tag (e.g., `v1.3.5`) and the description says it can be used to fetch the same or similar version. A lock file needs to be the exact same version down to the commit. This is needed to reproducible builds.\r\n2. There are cases where you have trees of dependencies. Those trees could list the same dependency more than once and have slightly different compatibility requirements. Any automation tooling needs to resolve the latest version that meets all the requirements. Handling this is usually done by specifying acceptable version ranges (e.g., `\u003e= 1.2.3, \u003c 2.0.0`). There needs to be a field to specify these ranges for resolution in addition to a locked revision field. In most modern systems these two types of information are captured in two different files (a config and a lock file).\r\n3. There are times where you don't know the VCS type. For example, the url `https://example.com/foo/bar` could be the path to a package but there isn't enough detail to capture which VCS is behind it. Is it Git, Svn, or something else? There really should be an opt-in property to specify the VCS since Go supports 4 out of the box. This is needed as part of the setup to reproducibly setup the environment in different systems.\r\n4. To produce a reproducible build you really need to capture the complete dependency tree and the pinned versions (commit ids) for everything. At the top level of an application you only want the packages for your application. I'm not sure how to deal with both using this spec.\r\n\r\nThese are just a few of my concerns. I really want to see something that allows for:\r\n\r\n* Provides a user friendly way to capture dependency information.\r\n* A nested dependency tree to be handled well with automation and variations in needed versions in that tree.\r\n* No requirement on packages being in the `GOPATH` at any point (other than the parent application being worked on). This is often requested.\r\n* Deals with renaming, private repos, multiple VCS, and lots of variation.\r\n\r\nTo illustrate the needs I've collected a number of [use cases](https://github.com/mattfarina/pkg/tree/master/use_cases) that need to be satisfied by any spec. I understand that a number of people come from C/C++ here. Other languages, where many Go developers are coming from, have already solved many of these problems. I wrote up [how they handle a number of common cases](http://engineeredweb.com/blog/2015/pkg-mgr-overview/). Building something with a similar experience or one they can understand with that background would be useful.\r\n\r\n*Note, in full disclosure I worked on [a competing spec](https://github.com/mattfarina/pkg/) attempting to solve these use cases. This data structure is what Glide is roughly moving to and is influenced by our work there.*\r\n",
	"user": {
		"login": "mattfarina",
		"id": 62991,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-28T19:42:14Z",
	"updated_at": "2015-12-28T19:42:14Z"
}
