{
	"id": 169085760,
	"body": "@kostya-sh - re: binary deps, my gut is that that's mostly, though not completely, orthogonal, as we've mostly been focused on getting and arranging source code here. I'd have to research that more, though.\r\n\r\nIf I'm understanding your first use case, then yep, that makes a lot of sense.\r\n\r\nIf I'm understanding the second use case, then I have the same question as I've asked before: why do you care about getting rid of code that the compiler is going to ignore, anyway?\r\n\r\n@freeformz - \r\n\r\nI think our positions are actually quite close, though yes, we're talking past each other. That's at least partly my fault - I was assuming the disconnect was over a lack of understanding as to what performing a resolution with a range would actually look like, and so was trying to clarify that. But, looking at your gisted response, I think maybe we've reached the kernel of it:\r\n\r\n\u003e I do not believe that we should rely on some arbitrary meta-data when code analysis and revision history can determine which versions (indicated by semver tags; or failing that which revisions) satisfy every package's usage (your main, A \u0026 B) of the dependency's (C) API.\r\n\r\nSadly, code analysis + revision history *cannot* do that. (If they could, I'd agree with you - no question, they'd be the way to go) At best, they can determine that code is *not incompatible*, not that it *is compatible*. Annoyingly, these are different things. [Here's an example](https://gist.github.com/sdboyer/ba6e46245d45883dcc7b).\r\n\r\nAll of which should be taken to mean that static analysis is certainly helpful, but not sufficient, for answering this question. Trying to make it sufficient brings you into a full-contact brawl with type theory (on which I'm still quite a newbie) as you try to compute type equivalencies. That's not what Go's type system was designed to do - but it IS a goal of [Hindley-Milner](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system)-like type systems (of which some variant is used in langs like Rust, Haskell, OCaml, SML). So yes, Go is different: its type system is simplistic, but sound, and that was very much the goal (as I understand it). Trying to do too much more will be swimming upstream against the design.\r\n\r\nThe reason I advocate for version ranges is because they are a sufficiently flexible system to accommodate *both* the helpful insights from the static analysis you want, *and* the insights about logical compatibility that an upstream author is more likely to have. Run your tool, and encode the results, along with whatever else you know, into a version range.\r\n\r\nWe're talking past each other because we're imagining...well, I guess different workflows, though I'm loathe to call it that. The article I'm writing tries to break it down into necessary states and necessary phases, largely without regard for worfklow. We'll see how that pans out.",
	"user": {
		"login": "sdboyer",
		"id": 21599,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-05T18:12:17Z",
	"updated_at": "2016-01-05T20:13:08Z"
}
