{
	"id": 168148018,
	"body": "Observation: The people in this thread pushing hardest for a separate build and lock file all have extensive PHP experience prior to getting into Go, and who were in PHP for the birth of Composer.  I don't know if this is a mark in favor or against that position, just an observation. :smile: \r\n\r\n@kardianos Composer's build file, `composer.json`, is just a plain JSON file so it's human editable but also machine editable.  The composer CLI tool includes a bunch of commands to manipulate it.  Here's a few examples that are part of a typical workflow:\r\n\r\n`$ composer init`\r\n\r\nCreates a new composer.json file, asks a few questions wizard-style to prepopulate it.  Generally this is done at the very start of a project.\r\n\r\n`$ composer require foo/bar`\r\n\r\nAdds an entry to the \"requires\" section of composer.json for the foo/bar package, then downloads it into your /vendor directory.  By default it will select the current stable version, and provide a version range of \"^2\" (that is, accept version 2.anything, but not 3.anything.)  You can also specify a specific version or version range on the command line, or edit the file afterward.\r\n\r\nIf foo/bar has other dependencies, those get downloaded automatically as well with versions all being figured out to \"the most recent version that satisfies all requirements.\"\r\n\r\nAt this point, a composer.lock file is also created that contains the aggregate of my composer.json, foo/bar's composer.json, and the composer.json of any of foo/bar's dependencies, as well as the specific commits that are installed right now.\r\n\r\n`$composer update foo/bar`\r\n\r\nChecks foo/bar again for the most up to date version that still satisfies all specified dependency ranges, downloads that, and updates the composer.lock file accordingly.\r\n\r\n`$ composer update`\r\n\r\nUpdates all packages in your top-level composer.json file to their latest versions that satisfy all dependency ranges, and updates the composer.lock file accordingly.\r\n\r\nWith Composer, you're pretty much never supposed to check /vendor into your repository.  That means when joining an existing project, your initial checkout will contain only the first-party code, composer.json, and composer.lock.  There will be no vendor directory at all.  The first step is therefore to run\r\n\r\n`$ composer install`\r\n\r\nIf you have a composer.lock file, composer install will download the exact commit snapshots referenced in that file.  That guarantees you that you have the exact same code as everyone else working on the project, down to the last comment line.\r\n\r\nIf there is no composer.lock file, then composer will download the latest version of all packages that satisfy all dependencies and generate a composer.lock file for you.  You want that on an application instance, but not for a library. Hence why when I'm building a library I do NOT check my composer.lock file into the repository.  When building an application instance, I do.\r\n\r\nComposer also has a really nifty feature where you can checkout a repository as a non-vendor, with no VCS control files, but all of its dependencies in a /vendor directory.  That's helpful for bootstrapping a project you're expected to customize.  Symfony, for instance, can be installed with:\r\n\r\n`$ composer create-project symfony/standard-edition mypath`\r\n\r\nWhich will then download the \"standard edition\" project (which is a repository), then run composer install on it to get all of its dependencies.  The symfony/standard-edition is a starter-kit for projects based on the Symfony framework (one of many), and provides pre-set code that you can and should then modify and add your own code to.  (And in fact all of the Symfony libraries themselves are considered a 3rd party dependency of your project, then.)  Other, more complete applications can use the same tool but then you don't really modify them.\r\n\r\nThe result is that when you *start* a project, you get the most-recent-version of everything.  As you develop a project, you only change the version of a dependency you have when you specifically want to.\r\n\r\nIn all of those cases, the composer.json file is human-friendly and human-editable if you are so inclined, but composer.lock is not.\r\n\r\nIf you're developing several of those libraries in concert, Composer lets you download full git checkouts rather than just snapshot tarballs, making pushing changes back upstream quite easy. \r\n\r\nComposer's dependency resolution logic began life as a PHP port of OpenSUSE's package management library, so it has a fairly solid pedigree.  Distribution maintainers have been dealing with dependencies far longer than languages have.\r\n\r\nAll of that relies on the assumption that a package == a repository, and is versioned as a single unit.  Technically you can have any number of namespaces within that package/repository.  It's conventional for the package vendor to also be the top-level namespace of the code it contains, but that's not at all required by the tools.  So if you want to cluster multiple related pieces of code into a single package, but in different namespaces, you can do that.  But they are still all versioned and tagged and downloaded as a single unit.  You cannot download \"just this subdirectory of package foo/bar\".  Actually, I think that's fine given Go's smart compiler as even if  you download a package with 5 different clusters of code in it only the one you're using will end up in the binary, so at worst you're using some extra disk space for devleopment.  Boo hoo. :smile: \r\n\r\nIn the (little) Go I've done, I've had several files that were in the same namespace because it made sense to organize the code that way, logically.  I don't know if that's idiomatic or not, but I favor that over a single 10k line file if it happens to be a larger package.\r\n\r\n\r\nI think one subtle difference between Go's current conventions and PHP's is that in Go, the package name is the namespace and is also the URI of the repository where the code lives.  With Composer in PHP, there's an extra layer of indirection where a package's identifier is specified in the composer.json file, and then indexed on Packagist.org.  So the `foo/bar` package above is the `bar` package in the `foo` vendor-space, which usually coincidentally corresponds to a GitHub user of \"foo\" and a \"bar\" repository.  That's not at all required, though, just a convenient common pattern.  So no, Composer can't locate all dependencies just from source parsing, but it can just from build-file parsing.\r\n\r\nThere's probably a lengthy debate that could be had about whether it's better to have that extra indirection or to use GitHub repo names as package names, always.  I don't want to get too far into that right now, but I will offer the following advantages of that extra layer of indirection:\r\n\r\n1. If the maintainer of a package changes, you don't necessarily need to rename it.  Vis, the most popular HTTP client for PHP is called Guzzle, and its Composer name is `guzzlehttp/guzzle`.  That happens to live on GitHub at https://github.com/guzzle/guzzle.  (Note the slight difference in name.)  It could also move to BitBucket without breaking anyone's code.  The maintainers would just need to update the repository record on Packagist.org and poof, no one else needs to care.  (As an extreme, imagine how messy it would be for Go if GitHub went down hill like Sourceforge and Freshmeat before it did and everyone decided to migrate to another platform. How much code would need to be modified?)\r\n2. It makes it really easy to make personal forks of a 3rd party project, say if you have bugfixes you need that haven't made it upstream yet.  By specifying additional overriding repositories in your composer.json file, you tell Composer \"use these instead of what Packagist.org says, if relevant\".  Then when your changes get merged upstream you can just remove your repository overrides and start getting the official upstream version again, no other changes required.  Without that, using a custom fork of a project, even temporarily, requires modifying all of your source files.\r\n\r\nNo doubt some of that is not relevant for Go, but hopefully that paints a better picture of what the split between lock and build files offers.  The lack of versioning is, I would say, the number one downside of the `go get` architecture right now (which is also partially dependent on the use of repository names for namespaces), so any improved packaging system needs to have a good answer for it.",
	"user": {
		"login": "Crell",
		"id": 254863,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-31T08:00:39Z",
	"updated_at": "2015-12-31T08:00:39Z"
}
