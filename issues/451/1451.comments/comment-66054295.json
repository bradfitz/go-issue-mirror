{
	"id": 66054295,
	"body": "\u003ca id=\"c11\"\u003e\u003c/a\u003eComment 11 by **crazy1be**:\n\n\u003cpre\u003eThe difficulty here is that the interfaces provided by different operating systems\ndiffer so much that making a single, coherent, interface is going to potentially result\nin loosing a significant amount of functionality. In particular, we loose the advantages\neach system provides, making implementing something that makes full use of the APIs\n(e.g. a search indexing engine) quite difficult. However, that being said, we can easily\ncreate an API that supports the most useful subset of functionality: watching arbitrary\ndirectories for create, delete, and modify events.\n\nThe situation on Linux is probably the rosiest, which is part of the reason os/inotify\nalready exists. The inotify api provides events of almost every variety, for any\ndirectory, in a reasonably coherent API. The go wrapper on this is pretty nice,\nabstracting the low-level API surprisingly nicely.\n\nOn Windows, things are still pretty nice, if the function calls are a bit longer and\nuglier :P. ReadDirectoryChangesW() appears to support the subset of functionality I\ndescribed above almost perfectly, and even has the additional feature of being able to\nwatch sub-directories natively, no additional directory-walking code required. I wasn't\nable to figure out how you register to receive and then receive events, but It seems\npossible that ReadDirectoryChangesW() returns all changes since the folder was opened or\nit was last called.\n\nOn Mac OSX, the situation is UGLY. The API is completely and totally different from the\nones on Windows and Linux, and, it seems, designed for a completely different usage\ncase. It was implemented in order to allow the search indexer to keep up-to-date on file\nchanges, and was initially private to only that program. Since then, the FSEvents API\nhas been added, which allows external applications access to the same information that\nthe search indexer gets, filtered by top-level directory. This is recursive in nature,\nand it is impossible to make it non-recursive (although you can obviously ignore events\nfrom subfolders). Because you can ignore information, that is not a big issue. The\nbigger issue is that this API does not provide you with any information on *how* a file\nchanged, telling you only that it changed. The jnotify library gets around this by\nchecking for changes itself, but this has obvious disadvantages in that you can only see\nchanges within the directory, and you're liable to miss events if there are multiple\nevents within a short period. Moves seem especially difficult to guess, i'm not sure how\njnotify gets around this.\n\nAll in all, I think that we should provide the low-level (syscall) and medium-level\n(os/inotify) interfaces to each library, in case application developers want to take\nadvantage of this additional functionality on a particular platform. The wrapper library\nshould provide only basic functionality, like detecting modifications, moves, creations,\nand deletions. I'm undecided whether we should support recursive watching, it certainly\nhas quite a few uses I can think of, and is supported directly on all OSes except Linux.\n\nThe interface for this library is tricky to decide on. I started on mine\n(\u003ca href=\"http://github.com/crazy2be/fsmon)\"\u003ehttp://github.com/crazy2be/fsmon)\u003c/a\u003e with Callbacks, simply because that seemed like it\nwould work best for the way I was using the library. However, channels are also an\noption, perhaps divided like this:\n\nwatcher := fsmon.NewWatcher(true)\nwatcher.AddWatch(\"foo\")\nstr, str := \u0026lt;-watcher.Moves\nerr := \u0026lt;-watcher.Errors\nstr := \u0026lt;-watcher.Deletes\nstr := \u0026lt;-watcher.Creations\nstr := \u0026lt;-watcher.Modifications\n\nLet me know of your ideas and thoughts on this, @michael.\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2011-06-23T05:22:04Z",
	"updated_at": "2014-12-22T05:47:46Z"
}
