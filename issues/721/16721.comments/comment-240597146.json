{
	"id": 240597146,
	"body": "Summary of problem\r\n1. Vast majority of sort.Interface uses a slice\r\n2. Have to define a new top level type\r\n3. Len and Swap methods are always the same\r\n4. Want to make common case simpler with least hit to performance\r\n\r\nSummary of proposals\r\n1: original proposal (@bradfitz)\r\n  - pro: \r\n    - simple well-thought out api\r\n    - easy to use\r\n    - not much slower than defining own type\r\n  - con:\r\n    - no static type checking on first argument\r\n    - required to be in stdlib to take advantage of internals to work efficiently in addition to using reflect and unsafe\r\n    - adds magic to sort package (obviated by (7), these are in order)\r\n    - requires passing the slice and capturing it in the comparator by type or closure\r\n\r\n2: have something generate the boilerplate, go generate or an editor macro (me)\r\n  - pro: \r\n    - simple\r\n    - can do it now if you care and ignore it if you don't\r\n    - zero runtime performance hit\r\n    - no interface{}, no use of reflect or unsafe packages\r\n  - con: awkward to use and you have to use/remember how to use an additional tool\r\n\r\n3: Take two interface arguments []T and func(a, b T) bool (T could be a pointer) (@ianlancetaylor indirectly/me)\r\n  - pro: easier to use than original for writing the comparator\r\n  - con: \r\n    - more interface{}s = even less compile time type checking\r\n    - copying could be slow for large (non-pointer) T\r\n    - overhead of calling the comparator through reflect is *very* slow\r\n\r\n4: Take two interface arguments []T and func(a, b S) bool (If T is a pointer S=T, otherwise S=*T)\r\n  - Same as (3) but more complicated, though avoids copying large T.\r\n\r\n5: add a new builtin (@nsf)\r\n  - pro: could use magic for optimizations and type checking\r\n  - con: \r\n    - violates conservation of builtins\r\n    - would have to implicitly import sort package\r\n    - very specialized use case for a builtin: the bar is higher than that.\r\n\r\n6: LocalSorter struct (@Merovius)\r\n  - pro:\r\n    - simple to use\r\n    - simple to implement\r\n    - could work with non-slices\r\n    - could be used to implement (1)\r\n    - no interface{}, no use of reflect or unsafe packages\r\n  - con:\r\n    - not as simple to use as (1), have to define swapper and call len yourself\r\n    - not much shorter than just defining a type\r\n    - the names of the struct fields can't be the obvious Len, Less, Swap since those also have to be methods\r\n    - requires capturing the slice in the swapper and comparator by type or closure\r\n\r\n7: Add a reflect method that creates an efficient swapper for reflect.Value containing a slice in order to implement (1) (@bradfitz)\r\n  - pro:\r\n    - provides the interesting bit of the implementation as something anybody could use\r\n    - keeps the sort package free from magic\r\n  - con:\r\n    - how many uses are there for Swapper other than (1)?\r\n    - adds a new kind of power to reflect\r\n\r\n5 is too magic.\r\n\r\n1(+7), 2, and 6 solve the problem and check all the constraint boxes, all usable separately. 6+7 could implement 1 trivially.\r\n\r\n3 and 4 fail on performance, but could easily be a go gettable package. Both would be enhanced by (7).\r\n\r\n(let me know if I got anything wrong and I'll correct it) \r\nedits:\r\n- removed question mark on (1) after reading CL\r\n- added pro to 2 and 6 \"no interface{}, no use of reflect or unsafe packages\", as per @myitcv's suggestion\r\n- added con about having to capture slice to 1 and 6, as per @joshlf's suggestion\r\n- noted that struct fields couldn't be the obvious choices in 6",
	"user": {
		"login": "jimmyfrasche",
		"id": 375553,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-18T01:16:47Z",
	"updated_at": "2016-08-18T19:56:33Z"
}
