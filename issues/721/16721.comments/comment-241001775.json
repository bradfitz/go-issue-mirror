{
	"id": 241001775,
	"body": "To start off, this builds on @Merovius' solution and point of view and tries to justify it, so if this clutters up the discussion for you, stop reading. Also, this is another rant against using `reflect` so if that clutters up the discussion, stop reading. This is also a rant against `interface{}` and generics in general, so if that clutters up the discussion, stop reading.\r\n\r\nThere is a precedent for a possible solution to this in my opinion, its [sort.Search](https://golang.org/pkg/sort/#Search)\r\n\r\nread the godoc for details, but the general idea is that we use length and closure instead of doing generic stuff\r\n\r\na sort shorthand would probably look like\r\n\r\n```go\r\nfunc Slice(n int, less func(i, j int) bool, swap func(i, j int))\r\n```\r\n\r\n`LocalSorter` just becomes an internal, private type.\r\n\r\nan example usage\r\n\r\n```go\r\na := []int{5, 3, 4, 1, 2}\r\n\r\nsort.Slice(5, func(i, j int) bool { return a[i] \u003c a[j] }, func(i, j int) { a[i], a[j] = a[j], a[i] })\r\n```\r\n\r\nthe fundamental reason I think this works is because this builds upon already existing semantics with `sort.Search`, it works for me because `sort.Search` works for me, while the proposed signature doesn't because it is basically C++/Java/C# STL sort\r\n\r\n```c++\r\nstd::sort(std::begin(a), std::end(a), [](T a, T b) {\r\n\t...\r\n})\r\n```\r\n\r\nwhich only works there because of templates (half assed generics). In the method proposed so far, we circumvent generics using `reflect`, which, and this may only be because I have only been doing golang since january this year, seems like a serious antipattern to me, because for me interfaces in go have no business with type, only functionality.\r\n\r\nBy using reflect to make the round trip of getting a subtype, I think we are propogating the idea that this is how generics work in go, you send a super type and then get back the sub type using `reflect`.\r\n\r\nAnother advantage I can think of is that  at least we are giving a choice to the user to generate a `Swap` using `reflect` or write one line of code.\r\n\r\nHowever, I think generating methods using `reflect` opens up a wide array of problems of its own, because today its `Sort`, tomorrow it will be `Search`, and instead of generating `Swap`, we would be generating `Less` functions, then Lower Bound, Upper Bound, Min Element, Max Element and so on.... \r\n\r\n__TL;DR:__ I don't think we can define functions in go with semantics of languages that have generics, because we don't. I think that `sort.Search` is one of the best implemented functions in the go standard library, and we should do things in the semantics introduced by that function.\r\n\r\nI also think that if and only if we want to introduce a shorthand, we need another function definition, but if we want to only reduce boilerplate code, we should definitely look at `go generate` and @myitcv's sortgen, because irrespective of pros and cons, generating boilerplate code that you don't want to maintain is the fundamental reason `go generate` exists (in my opinion).\r\n\r\nAlso, more shorthands can be implemented, we should also implement a shorthand for `sort.IsSorted` and I propose that we add `Greater`, `LessOrEqual` and `GreaterOrEqual` to `sort.IntSlice`, `sort.StringSlice` and `sort.FloatSlice`. With them, lower bound in go simply becomes\r\n\r\n```go\r\nsort.Search(n, sort.IntSlice(a).GreaterOrEqual)\r\n```\r\n\r\nand upper bound is \r\n\r\n```go\r\nsort.Search(n, sort.IntSlice(a).Greater)\r\n```\r\n",
	"user": {
		"login": "suyash",
		"id": 16324837,
		"type": "User",
		"site_admin": false
	},
	"reactions": {
		"total_count": 6,
		"+1": 4,
		"heart": 2
	},
	"created_at": "2016-08-19T12:09:44Z",
	"updated_at": "2016-08-19T12:09:44Z"
}
