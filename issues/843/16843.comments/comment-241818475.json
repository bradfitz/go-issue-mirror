{
	"id": 241818475,
	"body": "This does not propose a callback or channel for delivering a memory\nexceeded message or a memory almost exceeded message. At that point it is\nalready too late. This proposes a mechanism for providing the application\ntimely information that it can use to avoid the OOM. The application knows\nhow best to predict memory usage and, if need be, throttle its memory usage.\n\nOne suggestion was\nfunc runtime.ReserveOOMBuffer(size uint64)\n\nThe application's heap monitor goroutine, HMG, could initially allocate a\nlarge object of the required size and retain a single reference to it. If\nthe HMG using information provided by the runtime determines that the\ncurrent GOGC and live heap size will not support the application's\npredicted allocations then it can release that single reference confident\nthat the next GC will recover those spans and make them available. It the\nHMG wants the GC to happen sooner than currently scheduled then it can\nlower GOGC using SetGCPercent.\n\nIf ReserveOOMBuffer is the API that some Go application needs then this\nprovides it. The intent of this proposal is to provide the application with\nthe information it needs to create the abstractions that best fits its need\nwhile minimizing Go's runtime API surface.\n\n\n\n\n\n\n\nOn Tue, Aug 23, 2016 at 11:13 AM, rgooch \u003cnotifications@github.com\u003e wrote:\n\n\u003e I previously gave the reasoning why using a channel or a callback to\n\u003e receive memory exceeded events won't work: #14162\n\u003e \u003chttps://github.com/golang/go/issues/14162\u003e\n\u003e That same reasoning applies to a channel whenever a GC run is completed.\n\u003e\n\u003e To robustly handling exceeding a memory limit the check for the limit has\n\u003e to be part of the allocator, not done after a GC run. This is because you\n\u003e can't afford to wait. If you wait for the next GC run, it may be too late.\n\u003e Consider a single large slice allocation that would put you over the soft\n\u003e limit *and* would exceed the hard memory limit. You'll get an OOM panic.\n\u003e The same applies to a callback function.\n\u003e\n\u003e You need to immediately stop the code which is doing the heavy allocating.\n\u003e To do that you need a check in the allocator and you need to send a\n\u003e panic(). It's up to the application to set the soft memory limit at which\n\u003e these optional, catchable panics are sent.\n\u003e\n\u003e Please, before rehashing old suggestions or coming up with new variants,\n\u003e read through #14162 \u003chttps://github.com/golang/go/issues/14162\u003e where I\n\u003e gave the reasoning why a panic and a check in the allocator is needed.\n\u003e Otherwise we keep covering the same old ground.\n\u003e\n\u003e â€”\n\u003e You are receiving this because you commented.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/16843#issuecomment-241764850\u003e, or mute\n\u003e the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AA7Wn4rwLDnFazl8ko7MEgqGqjlHlYJKks5qiw4rgaJpZM4Jqa25\u003e\n\u003e .\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-23T17:56:21Z",
	"updated_at": "2016-08-23T17:56:21Z"
}
