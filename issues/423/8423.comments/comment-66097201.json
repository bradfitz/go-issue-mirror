{
	"id": 66097201,
	"body": "\u003ca id=\"c5\"\u003e\u003c/a\u003eComment 5 by **educability**:\n\n\u003cpre\u003eI decided to do a little digging after an old friend of mine informed me that there were\nsome pretty major sandboxing changes in OS X between Mavericks and Yosemite.\n\nReadDirent is called from syscall_bsd.go:\nfunc ReadDirent(fd int, buf []byte) (n int, err error) {\n\t// Final argument is (basep *uintptr) and the syscall doesn't take nil.\n\t// 64 bits should be enough. (32 bits isn't even on 386). Since the\n\t// actual system call is getdirentries64, 64 is a good guess.\n\t// TODO(rsc): Can we use a single global basep for all calls?\n\tvar base = (*uintptr)(unsafe.Pointer(new(uint64)))\n\treturn Getdirentries(fd, buf, base)\n}\n\nGetdirentries is defined in syscall_darwin.go as:\n//sys\tGetdirentries(fd int, buf []byte, basep *uintptr) (n int, err error) =\nSYS_GETDIRENTRIES64\n\n`mksyscall.pl syscall_bsd.go syscall_darwin.go syscall_darwin_amd64.go` creates\nzsyscall_darwin_amd64.go with:\nfunc Getdirentries(fd int, buf []byte, basep *uintptr) (n int, err error) {\n\tvar _p0 unsafe.Pointer\n\tif len(buf) \u0026gt; 0 {\n\t\t_p0 = unsafe.Pointer(\u0026buf[0])\n\t} else {\n\t\t_p0 = unsafe.Pointer(\u0026_zero)\n\t}\n\tr0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)\n\tn = int(r0)\n\tif e1 != 0 {\n\t\terr = e1\n\t}\n\treturn\n}\n\nIt seems the problem is happening in Syscall6. Syscall6 traces back to\npkg/syscall/asm_darwin_\u0026lt;arch\u0026gt;.s (asm_darwin_amd64.s in my case):\nTEXT\t路Syscall6(SB),NOSPLIT,$0-80\n\tCALL\truntime路entersyscall(SB)\n\tMOVQ\t16(SP), DI\n\tMOVQ\t24(SP), SI\n\tMOVQ\t32(SP), DX\n\tMOVQ\t40(SP), R10\n\tMOVQ\t48(SP), R8\n\tMOVQ\t56(SP), R9\n\tMOVQ\t8(SP), AX\t// syscall entry\n\tADDQ\t$0x2000000, AX\n\tSYSCALL\n\tJCC\tok6\n\tMOVQ\t$-1, 64(SP)\t// r1\n\tMOVQ\t$0, 72(SP)\t// r2\n\tMOVQ\tAX, 80(SP)  // errno\n\tCALL\truntime路exitsyscall(SB)\n\tRET\nok6:\n\tMOVQ\tAX, 64(SP)\t// r1\n\tMOVQ\tDX, 72(SP)\t// r2\n\tMOVQ\t$0, 80(SP)\t// errno\n\tCALL\truntime路exitsyscall(SB)\n\tRET\n\nI am, unfortunately, not an assembly aficionado and have no idea how to fix this. It\nseems the sandboxing changes may indeed be the cause of the assembly code no longer\nworking correctly.\n\nThat's as far as I've gotten when it comes to solving this problem.\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-07-30T01:54:14Z",
	"updated_at": "2014-12-22T06:36:29Z"
}
