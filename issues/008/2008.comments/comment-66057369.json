{
	"id": 66057369,
	"body": "\u003ca id=\"c2\"\u003e\u003c/a\u003eComment 2:\n\n\u003cpre\u003eAs far as I can tell this is in Apple's hands.\nCPU profiling only works in single-proc programs, but\npprof.StartCPUProfiling inherently starts a second proc\n(blocked waiting for profiling data), and the cpu ticks\nvery often go there.\n\nI don't expect this to be fixed any time soon but if\nthis is important to you and you have some way to\nmake that known to Apple, feel free.\n\nFull Apple Bug Report below.\n\n\nchangeset:   7868:35b716c94225\nuser:        Russ Cox \u0026lt;rsc@golang.org\u0026gt;\ndate:        Fri Mar 25 13:47:07 2011 -0400\nfiles:       src/pkg/runtime/pprof/pprof_test.go\ndescription:\nruntime/pprof: disable test on darwin\n\nFixes \u003ca href=\"https://golang.org/issue/1641\"\u003eissue #1641\u003c/a\u003e.\n\nActually it side steps the real issue, which is that the\nsetitimer(2) implementation on OS X is not useful for\nprofiling of multi-threaded programs.  I filed the below\nusing the Apple Bug Reporter.\n\n/*\nFiled as Apple Bug Report #9177434.\n\nThis program creates a new pthread that loops, wasting cpu time.\nIn the main pthread, it sleeps on a condition that will never come true.\nBefore doing so it sets up an interval timer using ITIMER_PROF.\nThe handler prints a message saying which thread it is running on.\n\nPOSIX does not specify which thread should receive the signal, but\nin order to be useful in a user-mode self-profiler like pprof or gprof\n   \u003ca href=\"http://code.google.com/p/google-perftools\"\u003ehttp://code.google.com/p/google-perftools\u003c/a\u003e\n   \u003ca href=\"http://www.delorie.com/gnu/docs/binutils/gprof_25.html\"\u003ehttp://www.delorie.com/gnu/docs/binutils/gprof_25.html\u003c/a\u003e\nit is important that the thread that receives the signal is the one\nwhose execution caused the timer to expire.\n\nLinux and FreeBSD handle this by sending the signal to the process's\nqueue but delivering it to the current thread if possible:\n\n   \u003ca href=\"http://lxr.linux.no/linux+v2.6.38/kernel/signal.c#L802\"\u003ehttp://lxr.linux.no/linux+v2.6.38/kernel/signal.c#L802\u003c/a\u003e\n     807        /*\n     808         * Now find a thread we can wake up to take the signal off the queue.\n     809         *\n     810         * If the main thread wants the signal, it gets first crack.\n     811         * Probably the least surprising to the average bear.\n     812         * /\n\n   \u003ca href=\"http://fxr.watson.org/fxr/source/kern/kern_sig.c?v=FREEBSD8\"\u003ehttp://fxr.watson.org/fxr/source/kern/kern_sig.c?v=FREEBSD8\u003c/a\u003e;im=bigexcerpts#L1907\n     1914         /*\n     1915          * Check if current thread can handle the signal without\n     1916          * switching context to another thread.\n     1917          * /\n\nOn those operating systems, this program prints:\n\n    $ ./a.out\n    signal on cpu-chewing looper thread\n    signal on cpu-chewing looper thread\n    signal on cpu-chewing looper thread\n    signal on cpu-chewing looper thread\n    signal on cpu-chewing looper thread\n    signal on cpu-chewing looper thread\n    signal on cpu-chewing looper thread\n    signal on cpu-chewing looper thread\n    signal on cpu-chewing looper thread\n    signal on cpu-chewing looper thread\n    $\n\nThe OS X kernel does not have any such preference.  Its get_signalthread\ndoes not prefer current_thread(), in contrast to the other two systems,\nso the signal gets delivered to the first thread in the list that is able to\nhandle it, which ends up being the main thread in this experiment.\n\u003ca href=\"http://fxr.watson.org/fxr/source/bsd/kern/kern_sig.c?v=xnu-1456.1.26\"\u003ehttp://fxr.watson.org/fxr/source/bsd/kern/kern_sig.c?v=xnu-1456.1.26\u003c/a\u003e;im=excerpts#L1666\n\n    $ ./a.out\n    signal on sleeping main thread\n    signal on sleeping main thread\n    signal on sleeping main thread\n    signal on sleeping main thread\n    signal on sleeping main thread\n    signal on sleeping main thread\n    signal on sleeping main thread\n    signal on sleeping main thread\n    signal on sleeping main thread\n    signal on sleeping main thread\n    $\n\nThe fix is to make get_signalthread use the same heuristic as\nLinux and FreeBSD, namely to use current_thread() if possible\nbefore scanning the process thread list.\n\n*/\n\n\n#include \u0026lt;sys/time.h\u0026gt;\n#include \u0026lt;sys/signal.h\u0026gt;\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nstatic void handler(int);\nstatic void* looper(void*);\n\nstatic pthread_t pmain, ploop;\n\nint\nmain(void)\n{\n        struct itimerval it;\n        struct sigaction sa;\n        pthread_cond_t cond;\n        pthread_mutex_t mu;\n\n        memset(\u0026sa, 0, sizeof sa);\n        sa.sa_handler = handler;\n        sa.sa_flags = SA_RESTART;\n        memset(\u0026sa.sa_mask, 0xff, sizeof sa.sa_mask);\n        sigaction(SIGPROF, \u0026sa, 0);\n\n        pmain = pthread_self();\n        pthread_create(\u0026ploop, 0, looper, 0);\n\n        memset(\u0026it, 0, sizeof it);\n        it.it_interval.tv_usec = 10000;\n        it.it_value = it.it_interval;\n        setitimer(ITIMER_PROF, \u0026it, 0);\n\n        pthread_mutex_init(\u0026mu, 0);\n        pthread_mutex_lock(\u0026mu);\n\n        pthread_cond_init(\u0026cond, 0);\n        for(;;)\n                pthread_cond_wait(\u0026cond, \u0026mu);\n\n        return 0;\n}\n\nstatic void\nhandler(int sig)\n{\n        static int nsig;\n        pthread_t p;\n\n        p = pthread_self();\n        if(p == pmain)\n                printf(\"signal on sleeping main thread\\n\");\n        else if(p == ploop)\n                printf(\"signal on cpu-chewing looper thread\\n\");\n        else\n                printf(\"signal on %p\\n\", (void*)p);\n        if(++nsig \u0026gt;= 10)\n                exit(0);\n}\n\nstatic void*\nlooper(void *v)\n{\n        for(;;);\n}\n\nR=r\nCC=golang-dev\n\u003ca href=\"http://golang.org/cl/4273113\"\u003ehttp://golang.org/cl/4273113\u003c/a\u003e\u003c/pre\u003e\n\n_Labels changed: added **expertneeded**._\n\n\n_Status changed to **LongTerm**._",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2011-06-27T21:49:04Z",
	"updated_at": "2014-12-22T05:56:46Z"
}
