{
	"id": 66082136,
	"body": "\u003ca id=\"c2\"\u003e\u003c/a\u003eComment 2:\n\n\u003cpre\u003eThanks for finding and reporting an interesting and subtle constellation of bugs!  I\nthink this behaviour arises from a lack of clarity in the language specification, but\nit's not yet clear to me what the appropriate fix is.\n\nConsider this source program and generated SSA code:\n\n    bitSize := 64\n    cutoff := uint64(1 \u0026lt;\u0026lt; uint(bitSize-1))\n\n \tt0 = 64:int - 1:int                                                     int\n    \tt1 = convert uint \u0026lt;- int (t0)                                          uint\n    \tt2 = convert uint64 \u0026lt;- uint (t1)                                     uint64\n    \tt3 = 1:untyped integer \u0026lt;\u0026lt; t2                                untyped integer\n\nThe expression 1 is an untyped integer constant, and the shift is non-constant since the\nright operand is a variable.  The spec tells us:\n\n  \"If the left operand of a non-constant shift expression is an untyped constant, the type of the constant is what it would be if the shift expression were replaced by its left operand alone.\"\n\nThere are a number of problems with this statement (and it has proven very subtle to\nimplement).\n\nFirstly, the term \"untyped\" is misleading, as it really means something like \"exact\", or\nmore precisely \"of a very large but implementation-specific width\".  From a\ntype-theoretic perspective, the types of \"untyped constants\" are real types.  I move for\na future version of the spec to describe them with a different term such as \"exact\".\n\nI think this sentence assumes the reader knows that type-checking requires both\nbottom-up and top-down attributes of the abstract syntax tree---or \"synthesized\" and\n\"inherited\" attributes, to use Knuth's attribute grammar terminology---and what it is\ntrying to say is that the attributes inherited by the x\u0026lt;\u0026lt;y expression are also\ninherited by the x subtree.  It is confusing because the \"if ...\" clause seems to know\nalready the type of x (\"an untyped constant\") yet the type is determined by the\n\"then...\" clause (\"the type of the constant would be...\"), which seems circular.  Only\nby explaining type inference as a function of both synthetic and inherited attributes\ndoes it make sense.\n\nNow consider y := 1 \u0026lt;\u0026lt; x.  We've determined that the type of 1 here is the same as\nthe type of 1 in this code: y := 1.  But is that int (inherited from the assignment to\ny) or is it 'untyped int', which is the synthesized type of 1?  If the former, then we\nhave a bug in the type-checker since it should not report 'untyped int' for this\nliteral, nor indeed for any expression except those internal to a constant expression. \nIn the concrete example at the top, the inherited type might by uint64 from the\nconversion, but it's not clear.\n\nThen there's a separate question of the following possible (but not current) invariant:\nshould any SSA instruction yield a value of an \"untyped\" type?  I think the answer\nshould be \"no\", and I would love to make it so, since representing such values is\nchallenging and the intent of the spec is that they're only needed by the compiler\nfront-end.  Currently, values of 'untyped' types do appear in the SSA form, and the\ninterpreter represents them by whatever type they would be converted to if assigned to\nan empty interface: int, float64, etc.  So if you're running on a 32-bit system, they'll\nbe converted to int, which means you'll see 32-bit arithmetic in the shift operation,\nwhich yields the value of zero.  The spec nowhere describes the width of the arithmetic\nused in an \"untyped\" shift, perhaps because it assumes that all variables have \"typed\"\ntypes ultimately derived from their inherited type.\n\nA more prosaic bug you have found is that the SSA builder seems to be generating a\nrather unnecessary pair of conversions int-\u0026gt;uint-\u0026gt;uint64; I will file a separate\nbug report for that.\n\n\nAlso, just FYI:\n \n- I find the (underspecified) 'println' built-in function very helpful for debugging\nsince it allows one to inspect a value without importing functions from other packages\nsuch as fmt.Print or os.Exit.  For example:\n\nfunc main() {\n        bitSize := 64\n        println(uint64(1 \u0026lt;\u0026lt; uint(bitSize-1)))\n}\n\n- Changing 'bitSize := 64' to 'const bitSize = 64' causes the whole thing to become\nconstant folded.\n\n- There are three commented-out lines at the end of ssa/interp.visitInstr.  Uncommenting\nthem causes the interpreter to print the result of every instruction.  This can be\nuseful for debugging very tiny programs such as the one above.  I will give your\ninterpreter a try today though.\u003c/pre\u003e\n\n\n_Owner changed to @griesemer._",
	"user": {
		"login": "adonovan",
		"id": 5658175,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-07-08T15:50:22Z",
	"updated_at": "2014-12-22T06:26:29Z"
}
