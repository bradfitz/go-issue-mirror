{
	"id": 163784205,
	"body": "This appears to be fixed (or the error was incorrectly analyzed). For the following program:\r\nhttp://play.golang.org/p/BSaLgO57dT\r\nwe get with cmd/compile (playground and command line):\r\n```\r\n-1.1102230246251565e-16 false\r\n0 true\r\n(1e+30+0i)\r\n1e+30\r\n(1e+30+0i)\r\n```\r\nThe corresponding test case for go/types is (the trace built-in is available for testing only):\r\n```\r\npackage main\r\n\r\nconst (\r\n\te           = 1.0 / (1.0 \u003c\u003c 53)\r\n\ta           = 1.0 + e\r\n\ta64 float64 = 1.0 + e\r\n\r\n\tx = 1e15 / complex64(1e-15)\r\n\ty = 1e15 / 1e-15\r\n\tz = complex64(1e15) / complex64(1e-15)\r\n)\r\n\r\nfunc main() {\r\n\ttrace(1.0-a, a == 1.0)\r\n\ttrace(1.0-a64, a64 == 1.0)\r\n\ttrace(x)\r\n\ttrace(y)\r\n\ttrace(z)\r\n}\r\n```\r\nWith the current go/types (uses big.Rat for constant arithmetic) we get:\r\n```\r\n$ go test -run=Check -files=/Users/gri/tmp/f.go -list\r\nf.go:14:8: 1.0 - a (untyped float constant -1/9007199254740992)\r\nf.go:14:15: a == 1.0 (untyped bool constant false)\r\nf.go:15:8: 1.0 - a64 (constant 0 of type float64)\r\nf.go:15:17: a64 == 1.0 (untyped bool constant true)\r\nf.go:16:8: x (constant 1000000015047466219876688855040 of type complex64)\r\nf.go:17:8: y (untyped float constant 1000000000000000000000000000000)\r\nf.go:18:8: z (constant 1000000015047466219876688855040 of type complex64)\r\n```\r\n-1/9007199254740992 is -1.1102230246251565404236316680908203125 Ã— 10^-16 which is -1.11022e-16 or -2**-53 which is correct (http://www.wolframalpha.com/input/?i=-1%2F9007199254740992).\r\nThe discrepancies for line 16 and 18 are identical and are due to the fact that 1e-15 after truncation to complex64 is actually slightly smaller than 1e-15 resulting in a slightly larger result.\r\n\r\nWith the pending CL https://go-review.googlesource.com/#/c/17360/ (uses big.Float for constant arithmetic):\r\n```\r\n$ go test -run=Check -files=/Users/gri/tmp/f.go -list\r\nf.go:14:8: 1.0 - a (untyped float constant -1.11022e-16)\r\nf.go:14:15: a == 1.0 (untyped bool constant false)\r\nf.go:15:8: 1.0 - a64 (constant 0 of type float64)\r\nf.go:15:17: a64 == 1.0 (untyped bool constant true)\r\nf.go:16:8: x (constant (1e+30 + 0i) of type complex64)\r\nf.go:17:8: y (untyped float constant 1e+30)\r\nf.go:18:8: z (constant (1e+30 + 0i) of type complex64)\r\n```\r\nmatching cmd/compile output exactly.\r\n\r\nOr in other words: The incorrect expression in the error message reported in the beginning of this issue was fixed. The other discrepancies in output are due to the fact that go/types, when based on rational arithmetic, is doing exact (algebraic) math (no rounding). When using go/types based on floating-point arithmetic (doing rounding), we get the same result as cmd/compile.\r\n\r\nClosing as resolved.",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-10T23:21:17Z",
	"updated_at": "2015-12-10T23:21:59Z"
}
