{
	"id": 51286211,
	"number": 7115,
	"state": "closed",
	"title": "cmd/godoc: godoc -src strings HasPrefix prints too much",
	"body": "\u003cpre\u003eExpected output:\n\n$ godoc -src strings HasPrefix\n// HasPrefix tests whether the string s begins with prefix.\nfunc HasPrefix(s, prefix string) bool {\n    return len(s) \u0026gt;= len(prefix) \u0026amp;\u0026amp; s[0:len(prefix)] == prefix\n}\n$\n\nActual output:\n\n$ godoc -src strings HasPrefix\n// HasPrefix tests whether the string s begins with prefix.\nfunc HasPrefix(s, prefix string) bool {\n    return len(s) \u0026gt;= len(prefix) \u0026amp;\u0026amp; s[0:len(prefix)] == prefix\n}\n// HasPrefix tests whether the string s begins with prefix.\nfunc HasPrefix(s, prefix string) bool {\n    return len(s) \u0026gt;= len(prefix) \u0026amp;\u0026amp; s[0:len(prefix)] == prefix\n}\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// A Reader implements the io.Reader, io.ReaderAt, io.Seeker, io.WriterTo,\n// io.ByteScanner, and io.RuneScanner interfaces by reading\n// from a string.\npackage strings\n\n// current reading index\n// index of previous rune; or \u0026lt; 0\n\n// Len returns the number of bytes of the unread portion of the\n// string.\n\n// Seek implements the io.Seeker interface.\n\n// WriteTo implements the io.WriterTo interface.\n\n// NewReader returns a new Reader reading from s.\n// It is similar to bytes.NewBufferString but more efficient and read-only.\n\n// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// A Replacer replaces a list of strings with replacements.\n\n// replacer is the interface that a replacement algorithm needs to implement.\n\n// byteBitmap represents bytes which are sought for replacement.\n// byteBitmap is 256 bits wide, with a bit set for each old byte to be\n// replaced.\n\n// NewReplacer returns a new Replacer from a list of old, new string pairs.\n// Replacements are performed in order, without overlapping matches.\n\n// Later old-\u0026gt;new maps do not override previous ones with the same old string.\n\n// Later old-\u0026gt;new maps do not override previous ones with the same old string.\n\n// Replace returns a copy of s with all replacements performed.\n\n// WriteString writes s to w with all replacements performed.\n\n// trieNode is a node in a lookup trie for prioritized key/value pairs. Keys\n// and values may be empty. For example, the trie containing keys \u0026quot;ax\u0026quot;,\n\u0026quot;ay\u0026quot;,\n// \u0026quot;bcbc\u0026quot;, \u0026quot;x\u0026quot; and \u0026quot;xy\u0026quot; could have eight nodes:\n//\n//  n0  -\n//  n1  a-\n//  n2  .x+\n//  n3  .y+\n//  n4  b-\n//  n5  .cbc+\n//  n6  x+\n//  n7  .y+\n//\n// n0 is the root node, and its children are n1, n4 and n6; n1's children are\n// n2 and n3; n4's child is n5; n6's child is n7. Nodes n0, n1 and n4 (marked\n// with a trailing \u0026quot;-\u0026quot;) are partial keys, and nodes n2, n3, n5, n6 and n7\n// (marked with a trailing \u0026quot;+\u0026quot;) are complete keys.\n\n// value is the value of the trie node's key/value pair. It is empty if\n// this node is not a complete key.\n\n// priority is the priority (higher is more important) of the trie node's\n// key/value pair; keys are not necessarily matched shortest- or longest-\n// first. Priority is positive if this node is a complete key, and zero\n// otherwise. In the example above, positive/zero priorities are marked\n// with a trailing \u0026quot;+\u0026quot; or \u0026quot;-\u0026quot;.\n\n// A trie node may have zero, one or more child nodes:\n//  * if the remaining fields are zero, there are no children.\n//  * if prefix and next are non-zero, there is one child in next.\n//  * if table is non-zero, it defines all the children.\n//\n// Prefixes are preferred over tables when there is one child, but the\n// root node always uses a table for lookup efficiency.\n\n// prefix is the difference in keys between this trie node and the next.\n// In the example above, node n4 has prefix \u0026quot;cbc\u0026quot; and n4's next node is n5.\n// Node n5 has no children and so has zero prefix, next and table fields.\n\n// table is a lookup table indexed by the next byte in the key, after\n// remapping that byte through genericReplacer.mapping to create a dense\n// index. In the example above, the keys only use 'a', 'b', 'c', 'x' and\n// 'y', which remap to 0, 1, 2, 3 and 4. All other bytes remap to 5, and\n// genericReplacer.tableSize will be 5. Node n0's table will be\n// []*trieNode{ 0:n1, 1:n4, 3:n6 }, where the 0, 1 and 3 are the remapped\n// 'a', 'b' and 'x'.\n\n// Need to split the prefix among multiple nodes.\n// length of the longest common prefix\n\n// First byte differs, start a new lookup table here. Looking up\n// what is currently t.prefix[0] will lead to prefixNode, and\n// looking up key[0] will lead to keyNode.\n\n// Insert new node after the common section of the prefix.\n\n// Insert into existing table.\n\n// Iterate down the trie to the end, and grab the value and keylen with\n// the highest priority.\n\n// genericReplacer is the fully generic algorithm.\n// It's used as a fallback when nothing faster can be used.\n\n// tableSize is the size of a trie node's lookup table. It is the number\n// of unique key bytes.\n\n// mapping maps from key bytes to a dense index for trieNode.table.\n\n// Find each byte used, then assign them each an index.\n\n// Ensure root node uses a lookup table (for performance).\n...\n$\u003c/pre\u003e",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		}
	],
	"comments": 4,
	"closed_at": "2014-12-08T10:39:34Z",
	"created_at": "2014-01-13T18:49:06Z",
	"updated_at": "2016-06-25T01:25:32Z",
	"milestone": {
		"id": 1067211,
		"number": 17,
		"title": "Go1.3"
	}
}
