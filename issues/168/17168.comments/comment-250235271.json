{
	"id": 250235271,
	"body": "It seems this issue is due to a change in the way the `_umtx_op` syscall interprets it's arguments.\r\n\r\nThe tl;dr is that due to the way the runtime calls `_umtx_op`, the timeout it specifies is based on `CLOCK_REALTIME` rather than `CLOCK_MONOTONIC`.\r\n\r\nThe relevant FreeBSD commit is [232144](https://svnweb.freebsd.org/base?view=revision\u0026revision=232144), which I think landed in the 10.0.0 release.\r\n\r\nFor reference, this is the prototype for `_umtx_op`. The parameters relevant to this discussion are `uaddr1` and `uaddr2`.\r\n\r\n    int _umtx_op(void *obj, int op, u_long val, void *uaddr1, void *uaddr2);\r\n\r\nAnd here is how we call it from `futexsleep1` in `runtime/os_freebsd.go`:\r\n\r\n    ret := sys_umtx_op(addr, _UMTX_OP_WAIT_UINT_PRIVATE, val, nil, tsp)\r\n\r\nThat is, `uaddr1=nil`, and `uaddr2` is a `timespec` pointer.\r\n\r\nPrior to the above mentioned FreeBSD commit, going back at least as far as release 8.0.0, `_umtx_op` always considered `uaddr2` to be a (possibly NULL) `struct timespec *`. Based on a quick scan of old kernel sources, my understanding is that it used a monotonic timer (`nanouptime(9)`/`getnanouptime(9)`) for timeout calculations, but I didn't verify this with testing.\r\n\r\nAfter revision [232144](https://svnweb.freebsd.org/base?view=revision\u0026revision=232144), the above call will result in `__umtx_op_wait_uint_private` constructing a `struct _umtx_time` with it's `_clockid` set to `CLOCK_REALTIME`. If you want `CLOCK_MONOTONIC`, you must construct your own `struct _umtx_time` and pass it as `uaddr2`, setting `uaddr1` to something larger than `sizeof(struct timespec)`.\r\n\r\nThe relevant listing from `sys/kern/kern_umtx.c`. This function is called from `__umtx_op_wait_uint_private` with `addr=uaddr2` and `size=(size_t)uaddr1`.\r\n\r\n\tstatic inline int\r\n\tumtx_copyin_umtx_time(const void *addr, size_t size, struct _umtx_time *tp)\r\n\t{\r\n\t\t\tint error;\r\n\r\n\t\t\tif (size \u003c= sizeof(struct timespec)) {\r\n\t\t\t\t\ttp-\u003e_clockid = CLOCK_REALTIME;\r\n\t\t\t\t\ttp-\u003e_flags = 0;\r\n\t\t\t\t\terror = copyin(addr, \u0026tp-\u003e_timeout, sizeof(struct timespec));\r\n\t\t\t} else\r\n\t\t\t\t\terror = copyin(addr, tp, sizeof(struct _umtx_time));\r\n\t\t\tif (error != 0)\r\n\t\t\t\t\treturn (error);\r\n\t\t\tif (tp-\u003e_timeout.tv_sec \u003c 0 ||\r\n\t\t\t\ttp-\u003e_timeout.tv_nsec \u003e= 1000000000 || tp-\u003e_timeout.tv_nsec \u003c 0)\r\n\t\t\t\t\treturn (EINVAL);\r\n\t\t\treturn (0);\r\n\t}\r\n\r\nI modified `runtime.futexsleep1` to pass `sys_umtx_op` a `struct _umtx_time *` with `_clockid=CLOCK_MONOTONIC` and verified that this did resolve the issue on FreeBSD 10.3 / amd64.  That is, the timers from OP's test program above continue to fire every 5 seconds even when twiddling the system clock during execution.\r\n\r\nI'm posting this wall of text here rather than mailing a change list because I'm sufficiently ignorant of the golang runtime that making even a small change makes me nervous, especially when it's difficult for me test against the full range of supported FreeBSD versions / architectures. If the maintainers don't mind beating acceptable code out of me via code review, just say the word and I'll mail a CL.\r\n",
	"user": {
		"login": "appleby",
		"id": 86076,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-09-28T17:20:03Z",
	"updated_at": "2016-09-28T17:20:03Z"
}
