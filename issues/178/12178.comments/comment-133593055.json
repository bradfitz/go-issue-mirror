{
	"id": 133593055,
	"body": "So it isn't pretty, but if Go wants to continue using the SHT_NOTE section for .note.go.buildid, the following appears to work:\r\n\r\n```\r\ndiff --git a/src/cmd/go/note_test.go b/src/cmd/go/note_test.go\r\nindex 3d64451..9b7e246 100644\r\n--- a/src/cmd/go/note_test.go\r\n+++ b/src/cmd/go/note_test.go\r\n@@ -33,9 +33,6 @@ func TestNoteReading(t *testing.T) {\r\n \t\t// no external linking\r\n \t\tt.Logf(\"no external linking - skipping linkmode=external test\")\r\n \r\n-\tcase \"solaris\":\r\n-\t\tt.Logf(\"skipping - golang.org/issue/12178\")\r\n-\r\n \tdefault:\r\n \t\ttg.run(\"build\", \"-ldflags\", \"-buildid=\"+buildID+\" -linkmode=external\", \"-o\", tg.path(\"hello.exe\"), tg.path(\"hello.go\"))\r\n \t\tid, err := main.ReadBuildIDFromBinary(tg.path(\"hello.exe\"))\r\ndiff --git a/src/cmd/link/internal/ld/lib.go b/src/cmd/link/internal/ld/lib.go\r\nindex 8ccbec9..79e1b96 100644\r\n--- a/src/cmd/link/internal/ld/lib.go\r\n+++ b/src/cmd/link/internal/ld/lib.go\r\n@@ -1071,6 +1071,35 @@ func hostlink() {\r\n \t\targv = append(argv, peimporteddlls()...)\r\n \t}\r\n \r\n+\tif HEADTYPE == obj.Hsolaris {\r\n+\t\t// Before linking, create a mapfile that directs the Solaris\r\n+\t\t// linker to reassign the .note.go.buildid section to the text\r\n+\t\t// segment so that it remains allocable.\r\n+\t\tp := fmt.Sprintf(\"%s/mapfile\", tmpdir)\r\n+\t\tvar err error\r\n+\t\tf, err := os.OpenFile(p, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)\r\n+\t\tif err != nil {\r\n+\t\t\tExitf(\"cannot create %s: %v\", p, err)\r\n+\t\t}\r\n+\r\n+\t\tb := bufio.NewWriter(f)\r\n+\t\t_, err = b.WriteString(`$mapfile_version 2\r\n+PHDR_ADD_NULL = 1;\r\n+LOAD_SEGMENT text {\r\n+\tASSIGN_SECTION {\r\n+\t\tIS_NAME = .note.go.buildid;\r\n+\t};\r\n+\tOS_ORDER = .note.go.buildid;\r\n+};\r\n+`)\r\n+\t\tif err != nil {\r\n+\t\t\tExitf(\"cannot write to %s: %v\", p, err)\r\n+\t\t}\r\n+\t\tb.Flush()\r\n+\r\n+\t\targv = append(argv, \"-Wl,-M,\" + p)\r\n+\t}\r\n+\r\n \tif Debug['v'] != 0 {\r\n \t\tfmt.Fprintf(\u0026Bso, \"host link:\")\r\n \t\tfor _, v := range argv {\r\n@@ -1087,6 +1116,30 @@ func hostlink() {\r\n \t\tBso.Flush()\r\n \t}\r\n \r\n+\tif HEADTYPE == obj.Hsolaris {\r\n+\t\t// After linking, transform the PT_NULL entry created by\r\n+\t\t// Solaris linker using a mapfile into a PT_NOTE for the\r\n+\t\t// .note.go.buildid section.\r\n+\t\tf, err := elf.Open(outfile)\r\n+\t\tdefer f.Close()\r\n+\t\tif err != nil {\r\n+\t\t\treturn\r\n+\t\t}\r\n+\r\n+\t\tsect := f.Section(\".note.go.buildid\")\r\n+\t\tf.Close()\r\n+\r\n+\t\targv := []string{\"elfedit\", \"-e\", fmt.Sprintf(\"phdr:p_vaddr PT_NULL %d\", sect.Addr), \"-e\", fmt.Sprintf(\"phdr:p_paddr PT_NULL %d\", sect.Addr), \"-e\", fmt.Sprintf(\"phdr:p_offset PT_NULL %d\", sect.Offset), \"-e\", fmt.Sprintf(\"phdr:p_memsz PT_NULL %d\", sect.Size), \"-e\", fmt.Sprintf(\"phdr:p_filesz PT_NULL %d\", sect.Size), \"-e\", fmt.Sprintf(\"phdr:p_align PT_NULL %d\", sect.Addralign), \"-e\", \"phdr:p_type PT_NULL PT_NOTE\", outfile}\r\n+\t\tif out, err := exec.Command(argv[0], argv[1:]...).CombinedOutput(); err != nil {\r\n+\t\t\tExitf(\"running %s failed: %v\\n%s\", argv[0], err, out)\r\n+\t\t}\r\n+\r\n+\t\tif Debug['v'] != 0 {\r\n+\t\t\tfmt.Fprintf(\u0026Bso, \"elfedit: %s\\n\", strings.Join(argv, \" \"))\r\n+\t\t\tBso.Flush()\r\n+\t\t}\r\n+\t}\r\n+\r\n \tif Debug['s'] == 0 \u0026\u0026 debug_s == 0 \u0026\u0026 HEADTYPE == obj.Hdarwin {\r\n \t\t// Skip combining dwarf on arm.\r\n \t\tif Thearch.Thechar != '5' \u0026\u0026 Thearch.Thechar != '7' {\r\n```\r\n\r\nIt accomplishes this by a combination of what I outlined earlier:\r\n * ensure `.note.go.buildid` is placed in text segment via mapfile\r\n * ensure a stub program header is created via mapfile\r\n * after linking, invoke elfedit to transform stub program header into a PT_NOTE and link to .note.go.buildid\r\n\r\n```\r\n$ elfdump hello\r\nProgram Header[4]:\r\n    p_vaddr:      0x400200            p_flags:    0\r\n    p_paddr:      0x400200            p_type:     [ PT_NOTE ]\r\n    p_filesz:     0x38                p_memsz:    0x38\r\n    p_offset:     0x200               p_align:    0x20\r\n...\r\nSection Header[1]:  sh_name: .note.go.buildid\r\n    sh_addr:      0x400200            sh_flags:   [ SHF_ALLOC ]\r\n    sh_size:      0x38                sh_type:    [ SHT_NOTE ]\r\n    sh_offset:    0x200               sh_entsize: 0\r\n    sh_link:      0                   sh_info:    0\r\n    sh_addralign: 0x20              \r\n...\r\n/builds/srwalker/golang/go/pkg/tool/solaris_amd64/link -o $WORK/cmd/go/_test/go.test -L $WORK/cmd/go/_test -L $WORK -w -extld=gcc -buildmode=exe $WORK/cmd/go/_test/main.a\r\n$WORK/cmd/go/_test/go.test -test.v=true -test.run=TestNoteReading\r\n=== RUN   TestNoteReading\r\n--- PASS: TestNoteReading (0.35s)\r\n\tgo_test.go:251: running testgo [build -ldflags -buildid=TestNoteReading-Build-ID -o /tmp/gotest494547271/hello.exe /tmp/gotest494547271/hello.go]\r\n\tgo_test.go:251: running testgo [build -ldflags -buildid=TestNoteReading-Build-ID -linkmode=external -o /tmp/gotest494547271/hello.exe /tmp/gotest494547271/hello.go]\r\nPASS\r\nok  \tcmd/go\t2.886s\r\n...\r\n```\r\n\r\nThe test now passes as expected.  However, I feel like this solution is pretty ugly given the amount of additional platform-specific code I had to add to the linking step.",
	"user": {
		"login": "binarycrusader",
		"id": 541114,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-22T00:02:47Z",
	"updated_at": "2015-08-22T00:02:47Z"
}
