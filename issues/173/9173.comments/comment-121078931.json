{
	"id": 121078931,
	"body": "Don't be misled by the SIGPIPE in the strace output.  Nothing is happening because of that signal.  It is caught and ignored.\r\n\r\nIn the os/exec package, the io.Copy call in Cmd.stdin is returning an EPIPE error.  That is the error being reported by the call to the Wait method.  The name of the write side of the pipe is \"|1\" (from os.Pipe).  The error is an os.PathError generated by os.File.Write, called by io.Copy.\r\n\r\nI think that your suggestion of ignoring an EPIPE error in os/exec.stdin is reasonable.  Cmd.Wait will already only return that error if the program exited successfully.  In that scenario, returning EPIPE conveys little useful information.\r\n\r\nOr, we could document the behaviour.\r\n\r\nMost C programs in this situation will receive the SIGPIPE signal, fail to handle it, and exit.  In a shell pipeline, nothing much will happen, because the shell will use the exit status of the final process in the pipeline.\r\n\r\nIf you do this, using bash:\r\n\r\nset -o pipefail\r\ncat boat.jpg | /usr/bin/djpeg \u003e /dev/null\r\necho $?\r\n\r\nyou will see that the cat program died due to a SIGPIPE signal.\r\n\r\nIf you do this:\r\n\r\ntrap \"\" PIPE\r\ncat boat.jpg | /usr/bin/djpeg \u003e /dev/null\r\n\r\nthen the cat program will not get a SIGPIPE signal, but will instead fail because write returned EPIPE.\r\n\r\ncat: write error: Broken pipe\r\n\r\nAnyhow, the only real question is whether we should return the EPIPE error from os/exec, or just drop it.  Personally I think it would be fine to drop it.  That is the natural implementation of the default behaviour of shell pipelines.",
	"user": {
		"login": "ianlancetaylor",
		"id": 3194333,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-07-13T22:21:49Z",
	"updated_at": "2015-07-13T22:21:49Z"
}
