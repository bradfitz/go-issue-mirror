{
	"id": 125620334,
	"body": "Yes, that is true.  The core reason why is the size class is a useful hint in indicating the size of the individual objects involved in the measurement.  For instance, this is to help differentiate between low volume of large object churn versus high volume of small object churn.\r\n\r\nAs for hiding the implementation details of the runtime, let me offer a few remarks:\r\n\r\n1. Metrics that abstract/hide what the runtime is really doing under the hood are of specious value,\r\n    because it forces the consumers of said metrics to study the runtime in much greater detail than\r\n    the case of just exposing the raw internals bare.  A quick analogy of this from the world of\r\n    Java: MBean and MXBeans ([example package](http://docs.oracle.com/javase/7/docs/api/java/lang/management/package-summary.html)) are the\r\n    training wheels of internal runtime metrics; whereas anyone worth his or her salt uses HSPerfData \r\n    [example](https://github.com/prometheus/client_java/blob/master/utility/jvmstat/src/main/java/io/prometheus/client/utility/jvmstat/JvmstatMonitor.java#L730) because of the level of actionable detail it provides.  At\r\n    the very worst, the Bean metric approach shoehorns implementation-specific details into\r\n    standardized types that either do not make sense or lose needed detail.  Most of this pain occurs\r\n    at runtime when one gets a runtime exception or zero values from a bean that exists as a\r\n    placeholder but has no relevance for the runtime in use.\r\n\r\n    The question I have is this: what happens the moment there are alternative runtimes available for\r\n    Go?  It seems doubtful that each runtime would be able to meaningfully shoehorn its allocator\r\n    metrics into `runtime.MemStats` unless they all use the same paradigms.\r\n\r\n2. The [Go 1.X Stability Grant](https://golang.org/doc/go1compat) makes a lot of sense in general, but\r\n    it may not be well to apply it doctrinally to the runtime package since that one is out of all of the\r\n    packages the most likely to undergo churn behind the scenes.\r\n\r\n3. The domain of runtime is ultimately implementation-specific.  Treating it as less than that is a\r\n    disservice to the user.\r\n\r\nI think there is a middleground; just not sure what it is.\r\n",
	"user": {
		"login": "matttproud",
		"id": 46149,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-07-28T14:01:45Z",
	"updated_at": "2015-07-28T14:01:45Z"
}
