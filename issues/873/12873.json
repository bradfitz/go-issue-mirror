{
	"id": 110322100,
	"number": 12873,
	"state": "closed",
	"title": "runtime: C popen hangs when linked with Go shared library",
	"body": "Hello, Folks!\r\n\r\nI have used dynamic library builded with Go:\r\n```bash\r\ngo build -buildmode=c-shared -o libgobgp.so *.go\r\n```\r\n\r\nAnd I link this dynamic library with my C++ code which uses daemonization and popen system call:\r\n```C\r\n// Call fork function\r\nint do_fork() {\r\n    int status = 0;\r\n\r\n    switch (fork()) {\r\n    case 0:\r\n        // It's child\r\n        break;\r\n    case -1:\r\n        /* fork failed */\r\n        status = -1;\r\n        break;\r\n    default:\r\n        // We should close master process with _exit(0)\r\n        // We should not call exit() because it will destroy all global variables for programm\r\n        _exit(0);\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\nvoid redirect_fds() {\r\n    // Close stdin, stdout and stderr\r\n    close(0);\r\n    close(1);\r\n    close(2);\r\n\r\n    if (open(\"/dev/null\", O_RDWR) != 0) { \r\n        // We can't notify anybody now\r\n        exit(1);\r\n    }    \r\n\r\n    // Create copy of zero decriptor for 1 and 2 fd's\r\n    // We do not need return codes here but we need do it for suppressing complaints from compiler\r\n    int first_dup_result  = dup(0);\r\n    int second_dup_result = dup(0);\r\n}\r\n\r\nstd::vector\u003cstd::string\u003e exec(std::string cmd) {\r\n    std::vector\u003cstd::string\u003e output_list;\r\n\r\n    FILE* pipe = popen(cmd.c_str(), \"r\");\r\n    if (!pipe) return output_list;\r\n\r\n    char buffer[256];\r\n    while (!feof(pipe)) {\r\n        if (fgets(buffer, 256, pipe) != NULL) {\r\n            size_t newbuflen = strlen(buffer);\r\n\r\n            // remove newline at the end\r\n            if (buffer[newbuflen - 1] == '\\n') {\r\n                buffer[newbuflen - 1] = '\\0';\r\n            }    \r\n\r\n            output_list.push_back(buffer);\r\n        }    \r\n    }    \r\n\r\n    pclose(pipe);\r\n    return output_list;\r\n}\r\n\r\nint main () {\r\n    if (daemonize) {\r\n        int status = 0;\r\n\r\n        printf(\"We will run in daemonized mode\\n\");\r\n\r\n        if ((status = do_fork()) \u003c 0) {\r\n            // fork failed\r\n            status = -1;\r\n        } else if (setsid() \u003c 0) {\r\n            // Create new session\r\n            status = -1;\r\n        } else if ((status = do_fork()) \u003c 0) {\r\n            status = -1;\r\n        } else {\r\n            // Clear inherited umask\r\n            umask(0);\r\n\r\n            // Chdir to root\r\n            int chdir_result = chdir(\"/\");\r\n\r\n            // close all descriptors because we are daemon!\r\n            redirect_fds();\r\n        }\r\n    }\r\n \r\n    // this code become zombie\r\n    exec(\"ip link show\");\r\n\r\n    // this code will be never called\r\n    while (true) {\r\n \r\n   }\r\n}\r\n```\r\n\r\nWhen I run my tool in normal non daemon code everything work perfectly.\r\n\r\nBut when I use --daemonize with my toolkit everything become weird and \"/sbin/ip\" become zombie:\r\n```bash\r\n15747 root       20   0  297M 18332 12408 S  0.0  0.1  0:00.00 ├─ ./fastnetmon --daemonize\r\n15748 root       20   0     0     0     0 Z  0.0  0.0  0:00.00 │  └─ sh\r\n\r\ncat /proc/15748/status\r\nName:   sh\r\nState:  Z (zombie)\r\n```\r\n\r\nIn strace I saw:\r\n```bash\r\n[pid 15475] write(1, \"11: eth5: \u003cBROADCAST,MULTICAST,PROMISC,UP,LOWER_UP\u003e mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000\\\\    link/ether a0:36:9f:0c:8d:d6 brd ff:ff:ff:ff:ff:ff\\n\", 171 \u003cunfinished ...\u003e\r\n[pid 15473] \u003c... read resumed\u003e \"10: eth6: \u003cBROADCAST,MULTICAST,PROMISC,UP,LOWER_UP\u003e mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000\\\\    link/ether a0:36:9f:0c:8d:d4 brd ff:ff:ff:ff:ff:ff\\n\", 4096) = 171\r\n[pid 15475] \u003c... write resumed\u003e )       = 171\r\n[pid 15473] read(4,  \u003cunfinished ...\u003e\r\n[pid 15475] exit_group(0)               = ?\r\n[pid 15473] \u003c... read resumed\u003e \"11: eth5: \u003cBROADCAST,MULTICAST,PROMISC,UP,LOWER_UP\u003e mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000\\\\    link/ether a0:36:9f:0c:8d:d6 brd ff:ff:ff:ff:ff:ff\\n\", 4096) = 171\r\n[pid 15473] read(4,  \u003cunfinished ...\u003e\r\n[pid 15475] +++ exited with 0 +++\r\n[pid 15474] \u003c... wait4 resumed\u003e [{WIFEXITED(s) \u0026\u0026 WEXITSTATUS(s) == 0}], 0, NULL) = 15475\r\n[pid 15474] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=15475, si_uid=0, si_status=0, si_utime=0, si_stime=0} ---\r\n[pid 15474] rt_sigreturn()              = 15475\r\n[pid 15474] exit_group(0)               = ?\r\n[pid 15474] +++ exited with 0 +++\r\n\u003c... read resumed\u003e \"\", 4096)            = 0\r\n--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=15474, si_uid=0, si_status=0, si_utime=0, si_stime=0} ---\r\nrt_sigprocmask(SIG_SETMASK, NULL, ~[KILL STOP], 8) = 0\r\nsigaltstack({ss_sp=0xc820032000, ss_flags=0, ss_size=32672}, NULL) = 0\r\ngettid()                                = 15473\r\nrt_sigprocmask(SIG_SETMASK, ~[ILL TRAP BUS FPE KILL SEGV STKFLT CHLD STOP PROF], NULL, 8) = 0\r\nfutex(0xc820030110, FUTEX_WAIT, 0, NULL\r\n```\r\n\r\nI have found so much signal reconfigurations from Go's runtime side and assume this problems related with Go runtime itself. And we have got conflict between Golang's signal handlers and popen's SIGCHILD signal call.\r\n\r\nDo you have any workaround for this case?\r\n",
	"user": {
		"login": "pavel-odintsov",
		"id": 2744166,
		"type": "User",
		"site_admin": false
	},
	"comments": 15,
	"closed_at": "2015-11-05T16:56:19Z",
	"created_at": "2015-10-07T21:33:20Z",
	"updated_at": "2015-11-05T16:56:19Z",
	"milestone": {
		"id": 1096159,
		"number": 24,
		"title": "Go1.6"
	}
}
