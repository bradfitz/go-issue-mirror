{
	"id": 67928194,
	"body": "That sounds like a reasonable plan to me.\r\nI curious about whether we need to do anything for chan struct{}.  I don't\r\nthink we actually materialize a pointer to the struct elements in this\r\ncase, but I'm not sure.  I think we set the elem pointer to point back to\r\nthe channel header.\r\n\r\nOn Mon, Dec 22, 2014 at 10:06 PM, Russ Cox \u003cnotifications@github.com\u003e wrote:\r\n\u003e\r\n\u003e It seems like there are two options.\r\n\u003e\r\n\u003e    1. Fix the code manipulating the struct memory never to point past the\r\n\u003e    end.\r\n\u003e    2. Add more memory to the struct so that all the existing manipulation\r\n\u003e    code becomes correct.\r\n\u003e\r\n\u003e I believe that since zero-size types are excluded from the problem, we've\r\n\u003e narrowed the problem to very rare cases. The best solution is probably the\r\n\u003e one that introduces the fewest new corner cases where bugs can hide. There\r\n\u003e are many fewer places that decide struct layout and allocation than there\r\n\u003e are things that walk structs, which means we should favor choice 2.\r\n\u003e (Another point in favor of choice 2: choice 1 may require changes to code\r\n\u003e we don't even control; what if something like goprotobuf broke these rules?)\r\n\u003e\r\n\u003e In #9384 \u003chttps://github.com/golang/go/issues/9384\u003e, Keith proposed a new\r\n\u003e type flag to indicate that the memory footprint ends in a zero-length\r\n\u003e field, so that allocation would add just a little more room after that.\r\n\u003e That would probably work, but given the previous argument, I think that's\r\n\u003e more subtle than this problem warrants. I want something that's dead\r\n\u003e simple. I worry that if new(T) sometimes (but almost never) allocates \u003e\r\n\u003e T.size bytes, that will create a space for bugs.\r\n\u003e\r\n\u003e I propose the dumber solution that if a non-zero-sized struct ends in a\r\n\u003e zero-length field, we add 1 byte of padding to end of the struct before\r\n\u003e aligning the final struct size. That is, given:\r\n\u003e\r\n\u003e type T1 struct {\r\n\u003e     X byte\r\n\u003e     Y [0]byte\r\n\u003e }\r\n\u003e\r\n\u003e type T2 struct {\r\n\u003e     X uint32\r\n\u003e     Y struct{}\r\n\u003e }\r\n\u003e\r\n\u003e T1 would have size 2 (= 1 + 0 + 1) and T2 would have size 8 (= 4 + 0 + 1 +\r\n\u003e padding to 4-byte alignment for field X).\r\n\u003e\r\n\u003e In cases where this padding is a problem, it can be avoided by manual\r\n\u003e rearrangement or removal of the zero-length fields, as Keith did in the fix\r\n\u003e for #9384 \u003chttps://github.com/golang/go/issues/9384\u003e.\r\n\u003e\r\n\u003e I think all the things making structs at runtime have to build gcProgs,\r\n\u003e and there are only two mentions of gcProg in package reflect: bucketOf and\r\n\u003e funcLayout. bucketOf is already fixed. funcLayout could just add regSize to\r\n\u003e the total size any time the total size is not 0. This would also make safe\r\n\u003e the use of frame+retOffset when functions have arguments but no results.\r\n\u003e\r\n\u003e â€”\r\n\u003e Reply to this email directly or view it on GitHub\r\n\u003e \u003chttps://github.com/golang/go/issues/9401#issuecomment-67924608\u003e.\r\n\u003e",
	"user": {
		"login": "randall77",
		"id": 6889504,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-12-23T07:42:16Z",
	"updated_at": "2014-12-23T07:42:16Z"
}
