{
	"id": 164901033,
	"body": "Second round of comment-begging:\r\nI've been trying to ensure coverage of all the escape \"reasons\" and I've noticed that there are places where the line numbers/logic gets a hair flaky.\r\nI'm going to propose that this be conditional on \"-m -m\" for two reasons:\r\n 1. it looks like it might be flaky for a while and want tweaking and refinement.\r\n 2. the testing burden of correcting everything that expects output for a simple \"-m\"\r\n     and of maintaining that over time as the output is improved.\r\n\r\nI'm experimentally trying it right now with a \"#\" prefix and a modified run.go:\r\n\r\n```\r\n# command-line-arguments\r\n./escpath.go:16: (*pair).EqualParts p does not escape\r\n./escpath.go:22: a escapes to heap\r\n# \tfrom a at line 22 because assigned to top level variable\r\n./escpath.go:20: leaking param: p\r\n# \tfrom [3]*int literal at line 21 because array literal element\r\n# \tfrom a at line 21 because assigned\r\n# \tfrom a at line 22 because interface-converted\r\n# \tfrom a at line 22 because assigned to top level variable\r\n./escpath.go:30: \u0026u escapes to heap\r\n# \tfrom \u0026u at line 30 because assigned to top level variable\r\n./escpath.go:29: moved to heap: u\r\n./escpath.go:30: \u0026u escapes to heap\r\n# \tfrom \u0026u at line 30 because interface-converted\r\n# \tfrom \u0026u at line 30 because assigned to top level variable\r\n./escpath.go:26: leaking param: q\r\n# \tfrom s at line 27 because assigned\r\n# \tfrom pair literal at line 28 because struct literal element\r\n# \tfrom t at line 28 because assigned\r\n# \tfrom u at line 29 because assigned\r\n# \tfrom \u0026u at line 30 because address-of\r\n# \tfrom \u0026u at line 30 because interface-converted\r\n# \tfrom \u0026u at line 30 because assigned to top level variable\r\n./escpath.go:35: c escapes to heap\r\n# \tfrom c at line 35 because return\r\n./escpath.go:33: leaking param: r to result ~r1 level=-1\r\n# \tfrom []*int literal at line 34 because slice-literal-element\r\n# \tfrom c at line 34 because assigned\r\n# \tfrom c at line 35 because interface-converted\r\n# \tfrom c at line 35 because return\r\n./escpath.go:34: []*int literal escapes to heap\r\n# \tfrom c at line 34 because assigned\r\n# \tfrom c at line 35 because interface-converted\r\n# \tfrom c at line 35 because return\r\n./escpath.go:38: leaking param: a\r\n# \tfrom a at line 38 because appended to slice\r\n./escpath.go:38: leaking param content: s\r\n# \tfrom *s at line 38 because indirection\r\n# \tfrom *s at line 38 because appendee slice\r\n./escpath.go:43: leaking param content: s2\r\n# \tfrom *s2 at line 43 because indirection\r\n# \tfrom *s2 at line 43 because appended slice...\r\n./escpath.go:43: leaking param content: s1\r\n# \tfrom *s1 at line 43 because indirection\r\n# \tfrom *s1 at line 43 because appendee slice\r\n./escpath.go:48: f6 x does not escape\r\n./escpath.go:48: f6 y does not escape\r\n./escpath.go:50: f6 \u0026p does not escape\r\n./escpath.go:50: f6 \u0026p does not escape\r\n\u003cautogenerated\u003e:1: leaking param: .this\r\n# \tfrom .this at line 113 because receiver in indirect call\r\n```\r\n\r\n```\r\npackage main\r\n\r\nfunc main() {\r\n}\r\n\r\nvar sink interface{}\r\n\r\ntype pair struct {\r\n\tx, y *int\r\n}\r\n\r\ntype Pairy interface {\r\n\tEqualParts() bool\r\n}\r\n\r\nfunc (p *pair) EqualParts() bool {\r\n\treturn p != nil \u0026\u0026 (p.x == p.y || *p.x == *p.y)\r\n}\r\n\r\nfunc f1(p *int) { // ERROR  \"array literal element\" \"assign\" \"interface-converted\" \"assigned to top level variable\"\r\n\ta := [3]*int{p, nil, nil}\r\n\tsink = a\r\n\r\n}\r\n\r\nfunc f2(q *int) { // ERROR \"struct literal element\" \"interface-converted\" \"assigned to top level variable\" \"address of\"\r\n\ts := q\r\n\tt := pair{s, nil}\r\n\tu := t\r\n\tsink = \u0026u // ERROR \"interface-converted\" \"assigned to top level variable\"\r\n}\r\n\r\nfunc f3(r *int) interface{} { // ERROR \"slice-literal-element\" \"interface-converted\" \"assign\" \"return\"\r\n\tc := []*int{r} // ERROR \"interface-converted\" \"assign\" \"return\"\r\n\treturn c       // \"return\"\r\n}\r\n\r\nfunc f4(a *int, s []*int) int {\r\n\ts = append(s, a)\r\n\treturn *(s[0])\r\n}\r\n\r\nfunc f5(s1, s2 []*int) int {\r\n\ts1 = append(s1, s2...)\r\n\treturn *(s1[0])\r\n}\r\n\r\nfunc f6(x, y *int) bool {\r\n\tp := pair{x, y}\r\n\tvar P Pairy = \u0026p\r\n\tpp := P.(*pair)\r\n\treturn pp.EqualParts()\r\n}\r\n```\r\nHere's my list of \"reasons\" for things to escape, first the ones for which I got coverage:\r\n```\r\n//    \"appended slice...\"\r\n//    \"appended to slice\"\r\n//    \"appendee slice\"\r\n//    \"arg to ...\"\r\n//    \"arg to recursive call\"\r\n//    \"array literal element\"\r\n//    \"array-element-equals\"\r\n//    \"assign-pair\"\r\n//    \"assign-pair-dot-type\"\r\n//    \"assign-pair-func-call\"\r\n//    \"call part \\(?\\)\"\r\n//    \"captured by a closure\"\r\n//    \"closure-var\"\r\n//    \"converted\"\r\n//    \"copied slice\"\r\n//    \"dot of pointer\"\r\n//    \"dot\"\r\n//    \"dot-equals\"\r\n//    \"fixed-array-index-of\"\r\n//    \"go func ...\"\r\n//    \"go func arg\"\r\n//    \"go func\"\r\n//    \"indexmap\"\r\n//    \"indexmap-right\"\r\n//    \"indirection\"\r\n//    \"interface-converted\"\r\n//    \"map literal key\"\r\n//    \"map literal value\"\r\n//    \"parameter to indirect call\"\r\n//    \"passed to function[content escapes]\"\r\n//    \"passed to function[unknown]\"\r\n//    \"passed-to-and-returned-from-function\"\r\n//    \"pointer literal\" (flood)\r\n//    \"range\"\r\n//    \"range-deref\"\r\n//    \"receiver in indirect call\"\r\n//    \"return\"\r\n//    \"Returned from recursive function\"\r\n//    \"send\"\r\n//    \"slice\"\r\n//    \"slice-element-equals\"\r\n//    \"slice-literal-element\"\r\n//    \"star-dot-equals\"\r\n//    \"star-equals\"\r\n//    \"switch case\"\r\n//    \"too large for stack\"\r\n```\r\nand then those that I could not\r\n```\r\n//  \"... arg to recursive call\"\r\n//  \"append-first-arg\"\r\n//  \"assign-pair-mapr\"\r\n//  \"assign-pair-receive\"\r\n//  \"call receiver\"\r\n//  \"map index\"\r\n//  \"panic\"\r\n//  \"pointer literal\" (assign)\r\n//  \"returned from recursive function\"\r\n//  \"slice literal element\"\r\n```\r\n",
	"user": {
		"login": "dr2chase",
		"id": 1928999,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-15T21:23:58Z",
	"updated_at": "2015-12-15T21:23:58Z"
}
