{
	"id": 164499415,
	"body": "I have a first result, I think it would be good to get feedback on the output format.  I did it this way so I could read it and fix it.\r\nTest program:\r\n```\r\npackage main\r\n\r\nfunc main() {\r\n}\r\n\r\nvar sink interface{}\r\n\r\ntype pair struct {\r\n\tx, y *int\r\n}\r\n\r\nfunc f(p, q, r *int) interface{} {\r\n\ta := [3]*int{p, nil, nil}\r\n\tsink = a\r\n\r\n\ts := q\r\n\tt := pair{s, nil}\r\n\tu := t\r\n\tsink = \u0026u\r\n\r\n\tc := []*int{r}\r\n\treturn c\r\n}\r\n```\r\nOutput:\r\n```\r\n./escpath.go:3: can inline main\r\n./escpath.go:12: can inline f\r\n./escpath.go:14: a escapes to heap\r\n./escpath.go:14: \tfrom a at 14 because assigned to top level variable\r\n./escpath.go:12: leaking param: p\r\n./escpath.go:12: \tfrom [3]*int literal at 13 because array/slice literal element\r\n./escpath.go:12: \tfrom a at 13 because assign\r\n./escpath.go:12: \tfrom a at 14 because interface-converted\r\n./escpath.go:12: \tfrom a at 14 because assigned to top level variable\r\n./escpath.go:19: \u0026u escapes to heap\r\n./escpath.go:19: \tfrom \u0026u at 19 because assigned to top level variable\r\n./escpath.go:18: moved to heap: u\r\n./escpath.go:19: \u0026u escapes to heap\r\n./escpath.go:19: \tfrom \u0026u at 19 because interface-converted\r\n./escpath.go:19: \tfrom \u0026u at 19 because assigned to top level variable\r\n./escpath.go:12: leaking param: q\r\n./escpath.go:12: \tfrom s at 16 because assign\r\n./escpath.go:12: \tfrom pair literal at 17 because struct literal element\r\n./escpath.go:12: \tfrom t at 17 because assign\r\n./escpath.go:12: \tfrom u at 18 because assign\r\n./escpath.go:12: \tfrom \u0026u at 19 because ptrlit/oaddr\r\n./escpath.go:12: \tfrom \u0026u at 19 because interface-converted\r\n./escpath.go:12: \tfrom \u0026u at 19 because assigned to top level variable\r\n./escpath.go:22: c escapes to heap\r\n./escpath.go:22: \tfrom c at 22 because return\r\n./escpath.go:12: leaking param: r to result ~r3 level=-1\r\n./escpath.go:12: \tfrom []*int literal at 21 because slice-literal-element\r\n./escpath.go:12: \tfrom c at 21 because assign\r\n./escpath.go:12: \tfrom c at 22 because interface-converted\r\n./escpath.go:12: \tfrom c at 22 because return\r\n./escpath.go:21: []*int literal escapes to heap\r\n./escpath.go:21: \tfrom c at 21 because assign\r\n./escpath.go:21: \tfrom c at 22 because interface-converted\r\n./escpath.go:21: \tfrom c at 22 because return\r\n```\r\nI have the following opinions:\r\n 1. putting this all on a single line would make it harder to read.\r\n 2. putting this all on a single line would make it easier for automated tools.\r\n 3. we should require -gcflags '-m -m' to see the extra detail; that leaves the automated tools undisturbed (and I'll need to move all the debugging numbers up by one to make room).\r\n 4. the \"because\" data should be tweaked to ensure that it gives some guidance into the escape analysis reasoning; for example \"slice-literal-element' helps imply that elements of slice literals follow the slice, but this may not always be true.\r\n 5. The current analysis manages to lose the target \"top level variable\" name which seems unfortunate.\r\n 6. I'm going to need to write test cases that get every \"because\" (aka \"why\" in the source code).\r\n\r\nAny comment on these opinions?  I'll use that to refine, then create a CL.\r\n\r\n@paranoiacblack @rsc \r\n",
	"user": {
		"login": "dr2chase",
		"id": 1928999,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-14T17:16:30Z",
	"updated_at": "2015-12-14T17:16:30Z"
}
