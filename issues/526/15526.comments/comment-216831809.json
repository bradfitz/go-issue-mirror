{
	"id": 216831809,
	"body": "Update:\r\n\r\nFollowed josharian's guidance (with several variations) and found an improved outcome. Still of course paying the one bounds check, but not more. **I accept that there is a way to program around the issue, so the proposal's advantage now is mostly about clarity of expression.** (See comments in the example below)\r\n\r\n$ go test -bench=RichardsTwoWayIterative\r\nBenchmarkRichardsTwoWayIterative04-8   \t50000000\t        32.3 ns/op\r\nBenchmarkRichardsTwoWayIterative05-8   \t20000000\t        74.4 ns/op\r\nBenchmarkRichardsTwoWayIterative06-8   \t10000000\t       211 ns/op\r\nBenchmarkRichardsTwoWayIterative07-8   \t 2000000\t       748 ns/op\r\nBenchmarkRichardsTwoWayIterative08-8   \t  500000\t      2778 ns/op\r\nBenchmarkRichardsTwoWayIterative09-8   \t  100000\t     15425 ns/op\r\nBenchmarkRichardsTwoWayIterative10-8   \t   10000\t    102282 ns/op\r\nBenchmarkRichardsTwoWayIterative11-8   \t    3000\t    493416 ns/op\r\nBenchmarkRichardsTwoWayIterative12-8   \t     500\t   2567382 ns/op\r\nBenchmarkRichardsTwoWayIterative13-8   \t     100\t  14133869 ns/op\r\nBenchmarkRichardsTwoWayIterative14-8   \t      20\t  82740477 ns/op\r\nBenchmarkRichardsTwoWayIterative15-8   \t       2\t 562817334 ns/op\r\nBenchmarkRichardsTwoWayIterative16-8   \t       1\t3404951675 ns/op\r\nPASS\r\nok  \tqueen\t24.209s\r\n$ go test -bench=RichardsTwoWayIterative -gcflags=-B\r\nBenchmarkRichardsTwoWayIterative04-8   \t50000000\t        30.7 ns/op\r\nBenchmarkRichardsTwoWayIterative05-8   \t20000000\t        67.3 ns/op\r\nBenchmarkRichardsTwoWayIterative06-8   \t10000000\t       193 ns/op\r\nBenchmarkRichardsTwoWayIterative07-8   \t 2000000\t       643 ns/op\r\nBenchmarkRichardsTwoWayIterative08-8   \t  500000\t      2550 ns/op\r\nBenchmarkRichardsTwoWayIterative09-8   \t  100000\t     14659 ns/op\r\nBenchmarkRichardsTwoWayIterative10-8   \t   20000\t     91065 ns/op\r\nBenchmarkRichardsTwoWayIterative11-8   \t    3000\t    458559 ns/op\r\nBenchmarkRichardsTwoWayIterative12-8   \t     500\t   2373090 ns/op\r\nBenchmarkRichardsTwoWayIterative13-8   \t     100\t  13105999 ns/op\r\nBenchmarkRichardsTwoWayIterative14-8   \t      20\t  76434452 ns/op\r\nBenchmarkRichardsTwoWayIterative15-8   \t       3\t 477616045 ns/op\r\nBenchmarkRichardsTwoWayIterative16-8   \t       1\t3162263098 ns/op\r\nPASS\r\nok  \tqueen\t25.485s\r\n\r\nRobert: \r\n\r\nPush and append are the same...the \"extract\" is all that is added in that case with names meant to suggest that append/extract == push/pop. Sorry for confusion on that point.\r\n\r\nSample code is always available. It was in the email I sent to Rob that lead to this proposal! ;-) Here is a simple example:\r\n\r\n    func richardsTwoWayIterative(n int) (count int) {\r\n    \tvar c, l, r, p int\r\n    \t// var cc, ll, rr, pp [MaxN]int\r\n    \tvar stack [4 * MaxN]int\r\n    \r\n    \tfor q0 := 0; q0 \u003c n-2; q0++ {\r\n    \t\tfor q1 := q0 + 2; q1 \u003c n; q1++ {\r\n    \t\t\tbit0 := 1 \u003c\u003c uint(q0)\r\n    \t\t\tbit1 := 1 \u003c\u003c uint(q1)\r\n    \t\t\tc = bit0 | bit1 | (-1 \u003c\u003c uint(n))\r\n    \t\t\tl = ((bit0 \u003c\u003c 1) | bit1) \u003c\u003c 1\r\n    \t\t\tr = ((bit0 \u003e\u003e 1) | bit1) \u003e\u003e 1\r\n    \t\t\tp = ^(l | c | r)\r\n    \r\n    \t\t\td := 4\r\n    \t\t\tfor d \u003e= 4 {\r\n    \t\t\t\tfor p != 0 {\r\n    \t\t\t\t\tlsb := p \u0026 -p\r\n    \t\t\t\t\tp ^= lsb\r\n    \t\t\t\t\tnc := c | lsb\r\n    \t\t\t\t\tif nc == -1 {\r\n    \t\t\t\t\t\tcount++\r\n    \t\t\t\t\t} else {\r\n    \t\t\t\t\t\tnl := (l | lsb) \u003c\u003c 1\r\n    \t\t\t\t\t\tnr := (r | lsb) \u003e\u003e 1\r\n    \t\t\t\t\t\tnp := ^(nl | nc | nr)\r\n    \t\t\t\t\t\tif np != 0 {\r\n    \t\t\t\t\t\t\tif p != 0 {\r\n    \t\t\t\t\t\t\t\t// STACK(slice) = c, l, r, p // https://github.com/golang/go/issues/15526\r\n    \r\n    \t\t\t\t\t\t\t\t// cc[d], ll[d], rr[d], pp[d] = c, l, r, p\r\n    \t\t\t\t\t\t\t\t// d++\r\n    \r\n    \t\t\t\t\t\t\t\t// _ = stack[d+3]\r\n    \t\t\t\t\t\t\t\tstack[d+3] = p\r\n    \t\t\t\t\t\t\t\tstack[d] = c\r\n    \t\t\t\t\t\t\t\tstack[d+1] = l\r\n    \t\t\t\t\t\t\t\tstack[d+2] = r\r\n    \t\t\t\t\t\t\t\td += 4\r\n    \r\n    \t\t\t\t\t\t\t\t// s := stack[d : d+4]\r\n    \t\t\t\t\t\t\t\t// s[0], s[1], s[2], s[3] = c, l, r, p\r\n    \t\t\t\t\t\t\t\t// d += 4\r\n    \t\t\t\t\t\t\t}\r\n    \t\t\t\t\t\t\tc, l, r, p = nc, nl, nr, np\r\n    \t\t\t\t\t\t}\r\n    \t\t\t\t\t}\r\n    \t\t\t\t}\r\n    \r\n    \t\t\t\t// c, l, r, p = STACK(slice) // https://github.com/golang/go/issues/15526\r\n    \r\n    \t\t\t\t// d--\r\n    \t\t\t\t// c, l, r, p = cc[d], ll[d], rr[d], pp[d]\r\n    \r\n    \t\t\t\t// _ = stack[d-4]\r\n    \t\t\t\tc = stack[d-4]\r\n    \t\t\t\tp = stack[d-1]\r\n    \t\t\t\tr = stack[d-2]\r\n    \t\t\t\tl = stack[d-3]\r\n    \t\t\t\td -= 4\r\n    \r\n    \t\t\t\t// s := stack[d-4 : d]\r\n    \t\t\t\t// c, l, r, p = s[0], s[1], s[2], s[3]\r\n    \t\t\t\t// d -= 4\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \r\n    \t// double result due to 2-way horizontal symmetry\r\n    \tcount \u003c\u003c= 1\r\n    \treturn\r\n    }",
	"user": {
		"login": "MichaelTJones",
		"id": 7877285,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-05-04T11:18:35Z",
	"updated_at": "2016-05-04T11:18:35Z"
}
