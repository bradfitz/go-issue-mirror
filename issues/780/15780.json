{
	"id": 156071763,
	"number": 15780,
	"state": "open",
	"title": "cmd/compile: recognize continuous runs in switch cases",
	"body": "```go\r\npackage src\r\n\r\nfunc small(i int) bool {\r\n\tswitch i {\r\n\tcase 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15: // 9 is only small on a hot day\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc small2(i int) bool {\r\n\tswitch {\r\n\tcase 0 \u003c= i \u0026\u0026 i \u003c= 8, 10 \u003c= i \u0026\u0026 i \u003c= 15:\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n```\r\n\r\nWe should compile small to the same code as small2. Instead, we handle each of the cases independently:\r\n\r\n```\r\n\"\".small t=1 size=112 args=0x10 locals=0x0\r\n\"\".small2 t=1 size=48 args=0x10 locals=0x0\r\n```\r\n\r\nWorse, we end up paying a significant cost in the SSA backend juggling all the branches and blocks generated by the frontend.\r\n\r\nThis sounds theoretical, but I keep encountering large switch statements in functions with bad compile times, and I have seen a bunch of contiguous runs. Here's an excerpted example from cmd/vendor/golang.org/x/arch/x86/x86asm:\r\n\r\n```go\r\nfunc gnuArg(inst *Inst, x Arg, usedPrefixes *bool) string {\r\n// ...\r\n\t\tswitch inst.Op {\r\n\t\tcase CVTSI2SS, CVTSI2SD, CVTSS2SI, CVTSD2SI, CVTTSD2SI, CVTTSS2SI:\r\n\t\t\tif inst.DataSize == 16 \u0026\u0026 EAX \u003c= x \u0026\u0026 x \u003c= R15L {\r\n\t\t\t\tx -= EAX - AX\r\n\t\t\t}\r\n// ...\r\n```\r\n\r\nThose constants all happen to be next to each other.\r\n",
	"user": {
		"login": "josharian",
		"id": 67496,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "Performance"
		},
		{
			"name": "ToolSpeed"
		}
	],
	"assignee": {
		"login": "josharian",
		"id": 67496,
		"type": "User",
		"site_admin": false
	},
	"comments": 9,
	"created_at": "2016-05-21T00:03:51Z",
	"updated_at": "2016-05-28T00:38:05Z",
	"milestone": {
		"id": 1055141,
		"number": 6,
		"title": "Unplanned"
	},
	"reactions": {
		"total_count": 1,
		"+1": 1
	}
}
