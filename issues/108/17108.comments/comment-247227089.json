{
	"id": 247227089,
	"body": "I played with this a bit and I have a prototype that could work. Observations: Passing an address to a field is problematic: Many fields that we are interested in are (ast.)Expr, Stmt, and Decl fields, which are interfaces. To \"unpack\" them we have to type-switch on the address, then deref the address and then type-switch again on the contents; thus requiring two type switches. Here's a better approach: If we have the parent, field name (or field index), plus slice index if needed, we have all that is necessary because we can use reflect to set a field with this information. Changing/rewriting fields is (probably) much less common then reading (traversing) the tree, thus the more costly set field operation is ok. In turn, the API can be closer to Walk and thus easier to use:\r\n```\r\n// An ApplyFunc is invoked by Apply for each node n, before and/or after\r\n// the node's children. See Apply for the interpretation of the return\r\n// value.\r\n//\r\n// The parent, name, and index field are used to identify the parent\r\n// node's field containing n. If the field is a list, index identifies\r\n// the node's position in that list; index is \u003c 0 otherwise. Roughly:\r\n//\r\n//   n == parent.name         if index \u003c 0\r\n//   n == parent.name[index]  if index \u003e= 0\r\n//\r\n// This information can be used to update/rewrite a node with SetField.\r\n//\r\n// Exception: If the parent is a *Package, and Apply is iterating\r\n// through the Files map, name is the filename, and index is -1.\r\ntype ApplyFunc func(parent Node, name string, index int, n Node) bool\r\n\r\n// Apply traverses a syntax tree recursively, starting with the node\r\n// identified by parent, name, index, and n. See Apply for the meaning\r\n// of these arguments.\r\n//\r\n// If pre is not nil, it is called for each node before its children\r\n// are traversed (pre-order). If the result of calling pre is false,\r\n// no children are traversed, and post is not called for the node.\r\n//\r\n// If post is not nil, it is called for each node after its children\r\n// were traversed (post-order). If the result of calling post is false,\r\n// traversal is terminated and Apply returns immediately.\r\n//\r\n// Only fields that refer to AST nodes are considered children.\r\n// Children are traversed in the order in which they appear in the\r\n// respective node's struct definition.\r\nfunc Apply(parent Node, name string, index int, n Node, pre, post ApplyFunc)\r\n\r\n// SetField sets the named field in the parent node to n. If the field\r\n// is a slice, index is the slice index. The named field must exist in\r\n// the parent, n must be assignable to that field, and the field must be\r\n// indexable if index \u003e= 0. Roughly:\r\n//\r\n//   parent.name        = n  if index \u003c 0\r\n//   parent.name[index] = n  if index \u003e= 0\r\n//\r\n// The parent node may be a pointer to the struct containing the named\r\n// field, or it may be the struct itself.\r\n//\r\n// Exception: If the parent is a Package, n must be a *File and name is\r\n// interpreted as the filename in the Package.Files map.\r\nfunc SetField(parent Node, name string, index int, n Node)\r\n```\r\nOpen questions:\r\n1) Should Apply require parent, name, and index (which often will be nil, \"\", -1) so that even the top-level node can be rewritten, or should that require a special case and in return a simpler Apply that just requires, the starting node n, pre, and post?\r\n\r\n2) Should field addressing happen via a name (string), which is nice to read but more expensive than say just the field index as provided by reflect)?\r\n",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-09-15T03:51:06Z",
	"updated_at": "2016-09-15T03:51:06Z"
}
