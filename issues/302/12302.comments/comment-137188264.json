{
	"id": 137188264,
	"body": "@peterbourgon those are projects that have adopted the scheme. That's great, but by code I meant a tool that makes use of the fact that versions follow a standard. For example, a scraper that shows Go projects and lets you browse them by version. Or a debian package builder. Or a vendoring tool that makes use of versions. There surely must be tools to write, otherwise why have a standard?\r\n\r\nBy analogy, the GOPATH layout came with the go tool that makes use of it. There was plenty of code in that layout already (the stdlib) that informed it. It could have started with http://golang.org/doc/code.html, then with projects slowly reorganizing their Makefiles, then someone writing the go tool. I think it's reasonable to say that would have been a harder sell. And it feels like that's what's happening here.\r\n\r\nAs I said very early in this thread, I think this is probably a fine idea. But there are a lot of qualifiers in there. \"I think\", \"probably'. You could get rid of those by writing tools that use versions first.",
	"user": {
		"login": "crawshaw",
		"id": 161319,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-09-02T17:50:41Z",
	"updated_at": "2015-09-02T17:51:15Z"
}
