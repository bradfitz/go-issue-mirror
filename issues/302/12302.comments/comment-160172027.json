{
	"id": 160172027,
	"body": "@davecheney \r\n\u003e Your major objection to the semver standard is a lack of clarity over how version numbers are chosen.\r\n\r\nNot really. My major objection is about the whole idea of defining \"breakage\" and \"compatibility\" in terms of an API in isolation, i.e. about the \"semantic\" part in \"SemVer\". I see the usefulness of versions to give human readable names to releases, I also acknowledge that it is useful to imply a total ordering on versions. But if you want to assign semantic meaning apart from that to a version, you would either a) have potentially false version-matches, e.g. I require 1.7.0 or above and 1.8.0 breaks me because the author considered a change-non-breaking but there is no such thing in go or b) have probable false version-mismatches, e.g. I require version 1.0 or above, the author did a minor change in the API that broke nothing in practice, but to avoid a) they chose to increment to version 2.0 which is assumed to break me as the major version increased.\r\n\r\nI think it's hard to reconcile any SemVer-equivalent versioning scheme with these concerns, while a purely chronological versioning scheme (e.g. every release increments a counter) that isn't used to make semantic deductions could.\r\n\r\nAs such, a tool to help in determining the next version number can't really ameliorate my concerns. In fact, the mentioned blog posts and my position towards SemVer is born out of me trying to write exactly this tool about half a year ago. I realized half-way through that there is no useful (read: prevents breakages but does not restrict language use too much) notion of compatibility for go.\r\n\r\nSo I maintain my position that the best way would be to at least not use semantic versions, but treat release-tags as convenience identifiers that have no meaning apart from that (and possibly a purely chronological ordering). I don't think that versions are the correct way to tackle the compatibility problem, but that this should rather be done by better tooling and conventions to work around that and actually look at the code that uses an API, instead of the API itself. A set of tools that helps you to choose the correct version to install and package based on the actual API and the code of the actual users of that API, instead of some ultimately heuristic number assigned to it.\r\n\r\n@perillo Thanks for your comments :) I have read the compatibility guarantee extensively, but I don't think it is a sufficient definition, because a) most community members I have talked to so far consider things that break this guarantee to be non-breaking and b) even the go stdlib constantly breaks it, if you are being precise. I see the go 1 compatibility guarantee more as a statement of intent then an actual definition of what compatibility means (and to be clear: That's still *far* better than anything else I've seen for other languages). I recommend reading the blog post I linked to earlier on why I think this needs more spelling out.\r\n\r\n\u003e Also note that SemVer has nothing to do with this problem.\r\n\r\nI respectfully disagree. It has everything to do with this problem, it is part of the proposal and my issues with the proposal are completely attributed to this.\r\n\r\n\u003e A release process like \"master is always the current stable release,\" is\r\nsimply a release process where no *version* is actual assigned to a\r\nrevision.\r\n\r\nPrecisely. I wanted to demonstrate that it is possible to have releases without having versions (which is what I would prefer).",
	"user": {
		"login": "Merovius",
		"id": 720787,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-27T16:37:52Z",
	"updated_at": "2015-11-27T16:37:52Z"
}
