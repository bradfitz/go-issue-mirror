{
	"id": 75911973,
	"body": "Yes, linux/ppc64le.\n\nI'll try the page shift hack and also out some asserts in to check\neverything is aligned to the page shift.\nOn 25 Feb 2015 17:22, \"Keith Randall\" \u003cnotifications@github.com\u003e wrote:\n\n\u003e Linux, right?\n\u003e\n\u003e The runtime currently uses 8K pages, so everything should be a multiple of\n\u003e 8K even if the OS pages are 4K.\n\u003e\n\u003e I don't see how an madvise call can possibly get a non-multiple of 8K. It\n\u003e is only called from sysUnused, and that is only called with a second\n\u003e argument that is ... \u003c\u003c _PageShift.\n\u003e\n\u003e There are a few places where munmap uses non-8K multiples. It's called\n\u003e from sysFree, and sysFree (and sysAlloc, for that matter) is called from\n\u003e some places with sizes that aren't necessarily page sizes. Maybe\n\u003e sysAlloc/sysFree should round to the page size before calling mmap/munmap?\n\u003e It may not matter, but I'm not sure what mmap/munmap do with partial pages.\n\u003e\n\u003e You might want to try setting _PageShift to 16 and see if that helps\n\u003e ppc64le. We probably don't want to leave that there, but it would be a\n\u003e good experiment.\n\u003e\n\u003e On Tue, Feb 24, 2015 at 9:39 PM, Dave Cheney \u003cnotifications@github.com\u003e\n\u003e wrote:\n\u003e\n\u003e \u003e I am sorry for the imprecise nature of this issue. The symptoms are\n\u003e random\n\u003e \u003e SIGSEGV's after processes have been running for several minutes. The most\n\u003e \u003e visible effect of this is go test std will segfault half way through the\n\u003e \u003e test run, making it impossible to complete a CI build.\n\u003e \u003e\n\u003e \u003e Last year @mwhudson \u003chttps://github.com/mwhudson\u003e and I saw a similar\n\u003e \u003e issue with gccgo-4.9 compiled programs which was eventually traced to the\n\u003e \u003e page size of the machine, most ppc64 machines 64k pages, being out of\n\u003e sync\n\u003e \u003e with the page size of that the runtime uses.\n\u003e \u003e\n\u003e \u003e In tracing some processes today I have found occurences of munmap(2) and\n\u003e \u003e madvise(2) calls that are not using multiples of 64k\n\u003e \u003e\n\u003e \u003e munmap(0x3fff82b40000, 26532) = 0\n\u003e \u003e\n\u003e \u003e More worrying, I've found examples that don't use a multiple of 4096\n\u003e bytes!\n\u003e \u003e\n\u003e \u003e munmap(0x3fff80e10000, 102680) = 0\n\u003e \u003e\n\u003e \u003e /cc @randall77 \u003chttps://github.com/randall77\u003e\n\u003e \u003e\n\u003e \u003e —\n\u003e \u003e Reply to this email directly or view it on GitHub\n\u003e \u003e \u003chttps://github.com/golang/go/issues/9993\u003e.\n\u003e \u003e\n\u003e\n\u003e —\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/9993#issuecomment-75911749\u003e.\n\u003e\n",
	"user": {
		"login": "davecheney",
		"id": 7171,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-02-25T06:25:13Z",
	"updated_at": "2015-02-25T06:25:13Z"
}
