{
	"id": 237116407,
	"body": "Even with 500 parallel requests (using your code exactly), I find it hard to reproduce this. I did see it, though.\r\n\r\nI see what's happening, though.\r\n\r\nAfter a connection negotiates ALPN protocol \"h2\", the upgrade function runs,\r\n\r\nhttps://github.com/golang/net/blob/e2ba55e4e78399d85f2a0e0b92396b81ed410633/http2/configure_transport.go#L34\r\n\r\nwhich returns a RoundTripper to use for that request, and also gets a new connection (`c *tls.Conn`) to use if it wants to:\r\n\r\n```go\r\n\tupgradeFn := func(authority string, c *tls.Conn) http.RoundTripper {\r\n\t\taddr := authorityAddr(\"https\", authority)\r\n\t\tif used, err := connPool.addConnIfNeeded(addr, t2, c); err != nil {\r\n\t\t\tgo c.Close()\r\n\t\t\treturn erringRoundTripper{err}\r\n\t\t} else if !used {\r\n\t\t\t// Turns out we don't need this c.\r\n\t\t\t// For example, two goroutines made requests to the same host\r\n\t\t\t// at the same time, both kicking off TCP dials. (since protocol\r\n\t\t\t// was unknown)\r\n\t\t\tgo c.Close()\r\n\t\t}\r\n\t\treturn t2\r\n\t}\r\n```\r\n\r\nThe error message you're seeing is coming from `t2` at the bottom there, which is configured to return the error if it doesn't have a usable connection.\r\n\r\nThe problem is that in `addConnIfNeeded`,\r\n\r\nhttps://github.com/golang/net/blob/e2ba55e4e78399d85f2a0e0b92396b81ed410633/http2/client_conn_pool.go#L127\r\n\r\nIt only makes it this far:\r\n\r\n```go\r\nfunc (p *clientConnPool) addConnIfNeeded(key string, t *Transport, c *tls.Conn) (used bool, err error) {\r\n\tp.mu.Lock()\r\n\tfor _, cc := range p.conns[key] {\r\n\t\tif cc.CanTakeNewRequest() {\r\n\t\t\tp.mu.Unlock()\r\n\t\t\treturn false, nil\r\n\t\t}\r\n\t}\r\n```\r\n\r\nIt sees that it has a connection and decides to use it, figuring that it'll be usable immediately.\r\n\r\nBut `CanTakeNewRequest` accounts for MAX_CONCURRENT_STREAMS:\r\n\r\nhttps://github.com/golang/net/blob/e2ba55e4e78399d85f2a0e0b92396b81ed410633/http2/transport.go#L496\r\n\r\nAnd google.com allows 100 concurrent streams:\r\n\r\n```\r\n$ h2i www.google.com\r\nConnecting to www.google.com:443 ...\r\nConnected to [2607:f8b0:4005:805::2004]:443\r\n[FrameHeader SETTINGS len=24]\r\n  [MAX_CONCURRENT_STREAMS = 100]\r\n  [INITIAL_WINDOW_SIZE = 1048576]\r\n  [MAX_FRAME_SIZE = 16384]\r\n  [MAX_HEADER_LIST_SIZE = 16384]\r\n[FrameHeader WINDOW_UPDATE len=4]\r\n  Window-Increment = 983041\r\n\r\nh2i\u003e \r\n```\r\n\r\nSo if you have over 100 goroutines in that codepath at once, all deciding they'll \"soon\" have an available connection, and without doing any dead-reckoning that they'll soon be taking one of those available slots, then `Transport.CanTakeNewRequest` returns `false` later when it's time to actually send a request, the `http2.Transport` tries to get a new connection, but its connection pool is configured to return `ErrNoCachedConn` thinking that return value will only be used by the upgrade function to decide whether to use keep the new TLS connection or not.\r\n\r\nThis is basically #13957 and #13774",
	"user": {
		"login": "bradfitz",
		"id": 2621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-03T02:32:38Z",
	"updated_at": "2016-08-03T02:32:38Z"
}
