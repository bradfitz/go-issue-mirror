{
	"id": 123714897,
	"body": " #11694 \u003chttps://github.com/golang/go/issues/11694\u003e is related.  #11694\n\u003chttps://github.com/golang/go/issues/11694\u003e has trace work to do but the GC\njust can't find it. The mutator can occasionally hide a \"gold\" pointers\nlong enough for the GC to progress to mark termination where it finds the\ngold pointer along with the 10 million untraced objects it is connected to.\n\n\nThe solution to both probably includes back pressure that forces the\nmutator to be more cooperative, for #11677 this probably means putting the\nmutator to sleep for a some period proportional to its debt, in effect\nslowing allocation by this goroutine down. For #11694\n\u003chttps://github.com/golang/go/issues/11694\u003e it means the same with the\nadded twist that before it sleeps it needs to do a gcw.dispose or in some\nother way reveal the gold pointer to the GC.\n\nThe trick of course is to minimize the cost to more mainstream applications\nso we can deal with these corner case devils gracefully.\n\nOn Tue, Jul 21, 2015 at 6:30 PM, Austin Clements \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e Here's what's going on. The loop that allocates 1,000 1MB byte slices does\n\u003e enter the assist and the assist knows that it needs to do a lot of work to\n\u003e pay for the allocation, but it finds no work to do, so it returns\n\u003e immediately. It keeps building up assist debt, but also keeps finding no\n\u003e work to do, so there's no back pressure.\n\u003e\n\u003e The reason it's not finding any work to do appears to be related to #11694\n\u003e \u003chttps://github.com/golang/go/issues/11694\u003e. There's no work to do\n\u003e because we're actually out of work. But we haven't entered mark termination\n\u003e yet, so the mutator is still running. This can happen simply because it\n\u003e takes us a while to go in to mark termination when we run out of work\n\u003e because we do things like rescanning globals to pick up more work to do in\n\u003e concurrent mark.\n\u003e\n\u003e It's also theoretically possible for this to happen when there is work to\n\u003e do, but it's not available to the assist. For example, the code in #11694\n\u003e \u003chttps://github.com/golang/go/issues/11694\u003e creates a heap that's almost\n\u003e entirely a long singly-linked list. A dedicated mark worker could be\n\u003e working on that list, but there's no way to hand off that work, so the\n\u003e assist won't be able to do anything, regardless of the assist debt.\n\u003e\n\u003e So it seems like we need to do something if we're in the assist and can't\n\u003e find enough work to pay down the assist debt.\n\u003e\n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/11677#issuecomment-123498614\u003e.\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-07-22T13:10:58Z",
	"updated_at": "2015-07-22T13:10:58Z"
}
