{
	"id": 66051840,
	"body": "\u003ca id=\"c64\"\u003e\u003c/a\u003eComment 64:\n\n\u003cpre\u003eThe current garbage collector takes a snapshot of memory at a particular moment. \nAnything accessible from global variables and goroutine stacks is live.  Everything else\nis freed.  A memory leak is when some memory block that is inaccessible is not freed. \nTo put it another way, a memory leak occurs when some value that is not a pointer\nappears to be a pointer and appears to point to a memory block that would otherwise be\nfreed.\n\nGo 1.1 is precise on the heap, which means that there are no such invalid pointers on\nthe heap.  The only source of invalid pointers is the goroutine stacks.  Since the stack\nis not precise, at any given snapshot of time, it is possible that the stack will\ncontain values that are not pointers but look like pointers, and that may cause some\nblocks to not be freed.  However, goroutine stacks are finite and (unless there is some\nbug in your program) the average size of the goroutine stacks as your program runs will\nremain fixed.  So on average you can't get an ever increasing number of invalid pointers\non the goroutine stacks.  Instead you have a fixed set of invalid numbers, and depending\non your program that fixed set will either change or not.\n\nIf the fixed set of invalid pointers doesn't change, then you have some fixed amount of\nextra memory that is not freed.  Data structure churn doesn't affect that.  The invalid\npointers will point to blocks that should be freed, but there are (by definition) no\nreal pointers to point to those blocks, so they won't change, and the amount of memory\nthey tie up won't change.\n\nAlternatively, if the fixed set of invalid pointers does change over time, then over\ntime some blocks will have no invalid pointers pointing to them and they will be freed,\nwhile other, different, blocks will be retained incorrectly.  The amount of memory\nincorrectly retained will fluctuate over time, but on average there is no reason to\nexpect it to either increase or decrease.  The only way that the incorrectly retained\nmemory would increase over time would be if the overall size of your live data is\nincreasing over time--in which case you have a problem anyhow.\n\nSo either way you have a leak in the sense that your program is using more memory than\nit should, but the amount of extra memory should be, on average, fixed based on the\nbehaviour of your program, and it should not increase over time.\n\nIt may be possible to write a Go 1.1 program that does have a memory leak in the worst\nsense, in that it steadily uses more memory over time even though the live memory does\nnot actually increase.  But I'm having a hard time thinking of a way to do it.  And I'm\nconfident that any such program would be highly specialized for this purpose; the\nproblem could not arise by accident.\u003c/pre\u003e",
	"user": {
		"login": "ianlancetaylor",
		"id": 3194333,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-06-22T19:47:48Z",
	"updated_at": "2014-12-08T10:06:20Z"
}
