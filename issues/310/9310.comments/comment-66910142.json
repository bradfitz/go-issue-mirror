{
	"id": 66910142,
	"body": "@dsymonds \r\n\r\n\u003e The \"real\" path when using a vanity import is the vanity import. That's what the package is known as.\r\n\r\nNo, the real path for any developer is where the data is. The vanity import has the purpose to make\r\nthe hosting service invisible for the user, so that the users package don't break if the hosting services is changed. However for any developer it is essential to know where the code is hosted since that is the place he pushes to.\r\n\r\nI must add that a developer of a library importing a package that has a vanity import is considered a **user of the imported package** in this terminology. That means if I import my own vanity package in another package, then **I am user of my own package**.\r\n\r\nAnd that makes perfectly sense, since I now (in the case of gopkg.in) depend of a published version\r\nof my package from the perspective of the other package. That means the dependency will be stable.\r\nHowever the development of the vanity package would happen in the hosting path from where new versions are cut that may be used in different versions by different packages (when using gopkg.in).",
	"user": {
		"login": "metakeule",
		"id": 180603,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-12-14T11:32:59Z",
	"updated_at": "2014-12-14T11:39:26Z"
}
