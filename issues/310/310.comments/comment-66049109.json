{
	"id": 66049109,
	"body": "\u003ca id=\"c6\"\u003e\u003c/a\u003eComment 6:\n\n\u003cpre\u003eWhile I'm not familiar with the assembly language generated by the 8g compiler, I can\nsee the problem.  Here is the code:\n...\n0015 (issue310.go:13) CALL    ,aint+0(SB)\n0016 (issue310.go:13) FMOVF   (SP),F0\n0017 (issue310.go:13) FMOVD   F0,F0\n0018 (issue310.go:13) FSTCW   ,.noname+-34(SP)\n0019 (issue310.go:13) MOVW    $3967,.noname+-36(SP)\n0020 (issue310.go:13) FLDCW   .noname+-36(SP),\n0021 (issue310.go:13) FMOVLP  F0,y+-32(SP)\n0022 (issue310.go:13) FLDCW   .noname+-34(SP),\n...\nHere is the comment from gsubr.c:\n...\n1527:        case CASE(TFLOAT32, TFLOAT32):\n1528:        case CASE(TFLOAT64, TFLOAT64):\n1529:                // The way the code generator uses floating-point\n1530:                // registers, a move from F0 to F0 is intended as a no-op.\n1531:                // On the x86, it's not: it pushes a second copy of F0\n1532:                // on the floating point stack.  So toss it away here.\n1533:                // Also, F0 is the *only* register we ever evaluate\n1534:                // into, so we should only see register/register as F0/F0.\n...\nIt is clear that the FMOVD F0,F0 is not being tossed away.\n\nSadly, this observation does not help with the problem in Comment 5.\u003c/pre\u003e",
	"user": {
		"login": "cldorian",
		"id": 10041646,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2009-11-26T05:30:11Z",
	"updated_at": "2014-12-08T10:04:05Z"
}
