{
	"id": 196642013,
	"body": "I followed Brad's advice and changed my test program https://play.golang.org/p/JmZcyYUgTz to use syscall.RawSyscall in setEvent:\r\n```\r\ndiff -r ebb09e700c4e main_test.go\r\n--- a/main_test.go\tTue Mar 15 12:20:13 2016 +1100\r\n+++ b/main_test.go\tTue Mar 15 14:49:35 2016 +1100\r\n@@ -33,7 +33,7 @@\r\n }\r\n \r\n func setEvent(h syscall.Handle) {\r\n-\tr0, _, e0 := syscall.Syscall(procSetEvent.Addr(), 1, uintptr(h), 0, 0)\r\n+\tr0, _, e0 := syscall.RawSyscall(procSetEvent.Addr(), 1, uintptr(h), 0, 0)\r\n \tif r0 == 0 {\r\n \t\tpanic(syscall.Errno(e0))\r\n \t}\r\n```\r\n\r\nI also had to change runtime and syscall to implement syscall.RawSyscall:\r\n```\r\ndiff --git a/src/runtime/cgocall.go b/src/runtime/cgocall.go\r\nindex 7a683d7..1763935 100644\r\n--- a/src/runtime/cgocall.go\r\n+++ b/src/runtime/cgocall.go\r\n@@ -128,6 +128,46 @@ func cgocall(fn, arg unsafe.Pointer) int32 {\r\n }\r\n \r\n //go:nosplit\r\n+func rawcgocall(fn, arg unsafe.Pointer) int32 {\r\n+\tif !iscgo \u0026\u0026 GOOS != \"solaris\" \u0026\u0026 GOOS != \"windows\" {\r\n+\t\tthrow(\"cgocall unavailable\")\r\n+\t}\r\n+\r\n+\tif fn == nil {\r\n+\t\tthrow(\"cgocall nil\")\r\n+\t}\r\n+\r\n+\tif raceenabled {\r\n+\t\tracereleasemerge(unsafe.Pointer(\u0026racecgosync))\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * Lock g to m to ensure we stay on the same stack if we do a\r\n+\t * cgo callback. Add entry to defer stack in case of panic.\r\n+\t */\r\n+\tlockOSThread()\r\n+\tmp := getg().m\r\n+\tmp.ncgocall++\r\n+\tmp.ncgo++\r\n+\tdefer endcgo(mp)\r\n+\r\n+\t/*\r\n+\t * Announce we are entering a system call\r\n+\t * so that the scheduler knows to create another\r\n+\t * M to run goroutines while we are in the\r\n+\t * foreign code.\r\n+\t *\r\n+\t * The call to asmcgocall is guaranteed not to\r\n+\t * split the stack and does not allocate memory,\r\n+\t * so it is safe to call while \"in a system call\", outside\r\n+\t * the $GOMAXPROCS accounting.\r\n+\t */\r\n+\terrno := asmcgocall(fn, arg)\r\n+\r\n+\treturn errno\r\n+}\r\n+\r\n+//go:nosplit\r\n func endcgo(mp *m) {\r\n \tmp.ncgo--\r\n \r\ndiff --git a/src/runtime/syscall_windows.go b/src/runtime/syscall_windows.go\r\nindex ebfa32f..6443de7 100644\r\n--- a/src/runtime/syscall_windows.go\r\n+++ b/src/runtime/syscall_windows.go\r\n@@ -172,3 +172,14 @@ func syscall_Syscall15(fn, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,\r\n \tcgocall(asmstdcallAddr, unsafe.Pointer(c))\r\n \treturn c.r1, c.r2, c.err\r\n }\r\n+\r\n+//go:linkname syscall_RawSyscall syscall.RawSyscall\r\n+//go:nosplit\r\n+func syscall_RawSyscall(fn, nargs, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\r\n+\tc := \u0026getg().m.syscall\r\n+\tc.fn = fn\r\n+\tc.n = nargs\r\n+\tc.args = uintptr(noescape(unsafe.Pointer(\u0026a1)))\r\n+\trawcgocall(asmstdcallAddr, unsafe.Pointer(c))\r\n+\treturn c.r1, c.r2, c.err\r\n+}\r\ndiff --git a/src/syscall/dll_windows.go b/src/syscall/dll_windows.go\r\nindex 8da1951..7d50b1a 100644\r\n--- a/src/syscall/dll_windows.go\r\n+++ b/src/syscall/dll_windows.go\r\n@@ -27,6 +27,7 @@ func Syscall12(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ui\r\n func Syscall15(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 uintptr) (r1, r2 uintptr, err Errno)\r\n func loadlibrary(filename *uint16) (handle uintptr, err Errno)\r\n func getprocaddress(handle uintptr, procname *uint8) (proc uintptr, err Errno)\r\n+func RawSyscall(trap, nargs, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\r\n \r\n // A DLL implements access to a single DLL.\r\n type DLL struct {\r\n```\r\n\r\nI see not much changed:\r\n```\r\nC:\\dev\\src\\issues\\issue14790\u003ego install -v syscall \u0026\u0026 go test -bench=.\r\ntesting: warning: no tests to run\r\nBenchmarkDefaultResolution                    50          31250200 ns/op\r\nBenchmark1ms                                1000           1956129 ns/op\r\nBenchmarkNoChannelDefaultResolution       300000              4166 ns/op\r\nBenchmarkNoChannel1ms                     300000              4078 ns/op\r\nBenchmarkOnlyChannelDefaultResolution    3000000               479 ns/op\r\nBenchmarkOnlyChannel1ms                  3000000               483 ns/op\r\nPASS\r\nok      issues/issue14790       10.718s\r\n\r\nC:\\dev\\src\\issues\\issue14790\u003e\r\n```\r\n(BenchmarkNoChannelDefaultResolution and BenchmarkNoChannel1ms are ~10% faster, but that is understandable). But main issue is still there.\r\n\r\nAlex",
	"user": {
		"login": "alexbrainman",
		"id": 9796621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-03-15T03:57:15Z",
	"updated_at": "2016-03-15T03:57:15Z"
}
