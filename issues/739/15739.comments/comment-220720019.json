{
	"id": 220720019,
	"body": "I got another bogus one,\r\nhttps://storage.googleapis.com/go-build-log/f48ca822/linux-amd64-race_04ff3748.log\r\n\r\nHere's why it's bogus:\r\n\r\nThe race says:\r\n```\r\nPrevious write at 0x00c42054ce20 by goroutine 235:\r\n  net/http.readRequest()\r\n      /tmp/workdir/go/src/net/http/request.go:827 +0x402\r\n  net/http.(*conn).readRequest()\r\n      /tmp/workdir/go/src/net/http/server.go:765 +0x233\r\n  net/http.(*conn).serve()\r\n      /tmp/workdir/go/src/net/http/server.go:1508 +0x3ff\r\n```\r\n\r\nBut here's the code, with line 827 at the bottom highlighted:\r\n\r\n```go\r\nfunc readRequest(b *bufio.Reader, deleteHostHeader bool) (req *Request, err error) {\r\n        tp := newTextprotoReader(b)\r\n        req = new(Request)\r\n\r\n        // First line: GET /index.html HTTP/1.0                                                                                                     \r\n        var s string\r\n        if s, err = tp.ReadLine(); err != nil {\r\n                return nil, err\r\n        }\r\n        defer func() {\r\n                putTextprotoReader(tp)\r\n                if err == io.EOF {\r\n                        err = io.ErrUnexpectedEOF\r\n                }\r\n        }()\r\n\r\n        var ok bool\r\n        req.Method, req.RequestURI, req.Proto, ok = parseRequestLine(s)\r\n        if !ok {\r\n                return nil, \u0026badStringError{\"malformed HTTP request\", s}\r\n        }\r\n        rawurl := req.RequestURI\r\n        if req.ProtoMajor, req.ProtoMinor, ok = ParseHTTPVersion(req.Proto); !ok {\r\n                return nil, \u0026badStringError{\"malformed HTTP version\", req.Proto}\r\n        }\r\n        \r\n        // CONNECT requests are used two different ways, and neither uses a full URL:                                                               \r\n        // The standard use is to tunnel HTTPS through an HTTP proxy.                                                                               \r\n        // It looks like \"CONNECT www.google.com:443 HTTP/1.1\", and the parameter is                                                                \r\n        // just the authority section of a URL. This information should go in req.URL.Host.                                                         \r\n        //                                                                                                                                          \r\n        // The net/rpc package also uses CONNECT, but there the parameter is a path                                                                 \r\n        // that starts with a slash. It can be parsed with the regular URL parser,                                                                  \r\n        // and the path will end up in req.URL.Path, where it needs to be in order for                                                              \r\n        // RPC to work.                                                                                                                             \r\n        justAuthority := req.Method == \"CONNECT\" \u0026\u0026 !strings.HasPrefix(rawurl, \"/\")\r\n        if justAuthority {\r\n                rawurl = \"http://\" + rawurl\r\n        }\r\n\r\n        if req.URL, err = url.ParseRequestURI(rawurl); err != nil {   // \u003c----- LINE 827\r\n                return nil, err\r\n        }\r\n```\r\n\r\nThat is all in a single goroutine, and it creates the memory (on the second line of the function), before assigning to it.\r\n\r\nIt can't race with anything yet, because that memory hasn't even escaped.\r\n\r\n@dvyukov, up to you to debug.\r\n",
	"user": {
		"login": "bradfitz",
		"id": 2621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-05-20T21:13:53Z",
	"updated_at": "2016-05-20T21:13:53Z"
}
