{
	"id": 234034292,
	"body": "\u003e It seems to me this will only be useful if you litter your data structure with fields of type json.Node.\r\n\r\nMy intention was to have this an interface analogous to unmarshalling to an `interface{}`. The way I've been using it is to unmarshal twice, once into a struct with json tags and once into a `json.Node`, effectively producing two trees. If you walk down both trees in sync you can simultaneously access both the unmarshalled data for validation and the offsets from the Node tree. A nice side effect of this is you can access the original string that was decoded and use it to generate warnings (e.g. if you have a field representing file permissions and the user put a value in the wrong base like 0644 instead of 420, the decimal equivalent). Furthermore, because all the json gets decoded into the `Node`, you can check for things like unused fields.\r\n\r\nAnother possibility would be to have the `Value` field of the Node structure be the struct you want to unmarshal into, and also add a `Children` field (being either `nil` for leaves, `map[string]Node` for objects or `[]Node` for arrays), but I wanted to get feedback on the simpler case first before implementing it. It's also unclear what the interface for this would look like? A separate `UnmarshalWithOffsets` function? Unmarshalling to a `Node` with a struct already set for `Value`?\r\n\r\n\u003e Another possibility would be to define a new method, along the lines of `UnmarshalJSON`, that takes an offset as an argument. That lets the user of the package choose how to handle the offset.\r\n\r\nThis would require every type to implement the interface, which would lead to a huge amount of boilerplate code. I'm also not sure I follow how this would be used? I'm imagining something like:\r\n```\r\ntype foo Foo\r\nfunc (f *Foo) UnmarshalJSONOffset(data []byte, offset int) error {\r\n    // record offset somewhere for later use\r\n    foo f2 := foo(*f)\r\n    if err := json.Unmarshal(data, f2); err != nil {\r\n        return err\r\n    }\r\n    *f = Foo(f2)\r\n}\r\n```\r\nBut the problem is that when `json.Unmarshal` gets called the offsets it uses will be relative to the start of the data passed to `UnmarshalJSONOffset`, not the start of the entire json blob. I suppose you could add something like `json.UnmarsalWithBaseOffset` which could automatically add the offset for you, but that seems somewhat messy.",
	"user": {
		"login": "ajeddeloh",
		"id": 2753421,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-20T18:15:05Z",
	"updated_at": "2016-07-20T18:17:09Z"
}
