{
	"id": 234965549,
	"body": "Hi Dmitry,\r\n\r\nYou are right that I had simply assumed that reducing cumulative runtime in `findrunnable` (which includes `stopm` parking/unparking) would reduce overall CPU consumption - but that does turn out to be the case. I don't have instrumentation for transaction latency, but the clients here are gated in part by the server response so throughput should be a proxy for latency. My X86 system is having issues so I'll show some results from POWER8 for a slightly different benchmark (partial results from X86 have a similar character).\r\n```\r\nGOMAXPROCS = 12\r\n------------------------------------------------------------\r\n                        Baseline  1) Only   2) Only    Both\r\n------------------------------------------------------------\r\nThroughput, TPS          1028       1031      1021     1036\r\nfindrunnable, cum. %     14.4       11.1       9.2     10.2\r\nCPU Time, sec             161        159       158      158\r\nCPU Time, % of Baseline              99%        99%     98%\r\n------------------------------------------------------------\r\n\r\nGOMAXPROCS = 80\r\n------------------------------------------------------------\r\n                        Baseline  1) Only   2) Only    Both\r\n------------------------------------------------------------\r\nThroughput, TPS          1045       1015      1026     1026\r\nfindrunnable, cum. %     31.2       26.0      14.3     16.5\r\nCPU Time, sec             200        195       171      174\r\nCPU Time, % of Baseline              98%       86%      87%\r\n------------------------------------------------------------\r\n\r\n```\r\nOf the 2 proposals, the proposal 2) to introduce `mayhavework` has the largest effect for this benchmark, especially for large GOMAXPROCS.\r\n\r\nI'm glad you mentioned the \"don't spin\" heuristic above. I'm puzzled at how this reduces CPU time, since threads branching to `stop` here enter a kind of limbo in which they are both forbidden to search for work to steal, yet also forbidden to park until there is no more work to steal.\r\n\r\nI have in fact created a highly modified scheduler that keeps one thread spinning permanently and sends all others immediately to park. This scheduler delivers a solid 5+% throughput boost for our application at the expense of burning a hardware thread. I wouldn't suggest this as a general solution, but I could see us offering something like this to our clients under certain conditions.\r\n\r\nFor today though, I would ask you to consider these proposals based on first principles, and even with the knowledge that decreasing the amount of time spent in work-stealing may slightly drop performance by missing out on chance encounters with work which was not present when the stealing loop was first entered. My own outlook is probably colored by having spent many years working on server energy efficiency, and I understand that not everyone is willing to make this kind of trade.",
	"user": {
		"login": "bcbrock",
		"id": 11968347,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-25T14:15:57Z",
	"updated_at": "2016-07-25T14:15:57Z"
}
