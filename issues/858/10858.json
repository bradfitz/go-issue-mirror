{
	"id": 76452289,
	"number": 10858,
	"state": "open",
	"title": "go/doc: comments dropped from interior of interface definition",
	"body": "The go doc output is missing some important comments from the definition of reflect.Type (so is godoc, but maybe go doc can do better). I've added the missing comments, bracketed by **, below. It's dropping anything that doesn't immediately precede a method definition.\n\n\t$ go doc reflect.Type\n\ttype Type interface {\n\n\t**\n\t\t// Methods applicable to all types.\n\t**\n\n\t\t// Align returns the alignment in bytes of a value of\n\t\t// this type when allocated in memory.\n\t\tAlign() int\n\t\n\t\t// FieldAlign returns the alignment in bytes of a value of\n\t\t// this type when used as a field in a struct.\n\t\tFieldAlign() int\n\t\n\t\t// Method returns the i'th method in the type's method set.\n\t\t// It panics if i is not in the range [0, NumMethod()).\n\t\t//\n\t\t// For a non-interface type T or *T, the returned Method's Type and Func\n\t\t// fields describe a function whose first argument is the receiver.\n\t\t//\n\t\t// For an interface type, the returned Method's Type field gives the\n\t\t// method signature, without a receiver, and the Func field is nil.\n\t\tMethod(int) Method\n\t\n\t\t// MethodByName returns the method with that name in the type's\n\t\t// method set and a boolean indicating if the method was found.\n\t\t//\n\t\t// For a non-interface type T or *T, the returned Method's Type and Func\n\t\t// fields describe a function whose first argument is the receiver.\n\t\t//\n\t\t// For an interface type, the returned Method's Type field gives the\n\t\t// method signature, without a receiver, and the Func field is nil.\n\t\tMethodByName(string) (Method, bool)\n\t\n\t\t// NumMethod returns the number of methods in the type's method set.\n\t\tNumMethod() int\n\t\n\t\t// Name returns the type's name within its package.\n\t\t// It returns an empty string for unnamed types.\n\t\tName() string\n\t\n\t\t// PkgPath returns a named type's package path, that is, the import path\n\t\t// that uniquely identifies the package, such as \"encoding/base64\".\n\t\t// If the type was predeclared (string, error) or unnamed (*T, struct{}, []int),\n\t\t// the package path will be the empty string.\n\t\tPkgPath() string\n\t\n\t\t// Size returns the number of bytes needed to store\n\t\t// a value of the given type; it is analogous to unsafe.Sizeof.\n\t\tSize() uintptr\n\t\n\t\t// String returns a string representation of the type.\n\t\t// The string representation may use shortened package names\n\t\t// (e.g., base64 instead of \"encoding/base64\") and is not\n\t\t// guaranteed to be unique among types.  To test for equality,\n\t\t// compare the Types directly.\n\t\tString() string\n\t\n\t\t// Kind returns the specific kind of this type.\n\t\tKind() Kind\n\t\n\t\t// Implements reports whether the type implements the interface type u.\n\t\tImplements(u Type) bool\n\t\n\t\t// AssignableTo reports whether a value of the type is assignable to type u.\n\t\tAssignableTo(u Type) bool\n\t\n\t\t// ConvertibleTo reports whether a value of the type is convertible to type u.\n\t\tConvertibleTo(u Type) bool\n\t\n\t\t// Comparable reports whether values of this type are comparable.\n\t\tComparable() bool\n\n\t**\n\t\t// Methods applicable only to some types, depending on Kind.\n\t\t// The methods allowed for each kind are:\n\t\t//\n\t\t//\tInt*, Uint*, Float*, Complex*: Bits\n\t\t//\tArray: Elem, Len\n\t\t//\tChan: ChanDir, Elem\n\t\t//\tFunc: In, NumIn, Out, NumOut, IsVariadic.\n\t\t//\tMap: Key, Elem\n\t\t//\tPtr: Elem\n\t\t//\tSlice: Elem\n\t\t//\tStruct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField\n\t**\n\t\n\t\t// Bits returns the size of the type in bits.\n\t\t// It panics if the type's Kind is not one of the\n\t\t// sized or unsized Int, Uint, Float, or Complex kinds.\n\t\tBits() int\n\t\n\t\t// ChanDir returns a channel type's direction.\n\t\t// It panics if the type's Kind is not Chan.\n\t\tChanDir() ChanDir\n\t\n\t\t// IsVariadic reports whether a function type's final input parameter\n\t\t// is a \"...\" parameter.  If so, t.In(t.NumIn() - 1) returns the parameter's\n\t\t// implicit actual type []T.\n\t\t//\n\t\t// For concreteness, if t represents func(x int, y ... float64), then\n\t\t//\n\t\t//\tt.NumIn() == 2\n\t\t//\tt.In(0) is the reflect.Type for \"int\"\n\t\t//\tt.In(1) is the reflect.Type for \"[]float64\"\n\t\t//\tt.IsVariadic() == true\n\t\t//\n\t\t// IsVariadic panics if the type's Kind is not Func.\n\t\tIsVariadic() bool\n\t\n\t\t// Elem returns a type's element type.\n\t\t// It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.\n\t\tElem() Type\n\t\n\t\t// Field returns a struct type's i'th field.\n\t\t// It panics if the type's Kind is not Struct.\n\t\t// It panics if i is not in the range [0, NumField()).\n\t\tField(i int) StructField\n\t\n\t\t// FieldByIndex returns the nested field corresponding\n\t\t// to the index sequence.  It is equivalent to calling Field\n\t\t// successively for each index i.\n\t\t// It panics if the type's Kind is not Struct.\n\t\tFieldByIndex(index []int) StructField\n\t\n\t\t// FieldByName returns the struct field with the given name\n\t\t// and a boolean indicating if the field was found.\n\t\tFieldByName(name string) (StructField, bool)\n\t\n\t\t// FieldByNameFunc returns the first struct field with a name\n\t\t// that satisfies the match function and a boolean indicating if\n\t\t// the field was found.\n\t\tFieldByNameFunc(match func(string) bool) (StructField, bool)\n\t\n\t\t// In returns the type of a function type's i'th input parameter.\n\t\t// It panics if the type's Kind is not Func.\n\t\t// It panics if i is not in the range [0, NumIn()).\n\t\tIn(i int) Type\n\t\n\t\t// Key returns a map type's key type.\n\t\t// It panics if the type's Kind is not Map.\n\t\tKey() Type\n\t\n\t\t// Len returns an array type's length.\n\t\t// It panics if the type's Kind is not Array.\n\t\tLen() int\n\t\n\t\t// NumField returns a struct type's field count.\n\t\t// It panics if the type's Kind is not Struct.\n\t\tNumField() int\n\t\n\t\t// NumIn returns a function type's input parameter count.\n\t\t// It panics if the type's Kind is not Func.\n\t\tNumIn() int\n\t\n\t\t// NumOut returns a function type's output parameter count.\n\t\t// It panics if the type's Kind is not Func.\n\t\tNumOut() int\n\t\n\t\t// Out returns the type of a function type's i'th output parameter.\n\t\t// It panics if the type's Kind is not Func.\n\t\t// It panics if i is not in the range [0, NumOut()).\n\t\tOut(i int) Type\n\t\n\t\tcommon() *rtype\n\t\tuncommon() *uncommonType\n\t}",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"assignee": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"comments": 1,
	"created_at": "2015-05-14T18:43:07Z",
	"updated_at": "2016-05-18T00:34:31Z",
	"milestone": {
		"id": 1709363,
		"number": 38,
		"title": "Go1.8"
	}
}
