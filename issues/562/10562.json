{
	"id": 70506412,
	"number": 10562,
	"state": "closed",
	"title": "proposal: builtin: First-Class Cancellation",
	"body": "Go should have a first-class cancellation pattern (in much the same way that it has a first class error pattern).  The cancellation pattern should meet the following requirements:\r\n\r\n1. **Very light-weight:** Such that it can be used to control cancellation at a very fine grained level.  *e.g. it should be perfectly reasonable for every goroutine started in an application to have a cancellation token.  It should not be unreasonable for many individual methods to have cancellation.*\r\n* **Least Privilege:**  The ability to `observe` cancellation and the ability to `cause` cancellation MUST be independent.\r\n* **Broadcast:**  It MUST be possible for multiple consumers to `observe` the same cancellation token without impacting each other.\r\n* **Idempotent:** A cancellation token, once cancelled, should never become uncancelled.\r\n* **Concurrency Safe:**  It MUST be possible for multiple consumers to `observe` cancellation in parallel without additional synchronization.\r\n* **Asynchronous:**  Cancellation of the token only guarantees that all observes will eventually see the cancellation, NOT that cancellation of a tree of computation will be cancelled synchronously.\r\n* **Synchronous Polling:**  It MUST be possible to synchronous `poll` whether cancellation has occurred.  This allows long running computations to periodically check whether they should stop running even if they never block on IO.\r\n* **Blocking Composition:**  It MUST be possible to compose a cancellation token with blocking I/O in a `select` statement.  *e.g. block on a data channel value or cancellation, which ever happens first.*\r\n* **Boolean Composition:**  It MUST be possible to combine cancellation token in an `and` or `or` manner such that you get a new cancellation token that becomes cancelled when its inputs become cancelled.\r\n* **Hierarchical Composition:** It MUST be possible to create child cancellation tokens that cancel when their parent cancels, but can also be cancelled independently without affect their parent.\r\n* **IO Composition:** It MUST be possible to create RPC contexts, HTTP contexts, etc. that are linked to a standard cancellation token as its parent.\r\n* **Debuggable:**  Cancellation SHOULD provide a `diagnostic` message that can be used in logging or other debugging to indicate the *reason* a computation was asked to cancel.\r\n\r\n# What Is It For\r\nCancellation allows a tree or pipeline of computation whose output is no longer needed to be terminated.  Go makes describing pipelines of computation easy.  Goroutines representing each stage of such a pipeline link together via channels to form a computational pipeline whose final channel delivers the final result of the computation.  Once a pipeline has produced sufficient output for the final consumer the pipeline needs to be torn down.  Sometimes this corresponds to natural boundaries of data being produced but sometimes it doesn't (e.g. when errors are encountered or the consumer disconnects abruptly).\r\n\r\n# What\r\nI propose that cancellation be implemented like errors through an interface of the following form:\r\n\r\n```go\r\ntype Cancel interface {\r\n\t// Returns a channel that is closed when signalled by the cancellation function.  \r\n\t// Guaranteed to return the same channel on each call \r\n\t// (i.e. can be safely cached by the caller.)\r\n\tDone() \u003c-chan struct{}\r\n\t// Err returns the error provided to the cancellation function.  \r\n\t// If not yet signalled always returns nil.  \r\n\t// (i.e. can be called at any time to poll the state of cancellation.)\r\n\tErr() error\r\n}\r\n\r\n// CancelFunc is called to signal that cancellation should begin.  \r\n// Signalling the cancellation token is synchronous and atomic.\r\n// CancelFunc is idempotent but only the first reason is preserved.  \r\n// If reason is nil, CancelFunc panics.\r\ntype CancelFunc func(reason error)\r\n\r\n// NewCancel creates a new cancellation signal and a cancellation \r\n// function to cancel it.\r\nfunc NewCancel() (Cancel, CancelFunc) { ... }\r\n\r\n// WithParent creates a new cancellation signal and a cancellation \r\n// function to cancel it.  The resulting token is cancelled with either\r\n// the cancellation function is called or the parent becomes cancelled.\r\nfunc WithParent(parent Cancel) (Cancel, CancelFunc) { ... }\r\n\r\n// And creates a new cancellation signal that becomes cancelled when\r\n// both of its inputs become cancelled.\r\nfunc And(left Cancel, right Cancel) Cancel { ... }\r\n\r\n// Or creates a new cancellation signal that becomes cancelled when\r\n// either of its inputs become cancelled.\r\nfunc Or(left Cancel, right Cancel) Cancel { ... }\r\n```\r\n\r\nThis interface allows for implementations that meet all of the above specifications.  Because the Done() channel's write endpoint is closely held in this design, it is possible for a language runtime implementation to use a cheaper channel implementation that allows for Boolean and Hierarchical composition *without* actually allocating a goroutine to wait on the inputs.\r\n\r\n# Why It Should Be Part Of The Language\r\nFor most of the same reasons that error is part of the language.  First-class treatment of cancellation will guarantee the proper level of composability that an external implementation cannot achieve.  \r\n\r\nFirst-class treatment allows the core libraries to also level the pattern.\r\n\r\nAs mentioned above, a language runtime level implementation can be significantly less expensive for composition that would be possible by a pure library implementation.  A low-cost enables its ubiquity as it allows it to be used in domains that simply would not permit a more expensive implementation.",
	"user": {
		"login": "invino4",
		"id": 11217472,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		},
		{
			"name": "Proposal"
		}
	],
	"comments": 6,
	"closed_at": "2015-04-23T23:42:00Z",
	"created_at": "2015-04-23T20:30:59Z",
	"updated_at": "2016-08-22T18:41:44Z"
}
