{
	"id": 66073022,
	"body": "\u003ca id=\"c7\"\u003e\u003c/a\u003eComment 7:\n\n\u003cpre\u003eThere are two orthogonal issues here:\n\n1) definition of the switch semantics\n2) restrictions on top of 1\n\nRegarding 1: The idea of the expression switch statement was (from day one) that it\nshould behave exactly like the corresponding if-else-if sequence (with the extra of\nfallthrough, but that is not an inherent complication). By defining a switch in terms of\nan if-else-if sequence we get an immediate and accurate definition of its behavior, it\nexplains why an if-else-if sequence can always be rewritten into a respective switch\nstatement and vice versa, and it also informs an straight-forward compiler how to\nimplement it  (e.g., by rewriting the AST to an if-else-if sequence). It also explains\ncorner-case situations such as:\n\n\tswitch 1\u0026lt;\u0026lt;100 {\n\tcase 1\u0026lt;\u0026lt;100:\n\t}\n\n\tvar x int\n\tswitch 1.0 {\n\tcase x:\n\t}\n\netc., which are currently not accepted by 6g or gccgo for no good reasons. Going away\nfrom the switch if-else-if equivalence will make the spec and programming in Go more\ncomplicated.\n\n2) It is possible to add orthogonal restrictions on top of the semantics proposed in 1).\nThe typical restriction is to disallow multiple equal constant case values as in:\n\n\tvar x int\n\tswitch x {\n\tcase 1:\n\tcase 1:\n\t}\n\nAt the moment, gc looks at duplicate integer, floating point, and string values (but\nignores duplicate complex or boolean values); gccgo ignores duplicate boolean, string,\nand complex values. The situation is more complex when the tag expression is of\ninterface type:\n\n\tvar x interface{}\n\tswitch x {\n\tcase 1:\n\tcase 1.0:\n\tcase 1e0:\n\t}\n\nIn this case 1 will be typed as int, while 1.0 and 1e0 will be typed as float64 and thus\n1.0 and 1e0 would be the same constant, but not so 1.\n\nThere are also good reasons for not having a restriction at all: For instance, any\nswitch statement with more than 2 constant boolean case values will have duplicates, but\nthose constants may be defined globally and enable/disable functionality that might be\nplatform-specific. In such a scenario, we would not want a compiler error depending on\nconfiguration. The same applies to string constants, and to some extent integer\nconstants.\n\nIt may be reasonable to say that the restriction should apply to numeric values only,\nand perhaps even to integers only because that's a common scenario (ioata-defined\nintegers of an \"enum\" type).\n\nAfter discussing this w/ r, I am leaning towards not having any restrictions enforced by\nthe compiler at all. r suggested that go vet might be better suited for this job.\u003c/pre\u003e",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-10-24T18:44:33Z",
	"updated_at": "2014-12-22T06:21:10Z"
}
