{
	"id": 253444392,
	"body": "Just too busy on the current commercial project right now to do this. \r\n\r\nInstead, i inline the the fix:\r\ngolang.org/x/exp/shiny/driver/gldriver/cocoa.m\t\r\n\r\nYou can easily drop this in and see the differences with git yourself..\r\n\r\n\r\n````\r\n\r\n// Copyright 2014 The Go Authors. All rights reserved.\r\n// Use of this source code is governed by a BSD-style\r\n// license that can be found in the LICENSE file.\r\n\r\n// +build darwin\r\n// +build 386 amd64\r\n// +build !ios\r\n\r\n#include \"_cgo_export.h\"\r\n#include \u003cpthread.h\u003e\r\n#include \u003cstdio.h\u003e\r\n\r\n#import \u003cCocoa/Cocoa.h\u003e\r\n#import \u003cFoundation/Foundation.h\u003e\r\n#import \u003cOpenGL/gl3.h\u003e\r\n\r\nvoid makeCurrentContext(uintptr_t context) {\r\n\tNSOpenGLContext* ctx = (NSOpenGLContext*)context;\r\n\t[ctx makeCurrentContext];\r\n}\r\n\r\nvoid flushContext(uintptr_t context) {\r\n\tNSOpenGLContext* ctx = (NSOpenGLContext*)context;\r\n\t[ctx flushBuffer];\r\n}\r\n\r\nuint64 threadID() {\r\n\tuint64 id;\r\n\tif (pthread_threadid_np(pthread_self(), \u0026id)) {\r\n\t\tabort();\r\n\t}\r\n\treturn id;\r\n}\r\n\r\n@interface ScreenGLView : NSOpenGLView\u003cNSWindowDelegate\u003e\r\n{\r\n}\r\n@end\r\n\r\n@implementation ScreenGLView\r\n- (void)prepareOpenGL {\r\n\t[self setWantsBestResolutionOpenGLSurface:YES];\r\n\tGLint swapInt = 1;\r\n\tNSOpenGLContext *ctx = [self openGLContext];\r\n\t[ctx setValues:\u0026swapInt forParameter:NSOpenGLCPSwapInterval];\r\n\r\n\t// Using attribute arrays in OpenGL 3.3 requires the use of a VBA.\r\n\t// But VBAs don't exist in ES 2. So we bind a default one.\r\n\tGLuint vba;\r\n\tglGenVertexArrays(1, \u0026vba);\r\n\tglBindVertexArray(vba);\r\n\r\n\tpreparedOpenGL((GoUintptr)self, (GoUintptr)ctx, (GoUintptr)vba);\r\n}\r\n\r\n- (void)callSetGeom {\r\n\t// Calculate screen PPI.\r\n\t//\r\n\t// Note that the backingScaleFactor converts from logical\r\n\t// pixels to actual pixels, but both of these units vary\r\n\t// independently from real world size. E.g.\r\n\t//\r\n\t// 13\" Retina Macbook Pro, 2560x1600, 227ppi, backingScaleFactor=2, scale=3.15\r\n\t// 15\" Retina Macbook Pro, 2880x1800, 220ppi, backingScaleFactor=2, scale=3.06\r\n\t// 27\" iMac,               2560x1440, 109ppi, backingScaleFactor=1, scale=1.51\r\n\t// 27\" Retina iMac,        5120x2880, 218ppi, backingScaleFactor=2, scale=3.03\r\n\tNSScreen *screen = self.window.screen;\r\n\tdouble screenPixW = [screen frame].size.width * [screen backingScaleFactor];\r\n\r\n\tCGDirectDisplayID display = (CGDirectDisplayID)[[[screen deviceDescription] valueForKey:@\"NSScreenNumber\"] intValue];\r\n\tCGSize screenSizeMM = CGDisplayScreenSize(display); // in millimeters\r\n\tfloat ppi = 25.4 * screenPixW / screenSizeMM.width;\r\n\tfloat pixelsPerPt = ppi/72.0;\r\n\r\n\t// The width and height reported to the geom package are the\r\n\t// bounds of the OpenGL view. Several steps are necessary.\r\n\t// First, [self bounds] gives us the number of logical pixels\r\n\t// in the view. Multiplying this by the backingScaleFactor\r\n\t// gives us the number of actual pixels.\r\n\tNSRect r = [self bounds];\r\n\tint w = r.size.width * [screen backingScaleFactor];\r\n\tint h = r.size.height * [screen backingScaleFactor];\r\n\r\n\tsetGeom((GoUintptr)self, pixelsPerPt, w, h);\r\n}\r\n\r\n- (void)reshape {\r\n\t[super reshape];\r\n\t[self callSetGeom];\r\n}\r\n\r\n- (void)drawRect:(NSRect)theRect {\r\n\t// Called during resize. Do an extra draw if we are visible.\r\n\t// This gets rid of flicker when resizing.\r\n\tdrawgl((GoUintptr)self);\r\n}\r\n\r\n- (void)mouseEventNS:(NSEvent *)theEvent {\r\n\tNSPoint p = [theEvent locationInWindow];\r\n\tdouble h = self.frame.size.height;\r\n\r\n\t// Both h and p are measured in Cocoa pixels, which are a fraction of\r\n\t// physical pixels, so we multiply by backingScaleFactor.\r\n\tdouble scale = [self.window.screen backingScaleFactor];\r\n\r\n\tdouble x = p.x * scale;\r\n\tdouble y = (h - p.y) * scale - 1; // flip origin from bottom-left to top-left.\r\n\r\n\tdouble dx, dy;\r\n\tif (theEvent.type == NSEventTypeScrollWheel) {\r\n\t\tdx = theEvent.scrollingDeltaX;\r\n\t\tdy = theEvent.scrollingDeltaY;\r\n\t}\r\n\r\n\tmouseEvent((GoUintptr)self, x, y, dx, dy, theEvent.type, theEvent.buttonNumber, theEvent.modifierFlags);\r\n}\r\n\r\n- (void)mouseMoved:(NSEvent *)theEvent        { [self mouseEventNS:theEvent]; }\r\n- (void)mouseDown:(NSEvent *)theEvent         { [self mouseEventNS:theEvent]; }\r\n- (void)mouseUp:(NSEvent *)theEvent           { [self mouseEventNS:theEvent]; }\r\n- (void)mouseDragged:(NSEvent *)theEvent      { [self mouseEventNS:theEvent]; }\r\n- (void)rightMouseDown:(NSEvent *)theEvent    { [self mouseEventNS:theEvent]; }\r\n- (void)rightMouseUp:(NSEvent *)theEvent      { [self mouseEventNS:theEvent]; }\r\n- (void)rightMouseDragged:(NSEvent *)theEvent { [self mouseEventNS:theEvent]; }\r\n- (void)otherMouseDown:(NSEvent *)theEvent    { [self mouseEventNS:theEvent]; }\r\n- (void)otherMouseUp:(NSEvent *)theEvent      { [self mouseEventNS:theEvent]; }\r\n- (void)otherMouseDragged:(NSEvent *)theEvent { [self mouseEventNS:theEvent]; }\r\n- (void)scrollWheel:(NSEvent *)theEvent       { [self mouseEventNS:theEvent]; }\r\n\r\n// raw modifier key presses\r\n- (void)flagsChanged:(NSEvent *)theEvent {\r\n\tflagEvent((GoUintptr)self, theEvent.modifierFlags);\r\n}\r\n\r\n// overrides special handling of escape and tab\r\n- (BOOL)performKeyEquivalent:(NSEvent *)theEvent {\r\n\t[self key:theEvent];\r\n\treturn YES;\r\n}\r\n\r\n- (void)keyDown:(NSEvent *)theEvent { [self key:theEvent]; }\r\n- (void)keyUp:(NSEvent *)theEvent   { [self key:theEvent]; }\r\n\r\n- (void)key:(NSEvent *)theEvent {\r\n\tNSRange range = [theEvent.characters rangeOfComposedCharacterSequenceAtIndex:0];\r\n\r\n\tuint8_t buf[4] = {0, 0, 0, 0};\r\n\tif (![theEvent.characters getBytes:buf\r\n\t\t\tmaxLength:4\r\n\t\t\tusedLength:nil\r\n\t\t\tencoding:NSUTF32LittleEndianStringEncoding\r\n\t\t\toptions:NSStringEncodingConversionAllowLossy\r\n\t\t\trange:range\r\n\t\t\tremainingRange:nil]) {\r\n\t\tNSLog(@\"failed to read key event %@\", theEvent);\r\n\t\treturn;\r\n\t}\r\n\r\n\tuint32_t rune = (uint32_t)buf[0]\u003c\u003c0 | (uint32_t)buf[1]\u003c\u003c8 | (uint32_t)buf[2]\u003c\u003c16 | (uint32_t)buf[3]\u003c\u003c24;\r\n\r\n\tuint8_t direction;\r\n\tif ([theEvent isARepeat]) {\r\n\t\tdirection = 0;\r\n\t} else if (theEvent.type == NSEventTypeKeyDown) {\r\n\t\tdirection = 1;\r\n\t} else {\r\n\t\tdirection = 2;\r\n\t}\r\n\tkeyEvent((GoUintptr)self, (int32_t)rune, direction, theEvent.keyCode, theEvent.modifierFlags);\r\n}\r\n\r\n- (void)windowDidChangeScreenProfile:(NSNotification *)notification {\r\n\t[self callSetGeom];\r\n}\r\n\r\n// TODO: catch windowDidMiniaturize?\r\n\r\n- (void)windowDidExpose:(NSNotification *)notification {\r\n\tlifecycleVisible((GoUintptr)self, true);\r\n}\r\n\r\n- (void)windowDidBecomeKey:(NSNotification *)notification {\r\n\tlifecycleFocused((GoUintptr)self, true);\r\n}\r\n\r\n- (void)windowDidResignKey:(NSNotification *)notification {\r\n\tlifecycleFocused((GoUintptr)self, false);\r\n\tif ([NSApp isHidden]) {\r\n\t\tlifecycleVisible((GoUintptr)self, false);\r\n\t}\r\n}\r\n\r\n- (void)windowWillClose:(NSNotification *)notification {\r\n\t// TODO: is this right? Closing a window via the top-left red button\r\n\t// seems to return early without ever calling windowClosing.\r\n\tif (self.window.nextResponder == NULL) {\r\n\t\treturn; // already called close\r\n\t}\r\n\r\n\twindowClosing((GoUintptr)self);\r\n\t[self.window.nextResponder release];\r\n\tself.window.nextResponder = NULL;\r\n}\r\n@end\r\n\r\n@interface AppDelegate : NSObject\u003cNSApplicationDelegate\u003e\r\n{\r\n}\r\n@end\r\n\r\n@implementation AppDelegate\r\n- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {\r\n\tdriverStarted();\r\n\t[[NSRunningApplication currentApplication] activateWithOptions:(NSApplicationActivateAllWindows | NSApplicationActivateIgnoringOtherApps)];\r\n}\r\n\r\n- (void)applicationWillTerminate:(NSNotification *)aNotification {\r\n\tlifecycleDeadAll();\r\n}\r\n\r\n- (void)applicationWillHide:(NSNotification *)aNotification {\r\n\tlifecycleHideAll();\r\n}\r\n@end\r\n\r\nuintptr_t doNewWindow(int width, int height) {\r\n\tNSScreen *screen = [NSScreen mainScreen];\r\n\tdouble w = (double)width / [screen backingScaleFactor];\r\n\tdouble h = (double)height / [screen backingScaleFactor];\r\n\t__block ScreenGLView* view = NULL;\r\n\r\n\tdispatch_sync(dispatch_get_main_queue(), ^{\r\n\t\tid menuBar = [NSMenu new];\r\n\t\tid menuItem = [NSMenuItem new];\r\n\t\t[menuBar addItem:menuItem];\r\n\t\t[NSApp setMainMenu:menuBar];\r\n\r\n\t\tid menu = [NSMenu new];\r\n\t\tNSString* name = [[NSProcessInfo processInfo] processName];\r\n\r\n\t\tid hideMenuItem = [[NSMenuItem alloc] initWithTitle:@\"Hide\"\r\n\t\t\taction:@selector(hide:) keyEquivalent:@\"h\"];\r\n\t\t[menu addItem:hideMenuItem];\r\n\r\n\t\tid quitMenuItem = [[NSMenuItem alloc] initWithTitle:@\"Quit\"\r\n\t\t\taction:@selector(terminate:) keyEquivalent:@\"q\"];\r\n\t\t[menu addItem:quitMenuItem];\r\n\t\t[menuItem setSubmenu:menu];\r\n\r\n\t\tNSRect rect = NSMakeRect(0, 0, w, h);\r\n\r\n\t\tNSWindow* window = [[NSWindow alloc] initWithContentRect:rect\r\n\t\t\t\tstyleMask:NSWindowStyleMaskTitled\r\n\t\t\t\tbacking:NSBackingStoreBuffered\r\n\t\t\t\tdefer:NO];\r\n\t\twindow.styleMask |= NSWindowStyleMaskResizable;\r\n\t\twindow.styleMask |= NSWindowStyleMaskMiniaturizable ;\r\n\t\twindow.styleMask |= NSWindowStyleMaskClosable;\r\n\t\twindow.title = name;\r\n\t\twindow.displaysWhenScreenProfileChanges = YES;\r\n\t\t[window cascadeTopLeftFromPoint:NSMakePoint(20,20)];\r\n\t\t[window setAcceptsMouseMovedEvents:YES];\r\n\r\n\t\tNSOpenGLPixelFormatAttribute attr[] = {\r\n\t\t\tNSOpenGLPFAOpenGLProfile, NSOpenGLProfileVersion3_2Core,\r\n\t\t\tNSOpenGLPFAColorSize,     24,\r\n\t\t\tNSOpenGLPFAAlphaSize,     8,\r\n\t\t\tNSOpenGLPFADepthSize,     16,\r\n\t\t\tNSOpenGLPFAAccelerated,\r\n\t\t\tNSOpenGLPFADoubleBuffer,\r\n\t\t\tNSOpenGLPFAAllowOfflineRenderers,\r\n\t\t\t0\r\n\t\t};\r\n\t\tid pixFormat = [[NSOpenGLPixelFormat alloc] initWithAttributes:attr];\r\n\t\tview = [[ScreenGLView alloc] initWithFrame:rect pixelFormat:pixFormat];\r\n\t\t[window setContentView:view];\r\n\t\t[window setDelegate:view];\r\n\t\t[window makeFirstResponder:view];\r\n\t});\r\n\r\n\treturn (uintptr_t)view;\r\n}\r\n\r\nvoid doShowWindow(uintptr_t viewID) {\r\n\tScreenGLView* view = (ScreenGLView*)viewID;\r\n\tdispatch_async(dispatch_get_main_queue(), ^{\r\n\t\t[view.window makeKeyAndOrderFront:view.window];\r\n\t});\r\n}\r\n\r\nvoid doCloseWindow(uintptr_t viewID) {\r\n\tScreenGLView* view = (ScreenGLView*)viewID;\r\n\tdispatch_sync(dispatch_get_main_queue(), ^{\r\n\t\t[view.window performClose:view];\r\n\t});\r\n}\r\n\r\nvoid startDriver() {\r\n\t[NSAutoreleasePool new];\r\n\t[NSApplication sharedApplication];\r\n\t[NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];\r\n\tAppDelegate* delegate = [[AppDelegate alloc] init];\r\n\t[NSApp setDelegate:delegate];\r\n\t[NSApp run];\r\n}\r\n\r\nvoid stopDriver() {\r\n\tdispatch_async(dispatch_get_main_queue(), ^{\r\n\t\t[NSApp terminate:nil];\r\n\t});\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n",
	"user": {
		"login": "joeblew99",
		"id": 11999859,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-10-13T08:10:24Z",
	"updated_at": "2016-10-13T08:10:24Z"
}
