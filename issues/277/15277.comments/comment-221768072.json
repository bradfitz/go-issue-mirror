{
	"id": 221768072,
	"body": "I am still seeing memory leaks in the production code from which my first test case was distilled. Here is a slightly different distillation that still demonstrates the leaks.\r\n\r\n```\r\n// run\r\n\r\n// Copyright 2016 The Go Authors. All rights reserved.\r\n// Use of this source code is governed by a BSD-style\r\n// license that can be found in the LICENSE file.\r\n\r\npackage main\r\n\r\nimport \"runtime\"\r\n\r\ntype big [10 \u003c\u003c 20]byte\r\n\r\nfunc f(x interface{}, start int64) {\r\n\tx1, x := x, nil\r\n\tif delta := inuse() - start; delta \u003c 9\u003c\u003c20 {\r\n\t\tprintln(\"after alloc: expected delta at least 9 MB, got\", delta\u003e\u003e20, \"MB\")\r\n\t}\r\n\tg(x1)\r\n\tif delta := inuse() - start; delta \u003e 1\u003c\u003c20 {\r\n\t\tprintln(\"after drop: expected delta below 1 MB, got\", delta\u003e\u003e20, \"MB\")\r\n\t}\r\n}\r\n\r\nfunc main() {\r\n\tx := inuse()\r\n\tf(new(big), x)\r\n}\r\n\r\nfunc inuse() int64 {\r\n\truntime.GC()\r\n\tvar st runtime.MemStats\r\n\truntime.ReadMemStats(\u0026st)\r\n\treturn int64(st.Alloc)\r\n}\r\n\r\n//go:noinline\r\nfunc g(interface{}) {}\r\n```\r\n\r\nThis program runs fine with `go run -gcflags=-ssa=0` but with `go run` it complains about 10 MB in use when it expects 1 MB.\r\n\r\nThe code is trying to allocate a local variable x1 initialized from the parameter x and then nil out x, under the theory that, in contrast to x, the local variable will not be kept alive for the lifetime of the function. In particular, after the call to g, x1 is no longer needed and should stop being live, allowing the underlying allocation to be reclaimed. The theory works in the old back end.\r\n\r\nIn the SSA back end, there's a leak. Looking at the liveness analysis that runs on the SSA-generated assembly:\r\n\r\n```\r\n$ go tool compile -live /tmp/x.go\r\n/tmp/x.go:13: live at entry to f: x\r\n/tmp/x.go:15: live at call to inuse: x\r\n/tmp/x.go:16: live at call to printlock: x\r\n/tmp/x.go:16: live at call to printstring: x\r\n/tmp/x.go:16: live at call to printsp: x\r\n/tmp/x.go:16: live at call to printint: x\r\n/tmp/x.go:16: live at call to printsp: x\r\n/tmp/x.go:16: live at call to printstring: x\r\n/tmp/x.go:16: live at call to printnl: x\r\n/tmp/x.go:16: live at call to printunlock: x\r\n/tmp/x.go:18: live at call to g: x\r\n/tmp/x.go:19: live at call to inuse: x\r\n/tmp/x.go:20: live at call to printlock: x\r\n/tmp/x.go:20: live at call to printstring: x\r\n/tmp/x.go:20: live at call to printsp: x\r\n/tmp/x.go:20: live at call to printint: x\r\n/tmp/x.go:20: live at call to printsp: x\r\n/tmp/x.go:20: live at call to printstring: x\r\n/tmp/x.go:20: live at call to printnl: x\r\n/tmp/x.go:20: live at call to printunlock: x\r\n```\r\n\r\nAll those live x are supposed to be OK because I set x to nil. But it appears that even though SSA needs x1 across the initial calls to inuse and printxxx, it does not put x1 itself on the stack. Instead it chooses not to nil x out and simply reload x1 from x later. I infer this from the fact that x1 must be saved somewhere yet does not appear in the liveness bitmaps, and therefore x1 is being reloaded from x rather than being saved. But that has the effect of never nilling out x, and then since x is live for the entire function, so is the allocation I'm trying to make available for garbage collection.\r\n\r\nI don't believe we can reasonably drop the whole-function-lifetime liveness of function parameters at this point in the Go 1.7 cycle, but it's clear we probably need to do that at the start of the Go 1.8 cycle. This is too confusing. (On the other hand, I expect subtle keepalive problems in Go 1.8.)\r\n\r\nI can fix my program by inserting _ = \u0026x at the top of the function. That records x as having its address taken, at which point SSA is no longer comfortable assuming that x1 can be reloaded from x later in the function nor that the store of nil can be elided, and then all the \"right\" things start happening. I will do that, taking this off any kind of critical path and giving us a pattern to suggest to others who run into this.",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-05-26T03:24:08Z",
	"updated_at": "2016-05-26T03:24:08Z"
}
