{
	"id": 135580478,
	"body": "I think the statement here can be made much more precise. Here is my understanding.\r\n\r\nToday, given:\r\n\r\n\ttype T1 struct {\r\n\t\tt2\r\n\t}\r\n\t\r\n\ttype t2 struct {\r\n\t\tX int\r\n\t\tu int\r\n\t}\r\n\r\n\tvar t1 T1\r\n\tv1 := reflect.ValueOf(\u0026t1).Elem()\r\n\tv2 := v1.Field(0)\r\n\tX := v2.Field(0)\r\n\tu := v2.Field(1)\r\n\r\nIn the gc toolchain,\r\n\r\n\tv1.CanSet() == true\r\n\tv1.Type().Field(0).PkgPath == nil // nil usually indicates exported name\r\n\tv2.CanSet() == true // usually unexported cannot be set\r\n\tX.CanSet() == true\r\n\tu.CanSet() == false\r\n\r\nIn the gccgo toolchain,\r\n\r\n\tv1.CanSet() == true\r\n\tv1.Type().Field(0).PkgPath != nil // unexported name \"t2\"\r\n\tv2.CanSet() == false\r\n\tX.CanSet() == false // uses of encoding/json and encoding/xml expect true here\r\n\tu.CanSet() == false\r\n\r\nThe fundamental problem here is that a Go program's source code can refer to t1.X (implicitly t1.t2.X) directly, while the reflect API cannot. The reflect API requires stepping into each field explicitly. The gc implementation allows reflection to set t1.X by recording the field t2 as exported (wrong): that makes it possible to set t1.t2.X (arguably right) but also all of t1.t2 (wrong). The gccgo implementation records t2 as unexported (right), which disallows setting t1.t2.X (arguably wrong) and also disallows setting t1.t2 (right).\r\n\r\nThe proposal is that both implementations record t2 as unexported, and then change reflect to record whether a value like v2 is read-only only because it is an unexported embedded field. In that case, accessing an exported element within would clear the read-only bit. The effect would be that t2 is record as unexported (right), t1.t2.X is settable (arguably right), t1.t2 is not settable (right), and of course t1.t2.u is also not settable (right).\r\n\r\nThat is, under this proposal:\r\n\r\n\tv1.CanSet() == true\r\n\tv1.Type().Field(0).PkgPath != nil // unexported name \"t2\"\r\n\tv2.CanSet() == false\r\n\tX.CanSet() == true\r\n\tu.CanSet() == false\r\n\r\nThat satisfies encoding/xml and encoding/json, disallows most of what is incorrectly allowed in the gc toolchain today, and allows what is arguably incorrectly disallowed in the gccgo toolchain today.\r\n\r\nBoth encoding/json and encoding/xml assume today that if f.PkgPath != nil then the field is unexported and must be ignored. That test needs to be revised to f.PkgPath != nil \u0026\u0026 !f.Anonymous, so that they do try to walk into the embedded fields to look for unexported fields contained within. Any similar external packages would need the same ~1 line change. The new condition is correct both before and after the proposed change, so it could be made by any affected packages independent of the eventual Go 1.6 release.\r\n",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-27T23:15:37Z",
	"updated_at": "2015-08-27T23:15:37Z"
}
