{
	"id": 66090684,
	"body": "\u003ca id=\"c11\"\u003e\u003c/a\u003eComment 11 by **ryguillian**:\n\n\u003cpre\u003eAlright this is getting obnoxious. I wasn't trying to be sarcastic or a pain in the\nneck, I was honestly confused. I'm not an idiot. I know Go doesn't have a 'yield'\nstatement. io.MultiReader.Read returns in the middle of a for loop once it receives\nio.EOF from an underlying reader. Fine. I get it. I know how it works. _As I said_ this\nis _obviously_ a _design decision_ that's _pervasive_ in Go. Okay?\n\nHere's what io.Reader's documentation that a...@golang.org linked to:\n\n'If some data is available but not len(p) bytes, Read conventionally returns what is\navailable instead of waiting for more.'\n\nWhat does 'available' mean? You have to be joking if you tell me this is clear. Also, it\nsays 'conventionally'. MultiReader is already inside of a for loop. Also, why is the\ndata from the next reader in mr.readers 'not available'? Can anybody actually explain\nthe actually design philosophy behind this or is it just made-up and to be intrepidly\ndefended because that's what we say and that's what goes? If that's the attitude at Go,\nfine, but then count you user base one less.\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-01-28T03:55:30Z",
	"updated_at": "2014-12-08T10:40:06Z"
}
