{
	"id": 66061700,
	"body": "\u003ca id=\"c5\"\u003e\u003c/a\u003eComment 5:\n\n\u003cpre\u003eOne non-obvious source of stack requirements is calling variadic functions, such as\nfmt.Println. Even if i is an existing interface{} variable, calling fmt.Println(i)\nallocates (on the stack) a backing array, derives a slice from the array, and passes the\nslice to fmt.Println.\n\nfmt.Println(i)\n\nis essentially\n\na := [1]interface{}{i}\ns := a[:]\nfmt.Println(s...)\n\nThus, this simple program's f1 function requires an 80-byte stack, despite not\nexplicitly declaring any local variables:\n\n$ cat main.go\npackage main\n\nimport \"fmt\"\n\nvar i interface{}\n\nfunc f1() {\n\tfmt.Println(i)\n}\n$ go tool 6g -S -o /dev/null main.go | grep TEXT.*f1\n0000 (main.go:7) TEXT    f1+0(SB),$80-0\n\nIn detail: the 80 bytes (10 quad-words) consist of 40 bytes for implicit locals, and 40\nbytes for the fmt.Println call (the 6g calling convention is that callers are\nresponsible for the stack space for arguments and return values).\n\nThe 40 bytes of implicit locals are 16 bytes for the array of 1 element (an interface{}\nrequires 16 bytes), 16 bytes for the slice (8 byte pointer, 4 byte len, 4 byte cap), and\nIIUC, 8 bytes to spill a register to the stack during the implied construction of s.\nThat register spill is probably a compiler bug.\n\nThe 40 bytes of calling-fmt.Println stack is straightforward to explain. The signature\nis:\nfunc Println(a ...interface{}) (n int, err error)\nwhich needs 16 bytes for the implicit []interface{} argument, 8 bytes for the int return\nvalue (well, 4 bytes, but each return value is 8-byte aligned) and 16 bytes for the\nerror return value.\n\nIt's an obvious waste that the implicit and short-lived s needs 16 bytes as a local\nvariable plus 16 bytes as a call argument. That's probably another compiler bug.\n\nAnother aspect is that the stack space for the implied array, slice and spill do not\nseem to be re-used across repeated calls to variadic functions. Fixing this may be\nnon-trivial to do correctly if the callee can save the implied slice, or the address of\nan implied element, past the lifetime of the call. Still:\n\n$ cat main.go\npackage main\n\nimport \"fmt\"\n\nvar i interface{}\n\nfunc f1() {\n\tfmt.Println(i)\n}\n\nfunc f2() {\n\tfmt.Println(i)\n\tfmt.Println(i)\n}\n\nfunc f3() {\n\tfmt.Println(i)\n\tfmt.Println(i)\n\tfmt.Println(i)\n}\n$ go tool 6g -S -o /dev/null main.go | grep TEXT.*f\n0000 (main.go:7) TEXT    f1+0(SB),$80-0\n0026 (main.go:11) TEXT    f2+0(SB),$120-0\n0076 (main.go:16) TEXT    f3+0(SB),$160-0\u003c/pre\u003e",
	"user": {
		"login": "nigeltao",
		"id": 8565232,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2012-08-19T04:38:41Z",
	"updated_at": "2014-12-08T10:14:34Z"
}
