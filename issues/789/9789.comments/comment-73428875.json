{
	"id": 73428875,
	"body": "syscall.Getdirentries is actually returning EINVAL on OS X, but @rsc added Yosemite work-around code to mask that error away.\r\n\r\nWith my added logging the syscall func is:\r\n\r\n```\r\nfunc ReadDirent(fd int, buf []byte) (n int, err error) {\r\n        // Final argument is (basep *uintptr) and the syscall doesn't take nil.                                                                                             \r\n        // 64 bits should be enough. (32 bits isn't even on 386). Since the                                                                                                 \r\n        // actual system call is getdirentries64, 64 is a good guess.                                                                                                       \r\n        // TODO(rsc): Can we use a single global basep for all calls?                                                                                                       \r\n        var base = (*uintptr)(unsafe.Pointer(new(uint64)))\r\n        n, err = Getdirentries(fd, buf, base)\r\n\r\n        println(\"syscall.ReadDirent\", n, err)\r\n        if err != nil {\r\n                println(\"syscall.ReadDirent == \" + err.Error())\r\n        }\r\n\r\n        // On OS X 10.10 Yosemite, if you have a directory that can be returned                                                                                             \r\n        // in a single getdirentries64 call (for example, a directory with one file),                                                                                       \r\n        // and you read from the directory at EOF twice, you get EOF both times:                                                                                            \r\n        //      fd = open(\"dir\")                                                                                                                                            \r\n        //      getdirentries64(fd) // returns data                                                                                                                         \r\n        //      getdirentries64(fd) // returns 0 (EOF)                                                                                                                      \r\n        //      getdirentries64(fd) // returns 0 (EOF)                                                                                                                      \r\n        //                                                                                                                                                                  \r\n        // But if you remove the file in the middle between the two calls, the                                                                                              \r\n        // second call returns an error instead.                                                                                                                            \r\n        //      fd = open(\"dir\")                                                                                                                                            \r\n        //      getdirentries64(fd) // returns data                                                                                                                         \r\n        //      getdirentries64(fd) // returns 0 (EOF)                                                                                                                      \r\n        //      remove(\"dir/file\")                                                                                                                                          \r\n        //      getdirentries64(fd) // returns ENOENT/EINVAL                                                                                                                \r\n        //                                                                                                                                                                  \r\n        // Whether you get ENOENT or EINVAL depends on exactly what was                                                                                                     \r\n        // in the directory. It is deterministic, just data-dependent.                                                                                                      \r\n        //                                                                                                                                                                  \r\n        // This only happens in small directories. A directory containing more data                                                                                         \r\n        // than fits in a 4k getdirentries64 call will return EOF correctly.                                                                                                \r\n        // (It's not clear if the criteria is that the directory be split across multiple                                                                                   \r\n        // getdirentries64 calls or that it be split across multiple file system blocks.)                                                                                   \r\n        //                                                                                                                                                                  \r\n        // We could change package os to avoid the second read at EOF,                                                                                                      \r\n        // and maybe we should, but that's a bit involved.                                                                                                                  \r\n        // For now, treat the EINVAL/ENOENT as EOF.                                                                                                                         \r\n        if runtime.GOOS == \"darwin\" \u0026\u0026 (err == EINVAL || err == ENOENT) {\r\n                err = nil\r\n        }\r\n\r\n        return\r\n}\r\n```\r\n\r\nBut I thought that the Yosemite issue was fixed?\r\n",
	"user": {
		"login": "bradfitz",
		"id": 2621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-02-08T20:08:34Z",
	"updated_at": "2015-02-08T20:08:34Z"
}
