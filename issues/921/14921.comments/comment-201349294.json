{
	"id": 201349294,
	"body": "I did a bit of experimenting. All of these results are for 4c9a470 (two days ago; forgot to sync).\r\n\r\nFirst, I reproduced @josharian's result using the following patch:\r\n\r\n```\r\ndiff --git a/src/runtime/mbarrier.go b/src/runtime/mbarrier.go\r\nindex 523d890..15244f8 100644\r\n--- a/src/runtime/mbarrier.go\r\n+++ b/src/runtime/mbarrier.go\r\n@@ -14,6 +14,7 @@\r\n package runtime\r\n \r\n import (\r\n+       \"runtime/internal/atomic\"\r\n        \"runtime/internal/sys\"\r\n        \"unsafe\"\r\n )\r\n@@ -123,10 +124,19 @@ func writebarrierptr_nostore1(dst *uintptr, src uintptr) {\r\n        releasem(mp)\r\n }\r\n \r\n+var wb, wbe, wbz uint64\r\n+\r\n // NOTE: Really dst *unsafe.Pointer, src unsafe.Pointer,\r\n // but if we do that, Go inserts a write barrier on *dst = src.\r\n //go:nosplit\r\n func writebarrierptr(dst *uintptr, src uintptr) {\r\n+       if src == 0 {\r\n+               atomic.Xadd64(\u0026wbz, +1)\r\n+       } else if *dst == src {\r\n+               atomic.Xadd64(\u0026wbe, +1)\r\n+       }\r\n+       atomic.Xadd64(\u0026wb, +1)\r\n+\r\n        *dst = src\r\n        if writeBarrier.cgo {\r\n                cgoCheckWriteBarrier(dst, src)\r\ndiff --git a/src/runtime/proc.go b/src/runtime/proc.go\r\nindex d386797..b146fa4 100644\r\n--- a/src/runtime/proc.go\r\n+++ b/src/runtime/proc.go\r\n@@ -208,6 +208,7 @@ func main() {\r\n // os_beforeExit is called from os.Exit(0).\r\n //go:linkname os_beforeExit os.runtime_beforeExit\r\n func os_beforeExit() {\r\n+       println(\"WB\", wb, wbe, wbz)\r\n        if raceenabled {\r\n                racefini()\r\n        }\r\n```\r\n\r\nI get this result:\r\n\r\n```\r\n$ go build -a |\u0026 awk '/^WB/{n+=$2; eq+=$3; z+=$4} END{print n \" \" eq \" \" z}'\r\n14525087 3412554 1422002\r\n```\r\n\r\nThat is, of 14M write barriers, 10% are writing nil and 23.5% are *dst == src (but not writing nil). I separately checked that almost all of the 10% nil writes also have *dst == src.\r\n\r\nWe should probably skip the write barrier earlier if src is nil. Currently we go through quite a bit of work before checking for a nil pointer.\r\n\r\nFocusing on the ones where *dst == src, but src != nil, I profiled where they're coming from using this patch:\r\n\r\n```\r\ndiff --git a/src/runtime/mbarrier.go b/src/runtime/mbarrier.go\r\nindex 523d890..e8ce821 100644\r\n--- a/src/runtime/mbarrier.go\r\n+++ b/src/runtime/mbarrier.go\r\n@@ -127,6 +127,13 @@ func writebarrierptr_nostore1(dst *uintptr, src uintptr) {\r\n // but if we do that, Go inserts a write barrier on *dst = src.\r\n //go:nosplit\r\n func writebarrierptr(dst *uintptr, src uintptr) {\r\n+       if src != 0 \u0026\u0026 *dst == src {\r\n+               cpc := getcallerpc((unsafe.Pointer)(\u0026dst)) - 1\r\n+               f := findfunc(cpc)\r\n+               file, line := funcline(f, cpc)\r\n+               print(\"WBE \", file, \":\", line, \" \", funcname(f), \"\\n\")\r\n+       }\r\n+\r\n        *dst = src\r\n        if writeBarrier.cgo {\r\n                cgoCheckWriteBarrier(dst, src)\r\n```\r\n\r\nThe result is\r\n\r\n```\r\n$ go build -a std |\u0026 awk '/^WBE/{print $2}' logx | sort | uniq -c | sort -nr | head -n 10\r\n  16519 /home/austin/go.dev/src/cmd/compile/internal/gc/typecheck.go:176\r\n  15369 /home/austin/go.dev/src/cmd/compile/internal/gc/dcl.go:58\r\n  15155 /home/austin/go.dev/src/cmd/compile/internal/ssa/sparseset.go:45\r\n  12066 /home/austin/go.dev/src/cmd/compile/internal/gc/dcl.go:753\r\n   8865 /home/austin/go.dev/src/cmd/compile/internal/ssa/value.go:167\r\n   8493 /home/austin/go.dev/src/cmd/compile/internal/ssa/func.go:94\r\n   8206 /home/austin/go.dev/src/cmd/compile/internal/ssa/stackalloc.go:266\r\n   7828 /home/austin/go.dev/src/runtime/mheap.go:603\r\n   7288 /home/austin/go.dev/src/runtime/mheap.go:196\r\n   6871 /home/austin/go.dev/src/runtime/hashmap.go:793\r\n```\r\n\r\nOf these, all but dcl.go:58, dcl.go:753, mheap.go:603, and hashmap.go:793 are appends. @randall77, can we optimize the generated append code so that the path that grows the slice in place doesn't write back the pointer if we're writing to the same slice we're growing? I imagine this would be something like the slicing optimization.\r\n\r\nWe can safely skip the write barrier on mheap.go:603. I'm a little surprised that does equal pointer writes so often. There may be also be an algorithmic improvement here.\r\n\r\nWe could put a conditional around the one in hashmap.go. I think that happens when we're iterating over a map and the iterator stays in the same bucket. I don't totally understand this code; there may be better ways to improve it.",
	"user": {
		"login": "aclements",
		"id": 2688315,
		"type": "User",
		"site_admin": false
	},
	"reactions": {
		"total_count": 1,
		"+1": 1
	},
	"created_at": "2016-03-25T16:23:12Z",
	"updated_at": "2016-03-25T16:23:12Z"
}
