{
	"id": 247265536,
	"body": "\u003e [...] I don't know how to define a portable definition of a canonical file name.\r\n\r\nProbably like [Java does](https://docs.oracle.com/javase/7/docs/api/java/io/File.html#getCanonicalPath()): \"A canonical pathname is both absolute and unique. The precise definition of canonical form is system-dependent\".\r\n\r\n\u003e Perhaps it's a Windows-specific issue.\r\n\r\nI don't think is it. Creating a canonical path involves steps that are applicable to e.g. Linux, too. Again quoting the Java docs: \"This typically involves removing redundant names such as \".\" and \"..\" from the pathname, resolving symbolic links (on UNIX platforms), and converting drive letters to a standard case (on Microsoft Windows platforms)\". Although not explicitly mentioned here, Java also converts short filenames in path to long filenames on Windows as part of canonization.\r\n\r\n\u003e We do have path/filepath.ToSlash which is half of the story.\r\n\r\nI don't think `ToSlash()` does any good here. I'm not talking about canonizing paths across different OSes. I.e. I'm not looking for a way to compare Windows paths to Linux paths or so. That is, a canonical path on Windows can and in fact should contain backslashes instead of slahes, as that's the OS-native way of specifying paths.\r\n\r\n\u003e I think the requirement itself is problematic. Trying to use a path to determine two files are the same portably is inherently impossible.\r\n\r\nI'm not sure it's impossible. But I agree using `stat()` like `SameFile()` does is much safer and cleaner.\r\n\r\nMaybe a better example is where you want to \"clean\" paths input by the user before showing them in some UI.\r\n\r\n\u003e Given that, what's the definition for a canonical path? Every Clean'ed and EvalSymlink'ed path is as canonical as any others.\r\n\r\nThat happens to be the case with the current implementation of `EvalSymlinks()`, yes. But @alexbrainman did not want to document that fact in order to be free to change the implementation some day so that it still evaluates symbolic links, but not resolves short filenames to long filenames on Windows anymore. And then the path returned by `EvalSymlinks()` would not be canonical anymore, and your statement would be wrong.\r\n\r\n\u003e There is no Windows API that would provide that functionality. What we do in filepath.EvalSymlinks is mish and mash.\r\n\r\nWhich is just fine with me. From my point of view Golang could come up with its own definition of what a canonical path should look like for each OS, i.e. what transformations are involved, as long it's a sane and consistent definition.",
	"user": {
		"login": "sschuberth",
		"id": 349154,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-09-15T08:15:44Z",
	"updated_at": "2016-09-15T08:15:44Z"
}
