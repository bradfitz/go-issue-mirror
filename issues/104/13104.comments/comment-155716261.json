{
	"id": 155716261,
	"body": "Why so many people tried to reinvent the console/terminal and failed? Being able to compare two worlds, I don't see that stateful OS API works at all. State belongs to user level. OS should only define who has focus to receive input and filter the critical key combinations that are needed by parent.\r\n\r\n  * \"open serial device and set baud rate\" - x/serial\r\n  * \"entering password\" - ideally it should be readkey/getkey - to process Y/n in one keypress, but this is really hard - see my code below - maybe even impossible to do with terminal abstraction - terminal doesn't process keys like F1, it doesn't return scancodes and if you make TUI menus with shortcuts (like all Linux programs do) - they break when you change keyboard layout - in Far Manager (my \"vimacs\" for Windows) it doesn't happen\r\n  * \"the raw mechanics necessary to implements readline type cli interfaces\" - what mechanics exactly? why readline is different from other console programs that need to receive keys from keyboard and write colored chars at arbitrary location of screen? \r\n  * \"and of course to be a base for more complicated projects\" - it won't be the base, because the basis - the concept of one stream that does it all is flawed - it is impossible to debug and deal with\r\n\r\nMy opinion is that terminals, TTY and all that serial stuff must die for text mode interface. Maybe reengineered from scratch for better latency and removed legacy like MOSH, stripped of features that add to technical debt, but these are specialized products.\r\n\r\nJust for the example of how things are badly broken - this is my attempt to read the key from terminal/console on Windows and Linux.\r\nhttps://bitbucket.org/techtonik/python-pager/src/2936adb19c9407b8e890949f9e88bf4f0461a524/pager.py?at=default\u0026fileviewer=file-view-default#pager.py-196\r\nWhat I see here is that if somebody interrupts my program on Linux while I listen for input, the terminal will be broken with no echo. Also there is no way to peek if there are characters in keyboard input. And users report that this stuff doesn't work on OS X, and piping the output is also broken when there is a terminal readkey call in the program flow.\r\n\r\nI really hate terminal interfaces, sorry. =/ stdin is not enough for user interface not matter what. The read console interface needs to start with user stories and instead of concentrating on that should be done with two wires, separate the stuff into what is practically possible over the terminal and what should use things like https://mosh.mit.edu/ and https://bitbucket.org/libtcod/libtcod and provide support for latter.\r\n\r\nFor me, the user is primary, so if we start with TTY and then at some point discover that https://bitbucket.org/libtcod/libtcod is not possible - that's would be fail - the same fail that the dozen of other packages already did. So, I feel that creating and good library for text mode interfaces for Linux, Windows and ... may be impossible at this point, but what can help is to form an API for a operating system that may not yet exists. Going with plain terminals for something that `libtcod` does is the same as trying to build the house by sticking balls with a chewing gum. That's my point.",
	"user": {
		"login": "techtonik",
		"id": 515889,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-11T09:36:34Z",
	"updated_at": "2015-11-11T09:36:58Z"
}
