{
	"id": 227935762,
	"body": "\u003e The real fix may be to avoid adding -lmingwex -lmingw32 in cmd/go, \r\n\r\nI agree.\r\n\r\nI have been playing with this a while ago. The way I understand build process here (and you can read full gory details of cgo process in $GOROOT/src/cmd/cgo/doc.go), there are 2 steps: 1) each package (that is part of your final executable) is compiled into a compiled form (the bits that go into your $GOPATH/pkg directory); 2) final executable is built from all compiled packages.\r\n\r\nWhen cmd/go runs steps 1, it calls `gcc ... -lmingwex -lmingw32 ...` to resolve all external symbols that you use in this package (pow in this case). This inserts machine code for pow into compiled package file, and it keeps \"pow\" as the function name.\r\n\r\nSo, when it is time to do step 2, the linker will discover that two different compiled packages have function with the same name (pow). It cannot have that.\r\n\r\nI think what needs to happen is the \"resolving pow symbol\" bit should happen during step 2, not step 1.\r\n\r\nYou can stop \"resolving pow symbol\" during step 1 by removing \"-lmingwex -lmingw32\" parameters from that call above.\r\n\r\nI am not sure how to add them during step 2. For \"external\" linking (the default mode), I think gcc will resolve symbols automatically (I had to revert https://go-review.googlesource.com/14472 to make \"go test\" pass in $GOROOT/misc/cgo/test - I still don't know why). For \"internal\" linking, I was toying with idea of calling `gcc --print-file-name=libmingwex.a` and `gcc --print-file-name=libmingw32\r\n.a` and maybe all other external libs supplied via `-l` `#cgo LDFLAGS` and including all returned libraries into final link step. I suspect that is what Ian meant when he said \"handle them as we do libgcc in loadlib in cmd/link/internal/lib.go\".\r\n\r\n\u003e any suggested workarounds?\r\n\r\nI think, if you apply this:\r\n```\r\ndiff --git a/src/cmd/go/build.go b/src/cmd/go/build.go\r\nindex 11a4eab..ddd5655 100644\r\n--- a/src/cmd/go/build.go\r\n+++ b/src/cmd/go/build.go\r\n@@ -3286,7 +3286,7 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofi\r\n \tif goos == \"windows\" {\r\n \t\t// libmingw32 and libmingwex have some inter-dependencies,\r\n \t\t// so must use linker groups.\r\n-\t\tstaticLibs = []string{\"-Wl,--start-group\", \"-lmingwex\", \"-lmingw32\", \"-Wl,--end-group\"}\r\n+\t\t//staticLibs = []string{\"-Wl,--start-group\", \"-lmingwex\", \"-lmingw32\", \"-Wl,--end-group\"}\r\n \t}\r\n \r\n \tcflags := stringList(cgoCPPFLAGS, cgoCFLAGS)\r\ndiff --git a/src/runtime/cgo/cgo.go b/src/runtime/cgo/cgo.go\r\nindex ce0e6a3..1528f51 100644\r\n--- a/src/runtime/cgo/cgo.go\r\n+++ b/src/runtime/cgo/cgo.go\r\n@@ -22,7 +22,7 @@ package cgo\r\n #cgo openbsd LDFLAGS: -lpthread\r\n // we must explicitly link msvcrt, because runtime needs ntdll, and ntdll\r\n // exports some incompatible libc functions. See golang.org/issue/12030.\r\n-#cgo windows LDFLAGS: -lmsvcrt -lm -mthreads\r\n+#cgo windows LDFLAGS: -lm -mthreads\r\n \r\n #cgo CFLAGS: -Wall -Werror\r\n \r\n```\r\nto the current tip, it will work for you. Assuming you are not doing anything fancy - for example, this will not work with \"internal\" linker.\r\n\r\nAlex",
	"user": {
		"login": "alexbrainman",
		"id": 9796621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-06-23T02:48:04Z",
	"updated_at": "2016-06-23T02:48:04Z"
}
