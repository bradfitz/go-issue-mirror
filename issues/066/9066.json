{
	"id": 51289049,
	"number": 9066,
	"state": "closed",
	"title": "math: all_test.go: test failures in TestLog2 on ppc64 (and s390)",
	"body": "by **vogt@linux.vnet.ibm.com**:\n\n\u003cpre\u003eThis is a copy of the bug report from the gcc bugtracker.  See\n\u003ca href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63269\"\u003ehttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=63269\u003c/a\u003e for the mentioned patch.\n\n--\n\n\nDominik Vogt 2014-09-15 14:10:37 UTC\n------------------------------------\nThere are several flaws in the math library test code.  On s390x, the test TestLog2\nfails for three reasons:\n\n1) This part of the test is too strict for i == 0:\n\nfor i := -1074; i \u0026lt;= 1023; i++ { \n  f := Ldexp(1, i) \n  l := Log2(f) \n  if l != float64(i) { \n    t.Errorf(\u0026quot;Log2(2**%d) = %g, want %d\u0026quot;, i, l, i) \n  } \n} \n\nIt should really use the veryclose function() as there is no guarantee that the result\nof this calculation from log10.go is exact:\n\n  return Log(frac)*(1/Ln2) + float64(exp)\n\nWith frac == 0.5 and exp == 1, the result may be just close to 0, not exactly zero:\n\n* If the compiler generated two instructions, one to mulitply and one to add, the result\nis (with a small error delta):\n\n  Product: Log(0.5)*(1/Ln2) = -1 + delta -\u0026gt; rounded to -1\n  Sum: -1 + 1 = 0 -\u0026gt; rounded to 0\n  Result: 0\n\n* If the compiler generates a single multiply and add instruction, only the final result\nis rouced, i.e.\n\n  Product: Log(0.5)*(1/Ln2) = -1 + delta (not rounded)\n  Sum: -1 + delta + 1 = delta -\u0026gt; rounded to delta'\n  Result: delta' != 0\n\nSo, the fix is to use the \u0026quot;veryclose\u0026quot; error tolerance.\n\n2) There's a bug in the tolerance() function:\n\n        if a != 0 { \n                e = e * a \n                if e \u0026lt; 0 { \n                        e = -e \n                } \n        } \n\nThis snippet uses the defective value a but should use the expected value b instead:\n\n        if b != 0 { \n                e = e * b \n                if e \u0026lt; 0 { \n                        e = -e \n                } \n        } \n\nOtherwise, bad things happen for an expected value 0 when the defective value is very\nclose, i.e. they never match.\n\n3) The alike() function does allow an error tolerance.  This kicks in on s390x in the\ncase that the expected value is 0 and the defective value is not identical.\n\n        switch { \n        case IsNaN(a) \u0026amp;\u0026amp; IsNaN(b): \n                return true \n        case a == b: \n                return Signbit(a) == Signbit(b) \n        } \n\n\nA possible fix would be to detect this one situation and return true, and rely on more\nspecific tests to chack that the error is small ebough.\n\n        switch { \n        case IsNaN(a) \u0026amp;\u0026amp; IsNaN(b): \n                return true \n        case a == 0 \u0026amp;\u0026amp; !IsNaN(b) \u0026amp;\u0026amp; !IsInf(b, 0): \n                // allow deviations when the expected value is zero\n                return true \n        case a == b: \n                return Signbit(a) == Signbit(b) \n        }\n\n\nComment 3 Ian Lance Taylor 2014-11-05 03:54:14 UTC\n--------------------------------------------------\nFirst, let me say that this code is in the Go master library and must be fixed there. \nIt might be more effective to discuss it on the Go issue tracker at\n\u003ca href=\"http://golang.org/issue\"\u003ehttp://golang.org/issue\u003c/a\u003e.\n\nI don't agree with your argument for item 1.  You say that the wrong result happens when\nusing a fused multiply-add instruction.  The math library is compiled with\n-ffp-contract=off (see MATH_FLAG in configure.ac and Makefile.am), so the compiler\nshould not be generating a fused multiply-add instruction.\n\nI'm not entirely persuaded by your argument for item 2.  Zero is a special value.  When\nwe expect a zero, we should get a zero, not something close to zero.  I don't think this\nchange is correct in general.  It may be correct for some specific cases, but then we\nneed to investigate those.\n\nItem 3 is the same sort of thing: when we expect zero, we should, in general, get\nexactly zero.\n\n\nComment 4 Dominik Vogt 2014-11-05 14:34:38 UTC\n----------------------------------------------\nregarding 2)\n\n\u0026gt; I'm not entirely persuaded by your argument for item 2. ...\n\nHm, good that you doubted it, because the actual mistake is somehwere else:  The\nunpatched code has\n\n  if l != float64(i)\n\nbut if you want to use a tolerance here this must become\n\n  if !veryclose(float64(i), l) {\n\nWith the argument reversed.  This could/should be cleaned up by renaming the arguments\nof the tolerance() function, e.g. a -\u0026gt; expected, b -\u0026gt; result, e -\u0026gt; maxerr.\n\n\u0026gt; Zero is a special\n\u0026gt; value.  When we expect a zero, we should get a zero, not something close to\n\u0026gt; zero.  I don't think this change is correct in general.  It may be correct for\n\u0026gt; some specific cases, but then we need to investigate those.\n\nActually, this has nothing to do with 0 being special here, abut with scaling of the\nallowed error: Multiplying it by 0 yields zero error tolerance, so the tolerance()\nfunction does not do that.\n\n--\u0026gt; This chunk is not necessary, but a (separate) cleanup patch might help to avoid\nfuture confusion.\n\n\nComment 5 Dominik Vogt 2014-11-05 16:47:03 UTC\n----------------------------------------------\n\nregarding 1)\n\nMy earlier explanation of the problem was wrong.  Multiply and add is not generated; it\nprobably only was in the artificial test case that I made and certainly did not compile\nwith -ffp-contract=off.\n\nIn this calculation in log2(),\n\n  Log(frac)*(1/Ln2) + float64(exp)\n\nGcc does constant folding for (1/Ln2) and generates a multiply instruction and then adds\nthe second term.  Same result if you write \u0026quot;*Log2E\u0026quot; instead of\n\u0026quot;*(1/Ln2)\u0026quot;).  But with\n\n  Log(frac)/Ln2 + float64(exp)\n\nit generates a divide instruction.  The multiplication and the division yield results\nthat differ in the least significant bit, and I don't see how this could be prevented in\ngeneral; it's just an artifact of the floating point format.  I've verified that the\nconstants Ln2, 1/Ln2 and Log2E are bit correct.\n\nThe \u0026quot;easy\u0026quot; way to fix this is increasing the allowed tolerance as my patch\ndoes (note that the arguments of the veryclose() call need to be swapped, see previous\ncomment).\n\nThe \u0026quot;right\u0026quot; way to fix this is to calculate platform specific ULPs for all the\nalgorithms from the math library and use these.  That's what glibc does.\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		}
	],
	"comments": 4,
	"closed_at": "2015-07-15T05:35:37Z",
	"created_at": "2014-11-06T10:16:57Z",
	"updated_at": "2016-07-18T19:45:24Z",
	"milestone": {
		"id": 905105,
		"number": 1,
		"title": "Go1.5"
	}
}
