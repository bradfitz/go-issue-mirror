{
	"id": 246662744,
	"body": "I don't think named input parameter binding is problem, you can use named input parameter in you statement string as long as your database support it. The underlying driver doesn't need to know the name, it can just treat named binding as positional binding and let the database server handle it. For example, [go-oci8](https://github.com/mattn/go-oci8) support named bind with `database/sql`, and it just use a [positional binding](https://github.com/mattn/go-oci8/blob/master/oci8.go#L871) under the hood. Note that placeholder can be numbered, named or not.\r\n\r\nThe only problem I can see is portability across database. For that you will also need a uniformed named placeholder format, which will inevitably need to do string substitution in the driver if the database doesn't support named binding or use a different format. This can already be done in a third-party helper library like [sqlx](https://github.com/jmoiron/sqlx) now.\r\n\r\nAs for output parameter binding, there are three problems now as I can see:\r\n\r\n- We can use a pointer to value as a argument supplied to `Exec()` and `Query()` for value output parameter, and database drivers can infer the database type from value type then doing the binding and store back the result in the pointer. The problem here is that, in `database/sql`, all args are converted to `database/sql/driver.Value` then pass to the underlying database driver, and `Value` [doesn't allow](https://godoc.org/database/sql/driver#Value) a pointer type, and will even do a auto-dereference with the default converter or use `database/sql/driver.IsValue()` to check that for custom `Valuer`. This can be work aroud in the driver by implement a custom [`ColumnConverter`](https://godoc.org/database/sql/driver#ColumnConverter) on `*Stmt`, but that doesn't work for all situation. A better solution will be create a `OutputValue` type as a pointer, and implement the [`Valuer`](https://godoc.org/database/sql/driver#Valuer) interface, then modify `database/sql/driver.IsValue()` to accept that.\r\n\r\n- For output `ref cursor`, we can't just use a pointer for drivers to infer its type, we will need a special type here. This special type could be merge with the above `OutputValue` type. Note that `ref cursor`'s result will be return as a result set and doesn't need to store in the argument passed to `Query()`.\r\n\r\n- Finally, some output parameter could have no placeholder in the statement. For example, when calling a function (not stored procedure) with return values, the return values will not have placeholder in our call statement. Another example will be something like `SELECT id, CURSOR(SELECT * FROM table_2) FROM table_1 where id=100;`, the cursor here is a output parameter without placeholder. For this problem, we could put extra arguments after those with placeholder in `Exec()` and `Query()`. The problem is that the database may not numbered the parameters in this order, but caller can always arrange the arguments' order base on which database they use.\r\n\r\nFor database specific types, I think is better leave to database drivers and modify `database/sql/driver.IsValue()` to accept them. I will add some comment in #12383.",
	"user": {
		"login": "noblehng",
		"id": 6649504,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-09-13T12:15:57Z",
	"updated_at": "2016-09-13T12:15:57Z"
}
