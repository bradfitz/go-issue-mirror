{
	"id": 108105133,
	"number": 12737,
	"state": "closed",
	"title": "x/net/http2: Exporting h2 connection setup",
	"body": "Issue from old http2 issue tracker: https://github.com/bradfitz/http2/issues/69\r\n\r\n### Some initial context\r\n\r\nsoheilhy have written cmux (https://github.com/soheilhy/cmux), and I have written serve2/serve2d (https://github.com/joushou/serve2d). These \"protocol multiplexers\" read some data from a connection, identifies it with some preprovided detection mechanisms, and feeds the result as a buffered net.Conn to a handler that should support the protocol. In case of serve2d, TLS is also handled by that machinery, leaving only a buffered net.Conn implementation, and the ability to inquire about transport information, such as ALPN information from TLS, but *tls.Conn's are never exposed, as I need to feed the data I read back when the protocol is about to be handled.\r\n\r\n### Our issue\r\n\r\nCurrently, the http lib(s) only provide a single way to handle HTTP connections, and that's through serving a net.Listener. This means that, to feed http/1.1 connections, one must have \"fake\" net.Listener stuffing connections into the http packages own server loop. The HTTP server logic then directly checks if the receives conn is a *tls.Conn, in which case it performs some setup, checks if there are hooks for the ALPN (called NPN in the source), and calls them if necessary. This means that if you are not feeding it a *tls.Conn, either due to using a different implementation, or due just doing something weird and different (like me), things won't work as intended. For HTTP/1.1, this only results in http.Request's TLS field not being set, but that is only a minor inconvenience, as the information can be retrieved through other means.\r\n\r\nWith h2, however, it is not possible to start the protocol without the http package knowing about the TLS wrapping, effectively making it impossible to start a h2 session using x/net/http2 when you're not using crypto/tls's tls.Conn. For serve2d, the result is that, while I can easily forward traffic to a real h2 server by just wrapping the traffic in a TLS client and requesting h2 as NextProto, the builtin web server (a convenience feature) is only capable of serving HTTP/1.1.\r\n\r\n### A solution: Expose HandleConn\r\n\r\nSolheilhy suggested in the old http2 issue tracker to expose Server.handleConn. This would allow one to provide an arbitrary net.Conn to start h2 upon, without http2 worrying about the TLS part (all TLS checks are only run if the provided net.Conn is actually a *tls.Conn). To copy his example from the old bug report, a server loop could then be made manually like this:\r\n\r\n```go\r\ns := \u0026http.Server{\r\n    Handler: \u0026myHandler{},\r\n}\r\ns2 := \u0026http2.Server{}\r\nfor {\r\n    c, err := l.Accept()\r\n    if err != nil {\r\n        if terr, ok := err.(net.Error); ok \u0026\u0026 terr.Temporary() {\r\n            continue\r\n        }\r\n        return\r\n    }\r\n    go s2.HandleConn(s, c, s.Handler)\r\n}\r\n```\r\n### Another solution: Introduce a \"NewH2Conn\"\r\n\r\nPersonally, I would also like this changed for the old http package, allowing you to start both http/1.1 and h2 given only a net.Conn. To do this, I would change Server.handleConn to Server.NewH2Conn, which instead of calling Server.serve, would return the serverConn (most likely also exposed as ServerConn), upon which one could call Serve to start the loop manually. This API could also be used as the \"advanced\" method, where h2c could potentially be exposed (previous discussions seem to indicate that h2c is not wanted by default). The effective result would be that one could manually start a h2 connection on a connection with TLS handled without being a *tls.Conn like so:\r\n\r\n```go\r\ns := \u0026http.Server{\r\n    Handler: \u0026myHandler{},\r\n}\r\ns2 := \u0026http2.Server{}\r\nfor {\r\n    c, err := l.Accept()\r\n    if err != nil {\r\n        if terr, ok := err.(net.Error); ok \u0026\u0026 terr.Temporary() {\r\n            continue\r\n        }\r\n        return\r\n    }\r\n    h2 := s2.NewH2Conn(s, c, s.Handler)\r\n    go h2.Serve()\r\n}\r\n```\r\n\r\nOne could then also expose a NewH1Conn or similar from the net/http package, exposing the serve() server loop there as Serve as well, making things nicely uniform:\r\n\r\n```go\r\ns := \u0026http.Server{\r\n    Handler: \u0026myHandler{},\r\n}\r\nfor {\r\n    c, err := l.Accept()\r\n    if err != nil {\r\n        if terr, ok := err.(net.Error); ok \u0026\u0026 terr.Temporary() {\r\n            continue\r\n        }\r\n        return\r\n    }\r\n    h1 := s.NewH1Conn(s, c, s.Handler)\r\n    go h1.Serve()\r\n}\r\n```\r\n\r\nMy fork of http2 (https://github.com/joushou/http2) implements NewH2Conn, and have been working flawlessly at serving HTTP2 from my own servers. The exposeserve branch implements my solution, the exposehandleconn branch implements solheilhy's solution, and master includes both exposeserve and an import adjustment commit for easy usage.\r\n\r\n### A third solution: Use an interface instead of asserting *tls.Conn\r\n\r\nOne could change instead of asserting a *tls.Conn, assert an interface that could be implemented easily externally.\r\n\r\n### Final words\r\n\r\nI realize that this request might only fit me and solheilhy's isolated use case, but I do not see any issues in exposing this functionality. Right now, a lot of http functionality seems \"closed off\", this specific issue being my biggest obstacle. One of the things I love about the Go standard and x libs, is how much it allows you to poke around, and implement things easily that would have taken unfeasible amounts of time and research without those libraries. I'm hoping that the HTTP packages could also allow for this kind of tinkering in the future.\r\n\r\nI'd love to help if there's anything I can do.",
	"user": {
		"login": "joushou",
		"id": 176245,
		"type": "User",
		"site_admin": false
	},
	"assignee": {
		"login": "bradfitz",
		"id": 2621,
		"type": "User",
		"site_admin": false
	},
	"comments": 2,
	"closed_at": "2016-02-03T16:58:10Z",
	"created_at": "2015-09-24T10:46:40Z",
	"updated_at": "2016-02-03T16:58:10Z",
	"milestone": {
		"id": 1067491,
		"number": 22,
		"title": "Unreleased"
	}
}
