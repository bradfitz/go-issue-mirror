{
	"id": 215041461,
	"body": "I've added some debug prints:\r\n\r\n```\r\ncpu% go test -v -run TestTransportRemovesDeadIdleConnections\r\n=== RUN   TestTransportRemovesDeadIdleConnections\r\nnewFD /net/tcp/11 local 127.0.0.1:60699 remote \u003cnil\u003e\r\nnewFD /net/tcp/18 local 127.0.0.1:60699 remote 127.0.0.1:39558\r\nnewFD /net/tcp/12 local 127.0.0.1:39558 remote 127.0.0.1:60699\r\nreadLoop: Peek\r\nRead: /net/tcp/12\r\nRead: /net/tcp/18\r\nRead: /net/tcp/18 -\u003e 132\r\nRead: /net/tcp/18\r\nRead: /net/tcp/12 -\u003e 132\r\nreadLoop: numExpectedResponses: 1\r\nreadLoop: Peek\r\nRead: /net/tcp/12\r\ncloseConnChan\r\nClose: /net/tcp/18\r\nHangup: write /net/tcp/11/listen: inappropriate use of fd\r\nwaitCondition: timed out\r\nClose: /net/tcp/12\r\nHangup\r\nRead: /net/tcp/12 -\u003e EOF\r\nRead: /net/tcp/18 -\u003e read /net/tcp/18/data: Hangup\r\nreadLoop: numExpectedResponses: 0\r\nreadLoop: returned\r\nremoveIdleConn\r\nClose: /net/tcp/18\r\n--- FAIL: TestTransportRemovesDeadIdleConnections (3.37s)\r\n\ttransport_test.go:480: Transport didn't notice idle connection's death.\r\n\t\tbefore: [\"|http|127.0.0.1:60699\"]\r\n\t\t after: [\"|http|127.0.0.1:60699\"]\r\nFAIL\r\nexit status: 'http.test 740549: 1'\r\nFAIL\tnet/http\t3.425s\r\n```\r\n\r\nThe server listens on /net/tcp/11. The client opens a connection on /net/tcp/12 which is accepted by the server on /net/tcp/18.\r\n\r\nIn [readLoop](https://github.com/golang/go/blob/2e30218/src/net/http/transport.go#L1160), on the first iteration (numExpectedResponses=1), the client calls [Peek(1)](https://github.com/golang/go/blob/2e30218/src/net/http/transport.go#L1189) and reads 132 bytes. Then, the server closes the connection on his side. On the second iteration (numExpectedResponses=0), the client calls [Peek(1)](https://github.com/golang/go/blob/2e30218/src/net/http/transport.go#L1189), but the [Read](https://github.com/golang/go/blob/2e30218/src/net/fd_plan9.go#L79) never returns. Consenquently, we never reach the \"[numExpectedResponses == 0](https://github.com/golang/go/blob/2e30218/src/net/http/transport.go#L1195)\" test to leave readLoop.\r\n\r\nThis happens because server closes the connection on his side (/net/tcp/18), but the connection is still open on client's side (/net/tcp/12).\r\n\r\nThis issue can be reproduced independently of Go, like this:\r\n\r\nListen on port 8080:\r\n\r\n```\r\n% aux/listen1 -v tcp!127.1!8080 cat\r\n```\r\n\r\nConnect to port 8080:\r\n\r\n```\r\n% netdial tcp!127.1!8080\r\n```\r\n\r\nFigure out what is the connection file on the server side:\r\n\r\n```\r\n% for(i in /net/tcp/*){if(grep 8080 $i/local \u003e/dev/null \u003e[2=1] \u0026\u0026 grep ::!0 $i/remote \u003e/dev/null \u003e[2=1]){echo $i}}\r\n/net/tcp/11\r\n```\r\n\r\nFigure out what is the connection file on the client side:\r\n\r\n```\r\n% for(i in /net/tcp/*){if(grep 8080 $i/remote \u003e/dev/null \u003e[2=1]){echo $i}}\r\n/net/tcp/12\r\n```\r\n\r\nClose the connection from the server side:\r\n\r\n```\r\n% echo hangup \u003e/net/tcp/11/ctl\r\n```\r\n\r\nThe connection on the client side is still on \"established\" state:\r\n\r\n```\r\n% cat /net/tcp/12/status\r\nEstablished qin 0 qout 0 rq 0.0 srtt 0 mdev 0 sst 1048560 cwin 32688 swin 1048560\u003e\u003e4 rwin 1048560\u003e\u003e4 qscale 4 timer.start 10 timer.count 10 rerecv 0 katimer.start 2400 katimer.count 1016\r\n```\r\n\r\nClosing the connection with \"hangup\" is supposed to send a RST to the other side. I'm not sure why the connection remains in \"established\" state. I'll investigate.\r\n\r\nFYI @bradfitz ",
	"user": {
		"login": "0intro",
		"id": 6043744,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-04-27T10:21:25Z",
	"updated_at": "2016-04-27T10:23:08Z"
}
