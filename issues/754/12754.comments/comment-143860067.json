{
	"id": 143860067,
	"body": "\u003e @adg On a personal note, I am not inspired by the examples in this proposal. In particular, the example showing returning an error is a classic example of bad style (you should always return error values, not values of concrete types that implement error). This weakens the proposal as a whole.\r\n\r\nThat is a good point, perhaps I should alter the example not to use error. It was simply a very simple illustration of the idea. That said, the standard library seems to _strongly_ prefer baretypes for everything _but_ error, and as I mentioned this would encourage that practice.\r\n\r\n\r\nHere is another, perhaps more compelling example based how we use [container/heap](https://golang.org/pkg/container/heap/#Interface) today.\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n\t\"container/heap\"\r\n\t\"fmt\"\r\n)\r\n\r\n// An IntHeap is a min-heap of ints.\r\ntype IntHeap []int\r\n\r\nfunc (h IntHeap) Len() int            { return len(h) }\r\nfunc (h IntHeap) Less(i, j int) bool  { return h[i] \u003c h[j] }\r\nfunc (h IntHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\r\nfunc (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\r\nfunc (h *IntHeap) Pop() interface{} {\r\n\told := *h\r\n\tn := len(old)\r\n\tx := old[n-1]\r\n\t*h = old[0 : n-1]\r\n\treturn x\r\n}\r\n\r\nfunc main() {\r\n\tvar h IntHeap\r\n\theap.Init(h)\r\n\theap.Push(h, 1)\r\n\theap.Push(h, 2)\r\n\tfmt.Println(\"Hello world: \", heap.Pop(h))\r\n\r\n\t// TYPE SAFTEY HAS ABANDONED ME!\r\n\th.Push(\"1\")\r\n\tfmt.Println(\"Hello world: \", heap.Pop(h))\r\n}\r\n```\r\n\r\nYIKES! While a viable implementation all of our beautiful type safety just went out the window.\r\n\r\nNow compare this with changing the interface matching.\r\n```\r\npackage main\r\n\r\nimport (\r\n\t\"container/heap\"\r\n\t\"fmt\"\r\n)\r\n\r\n// An IntHeap is a min-heap of ints.\r\ntype IntHeap []int\r\n\r\nfunc (h IntHeap) Len() int           { return len(h) }\r\nfunc (h IntHeap) Less(i, j int) bool { return h[i] \u003c h[j] }\r\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\r\nfunc (h *IntHeap) Push(x int)        { *h = append(*h, x) }\r\nfunc (h *IntHeap) Pop() int {\r\n\told := *h\r\n\tn := len(old)\r\n\tx := old[n-1]\r\n\t*h = old[0 : n-1]\r\n\treturn x\r\n}\r\n\r\nfunc main() {\r\n\tvar h IntHeap\r\n\theap.Init(h)\r\n\theap.Push(h, 1)\r\n\theap.Push(h, 2)\r\n\tfmt.Println(\"Hello world: \", heap.Pop(h))\r\n\r\n\t// NO PROBLEM, WON'T COMPILE!\r\n\t// But since int is an interface{}, we can compile the this once the below line is commented out.\r\n\th.Push(\"1\")\r\n\tfmt.Println(\"Hello world: \", heap.Pop(h))\r\n}\r\n```\r\n\r\nWe are not getting generics or anything like that, but we are at least a little more typesafe.\r\n\r\nI will get to answering minux's questions asap.\r\n\r\n\r\n",
	"user": {
		"login": "rfliam",
		"id": 718129,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-09-28T20:06:04Z",
	"updated_at": "2015-09-28T20:22:20Z"
}
