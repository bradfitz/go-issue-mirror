{
	"id": 66072902,
	"body": "\u003ca id=\"c3\"\u003e\u003c/a\u003eComment 3:\n\n\u003cpre\u003eTime to decide. \n\nIn the same 8-million-line corpus that I used for the return analysis, I looked for\nliterals using net types. There are hardly any, and most do use tags correctly. 6 of 15\nnet.IPAddr literals are missing field tags, 9 of 40 net.TCPAddr literals, and 44 of 89\nnet.UDPAddr literals. I think this is minor enough that we can add the zone to these\nstructs.\n\nThat is, Zone makes the cut.\n\nHere's what I think should change / stay the same. I created this list without reference\nto Mikio's CL; we should discuss the ones that disagree.\n\nFunctions that do accept address+zone strings.\n\ndial.go:188: func Dial(net, addr string) (Conn, error) {\ndial.go:195: func DialOpt(addr string, opts ...DialOption) (Conn, error) {\ndial.go:235: func DialTimeout(net, addr string, timeout time.Duration) (Conn, error) {\ndial.go:295: func Listen(net, laddr string) (Listener, error) {\ndial.go:312: func ListenPacket(net, laddr string) (PacketConn, error) {\niprawsock.go:28: func ResolveIPAddr(net, addr string) (*IPAddr, error) {\nipsock.go:74: func SplitHostPort(hostport string) (host, port string, err error) {\nipsock.go:141: func JoinHostPort(host, port string) string {\ntcpsock.go:31: func ResolveTCPAddr(net, addr string) (*TCPAddr, error) {\nudpsock.go:35: func ResolveUDPAddr(net, addr string) (*UDPAddr, error) {\n\nFunctions that do not accept address+zone strings.\n\ndial.go:55: func Network(net string) DialOption {\ninterface.go:112: func InterfaceByName(name string) (*Interface, error) {\nip.go:618: func ParseIP(s string) IP {\niprawsock_plan9.go:70: func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn,\nerror) {\niprawsock_plan9.go:82: func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error) {\niprawsock_posix.go:164: func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn,\nerror) {\niprawsock_posix.go:192: func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error) {\nlookup.go:13: func LookupHost(host string) (addrs []string, err error) {\nlookup.go:56: func LookupIP(host string) (addrs []IP, err error) {\nlookup.go:61: func LookupPort(network, service string) (port int, err error) {\nlookup.go:69: func LookupCNAME(name string) (cname string, err error) {\nlookup.go:82: func LookupSRV(service, proto, name string) (cname string, addrs []*SRV,\nerr error) {\nlookup.go:87: func LookupMX(name string) (mx []*MX, err error) {\nlookup.go:92: func LookupNS(name string) (ns []*NS, err error) {\nlookup.go:97: func LookupTXT(name string) (txt []string, err error) {\nlookup.go:103: func LookupAddr(addr string) (name []string, err error) {\nmac.go:39: func ParseMAC(s string) (hw HardwareAddr, err error) {\ntcpsock_plan9.go:81: func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error) {\ntcpsock_plan9.go:170: func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error) {\ntcpsock_posix.go:140: func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error) {\ntcpsock_posix.go:279: func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error) {\nudpsock_plan9.go:115: func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error) {\nudpsock_plan9.go:170: func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error) {\nudpsock_plan9.go:198: func ListenMulticastUDP(net string, ifi *Interface, gaddr\n*UDPAddr) (*UDPConn, error) {\nudpsock_posix.go:163: func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error) {\nudpsock_posix.go:187: func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error) {\nudpsock_posix.go:207: func ListenMulticastUDP(net string, ifi *Interface, gaddr\n*UDPAddr) (*UDPConn, error) {\nunixsock.go:37: func ResolveUnixAddr(net, addr string) (*UnixAddr, error) {\nunixsock_plan9.go:82: func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn,\nerror) {\nunixsock_plan9.go:97: func ListenUnix(net string, laddr *UnixAddr) (*UnixListener,\nerror) {\nunixsock_plan9.go:139: func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn,\nerror) {\nunixsock_posix.go:228: func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn,\nerror) {\nunixsock_posix.go:255: func ListenUnix(net string, laddr *UnixAddr) (*UnixListener,\nerror) {\nunixsock_posix.go:344: func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn,\nerror) {\n\nTypes without explicit zone.\n\ndial.go:13: type DialOption interface {\ndial_test.go:150: type DialErrorTest struct {\ndnsclient.go:13: type DNSError struct {\ndnsclient.go:166: type SRV struct {\ndnsclient.go:225: type MX struct {\ndnsclient.go:249: type NS struct {\ninterface.go:20: type Interface struct {\ninterface.go:28: type Flags uint\nip.go:30: type IP []byte\nip.go:33: type IPMask []byte\nip.go:594: type ParseError struct {\niprawsock_plan9.go:16: type IPConn struct {\niprawsock_posix.go:56: type IPConn struct {\nipsock.go:65: type InvalidAddrError string\nmac.go:14: type HardwareAddr []byte\nnet.go:55: type Addr interface {\nnet.go:63: type Conn interface {\nnet.go:210: type Error interface {\nnet.go:219: type PacketConn interface {\nnet.go:265: type Listener interface {\nnet.go:282: type OpError struct {\nnet.go:343: type AddrError struct {\nnet.go:367: type UnknownNetworkError string\nnet.go:374: type DNSConfigError struct {\ntcpsock_plan9.go:18: type TCPConn struct {\ntcpsock_plan9.go:106: type TCPListener struct {\ntcpsock_posix.go:63: type TCPConn struct {\ntcpsock_posix.go:222: type TCPListener struct {\nudpsock_plan9.go:18: type UDPConn struct {\nudpsock_posix.go:56: type UDPConn struct {\nunixsock.go:10: type UnixAddr struct {\nunixsock_plan9.go:17: type UnixConn struct {\nunixsock_plan9.go:93: type UnixListener struct{}\nunixsock_posix.go:107: type UnixConn struct {\nunixsock_posix.go:248: type UnixListener struct {\n\nTypes with explicit zone.\n\niprawsock.go:10: type IPAddr struct {\ntcpsock.go:10: type TCPAddr struct {\nudpsock.go:14: type UDPAddr struct {\n\nNot yet decided.\n\nip.go:36: type IPNet struct {\nip.go:632: func ParseCIDR(s string) (IP, *IPNet, error) {\n\nIn the case of ParseCIDR and IPNet, you've proposed to add zone there, but I don't\nunderstand what it means. Why is it important? How should a caller use the IPNet if a\nZone is involved? The purpose of the IPNet struct is to provide a Contains method, and\nyet the Contains method cannot use the Zone to make its decision. Is there any document\nexplaining the syntax of CIDR addresses with zones and what they mean?\u003c/pre\u003e",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-03-13T20:21:25Z",
	"updated_at": "2014-12-08T10:24:00Z"
}
