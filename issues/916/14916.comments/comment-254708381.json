{
	"id": 254708381,
	"body": "@robpike:\n\nSuppose dot is a \\[\\]T with len==1 and there is a (\\*T) M() method (pointer receiver).\nToday, `{{range .}} {{.M}} {{end}}` works but `{{with index . 0}} {{.M}} {{end}}` fails to find the method.\n\nThe problem is that the implementation of range ends up trying\n\n    x := reflect.ValueOf(slice).Index(0)\n    x.MethodByName(\"M\")\n\nwhile the use of index induces a conversion from reflect.Value to interface{} and back, so\n\n    x := reflect.ValueOf(slice).Index(0)\n    x = reflect.ValueOf(x.Interface())\n    x.MethodByName(\"M\")\n\nThat round trip makes x not addressable, so MethodByName cannot do an implicit address-of, so it cannot get at the pointer-receiver method M.\n\nThe options I see are:\n\n1. Leave everything alone and live with the inconsistency.\n\n2. Define that registered template functions can take reflect.Values as arguments and return them as results, with the effect that it is possible to bypass the lossy round trip to interface{}. This is similar to how fmt.Printf treats printing reflect.ValueOf(x) the same as printing x. Then index could be changed to work on reflect.Values and bypass the round trip issue. Then {{with index . 0}} would work identically to {{range .}} (assuming slice of length 1). Templates that formerly failed could start working.\n\n3. Change range to do the round trip as well, bringing it in line with index by breaking the method lookup. Templates that formerly worked could stop working.\n\nHere is the diff for 2 (and then the obvious changes to func index to make it take and return reflect.Value instead of interface{}):\n\n```\ndiff --git a/src/text/template/exec.go b/src/text/template/exec.go\nindex 8e5ad93..2af447f 100644\n--- a/src/text/template/exec.go\n+++ b/src/text/template/exec.go\n@@ -661,7 +661,11 @@ func (s *state) evalCall(dot, fun reflect.Value, node parse.Node, name string, a\n \t\ts.at(node)\n \t\ts.errorf(\"error calling %s: %s\", name, result[1].Interface().(error))\n \t}\n-\treturn result[0]\n+\tv := result[0]\n+\tif v.Type() == reflect.TypeOf(reflect.Value{}) {\n+\t\tv = v.Interface().(reflect.Value)\n+\t}\n+\treturn v\n }\n \n // canBeNil reports whether an untyped nil can be assigned to the type. See reflect.Zero.\n@@ -682,6 +686,9 @@ func (s *state) validateType(value reflect.Value, typ reflect.Type) reflect.Valu\n \t\t}\n \t\ts.errorf(\"invalid value; expected %s\", typ)\n \t}\n+\tif typ == reflect.TypeOf(reflect.Value{}) \u0026\u0026 value.Type() != typ {\n+\t\treturn reflect.ValueOf(value)\n+\t}\n \tif typ != nil \u0026\u0026 !value.Type().AssignableTo(typ) {\n \t\tif value.Kind() == reflect.Interface \u0026\u0026 !value.IsNil() {\n \t\t\tvalue = value.Elem()\n@@ -743,6 +750,10 @@ func (s *state) evalArg(dot reflect.Value, typ reflect.Type, n parse.Node) refle\n \t\tif typ.NumMethod() == 0 {\n \t\t\treturn s.evalEmptyInterface(dot, n)\n \t\t}\n+\tcase reflect.Struct:\n+\t\tif typ == reflect.TypeOf(reflect.Value{}) {\n+\t\t\treturn reflect.ValueOf(s.evalEmptyInterface(dot, n))\n+\t\t}\n \tcase reflect.String:\n \t\treturn s.evalString(typ, n)\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n```\n\nHere is the diff for 3:\n\n```\ndiff --git a/src/text/template/exec.go b/src/text/template/exec.go\nindex 8e5ad93..2b306b9 100644\n--- a/src/text/template/exec.go\n+++ b/src/text/template/exec.go\n@@ -327,7 +327,7 @@ func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) {\n \t\t\tbreak\n \t\t}\n \t\tfor i := 0; i \u003c val.Len(); i++ {\n-\t\t\toneIteration(reflect.ValueOf(i), val.Index(i))\n+\t\t\toneIteration(reflect.ValueOf(i), reflect.ValueOf(val.Index(i).Interface()))\n \t\t}\n \t\treturn\n \tcase reflect.Map:\n```\n\nThoughts?",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-10-19T04:36:52Z",
	"updated_at": "2016-10-19T04:36:52Z"
}
