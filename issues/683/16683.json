{
	"id": 170986508,
	"number": 16683,
	"state": "closed",
	"title": "crypto/rsa: some valid P1v1.5 signatures rejected by VerifyPKCS1v15",
	"body": "Please answer these questions before submitting your issue. Thanks!\r\n\r\n### What version of Go are you using (`go version`)?\r\n\r\nI'm using `go version go1.6.2 darwin/amd64`\r\n\r\n### What operating system and processor architecture are you using (`go env`)?\r\n\r\n    GOARCH=\"amd64\"\r\n    GOBIN=\"\"\r\n    GOEXE=\"\"\r\n    GOHOSTARCH=\"amd64\"\r\n    GOHOSTOS=\"darwin\"\r\n    GOOS=\"darwin\"\r\n    GOPATH=\"/Users/jweisblat/gocode\"\r\n    GORACE=\"\"\r\n    GOROOT=\"/usr/local/Cellar/go/1.6.2/libexec\"\r\n    GOTOOLDIR=\"/usr/local/Cellar/go/1.6.2/libexec/pkg/tool/darwin_amd64\"\r\n    GO15VENDOREXPERIMENT=\"1\"\r\n    CC=\"clang\"\r\n    GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fno-common\"\r\n    CXX=\"clang++\"\r\n    CGO_ENABLED=\"1\"\r\n\r\n### What did you do?\r\nhttps://play.golang.org/p/Dh7S2wq-4c\r\n\r\nThis program tries to verify that one certificate is properly signed by another. The given signing certificate is the attestation certificate of a yubikey, as described on https://developers.yubico.com/PIV/Introduction/PIV_attestation.html\r\n\r\n\r\n### What did you expect to see?\r\n\r\nI expected the program to finish successfully. The certificate is in fact properly signed - placing the certificates in the relevant files and running \r\n\r\n`openssl verify -partial_chain -CAfile /path/to/attestingCert /path/to/attestation` (with openssl 1.0.2 for the `partial_chain` flag)\r\n\r\npasses.\r\n\r\n### What did you see instead?\r\n\r\nI got an error from [crypto/rsa/pkcs1v15.go:293](https://golang.org/src/crypto/rsa/pkcs1v15.go?s=9744:9836#L254) - In particular, the check on line 285 fails, citing an incorrect \"prefix\".\r\n\r\n\r\nThe way go's crypto library implements this check is interesting. From `crypto/rsa/pkcs1v15.go`:\r\n\r\n    // These are ASN1 DER structures:\r\n    //   DigestInfo ::= SEQUENCE {\r\n    //     digestAlgorithm AlgorithmIdentifier,\r\n    //     digest OCTET STRING\r\n    //   }\r\n    // For performance, we don't use the generic ASN1 encoder. Rather, we\r\n    // precompute a prefix of the digest value that makes a valid ASN1 DER string\r\n    // with the correct contents.\r\n    var hashPrefixes = map[crypto.Hash][]byte{\r\n    \tcrypto.MD5:       {0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10},\r\n    \tcrypto.SHA1:      {0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14},\r\n    \tcrypto.SHA224:    {0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1c},\r\n    \tcrypto.SHA256:    {0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20},\r\n    \tcrypto.SHA384:    {0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30},\r\n    \tcrypto.SHA512:    {0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40},\r\n    \tcrypto.MD5SHA1:   {}, // A special TLS case which doesn't use an ASN1 prefix.\r\n    \tcrypto.RIPEMD160: {0x30, 0x20, 0x30, 0x08, 0x06, 0x06, 0x28, 0xcf, 0x06, 0x03, 0x00, 0x31, 0x04, 0x14},\r\n    }\r\n\r\nWhen the function which checks signatures checks that the signature is valid, rather than decoding the ASN.1 DER structure mentioned above, it checks that the structure is equal to the one it expects. However, there are in fact 2 legal ways of representing each of the above algorithms. [RFC 4055](https://tools.ietf.org/html/rfc4055#section-5) defines a set of oids for representing a `digestAlgorithm`:\r\n\r\n\u003e   When any of these four object identifiers appears within an\r\n\u003e   AlgorithmIdentifier, the parameters MUST be NULL.  Implementations\r\n\u003e   MUST accept the parameters being absent as well as present.\r\n\r\nThe go implementation contains the ASN.1 structure corresponding to the object identifier *with* a NULL parameter. However, the certificates that yubikeys generate instead contain the ASN.1 structure *without* a NULL parameter. These examples give a digest of all zeroes, but that bitstring would normally contain the hashed value.\r\n\r\nWith parameter: https://lapo.it/asn1js/#3031300D0609608648016503040201050004200000000000000000000000000000000000000000000000000000000000000000\r\nWithout: https://lapo.it/asn1js/#302F300B060960864801650304020104200000000000000000000000000000000000000000000000000000000000000000\r\n\r\n\r\nThus, despite the certificate being valid, the go library finds the \"prefix\" to be incorrect and errors when validating it.\r\n\r\n\r\nI see a few possible fixes:\r\n\r\n - rewrite the validation code so that it actually parses the relevant ASN.1 structures\r\n - add a second set of possible values and compare against both of them\r\n - something else?\r\n \r\nI'd tend toward implementing the second of the above fixes, because the first seems more likely to introduce timing attacks toward breaking the relevant crypto; however, I'm not an expert and could be convinced to implement either.",
	"user": {
		"login": "jakob223",
		"id": 4698687,
		"type": "User",
		"site_admin": false
	},
	"comments": 5,
	"closed_at": "2016-08-15T22:45:09Z",
	"created_at": "2016-08-13T01:33:11Z",
	"updated_at": "2016-08-18T14:47:21Z",
	"milestone": {
		"id": 1709363,
		"number": 38,
		"title": "Go1.8"
	}
}
