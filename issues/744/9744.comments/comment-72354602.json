{
	"id": 72354602,
	"body": "\u003e It all depends on the meaning of \"the first error\".\r\n\r\nYes, and my opinion is that it's quite a bit of stretch to call the error from Write the first error in this scenario, and that it is not what most people reading the docs would think.\r\n\r\nThe way I interpret the docs is that the first error is returned (which in this situation would be the one from Read), and there may be further errors (e.g. from a subsequent Write) but those will be discarded.\r\n\r\n\u003e If you think it means the read, then it shouldn't continue to issue\r\n\u003e the Write even if n \u003e 0, because the Copy call is guaranteed to\r\n\u003e fail.\r\n\r\nI think it means the read, but as I've already said in my previous comment, I don't agree with this reasoning; not issuing the Write is contrary to the established Go convention, that is, contrary to what people reading the docs should be expecting.\r\n\r\n\u003e On the other hand, if you regard that a Read that returns (n, err)\r\n\u003e with n \u003e 0 and err != nil as successful, then the current behavior\r\n\u003e is correct.\r\n\r\nI'd prefer not to introduce new terms (\"successful\"); we have enough confusion with the existing ones already. :) My primary issue is not which behavior is \"correct\"; it is that it's not doing what (I think) the docs say.\r\n\r\n\u003e Making io.Copy return a new Error struct combining the two errors\r\n\u003e is an API change that might break existing code.\r\n\r\nI'm aware of that, and I didn't mean to suggest changing it that way. I just pointed it out to emphasize that discarding some errors is not \"inevitable\", but is a result of a conscious design choice, favoring simplicity over \"correctness\"/\"consistency\", which I agree with.\r\n\r\nApplying the same rationale, even if the current implementation is deemed the more \"correct\" or \"consistent\" behavior, changing the implementation to match the docs (return Read error, discard any further) can be considered favorable to documenting the current behavior (which may require introducing new terminology such as \"successful read\").\r\n\r\nIn addition, in case the two errors share the same underlying cause, keeping the one that occurred first (in time) may be more helpful than the second.\r\n\r\n\u003e There are more corner cases in the design of io.Copy (for example,\r\n\u003e if the Write fails due to some flakiness in underlying writer, the client\r\n\u003e might want to retry, so it is desirable to not discard the unwritten\r\n\u003e bytes.) If you want more control, I think you should design your own\r\n\u003e copy routine.\r\n\r\nI don't want more control, I just want it to do what it says (or, say what it does).\r\n",
	"user": {
		"login": "speter",
		"id": 450945,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-02-01T07:08:50Z",
	"updated_at": "2015-02-01T07:08:50Z"
}
