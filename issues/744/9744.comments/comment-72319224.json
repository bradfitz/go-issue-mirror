{
	"id": 72319224,
	"body": "\u003e io.Copy has to discard at least one error here. And it's debatable\r\n\u003e whether to discard the read error or the write error.\r\n\r\nTechnically, it doesn't necessarily have to discard one of the errors; returning an error that holds both underlying errors could be an option too, but it is probably not worth the added complexity. So I agree that it is reasonable to return just one of the errors in this situation.\r\n\r\n\u003e If we change it to return the Read error, then I think it shouldn't issue\r\n\u003e the Write call at all. Because the io.Copy has already failed.\r\n\u003e However, on the other hand, we all know that's not the correct way\r\n\u003e of dealing with the result from io.Reader.\r\n\r\nThis paragraph seems self-contradictory to me... I agree with the second half -- not issuing the Write call would be against the convention regarding how to handle io.Reader errors.\r\n\r\n\u003e We could also interpret the docs in a different way. Because it's\r\n\u003e copying between dst and src, the Read and Write operation should\r\n\u003e always appear in pair if the n returned from Read is non-zero (the\r\n\u003e Read did succeed in some sense), and the first error is indeed\r\n\u003e coming from Write.\r\n\r\nI see where you're coming from; it makes sense if \"first error\" is interpreted as in byte positions. E.g. with read error at byte index 1024, write error at byte index 512, the write error can be considered \"first\" even if the read error occurred earlier. The question is, first, whether that was the intent, and second, what people reading the docs think. \r\n\r\nFor the first question, it may as well be the intent, and this way the error is actually correlated to the position (number of bytes successfully copied) that the error is returned together with.\r\n\r\nFor the second question, I can only speak for myself, but it didn't occur to me that \"first error encountered\" could refer to something other than temporal/\"happens-before\" first... Given the current docs (and the established Go convention to process any \"residual\" data received together with a read error), my interpretation was that if I get a write error, I could assume that there was no (read) error prior to that. On the other hand, if I get a read error, I couldn't assume anything about what happened afterwards. Although I have to add that English is not my native language (but then, the same is true for a large portion of people reading the docs).\r\n\r\nAssuming the behavior is intended, I'm thinking that there should be a better way to put it that is clearer to a wider range of users, though I haven't managed come up with a good one -- I'll keep thinking.\r\n\r\n\u003e BTW, could network connections return (n, err) with n \u003e 0 and err != nil?\r\n\u003e I think the underlying read syscall doesn't expose this capability.\r\n\r\nYou're right that syscalls don't directly expose this capability; I was assuming the case when using a buffering reader implementation that could aggregate results from multiple syscalls.\r\n",
	"user": {
		"login": "speter",
		"id": 450945,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-01-31T14:12:35Z",
	"updated_at": "2015-01-31T14:12:35Z"
}
