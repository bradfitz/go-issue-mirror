{
	"id": 130871134,
	"body": "@kostya-sh: do you really need __arbitrary precision__ for financial computation ?\r\nIn my mind, they are best done by using base 10 floating point __fixed-size__ data types, like a decimal128 (or decQuad).\r\n\r\nI say that because I think the API of big.Float (and big,Decimal will certainly be the same) is quite complex.\r\n\r\nAs an example, for addition:\r\n\u003e func (z *Float) Add(x, y *Float) *Float\r\n\u003e Add sets z to the rounded sum x+y and returns z. If z's precision is 0, it is changed to the larger of x's or y's precision before the operation. Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result. \r\n\r\nYou must prepare the result variable with proper precision and rounding mode, and think about it for each arithmetic operation.\r\n\r\nWith a fixed-size floating point API, and decimal128 data type, all you do would be:\r\n\r\n\u003e c = context.Add(a, b)\r\n\r\nwhere context contains the rounding mode, and stores computation error of it occurs.\r\n__Also, numbers are just values, not pointers.__\r\nIt would be as simple as working with float64.\r\n\r\nThe API of big.Float introduces a complexity that is not needed for most financial computation.\r\nWe just want that Add, Subtract and Mult don't round the result for numbers in usual range, but store them with the max precision allowed by the fixed-size data type. e.g. 34 significant digits for decimal128.\r\nAnd if we want to round or truncate the result, we can just call the proper function.\r\n\r\n### Usual range for monetary values\r\n\r\nAssets under management for a large multinational insurance company is:\r\n\r\n$265,507,000,000\r\n\r\nThis figure is the sum of amounts that can have 8 digits after decimal point, because this precision is needed when working with foreign currency conversion.\r\n\r\nThis means that for a large company, a decimal data type must cope with figures like:\r\n\r\n__100,000,000,000.00000000__, that is, 20 significant digits.\r\n\r\nA decimal128 fixed-size data type provides 34 significant digits, which can easily store these figures.\r\nWe can even store USA national debt of $18,000,000,000,000 in it with full precision.\r\n\r\nWhen doing financial computation, intermediate calculation can require some more digits, but __34 significant digits is really enough for most real cases financial computation__.\r\n\r\nThat's why I think that big.Decimal for most financial applications is overkill, and a fixed-size decimal128 base-10 floating type is more than \"good enough\".\r\n\r\n### PRO and CONS\r\n\r\n__big.Decimal__ arbitrary-precision \r\n\r\nCON: if like big.Float, the API is more complex than needed\r\nCON: variables are pointers\r\nCON: precision and rounding mode of the result must be think about for each operation\r\nCON: is there a lot of financial applications that requires a precision of more than 34 significant digits ?\r\nPRO: no limit to the precision\r\n\r\n__decnumber.Decimal128__ fixed-size\r\n\r\nPRO: API is simple\r\nPRO: variable are values\r\nPRO: no need to think about precision, as the result is always the max precision of decimal128\r\nPRO: decimal128 can store 34 significant digits, which can accomodate the range of values used in most financial applications\r\nPRO: no need to allocate memory to store the result, all numbers fits in 128 bits. (use of sync.Pool and small internal buffer can alleviate this problem, though)\r\n\r\n### Decimal floating point package used by other languages:\r\n\r\nLet a and b be operands, and z is the result.\r\n__context__ contains the rounding mode, and computation error if any.\r\nIf an operation fails, context will keep the error and subsequent operations are no-op. There is no need to check for error after each operation, only after the last one.\r\n\r\n__C__: gcc contains \"decNumber\" implementation of Mike Cowlishaw, __fixed-size__ floating point (it is an extension of GNU C)\r\ndecQuad type is __128 bits__.\r\nThe numbers are __pointers__.\r\n\r\n\u003e decQuadAdd(\u0026z, \u0026a, \u0026b, \u0026context);\r\n\r\n__java.math.BigDecimal__ is arbitrary-precision, consisting of an __arbitrary precision__ integer (like Go big.Int) and a scale.\r\nThe numbers are __immutable values__, not pointers.\r\n\r\n\u003e BigDecimal z = a.add(b, context);\r\n\r\n__Python \"decimal\" module__ is also __arbitrary-precision__, with an API that ressembles very much to the C \"decNumber\" API, because the IBM decimal implementation by Mike Cowlishaw was chosen\r\nas basis for the Python's decimal implementation.\r\nThe numbers are __immutable values__, not pointers.\r\n\r\n\u003e z = context.add(a, b)\r\n\r\n__Microsoft C# \"decimal\"__\r\nThe binary representation of a Decimal value consists of a 1-bit sign, a 96-bit integer number, and a scaling factor. \r\nIt is a __fixed-size 128 bits__ binary format, like C \"decNumber\", but the API is very different.\r\nThe numbers are __immutable values__, not pointers.\r\nNo context, we work with \"decimal\" data type like with base-2 \"Double\" data type.\r\n\r\n\u003e z = a + b\r\n\r\nThat being said, any means of working with base-10 floating point numbers, be it arbitrary-precision or fixed-size, will be welcomed by all those that work with monetary values ;-)\r\n\r\n",
	"user": {
		"login": "rin01",
		"id": 9582469,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-13T22:51:06Z",
	"updated_at": "2015-08-13T23:03:01Z"
}
