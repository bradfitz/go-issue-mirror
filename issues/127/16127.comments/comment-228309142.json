{
	"id": 228309142,
	"body": "I did leave out `QueryUnescape` as well, but the only exported functions that would change are `QueryEscape` and `QueryUnescape`.\r\n\r\n```go\r\n// QueryUnescape does the inverse transformation of QueryEscape, converting\r\n// %AB into the byte 0xAB and '+' into ' ' (space). It returns an error if\r\n// any % is not followed by two hexadecimal digits.\r\nfunc QueryUnescape(s string) (string, error) {\r\n\treturn unescape(s, escapeQueryComponent)\r\n}\r\n\r\n// unescape unescapes a string; the mode specifies\r\n// which section of the URL string is being unescaped.\r\nfunc unescape(s string, mode encoding) (string, error) {\r\n\t// Count %, check that they're well-formed.\r\n\tn := 0\r\n\thasPlus := false\r\n\tfor i := 0; i \u003c len(s); {\r\n\t\tswitch s[i] {\r\n\t\tcase '%':\r\n\t\t\tn++\r\n\t\t\tif i+2 \u003e= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) {\r\n\t\t\t\ts = s[i:]\r\n\t\t\t\tif len(s) \u003e 3 {\r\n\t\t\t\t\ts = s[:3]\r\n\t\t\t\t}\r\n\t\t\t\treturn \"\", EscapeError(s)\r\n\t\t\t}\r\n\t\t\t// Per https://tools.ietf.org/html/rfc3986#page-21\r\n\t\t\t// in the host component %-encoding can only be used\r\n\t\t\t// for non-ASCII bytes.\r\n\t\t\t// But https://tools.ietf.org/html/rfc6874#section-2\r\n\t\t\t// introduces %25 being allowed to escape a percent sign\r\n\t\t\t// in IPv6 scoped-address literals. Yay.\r\n\t\t\tif mode == encodeHost \u0026\u0026 unhex(s[i+1]) \u003c 8 \u0026\u0026 s[i:i+3] != \"%25\" {\r\n\t\t\t\treturn \"\", EscapeError(s[i : i+3])\r\n\t\t\t}\r\n\t\t\tif mode == encodeZone {\r\n\t\t\t\t// RFC 6874 says basically \"anything goes\" for zone identifiers\r\n\t\t\t\t// and that even non-ASCII can be redundantly escaped,\r\n\t\t\t\t// but it seems prudent to restrict %-escaped bytes here to those\r\n\t\t\t\t// that are valid host name bytes in their unescaped form.\r\n\t\t\t\t// That is, you can use escaping in the zone identifier but not\r\n\t\t\t\t// to introduce bytes you couldn't just write directly.\r\n\t\t\t\t// But Windows puts spaces here! Yay.\r\n\t\t\t\tv := unhex(s[i+1])\u003c\u003c4 | unhex(s[i+2])\r\n\t\t\t\tif s[i:i+3] != \"%25\" \u0026\u0026 v != ' ' \u0026\u0026 shouldEscape(v, encodeHost) {\r\n\t\t\t\t\treturn \"\", EscapeError(s[i : i+3])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti += 3\r\n\t\tcase '+':\r\n\t\t\tif mode == encodeQueryComponent || mode == escapeQueryComponent {\r\n\t\t\t\thasPlus = true\r\n\t\t\t}\r\n\r\n\t\t\ti++\r\n\t\tdefault:\r\n\t\t\tif (mode == encodeHost || mode == encodeZone) \u0026\u0026 s[i] \u003c 0x80 \u0026\u0026 shouldEscape(s[i], mode) {\r\n\t\t\t\treturn \"\", InvalidHostError(s[i : i+1])\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t}\r\n\t}\r\n\r\n\tif n == 0 \u0026\u0026 !hasPlus {\r\n\t\treturn s, nil\r\n\t}\r\n\r\n\tt := make([]byte, len(s)-2*n)\r\n\tj := 0\r\n\tfor i := 0; i \u003c len(s); {\r\n\t\tswitch s[i] {\r\n\t\tcase '%':\r\n\t\t\tt[j] = unhex(s[i+1])\u003c\u003c4 | unhex(s[i+2])\r\n\t\t\tj++\r\n\t\t\ti += 3\r\n\t\tcase '+':\r\n\t\t\tif mode == encodeQueryComponent || mode == escapeQueryComponent {\r\n\t\t\t\tt[j] = ' '\r\n\t\t\t} else {\r\n\t\t\t\tt[j] = '+'\r\n\t\t\t}\r\n\t\t\tj++\r\n\t\t\ti++\r\n\t\tdefault:\r\n\t\t\tt[j] = s[i]\r\n\t\t\tj++\r\n\t\t\ti++\r\n\t\t}\r\n\t}\r\n\treturn string(t), nil\r\n}\r\n```\r\n\r\n`net/url_test.go` would additionally change.\r\n\r\n```go\r\ntype shouldEscapeTest struct {\r\n\tin     byte\r\n\tmode   encoding\r\n\tescape bool\r\n}\r\n\r\nvar shouldEscapeTests = []shouldEscapeTest{\r\n\t// Unreserved characters (§2.3)\r\n\t{'a', encodePath, false},\r\n\t{'a', encodeUserPassword, false},\r\n\t{'a', encodeQueryComponent, false},\r\n\t{'a', encodeFragment, false},\r\n\t{'a', escapeQueryComponent, false},\r\n\t{'a', encodeHost, false},\r\n\t{'z', encodePath, false},\r\n\t{'A', encodePath, false},\r\n\t{'Z', encodePath, false},\r\n\t{'0', encodePath, false},\r\n\t{'9', encodePath, false},\r\n\t{'-', encodePath, false},\r\n\t{'-', encodeUserPassword, false},\r\n\t{'-', encodeQueryComponent, false},\r\n\t{'-', encodeFragment, false},\r\n\t{'-', escapeQueryComponent, false},\r\n\t{'.', encodePath, false},\r\n\t{'_', encodePath, false},\r\n\t{'~', encodePath, false},\r\n\r\n\t// Reserved characters (§2.2)\r\n\t{'?', encodePath, true},\r\n\t{'#', encodePath, true},\r\n\t{'[', encodePath, true},\r\n\t{']', encodePath, true},\r\n\t{'$', encodePath, false},\r\n\t{'\u0026', encodePath, false},\r\n\t{'!', encodePath, false},\r\n\t{'+', encodePath, false},\r\n\t{',', encodePath, false},\r\n\t{'\\'', encodePath, false},\r\n\t{':', encodePath, false},\r\n\t{';', encodePath, false},\r\n\t{'=', encodePath, false},\r\n\t{'@', encodePath, false},\r\n\t{'(', encodePath, false},\r\n\t{')', encodePath, false},\r\n\t{'*', encodePath, false},\r\n\r\n\t// Query component (§3.4)\r\n\t{'\u0026', encodeQueryComponent, true},\r\n\t{'?', encodeQueryComponent, true},\r\n\t{'/', encodeQueryComponent, true},\r\n\t{'#', encodeQueryComponent, true},\r\n\t{'[', encodeQueryComponent, true},\r\n\t{']', encodeQueryComponent, true},\r\n\t{'$', encodeQueryComponent, false},\r\n\t{'!', encodeQueryComponent, false},\r\n\t{'+', encodeQueryComponent, false},\r\n\t{',', encodeQueryComponent, false},\r\n\t{'\\'', encodeQueryComponent, false},\r\n\t{':', encodeQueryComponent, false},\r\n\t{';', encodeQueryComponent, false},\r\n\t{'=', encodeQueryComponent, false},\r\n\t{'@', encodeQueryComponent, false},\r\n\t{'(', encodeQueryComponent, false},\r\n\t{')', encodeQueryComponent, false},\r\n\t{'*', encodeQueryComponent, false},\r\n\r\n\t// User information (§3.2.1)\r\n\t{':', encodeUserPassword, true},\r\n\t{'/', encodeUserPassword, true},\r\n\t{'?', encodeUserPassword, true},\r\n\t{'@', encodeUserPassword, true},\r\n\t{'$', encodeUserPassword, false},\r\n\t{'\u0026', encodeUserPassword, false},\r\n\t{'+', encodeUserPassword, false},\r\n\t{',', encodeUserPassword, false},\r\n\t{';', encodeUserPassword, false},\r\n\t{'=', encodeUserPassword, false},\r\n\r\n\t// Host (IP address, IPv6 address, registered name, port suffix; §3.2.2)\r\n\t{'!', encodeHost, false},\r\n\t{'$', encodeHost, false},\r\n\t{'\u0026', encodeHost, false},\r\n\t{'\\'', encodeHost, false},\r\n\t{'(', encodeHost, false},\r\n\t{')', encodeHost, false},\r\n\t{'*', encodeHost, false},\r\n\t{'+', encodeHost, false},\r\n\t{',', encodeHost, false},\r\n\t{';', encodeHost, false},\r\n\t{'=', encodeHost, false},\r\n\t{':', encodeHost, false},\r\n\t{'[', encodeHost, false},\r\n\t{']', encodeHost, false},\r\n\t{'0', encodeHost, false},\r\n\t{'9', encodeHost, false},\r\n\t{'A', encodeHost, false},\r\n\t{'z', encodeHost, false},\r\n\t{'_', encodeHost, false},\r\n\t{'-', encodeHost, false},\r\n\t{'.', encodeHost, false},\r\n}\r\n\r\nfunc TestShouldEscape(t *testing.T) {\r\n\tfor _, tt := range shouldEscapeTests {\r\n\t\tif shouldEscape(tt.in, tt.mode) != tt.escape {\r\n\t\t\tt.Errorf(\"shouldEscape(%q, %v) returned %v; expected %v\", tt.in, tt.mode, !tt.escape, tt.escape)\r\n\t\t}\r\n\t}\r\n}\r\n```",
	"user": {
		"login": "gmccue",
		"id": 1085902,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-06-24T10:13:31Z",
	"updated_at": "2016-06-24T10:17:29Z"
}
