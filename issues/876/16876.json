{
	"id": 173192411,
	"number": 16876,
	"state": "open",
	"title": "proposal: expose Java API to gomobile bind programs",
	"body": "## Abstract\r\nToday, gomobile bind can take a set og Go packages and expose their public API to Java or ObjC apps. The proposal is to support the reverse, exposing Java API to the bound Go packages.\r\n\r\n## Motivation\r\nEven though mobile apps can access Go code already, there are still large parts of a typical app that is impossible or awkward to implement in Go. The most notable case is UI code, which interacts most with the platform APIs.\r\nPlatform APIs *can* be accessed from Go in an indirect way already. Creating a Java (or ObjC) class wrapping the desired API and passing it to Go does work. However, this is not nearly as convenient as writing the code directly in Java.\r\nTo improve support for writing platform specific code in Go, direct access to the platform is needed.\r\n\r\n## Proposed features\r\n### Importing Java classes and interfaces from Go\r\nThe Go wrappers for all Java API are generated each time gomobile bind is called. To access a Java package, use import statements on the form:\r\n\r\n````\r\n    import \"Java/some/pkg\"\r\n````\r\n\r\nTo access the static methods or constants on a Java class or interface, use\r\n\r\n````\r\n    import \"Java/some/pkg/SomeClass\"\r\n````\r\n\r\nor\r\n\r\n````\r\n    import \"Java/some/pkg/SomeClass/InnerClass\"\r\n````\r\n\r\nfor an inner class.\r\n\r\n### Static methods and constants\r\nAfter importing, the resulting packages SomeClass and InnerClass will contain the static methods and static final constants from their Java classes. For example\r\n\r\n    import \"Java/java/lang/Float\"\r\n\r\nwill expose (among others) the constant Float.MIN_VALUE and the function Float.ParseFloat.\r\n\r\n### Java classes and interfaces\r\nThe package `\"Java/some/pkg\"` contains Go interfaces wrapping every referenced Java type in `some.pkg`. The wrapper types are used to represent their wrapped Java types across the language barrier and to call methods on wrapped instances. For example, with the following Go function is now possible:\r\n\r\n````\r\nimport \"Java/java/lang\"\r\n\r\nfunc FloatDoubleValue(f lang.Float) float64 {\r\n    return f.DoubleValue()\r\n}\r\n````\r\n\r\n### Creating new Java instances\r\nTo create a new instance of a Java class, use the `New` function defined in the class package. For example:\r\n\r\n````\r\nimport (\r\n    \"Java/java/lang/Object\"\r\n    \"Java/java/lang\"\r\n)\r\n\r\nfunc NewObject() lang.Object {\r\n    return Object.New()\r\n}\r\n````\r\n\r\n### Errors and exceptions\r\nExceptions are normally translated to explicit Go errors, but since we don't control the platform API, we don't know which Java methods can result in an exception worth catching. Instead, a simple heuristic is used: If a Java method is declared to throw one or more exceptions, its Go function or method will return an error. If no exception is declared, any exception thrown will be converted to a panic with the exception as argument.\r\n\r\nIn addition, any Java class which inherits from `java.lang.Throwable` will satisfy the `error` interface. Its `Error` method will delegate to the toString() method.\r\n\r\n### Extending or implementing Java types from Go\r\nGomobile already exposes exported Go structs to Java; this proposal adds support for constructing Go structs directly from Java. In addition, Go structs will be able to extend Java classes and implement Java interfaces.\r\n\r\nTo declare a Go struct that extends or implements Java types, use the form:\r\n\r\n````\r\nimport \"Java/some/pkg/Class\"\r\nimport \"Java/some/pkg/Inner\"\r\nimport \"Java/another/pkg2/Interface\"\r\n\r\ntype S struct {\r\n    pkg.Class // extends Class\r\n    pkg2.Interface // implements Interface\r\n    Class.Inner // implements (or extends) inner interface (or class)\r\n}\r\n````\r\n\r\n### Java constructors\r\nTo allow Java to create instances of a Go struct, S, add one or more constructor on the form:\r\n\r\n````\r\nfunc NewS(...) *S {\r\n    ...\r\n}\r\n````\r\n\r\nFor each such Go constructor a Java constructor will be added taking the same arguments. The Java constructor calls its super constructor with its arguments before calling calling NewS. For example:\r\n\r\n````\r\npackage gopkg\r\n\r\nimport (\r\n    \"Java/java/lang\"\r\n)\r\n\r\ntype GoObject struct {\r\n    lang.Object\r\n}\r\n\r\nfunc NewGoObject() *GoObject {\r\n    return \u0026GoObject{}\r\n)\r\n````\r\n\r\nwill allow Java to construct instances of GoObject:\r\n\r\n````\r\nimport go.gopkg.GoObject;\r\n\r\n...\r\n\r\n    GoObject o = new GoObject();\r\n````\r\n\r\n### Overriding Java methods\r\nTo implement or override a method from a super class or interface, declare a Go method with the same name and its first letter capitalized. For example, to override the toString method in GoObject:\r\n\r\n````\r\nfunc (o *GoObject) ToString() string {\r\n    ...\r\n}\r\n````\r\n\r\n### Exposing `this`\r\nWhenever an foreign object is passed across the language barrier, a proxy is created to represent it. In the example above, there is a GoObject Java instance created in Java, and it contains a reference to its counterpart GoObject Go instance in Go. That means that when a Go method is called from Java, its method receiver contains the Go instance, while the Java instance is only accessible to Java.\r\nTo access the Java instance (for passing back to other Java APIs), any Go method can declare a `this` argument with one of the Java types the enclosing class extends or implements. For example, to access the `this` from the ToString method, use:\r\n\r\n````\r\nfunc (o *GoObject) ToString(t lang.Object) string {\r\n    ...\r\n}\r\n````\r\n\r\nThe `t` variable will behave just as if it were a pure Java Object, and if passed to Java, it will have the same identity as the Java reference.\r\n\r\n### Calling `super`\r\nIn Go, delegation is achieved through delegation, but in Java, the keyword `super` is needed to access overridden methods. To call a super method from Go, use the Super() method on the `this` variable: \r\n\r\n````\r\nfunc (o *GoObject) ToString(t lang.Object) string {\r\n    return t.Super().ToString()\r\n}\r\n````\r\n\r\n### Overloaded methods and constructors\r\nJava supports overloading; Go doesn't. To access or override overloaded methods and cosntructors from Go, a mangling scheme is used:\r\n\r\n \r\n - For any overloaded method where the number of arguments uniquely identifies the method, the argument count is appended to its name, except if the methods takes no arguments. For example, the Java methods\r\n\r\n````\r\nvoid m();\r\nvoid m(int i);\r\n```\r\n\r\nare called `M` and `M2`, respectively, in Go.\r\n\r\n  - If multiple methods have the same name and the same number of arguments, their names have an underscore and the [JNI mangled](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/design.html#wp16696) argument descriptor appended. For example, the Java methods:\r\n\r\n````\r\nvoid m(int i);\r\nvoid m(String s)\r\n````\r\n\r\nare called `M_I` and `M_Ljava_lang_String_2` in Go.\r\n\r\nThe JNI name mangling scheme is ugly. In particular, Java constructors are only distinguished by their arguments and are therefore often mangled. Suggestions for improved schemes are most welcome!",
	"user": {
		"login": "eliasnaur",
		"id": 524812,
		"type": "User",
		"site_admin": false
	},
	"comments": 22,
	"created_at": "2016-08-25T12:41:03Z",
	"updated_at": "2016-09-14T16:33:20Z",
	"milestone": {
		"id": 1373555,
		"number": 30,
		"title": "Proposal"
	},
	"reactions": {
		"total_count": 13,
		"+1": 13
	}
}
