{
	"id": 115010288,
	"body": "We've fixed several memory corruption problems in the runtime since this was reported and also rewritten this part of the signal handling code. Since this is most likely fixed, I'm closing the issue, but please reopen if it is still happening.\r\n\r\nI tried, unsuccessfully, to map this to a specific issue that was fixed. Below is a log of what I figured out from the core file and the version you were running.\r\n\r\nIn your first trace, it was actually goroutine 23 (0x17):\r\n```\r\n(gdb) info goroutines\r\n  23 running  runtime.systemstack_switch\r\n```\r\nNot very enlightening, unfortunately. And since it's running, probably a lie.\r\n\r\nThe signal itself reveals some of what was happening at the time. rdi is 11, so this is a SIGSEGV. rdx is the signal context (type *ucontext), so we can find out where caused the original segfault:\r\n```\r\n(gdb) x/xg $rdx + 40 + 120\r\n0xc2097ebb60:\t0x000000c208953410  # rsp\r\n0xc2097ebb68:\t0x000000000041ebb9  # rip\r\n(gdb) list *0x000000000041ebb9\r\n0x41ebb9 is in runtime.mallocgc (/ssd/src/go10/src/runtime/malloc.go:511).\r\n511   mp := acquirem()\r\n```\r\nSo the original cause of the SIGSEGV was also that g.m==nil.\r\n\r\nAnnoyingly, gdb won't let me trick it in to unwinding the pre-signal stack on a core file, but groveling through the stack for plausible return RIPs yields:\r\n```\r\n(gdb) list *0x000000000041f549\r\n0x41f549 is in runtime.newobject (/ssd/src/go10/src/runtime/malloc.go:725).\r\n725\treturn mallocgc(uintptr(typ.size), typ, flags)\r\n(gdb) list *0x00000000005b655d\r\n0x5b655d is in reflect.(*structType).Field (/ssd/src/go10/src/reflect/type.go:850).\r\n850\tf.Index = []int{i}\r\n(gdb) list *0x00000000005b51cd\r\n0x5b51cd is in reflect.(*rtype).Field (/ssd/src/go10/src/reflect/type.go:606).\r\n606\treturn tt.Field(i)\r\n(gdb) list *0x00000000005624eb\r\n0x5624eb is in encoding/binary.sizeof (/ssd/src/go10/src/encoding/binary/binary.go:353).\r\n353\ts := sizeof(t.Field(i).Type)\r\n```\r\n\r\nSo we're not in anything strange. We're just running regular user code and it's allocating a regular object.\r\n\r\nTaking a different track (suggested by your original post), I found only two places where we can legitimately set g.m to nil. There are other places where we change g.m, but they would all clearly crash immediately if g.m were set to nil. We set g.m to nil in dropg, but it also sets m.curg to nil. M 31 has curg set to 0xc20807ab40, the g that crashed, so unless two Ms were running that G, g.m wasn't set to nil in dropg. We set g.m to nil in goexit0, but we also cas the status to _Gdead and the g that crashed is in status _Grunning.\r\n\r\nAt this point, there seems to be no plausible way g.m could be nil other than memory corruption.",
	"user": {
		"login": "aclements",
		"id": 2688315,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-06-24T20:57:49Z",
	"updated_at": "2015-06-24T20:57:49Z"
}
