{
	"id": 119544272,
	"body": "I think there are still a little problem:\r\n\r\n1. if maxBytesReader initialized with n\u003c0, it will have a problem\r\n\r\n2. I think that this will never trigger\r\nsee https://github.com/golang/go/blob/master/src/net/http/request.go#L740\r\n\r\n```Go\r\nfunc (l *maxBytesReader) Read(p []byte) (n int, err error) {\r\n\ttoRead := l.n\r\n\tif l.n == 0 {\r\n\t\tif l.sawEOF {\r\n\t\t\treturn l.tooLarge()  // -------\u003e I think that this will never trigger\r\n\t\t}\r\n\t\t// The underlying io.Reader may not return (0, io.EOF)\r\n\t\t// at EOF if the requested size is 0, so read 1 byte\r\n\t\t// instead. The io.Reader docs are a bit ambiguous\r\n\t\t// about the return value of Read when 0 bytes are\r\n\t\t// requested, and {bytes,strings}.Reader gets it wrong\r\n\t\t// too (it returns (0, nil) even at EOF).\r\n\t\ttoRead = 1\r\n\t}\r\n\tif int64(len(p)) \u003e toRead {\r\n\t\tp = p[:toRead]\r\n\t}\r\n\tn, err = l.r.Read(p)\r\n\tif err == io.EOF {\r\n\t\tl.sawEOF = true\r\n\t}\r\n\tif l.n == 0 {\r\n\t\t// If we had zero bytes to read remaining (but hadn't seen EOF)\r\n\t\t// and we get a byte here, that means we went over our limit.\r\n\t\tif n \u003e 0 {\r\n\t\t\treturn l.tooLarge()\r\n\t\t}\r\n\t\treturn 0, err\r\n\t}\r\n\tl.n -= int64(n)\r\n\tif l.n \u003c 0 {\r\n\t\tl.n = 0\r\n\t}\r\n\treturn\r\n}\r\n```\r\n\r\nHere is my code:\r\n\r\n```Go\r\ntype maxBytesReader struct {\r\n\tw       ResponseWriter\r\n\tr       io.ReadCloser // underlying reader\r\n\tn       int64         // max bytes remaining\r\n\tstopped bool\r\n}\r\n\r\nfunc (l *maxBytesReader) tooLarge() (n int, err error) {\r\n\tif !l.stopped {\r\n\t\tl.stopped = true\r\n\t\tif res, ok := l.w.(*response); ok {\r\n\t\t\tres.requestTooLarge()\r\n\t\t}\r\n\t}\r\n\treturn 0, errors.New(\"http: request body too large\")\r\n}\r\n\r\nfunc (l *maxBytesReader) Read(p []byte) (n int, err error) {\r\n\tif l.n \u003c 0 {\r\n\t\treturn l.tooLarge() // Reached if and only if maxBytesReader initialized with n\u003c0\r\n\t}\r\n\r\n\ttoRead := l.n\r\n\tif l.n == 0 {\r\n\t\t// The underlying io.Reader may not return (0, io.EOF)\r\n\t\t// at EOF if the requested size is 0, so read 1 byte\r\n\t\t// instead. The io.Reader docs are a bit ambiguous\r\n\t\t// about the return value of Read when 0 bytes are\r\n\t\t// requested, and {bytes,strings}.Reader gets it wrong\r\n\t\t// too (it returns (0, nil) even at EOF).\r\n\t\ttoRead = 1\r\n\t}\r\n\tif int64(len(p)) \u003e toRead {\r\n\t\tp = p[:toRead]\r\n\t}\r\n\tn, err = l.r.Read(p)\r\n\tif l.n == 0 {\r\n\t\t// If we had zero bytes to read remaining (but hadn't seen EOF)\r\n\t\t// and we get a byte here, that means we went over our limit.\r\n\t\tif n \u003e 0 {\r\n\t\t\treturn l.tooLarge()\r\n\t\t}\r\n\t\treturn 0, err // Usually 0, io.EOF\r\n\t}\r\n\tl.n -= int64(n)\r\n\treturn\r\n}\r\n```\r\n\r\nBut I think the following code is better, \r\nMany times a read operation will be less\r\n\r\n```Go\r\ntype maxBytesReader struct {\r\n\tw       ResponseWriter\r\n\tr       io.ReadCloser // underlying reader\r\n\tn       int64         // max bytes remaining\r\n\tstopped bool\r\n}\r\n\r\nfunc (l *maxBytesReader) Read(p []byte) (n int, err error) {\r\n\t// The underlying io.Reader may not return (0, io.EOF)\r\n\t// at EOF if the requested size is 0, so read 1 more byte\r\n\t// instead. The io.Reader docs are a bit ambiguous\r\n\t// about the return value of Read when 0 bytes are\r\n\t// requested, and {bytes,strings}.Reader gets it wrong\r\n\t// too (it returns (0, nil) even at EOF).\r\n\ttoRead := l.n + 1\r\n\tif toRead \u003c= 0 {\r\n\t\t// Reached if and only if maxBytesReader initialized with n\u003c0\r\n\t\tif !l.stopped {\r\n\t\t\tl.stopped = true\r\n\t\t\tif res, ok := l.w.(*response); ok {\r\n\t\t\t\tres.requestTooLarge()\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0, errors.New(\"http: request body too large\")\r\n\t}\r\n\tif int64(len(p)) \u003e toRead {\r\n\t\tp = p[:toRead]\r\n\t}\r\n\tn, err = l.r.Read(p)\r\n\tif l.n \u003c int64(n) {\r\n\t\t// means we went over our limit.\r\n\t\tif !l.stopped {\r\n\t\t\tl.stopped = true\r\n\t\t\tif res, ok := l.w.(*response); ok {\r\n\t\t\t\tres.requestTooLarge()\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn int(l.n), errors.New(\"http: request body too large\")\r\n\t}\r\n\tl.n -= int64(n)\r\n\treturn\r\n}\r\n```",
	"user": {
		"login": "chanxuehong",
		"id": 3416908,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-07-08T11:16:42Z",
	"updated_at": "2015-07-08T13:58:40Z"
}
