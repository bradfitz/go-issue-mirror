{
	"id": 66060403,
	"body": "\u003ca id=\"c19\"\u003e\u003c/a\u003eComment 19 by **devers49**:\n\n\u003cpre\u003eIn an attempt to redeem myself, I tried gofmt5 (which _is_ compiled with softfloat) on\nthe qemu\nimage linked by the OP.  It does indeed get a SIGILL there.\n\nGdb says this:\n\nProgram received signal SIGILL, Illegal instruction.\n0x00032544 in runtime.rt_sigaction ()\n(gdb) bt\n#0  0x00032544 in runtime.rt_sigaction ()\n#1  0x0002eb98 in sigaction ()\nBacktrace stopped: frame did not save the PC\n(gdb) disass\nDump of assembler code for function runtime.rt_sigaction:\n0x0003252c \u0026lt;runtime.rt_sigaction+0\u0026gt;:    ldr     r0, [sp, #4]\n0x00032530 \u0026lt;runtime.rt_sigaction+4\u0026gt;:    ldr     r1, [sp, #8]\n0x00032534 \u0026lt;runtime.rt_sigaction+8\u0026gt;:    ldr     r2, [sp, #12]\n0x00032538 \u0026lt;runtime.rt_sigaction+12\u0026gt;:   ldr     r3, [sp, #16]\n0x0003253c \u0026lt;runtime.rt_sigaction+16\u0026gt;:   mov     r7, #174        ; 0xae\n0x00032540 \u0026lt;runtime.rt_sigaction+20\u0026gt;:   svc     0x00000000\n0x00032544 \u0026lt;runtime.rt_sigaction+24\u0026gt;:   add     pc, lr, #0      ; 0x0\n\nI believe the problem is the \"svc 0x0\" to do the rt_sigaction system call.\nIt is following the arm linux EABI syscall convention, with the syscall number\nin r7.  The qemu image seems to be for the \"arm\" (not armel) port of debian\nlenny, which uses the older OABI convention where the syscall number is\nstashed in the svc instruction itself.  If dcheney's armv5 is running an\nEABI kernel, that would explain why it works there but not for the OP.\n\nThe following alternative renderings of \"_exit(2)\" give evidence that the\nOP's qemu is OABI:\n\ndebian-arm:~# objdump -d foo\n\nfoo:     file format elf32-littlearm\n\nDisassembly of section .text:\n\n00008054 \u0026lt;_start\u0026gt;:\n    8054:       e3a00002        mov     r0, #2  ; 0x2\n    8058:       e3a07001        mov     r7, #1  ; 0x1\n    805c:       ef000000        svc     0x00000000\n    8060:       eafffffe        b       8060 \u0026lt;_start+0xc\u0026gt;\ndebian-arm:~# ./foo\nIllegal instruction\ndebian-arm:~# objdump -d bar\n\nbar:     file format elf32-littlearm\n\nDisassembly of section .text:\n\n00008054 \u0026lt;_start\u0026gt;:\n    8054:       e3a00002        mov     r0, #2  ; 0x2\n    8058:       ef900001        svc     0x00900001\n    805c:       eafffffe        b       805c \u0026lt;_start+0x8\u0026gt;\ndebian-arm:~# ./bar\ndebian-arm:~# echo $?\n2\n\nGiven that go's runtime/sys_linux_arm.s appears committed to the EABI\nconvention, I think the OP would have better luck with a different linux.\n\nThis might also be what was going on in the golang-nuts thread here:\n\u003ca href=\"http://groups.google.com/group/golang-nuts/browse_thread/thread/4b0a8808d33fe8e9\"\u003ehttp://groups.google.com/group/golang-nuts/browse_thread/thread/4b0a8808d33fe8e9\u003c/a\u003e\n\ntl;dr: it's not go, and it's not the ARM hardware variant, it's the linux kernel variant.\n\nHow anyone ever manages to hit the right combination of variables in ARM-land is\nbeyond me.  I hope I've not just injected more confusion.\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2012-01-06T19:42:17Z",
	"updated_at": "2014-12-22T06:04:57Z"
}
