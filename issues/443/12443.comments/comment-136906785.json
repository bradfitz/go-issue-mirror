{
	"id": 136906785,
	"body": "This is usually gnu multi arch which decided to move the location of the loader .so.\n\nI don't know where you got that tool chain from, but you may need a different one. \n\nIn any case, you found the workaround which is to create a symlink to the expected location of the linker. If you grep for that location in the go source, I think there is a comment explaining it.\n\n\n\n\u003e On 2 Sep 2015, at 10:48, Nick Glynn \u003cnotifications@github.com\u003e wrote:\n\u003e \n\u003e I am trying to use a Yocto toolchain to build cross-platform binaries for a Gumstix targte using the cgo bindings with the following code:\n\u003e \n\u003e package binding\n\u003e \n\u003e // #include \u003cstdlib.h\u003e\n\u003e // #include \u003cstdio.h\u003e\n\u003e /*  void myprint(char* s) {\n\u003e         printf(\"%s\", s);\n\u003e     }\n\u003e */\n\u003e import \"C\"\n\u003e \n\u003e func Random() int {\n\u003e     return int(C.random())\n\u003e }\n\u003e \n\u003e func PrintHello() {\n\u003e     C.myprint(C.CString(\"Hello\\n\"))\n\u003e }\n\u003e \n\u003e func Seed(i int) {\n\u003e     C.srandom(C.uint(i))\n\u003e }\n\u003e ...\n\u003e package main\n\u003e import (\n\u003e     \"./binding\"\n\u003e     \"fmt\"\n\u003e )\n\u003e \n\u003e func main() {\n\u003e     binding.PrintHello()\n\u003e     binding.Seed(1)\n\u003e     fmt.Println(binding.Random())\n\u003e     binding.Seed(2)\n\u003e     fmt.Println(binding.Random())\n\u003e     binding.Seed(3)\n\u003e     fmt.Println(binding.Random())\n\u003e }\n\u003e \n\u003e I built it using the following:\n\u003e \n\u003e nick@bignick:~/demo/cgodemo$ CC=arm-poky-linux-gnueabi-gcc CGO_CFLAGS=\"-march=armv7-a -mthumb-interwork -mfloat-abi=hard -mfpu=neon -mtune=cortex-a8 --sysroot=/opt/poky/1.7.1/sysroots/cortexa8hf-vfp-neon-poky-linux-gnueabi\" CGO_ENABLED=1 GOOS=linux GOARCH=arm GOARM=5 go build -o Foo_ARM *.go\n\u003e When trying to run the executable on target you groan and see:\n\u003e \n\u003e root@target:~# ./Foo_ARM\n\u003e -sh: ./Foo_ARM: No such file or directory\n\u003e The issue seems to be that the runtime loader used is incorrect\n\u003e If you run readelf you can see it's embedding ld-linux.so.3 as the linux loader but the toolchain is configured for ld-linux-armhf.so.3\n\u003e \n\u003e nick@bignick:~/demo/cgodemo$ arm-poky-linux-gnueabi-readelf Foo_ARM -a | grep ld-\n\u003e   [ 3] .note.gnu.build-i NOTE            00008188 000188 000024 00   A  0   0  4\n\u003e       [Requesting program interpreter: /lib/ld-linux.so.3]\n\u003e I'm not sure why this has happened as those CC and CFLAGS are exactly that used to produce other binaries which don't have this issue i.e.:\n\u003e \n\u003e nick@bignick:~/demo/cgodemo$ arm-poky-linux-gnueabi-readelf  NormalCrossCompiledHelloWorld -a | grep ld-\n\u003e   [ 3] .note.gnu.build-i NOTE            00008170 000170 000024 00   A  0   0  4\n\u003e       [Requesting program interpreter: /lib/ld-linux-armhf.so.3]\n\u003e    03     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .ARM.exidx .eh_frame \n\u003e    06     .note.ABI-tag .note.gnu.build-id \n\u003e  0x00000001 (NEEDED)                     Shared library: [ld-linux-armhf.so.3]\n\u003e   000000: Version: 1  File: ld-linux-armhf.so.3  Cnt: 1\n\u003e After a bit of faffing and checking out the binaries a suggested workaround is simply to create a softlink between the two but this should ideally be fixed when building:\n\u003e \n\u003e ln -s /lib/ld-linux-armhf.so.3 /lib/ld-linux.so.3\n\u003e root@target:/lib# ~/Foo_ARM \n\u003e Hello\n\u003e 1804289383\n\u003e 1505335290\n\u003e 1205554746\n\u003e Any suggestions?\n\u003e \n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub.\n\u003e \n",
	"user": {
		"login": "davecheney",
		"id": 7171,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-09-02T01:02:59Z",
	"updated_at": "2015-09-02T01:02:59Z"
}
