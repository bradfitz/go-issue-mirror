{
	"id": 66094247,
	"body": "\u003ca id=\"c7\"\u003e\u003c/a\u003eComment 7 by **Zteve.Powell**:\n\n\u003cpre\u003e| the implemented semantics is well established and understood.\n\nI'm not sure how it would be understood. It isn't in the spec, nor in the Go Language\nbook 'Programming in Go' (2012), so perhaps people didn't stumble upon this before then.\nIt can only be understood by experimentation; followed by dreaming up a possible\napplication.  Which, by the way, doesn't sound too useful to me.  If it were so useful,\nit should have a clear marker in the source code, and therefore in the language. As it\nstands you have to be aware of this glitch, recognise it in the source and then reason\nas to why it is there.  A 'private' keyword or some way of indicating restricted\nimplementation types would be better.\n\n| Any change affecting the implemented semantics is tantamount to a language change\nwhich might break\n| existing code\n\nYes. But then, how would this ever be false?  There can be no code that relies upon\nbehaviour that differs from the 'implemented semantics', can there? I think this is a\ngeneral argument that is essentially:\n\n\"It does what it does, and regardless of the language specification or design, we can\nnever change what it does.\"\n\nThis is of course not the case. Otherwise bugs would not be fixed! (Who says they are\nbugs, by the way--the spec?  Nah!)\n\nI think we should at least debate this, rather than dismiss it as 'working as\nimplemented'.\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-05-23T13:31:10Z",
	"updated_at": "2014-12-08T10:43:46Z"
}
