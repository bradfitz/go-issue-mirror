{
	"id": 83760263,
	"body": "So the cause of the error has no effect on the logic of your program, the cause only effects the decision to mute reporting of the error in a log? Did I understand that correctly?\n\n\n\n\u003e On 20 Mar 2015, at 08:01, davem-intersys \u003cnotifications@github.com\u003e wrote:\n\u003e \n\u003e The general strategy I use is to have a \"reader\" goroutine sitting in a [blocking] Read() passing any received []byte buffers to channel. I use ragel based parsers to parse the incoming []byte slices into higher order ResponseMessage's. There's also a \"writer\" that takes a RequestMessage, calls \"ToWire()\" to get a []byte representation and Write()'s it to the network. Usually an inbound ResponseMessage is matched up to the pending RequestMessage (via a channel), occasionally I have unsolicited messages that are posted to a separate channel for out-of-bound processing.\n\u003e \n\u003e This describes the steady-state of the system, aside from normal processing of messages, one of three things can happen:\n\u003e \n\u003e Remote server closes \u0026 disconnects (e.g. it might be restarting etc).\n\u003e Network error (read timeout, host unreachable etc)\n\u003e Local shutdown (e.g. systemctl stop myservice.service)\n\u003e 1 \u0026 2 are similar, in general the system moves to a mode of attempting to reconnect while pausing operations -- the underlying RequestMessage instances will timeout waiting for responses and the application handle that appropriately. In general, if I'm seeing a connection closed by remote host, then I typically suppress the error. If I'm seeing other kinds of network errors, I want to log them.\n\u003e \n\u003e As for 3, I close the network connection from main() (in response to a signal) which forces the \"reader\" out of it's Read() with an error. Again, I don't want to report the error if it's ErrClosed, the reader should shutdown quietly. Otherwise, the reader should be attempting a reconnection.\n\u003e \n\u003e Typically, the \"reader\" handles any reconnecting as the \"writer\" is usually blocking on a select waiting for messages to send, but it's possible that the writer will encounter the error before the reader does. In either case, I call Close() on the connection to ensure that both the reader and writer both see the error.\n\u003e \n\u003e Linux: dead connection detection\n\u003e I have some additional logic in the writer to check the kernel output queue size by calling ioctl(fd, SIOCOUTQ) after a select/time.After(30s) on the write channel. If there's still data in the queue, then it's likely the connection has failed somewhere along the line (despite using TCP_KEEPALIVE) and I need to bounce the connection by calling Close() on it.\n\u003e \n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub.\n\u003e \n",
	"user": {
		"login": "davecheney",
		"id": 7171,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-03-19T21:06:22Z",
	"updated_at": "2015-03-19T21:06:22Z"
}
