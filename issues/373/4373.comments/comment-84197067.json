{
	"id": 84197067,
	"body": "@ianlancetaylor thank you for your comprehensive reply. In response I have re-read the discussion in this issue and need to clarify my statements.\r\n\r\n1. Initially this issue was around net.Listener.Accept() returning an exported type so that callers could distinguish between concurrently closing their own listener, and some other error from the net.Listener implementation.\r\n\r\nI believe through the discussion this use case was debated and found to be insufficient justification.\r\n\r\n2. In Nov 2012 or there abouts I proposed replacing `errClosing` with `io.EOF` and this was rejected. In the three years that followed, I forgot this, sorry.\r\n\r\nIn this current discussion it appears to me that the request is for implementations of `net.Conn.Read` and `net.Conn.Write`, which currently return `errClosing` return an exported type. The motivation is similar, callers want to be able to identify their own actions which resulted in a spurious and this ignorable error. I believe while the motivation is the same as the original request, the specifics are different and this may allow a different conclusion than was reached in 2012.\r\n\r\n\u003e In a comment above you said the errClosing might be wrapped in a net.OpError, but I don't see how that can happen. Can you explain the case where that can occur?\r\n\r\nSo much has changed in the net package since I made those comments I cannot give a compelling justification for those statements, I withdraw that part of my objection.\r\n\r\n\u003e I think it might be useful to distinguish two cases. One is where the read/write is in progress, and then some other goroutine closes the connection. I think we have to return errClosing for that case. Nothing else properly conveys what happened. \r\n\r\nI agree with what you have said, but I don't believe that this issue is about should we return `io.EOF` vs `net.errClosing`, what the OP wants is that `errClosing` be exported so they can check it and quash logging of the error.\r\n\r\nThe OP has indicated that the cause of the error, `io.EOF`, `net.errClosing`, or some other non nil error does not affect their program's logic, only the tertiary process of logging the error. \r\n\r\nFurthermore the OP only appears to be concerned with errors coming from Read and Write; Accept and Close can be considered out of scope for this discussion -- or at least I consider them out of scope.\r\n\r\nTo reduce the scope even more, focussing on the net.Conn.Read method I think that it is reasonable to return `io.EOF` when the socket is closed as there is no more data to read. To me `io.EOF` means just that, there is no more data that can be read -- it is mute on why that is the case.\r\n\r\n\u003e Perhaps if we distinguish those cases we can separate ourselves from concerns that all other interfaces need to support errClosing, and then perhaps we can export it.\r\n\r\nAt the moment we're discussing the types in the net package only, as they are the only ones with access to `net.errClosed`, exporting `net.ErrClosed` so that it was part of the contract of io.Read/Write/Closers that were embedded in the `net.Conn` interface is something I would argue against because it would break the Go 1 guarantee.",
	"user": {
		"login": "davecheney",
		"id": 7171,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-03-20T23:54:30Z",
	"updated_at": "2015-03-20T23:54:30Z"
}
