{
	"id": 113332294,
	"body": "On 19 June 2015 at 11:42, Josh Bleecher Snyder \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e I should be clear that in all of this, I will defer to @rsc\n\u003e \u003chttps://github.com/rsc\u003e, @ianlancetaylor\n\u003e \u003chttps://github.com/ianlancetaylor\u003e, @minux \u003chttps://github.com/minux\u003e,\n\u003e and others who know the linker well.\n\u003e\nMe too :-)\n\n\u003e  I think it's really the format. I guess it would be possible to\n\u003e transplant my code into cmd/internal/goobj and write some more focused\n\u003e benchmarks.\n\u003e\n\u003e This might be a good idea.\n\u003e\nI tried and failed (that's what I get for hacking instead of thinking, I\nguess). Will try again in a bit.\n\n\u003e Given that there is lots of value in object file format stability, it\n\u003e makes sense to make one big change rather than many small ones. The easier\n\u003e it is to experiment and generate good numbers, the easier it will be to\n\u003e have confidene that we've settled on a good design.\n\u003e\nThere is a tension here of course, it's easier to see the benefit of each\nchange you make if you can make them independently. I guess I (or whoever\ndoes this work) can prepare a series of CLs and they can be landed in one\nhit. Or one could declare unstable season on .a files for a short part of\nthe 1.6 cycle, or something.\n\n\u003e It is probably also worth surveying to see whether there are other changes\n\u003e to make at the same time. For example, the current object file format\n\u003e doesn't support jump tables. And there are several issues that might be\n\u003e helped by object file format changes (or might not--I haven't thought it\n\u003e through very far): #7384 \u003chttps://github.com/golang/go/issues/7384\u003e, #7599\n\u003e \u003chttps://github.com/golang/go/issues/7599\u003e, #6993\n\u003e \u003chttps://github.com/golang/go/issues/6993\u003e, #10170\n\u003e \u003chttps://github.com/golang/go/issues/10170\u003e (and thus #6643\n\u003e \u003chttps://github.com/gol%20ang/go/i%20ssues/6643\u003e).\n\u003e\n I guess. Those are all more about the content of the files and I've been\nmostly thinking about the container format really...\n\n\u003e  It also makes the .a files quite a bit (20%?) smaller, which obviously\n\u003e reduces the IO required to read them...\n\u003e\n\u003e I'm surprised that there was so much headroom available,\n\u003e\nYes, I was surprised how much difference it makes. We make multiple\nreferences to symbols a lot in the object files, it seems.\n\n\u003e since IIRC, the current design was intended to be optimized for I/O. I\n\u003e also seem to recall (but can't seem to find a reference or details now)\n\u003e that there was a goal to keep some important info (what?) at the beginning\n\u003e of the file, to enable peeking. Does the symbol table impact that? (I guess\n\u003e I need to figure out the details to answer that.)\n\u003e\nI don't know how my proposed changes affect your extremely vague concern,\nI'm sorry :-)\n\n\u003e Is it safe to assume that you have looked at the Go 1.3 Linker Overhaul\n\u003e doc\n\u003e \u003chttps://docs.google.com/document/d/1xN-g6qjjWflecSP08LNgh2uFsKjWb-rR9KA11ip_DIE/\u003e\n\u003e and the discussion of the file format there?\n\u003e\nIt was sort of in the back of my mind, but really, I was just trying to\nmake the linker faster! Staring at pprof etc. I found these comments in\nobjfile.go after I'd started:\n\n```\n// TODO(rsc): The file format is good for a first pass but needs work.\n// - There are SymID in the object file that should really just be strings.\n// - The actual symbol memory images are interlaced with the symbol\n// metadata. They should be separated, to reduce the I/O required to\n// load just the metadata.\n// - The symbol references should be shortened, either with a symbol\n// table or by using a simple backward index to an earlier mentioned symbol.\n```\n\nand they must have been on my mind too, because basically I've addressed\nthe latter two.\n\u003e\n\u003e  Having a string block so you are converting []byte to string just the\n\u003e once and allocating all the strings/data read from the file as slices of\n\u003e one big string/data block certainly helps a bit too, and those are\n\u003e dependent on changing the format too.\n\u003e\n\u003e Good to know. When I played with this a while ago, I got the sense that\n\u003e the many []byte/string conversions were just a limitation of the code base,\n\u003e not the file format, but I am definitely prepared to believe that I was\n\u003e wrong. :)\n\u003e\nWell, unless there is a way to say to Go \"I know this []byte is mutable,\nbut I promise I'm not going to touch it, so don't bother copying the memory\nwhen I convert it to a string\", I don't see any other way to reduce them.\n\nThere are lots of ways you could speed things up if you are willing to give\nup memory safety :-)\n\n\u003e Thanks for pushing on this. My comments are questions here stem not from\n\u003e resistance but from wanting the next generation (if there is one) to be\n\u003e awesome.\n\u003e\nUnderstood.\n",
	"user": {
		"login": "mwhudson",
		"id": 672022,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-06-19T00:57:55Z",
	"updated_at": "2015-06-19T00:57:55Z"
}
