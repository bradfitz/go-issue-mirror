{
	"id": 163580952,
	"number": 16257,
	"state": "open",
	"title": "proposal: add SASL package to subrepos",
	"body": "I'd like to see a package that provides [RFC 4422][rfc4422] Simple Authentication and Security Layer (SASL) support in the `golang.org/x/` package tree (possibly as `golang.org/x/crypto/sasl`).\r\n\r\nThis could potentially be used under the covers in the `net/smtp` package in the future, and would be broadly useful for people implementing other protocols (IMAP, AMQP, IRC, XMPP, memcached, POP, etc.). It would provide a way for varoius packages to share implementations of SASL mechanisms and not introduce problems by always reinventing the wheel every time something needs a `SCRAM-SHA-1` implementation.\r\n\r\nThe API I had in mind (and have an implementation of) is something like this:\r\n\r\n```go\r\n//  State represents the current state of a Mechanism's underlying state machine. \r\ntype State int8\r\n\r\nconst (\r\n    Initial State = iota\r\n    AuthTextSent\r\n    ResponseSent\r\n    ValidServerResponse\r\n)\r\n\r\nconst (\r\n    // Bit is on if the remote client or server supports channel binding.\r\n    RemoteCB State = 1 \u003c\u003c (iota + 3)\r\n\r\n    // Bit is on if the machine has errored.\r\n    Errored\r\n\r\n    // Bit is on if the machine is a server.\r\n    Receiving\r\n)\r\n\r\n// Mechanism represents a SASL mechanism.\r\n// A Mechanism is stateless and may be shared between goroutines or Negotiators.\r\ntype Mechanism struct {\r\n    //  The name of the mechanism (eg. `DIGEST-MD5` or `SCRAM-SHA-2`).\r\n    Name  string\r\n\r\n    // These functions get called by a Negotiator.\r\n    // I suppose Mechanism could be an interface too, but I like the idea of having\r\n    // it contain these functions so that Step can enforce security constraints on\r\n    // the state machine as much as possible (eg. it can be the only thing that's\r\n    // allowed to mutate the internal state). The bool returned from Next indicates\r\n    // that we should expect more challenges (Step needs to be called again\r\n    // before auth can be completed). The cache return value is stored by a\r\n    // Negotiator and passed back in as the data parameter with the next invocation\r\n    // of Next so that mechanisms can pass state between their steps while still\r\n    // remaining stateless themselves.\r\n    Start func(n Negotiator) (more bool, resp []byte, cache interface{}, err error)\r\n    Next  func(n Negotiator, challenge []byte, data interface{}) (more bool, resp []byte, cache interface{}, err error)\r\n}\r\n\r\n// A Negotiator represents a SASL client or server state machine that can attempt\r\n// to negotiate auth. Negotiators should not be used from multiple goroutines, and\r\n// must be reset between negotiation attempts. \r\ntype Negotiator interface {\r\n    // Step is responsible for advancing the state machine and using the\r\n    // underlying mechanism. It should base64 decode the challenge (using the\r\n    // standard base64 encoding) and base64 encode the response generated from the\r\n    // underlying mechanism before returning it.\r\n    Step(challenge []byte) (more bool, resp []byte, err error)\r\n    State() State\r\n    Config() Config\r\n    Nonce() []byte\r\n    Reset()\r\n}\r\n\r\n// NewClient creates a new SASL client that supports the given mechanisms.\r\nfunc NewClient(m Mechanism, opts ...Option) Negotiator\r\n\r\n// Config is a SASL client or server configuration.\r\ntype Config struct {\r\n    // The state of any TLS connections being used to negotiate SASL (for channel\r\n    // binding).\r\n    TLSState *tls.ConnectionState\r\n\r\n    // A list of mechanisms as advertised by the other side of a SASL negotiation.\r\n    RemoteMechanisms []string\r\n\r\n    // I don't like having these here because other things might need other\r\n    // credentials (PGP key to sign a challenge with, OAuth token, etc.) and\r\n    // Adding tons of extra stuff here isn't very flexible. Suggestions welcome.\r\n    Identity, Username, Password string\r\n}\r\n\r\ntype Option func(*Config)\r\nfunc Authz(identity string) Option {}\r\nfunc ConnState(cs tls.ConnectionState) Option {}\r\nfunc Credentials(username, password string) Option {}\r\nfunc RemoteMechanisms(m ...string) Option {}\r\nâ€¦\r\n\r\nvar (\r\n    Plain Mechanism = plain\r\n\r\n    // These are identical internally, just the Hash used is different. Maybe it would make\r\n    // more sense just to expose a `SCRAM(h hash.Hash) Mechanism`\r\n    // function? On the other hand, 99% of the time people will probably just want these 4\r\n    // since they're the only ones standardized.\r\n    ScramSha256Plus = scram(\"SCRAM-SHA-256-PLUS\", sha256.New)\r\n    ScramSha256 = scram(\"SCRAM-SHA-256\", sha256.New)\r\n    ScramSha1Plus = scram(\"SCRAM-SHA-1-PLUS\", sha1.New)\r\n    ScramSha1 = scram(\"SCRAM-SHA-1\", sha1.New)\r\n)\r\n```\r\n\r\n*EDIT:* I pushed my initial, experimental, implementation with an API similar to this: https://godoc.org/mellium.im/sasl\r\n\r\nRight now my package has a buit in client implementation. Since the server needs to be able to look up things in a database, or hash credentials before comparing them internally, or any number of other things, I made the thing that actually handles negotiation (the \"Negotiator\" for lack of a better name) an interface. Implementations are welcome to use the built in client and implement their own server, or re-implement both and still share the underlying mechanisms so that they don't have to re-implement the crypto or protocol.\r\n\r\n[rfc4422]: https://tools.ietf.org/html/rfc4422",
	"user": {
		"login": "SamWhited",
		"id": 512573,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "Proposal"
		}
	],
	"comments": 0,
	"created_at": "2016-07-03T21:34:21Z",
	"updated_at": "2016-08-20T14:14:00Z",
	"milestone": {
		"id": 1373555,
		"number": 30,
		"title": "Proposal"
	}
}
