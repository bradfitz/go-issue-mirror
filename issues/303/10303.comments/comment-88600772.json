{
	"id": 88600772,
	"body": "This discussion is getting way out of scope for the issue. We are not going to redefine the way cgo works in this issue.\n\nThe problem is that when I converted cgo from generating C stubs to generating Go stubs, I did not preserve the semantics of the generated C stubs, namely that (1) from the compiler's perspective all pointers passed to the stubs escape, and (2) from the garbage collector's perspective all pointers passed to the stubs are kept live for the duration of the stub call.\n\nAs Minux wrote, the fix is similar to what we did in syscall: insert use(x) calls in the stubs after C is done with x, both to make x appear to escape and to make sure it is considered live until that point. Something along these lines should work and not require any assembly. The diff below illustrates what I mean but is not complete (isPointer needs to be defined) and not tested.\n\n\tg% git diff \n\tdiff --git a/src/cmd/cgo/out.go b/src/cmd/cgo/out.go\n\tindex 346ae94..0d36fd0 100644\n\t--- a/src/cmd/cgo/out.go\n\t+++ b/src/cmd/cgo/out.go\n\t@@ -76,6 +76,10 @@ func (p *Package) writeDefs() {\n\t \t\tfmt.Fprintf(fgo2, \"var _ syscall.Errno\\n\")\n\t \t}\n\t \tfmt.Fprintf(fgo2, \"func _Cgo_ptr(ptr unsafe.Pointer) unsafe.Pointer { return ptr }\\n\\n\")\n\t+\tif !*gccgo {\n\t+\t\tfmt.Fprintf(fgo2, \"//go:linkname _Cgo_use runtime.cgoUse\\n\")\n\t+\t\tfmt.Fprintf(fgo2, \"func _Cgo_use(unsafe.Pointer)\\n\")\n\t+\t}\n\t \n\t \ttypedefNames := make([]string, 0, len(typedef))\n\t \tfor name := range typedef {\n\t@@ -403,7 +407,7 @@ func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name) {\n\t \t\treturn\n\t \t}\n\t \n\t-\t// C wrapper calls into gcc, passing a pointer to the argument frame.\n\t+\t// Wrapper calls into gcc, passing a pointer to the argument frame.\n\t \tfmt.Fprintf(fgo2, \"//go:cgo_import_static %s\\n\", cname)\n\t \tfmt.Fprintf(fgo2, \"//go:linkname __cgofn_%s %s\\n\", cname, cname)\n\t \tfmt.Fprintf(fgo2, \"var __cgofn_%s byte\\n\", cname)\n\t@@ -438,6 +442,11 @@ func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name) {\n\t \tif n.AddError {\n\t \t\tfmt.Fprintf(fgo2, \"\\tif errno != 0 { r2 = syscall.Errno(errno) }\\n\")\n\t \t}\n\t+\tfor i, param := range d.Type.Params.List {\n\t+\t\tif isPointer(param.Type) {\n\t+\t\t\tfmt.Fprintf(fgo2, \"\\t_Cgo_use(unsafe.Pointer(p%d))\\n\", i)\n\t+\t\t}\n\t+\t}\n\t \tfmt.Fprintf(fgo2, \"\\treturn\\n\")\n\t \tfmt.Fprintf(fgo2, \"}\\n\")\n\t }\n\tdiff --git a/src/runtime/cgo.go b/src/runtime/cgo.go\n\tindex 5dc83c0..3fc576a 100644\n\t--- a/src/runtime/cgo.go\n\t+++ b/src/runtime/cgo.go\n\t@@ -28,3 +28,11 @@ var iscgo bool\n\t // cgoHasExtraM is set on startup when an extra M is created for cgo.\n\t // The extra M must be created before any C/C++ code calls cgocallback.\n\t var cgoHasExtraM bool\n\t+\n\t+// cgoUse is called by cgo-generated code (using go:linkname to get at\n\t+// an unexported name). The calls serve two purposes:\n\t+// 1) they are opaque to escape analysis, so the argument is considered to\n\t+// escape to the heap.\n\t+// 2) they keep the argument alive until the call site; the call is emitted after\n\t+// the end of the (presumed) use of the argument by C.\n\t+func cgoUse(unsafe.Pointer) {}\n\tg%",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-04-01T19:22:45Z",
	"updated_at": "2015-04-01T19:22:45Z"
}
