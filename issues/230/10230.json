{
	"id": 63886495,
	"number": 10230,
	"state": "closed",
	"title": "net/textproto: does not accept multiline error message",
	"body": "* go version go1.4.1 linux/amd64\r\n* related to #5700 (see last comment by Jeff)\r\n\r\nSummary\r\n=====\r\n```(r *Reader) ReadResponse(expectCode int)``` does not properly read all lines of a single error message (here's why: https://github.com/jnwhiteh/golang/blob/master/src/net/textproto/reader.go#L251).\r\n\r\nUse case\r\n=====\r\nThe above behavior causes a multitude of problems. In my use case case I use ```net.smtp``` to open a single SMTP session to Gmail MX server, and then I repeat multiple times (below is a gist of it) for every message I have in a queue for this server (to avoid opening \u0026 closing a separate connection for every message).:\r\n```go\r\nfor ....... {\r\n    if err = c.Reset(); err != nil {return err}\r\n    if err = c.Mail(); err != nil {return err}\r\n    if err = c.Rcpt(); err != nil {return err}\r\n    if err = c.Data(); err != nil {return err}\r\n}\r\n```\r\n\r\nAssuming that a recipient's email address doesn't exist, Gmail would return a multiline 550 error message, like this one:\r\n```\r\n550 5.1.1 The email account that you tried to reach does not exist. Please try\r\n550 5.1.1 double-checking the recipient's email address for typos or\r\n550 5.1.1 unnecessary spaces. Learn more at\r\n550 5.1.1 http://support.google.com/mail/bin/answer.py?answer=6596 k3si4281809wjy.17 - gsmtp\r\n```\r\n\r\nHowever, ```err``` returned by ```c.Rcpt()``` would **only have the first line**.\r\n**Following lines will be returned by ```c.Reset``` in the following iteration of the loop, line by line**!\r\nThis completely prevents me from reusing the connection, as there is no reliable way of flushing the remaining error message lines to get a \"clean\" smtp.Client. If ```c.Reset()``` doesn't do that, what will?\r\n\r\nWorkaround\r\n=======\r\nI have written the following patch which fixes the problem. It passes the current reader test for a multi-line message but there is no test for a multi-line error (and I did not write one yet). The logic seems correct and I have tested this with smtp.Client - the problem mentioned above goes away and ```c.Rcpt()``` correctly returns a multiline error and smtp.Client may be reused for another message.\r\n\r\n```diff\r\n--- /root/reader.go     2015-03-24 01:51:58.000000000 +0100\r\n+++ /usr/local/go/src/net/textproto/reader.go   2015-03-24 03:14:01.818576915 +0100\r\n@@ -248,21 +248,43 @@\r\n //\r\n func (r *Reader) ReadResponse(expectCode int) (code int, message string, err error) {\r\n        code, continued, message, err := r.readCodeLine(expectCode)\r\n-       for err == nil \u0026\u0026 continued {\r\n-               line, err := r.ReadLine()\r\n-               if err != nil {\r\n-                       return 0, \"\", err\r\n-               }\r\n+       if err == nil {\r\n+               for err == nil \u0026\u0026 continued {\r\n+                       line, err := r.ReadLine()\r\n+                       if err != nil {\r\n+                               return 0, \"\", err\r\n+                       }\r\n \r\n-               var code2 int\r\n-               var moreMessage string\r\n-               code2, continued, moreMessage, err = parseCodeLine(line, expectCode)\r\n-               if err != nil || code2 != code {\r\n-                       message += \"\\n\" + strings.TrimRight(line, \"\\r\\n\")\r\n-                       continued = true\r\n-                       continue\r\n+                       var code2 int\r\n+                       var moreMessage string\r\n+                       code2, continued, moreMessage, err = parseCodeLine(line, expectCode)\r\n+                       if err != nil || code2 != code {\r\n+                               message += \"\\n\" + strings.TrimRight(line, \"\\r\\n\")\r\n+                               continued = true\r\n+                               continue\r\n+                       }\r\n+                       message += \"\\n\" + moreMessage\r\n+               }\r\n+       } else {\r\n+               var moreErrMessage string\r\n+               for continued {\r\n+                       line, err2 := r.ReadLine()\r\n+                       if err2 != nil {\r\n+                               break\r\n+                       }\r\n+                       var code2 int\r\n+                       var moreMessage string\r\n+                       code2, continued, moreMessage, err2 = parseCodeLine(line, 0)\r\n+                       if err2 != nil || code2 != code {\r\n+                               moreErrMessage += \"\\n\" + strings.TrimRight(line, \"\\r\\n\")\r\n+                               continued = true\r\n+                               continue\r\n+                       }\r\n+                       moreErrMessage += \"\\n\" + moreMessage\r\n+               }\r\n+               if moreErrMessage != \"\" {\r\n+                       err = \u0026Error{code, message+moreErrMessage}\r\n                }\r\n-               message += \"\\n\" + moreMessage\r\n        }\r\n        return\r\n }\r\n```",
	"user": {
		"login": "DSpeichert",
		"id": 1254971,
		"type": "User",
		"site_admin": false
	},
	"comments": 5,
	"closed_at": "2016-01-08T16:33:06Z",
	"created_at": "2015-03-24T02:36:12Z",
	"updated_at": "2016-01-08T16:33:06Z",
	"milestone": {
		"id": 1055141,
		"number": 6,
		"title": "Unplanned"
	}
}
