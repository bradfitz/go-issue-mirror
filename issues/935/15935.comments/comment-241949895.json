{
	"id": 241949895,
	"body": "@nightlyone \r\n\u003e The exact error is usually not needed to decide what to do once the application is running, since complete error enumerations is an endless, never complete task. But what is useful, is to support the decision, whether I should retry (Temporary() == true), ignore it (in the cancel case) or report it.\r\n\r\nIf only it were that simple! Before seeing this issue, you might have reasonably concluded that Temporary() was \"good enough\" to make programmatic decisions regarding HTTP errors. Then this bug added another case, which is to ignore canceled errors. Your errorclass seems to handle this case.\r\n\r\nThen a future bug wants to know if the request timed out because Transport.ResponseHeaderTimeout was exceeded, or because Transport.TLSHandshakeTimeout was exceeded, or because the req.Context exceeded its deadline, or because of a DNS timeout, or because of a TCP connect timeout, etc. You cannot answer these questions with a simple IsTimeout() method on the error.\r\n\r\nFor example: I maintain a large proxy service that uses net/http. Rather than logging net/http errors as strings, we convert net/http errors into a custom enum error space (mostly because it's easy to verify that an enum doesn't contain PII, compared to an error string, which can contain arbitrary info; also, enums are easier to process than strings at large scales). Part of that service is ~70 lines of code that tries to convert the error returned by RoundTrip() or Body.Read() into an error in our custom enum space. This code actually isn't too bad. The standard library already exports types like net.OpError, net.DNSError, and os.SyscallError. However, we check for ResponseHeaderTimeout errors by checking for error strings that contain \"timeout awaiting response headers\". This introspection would be unnecessary if net/http's errTimeout was exported.\r\n\r\nI agree with your comment that \"complete error enumerations is an endless, never complete task\", but that comment is also overly pessimistic. Here's a simple rule: if an API exports N knobs, then it should also export N error types or vars, where each error means that the operation failed due to the corresponding knob. For net/http.RoundTrip, I think three errors could be exported following this rule:\r\n\r\n```plain\r\nerrTimeout               // Transport.ResponseHeaderTimeout\r\nerrRequestCanceled       // Transport.CancelRequest, Request.Cancel, Request.Context\r\ntlsHandshakeTimeoutError // Transport.TLSHandshakeTimeout\r\n```\r\n\r\nNote that `errRequestCanceledConn` doesn't need to be exported since it's controlled by the same knob as `errRequestCanceled`. Plus, the caller can use the new httptrace API to figure out when the error happened.\r\n\r\n(Footnote: I think you could make a case that RoundTrip should return Request.Context().Err() instead of errRequestCanceled when Request.Context() completes, to preserve that original error.)",
	"user": {
		"login": "tombergan",
		"id": 13954200,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-24T03:46:54Z",
	"updated_at": "2016-08-24T03:46:54Z"
}
