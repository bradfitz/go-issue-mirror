{
	"id": 180418217,
	"number": 17304,
	"state": "open",
	"title": "gccgo: compiler temp slice storage performance improvement",
	"body": "While looking at the code generated by gccgo when used to compile the go compiler, it was apparent that there are some unnecessary allocations in the generated code for the function cmd/compile/internal/ssa.applyRewrite().\r\n\r\nIn this routine there is a worklist (slice of pointers) that gets appended to in an inner loop. Code from deadcode.go:\r\n\r\n```\r\n\t// Find all live values\r\n\tvar q []*Value // stack-like worklist of unscanned values\r\n\r\n  ....\r\n\t\tif v := b.Control; v != nil \u0026\u0026 !live[v.ID] {\r\n\t\t\tlive[v.ID] = true\r\n\t\t\tq = append(q, v)\r\n\t\t}\r\n\r\n```\r\n\r\nFor the append call, gccgo as part of the lowering process creates a temporary slice value to hold \"v\"; the slice is then passed to the routine __go_append(). The storage underlying the temp slice is heap-allocated, which is not needed (the storage doesn't escape), so we wind up with spurious allocations + garbage.  It would be better to catch this case and insure that the storage in question is always stack allocated (this applies in cases where there are call to other varargs routines as well).",
	"user": {
		"login": "thanm",
		"id": 12280172,
		"type": "User",
		"site_admin": false
	},
	"assignee": {
		"login": "thanm",
		"id": 12280172,
		"type": "User",
		"site_admin": false
	},
	"comments": 1,
	"created_at": "2016-09-30T22:52:44Z",
	"updated_at": "2016-10-03T22:34:29Z",
	"milestone": {
		"id": 1069171,
		"number": 23,
		"title": "Gccgo"
	}
}
