{
	"id": 166751740,
	"body": "FYI. In case anyone is interested/would benefit: I got the shell string cache solution mentioned above working (example code below) but I would no longer recommend that solution.\r\n\r\nThe system still requires a resource dll (and you will probably need two versions, one for 64-bit systems and one for 32-bit as well; I have no way of testing the latter). The system also requires that the resource IDs exists in the dll. Once you have those requirements down you can inject the shell string cache with known values and those will be returned when you call GetMUIStringValue.\r\n\r\nThe string cache is however located in different locations depending on OS version. All in all this feels very brittle and complex, so like I said, I would not recommend this solution if the current strategy (testing GetMUIStringValue against another Windows function) ever needs to be revised.\r\n\r\nExample code (could contain bugs):\r\n\r\n```go\r\nfunc TestGetMUIStringValue(t *testing.T) {\r\n\r\n\twd, _ := os.Getwd()\r\n\r\n\tvar tests = []struct {\r\n\t\tname  string\r\n\t\twant  interface{}\r\n\t\tdata  string\r\n\t\tcache bool // if true, inject data into shell string cache, otherwise false\r\n\t}{\r\n\t\t{name: \"Valid string (with path)\", want: \"a value\", data: \"@\" + wd + \"\\\\testdata\\\\resource.dll,-666\", cache: true},\r\n\t\t{name: \"Invalid string (wrong format)\", want: error(registry.ErrInvalidData), data: \"a value\"},\r\n\t\t{name: \"Invalid string (dll missing)\", want: error(registry.ErrNotExist), data: \"@shouldnotexist666.dll,-1\"},\r\n\t}\r\n\r\n\tif err := registry.LoadRegLoadMUIString(); err != nil {\r\n\t\tt.Skip(\"regLoadMUIString not supported; skipping\")\r\n\t}\r\n\r\n\tbasek, kpath := registry.CURRENT_USER, \"Software\\\\\"+randKeyName(\"TestMUIValues_\")\r\n\tk, err := tempSubKey(basek, kpath)\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\tdefer k.Close()\r\n\tdefer registry.DeleteKey(basek, kpath)\r\n\r\n\tfor _, test := range tests {\r\n\t\tif err = k.SetStringValue(test.name, test.data); err != nil {\r\n\t\t\tt.Fatalf(\"SetValue for %q failed: %v\", test.name, err)\r\n\t\t}\r\n\t}\r\n\r\n\tdefer walkShellStringCache(func(k registry.Key) {\r\n\t\tfor _, test := range tests {\r\n\t\t\tif test.cache {\r\n\t\t\t\tk.DeleteValue(test.data)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\twalkShellStringCache(func(k registry.Key) {\r\n\t\tfor _, test := range tests {\r\n\t\t\tif test.cache {\r\n\t\t\t\tif err = k.SetStringValue(test.data, test.want.(string)); err != nil {\r\n\t\t\t\t\tt.Fatalf(\"SetValue for %q failed: %v\", test.name, err)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfor _, test := range tests {\r\n\t\tvar got interface{}\r\n\t\tgot, err = k.GetMUIStringValue(test.name)\r\n\t\tif _, ok := test.want.(error); ok {\r\n\t\t\tgot = err\r\n\t\t}\r\n\t\tif got != test.want {\r\n\t\t\tt.Errorf(\"GetMUIStringValue: %s: Got %T %q, want %T %q\", test.name, got, got, test.want, test.want)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc tempSubKey(basek registry.Key, path string) (k registry.Key, err error) {\r\n\tk, _, err = registry.CreateKey(basek, path, registry.CREATE_SUB_KEY|registry.QUERY_VALUE|registry.SET_VALUE)\r\n\tif err != nil {\r\n\t\treturn 0, err\r\n\t}\r\n\treturn k, nil\r\n}\r\n\r\nfunc walkShellStringCache(visitorFn func(registry.Key)) error {\r\n\r\n\tkeys := []struct {\r\n\t\tk    registry.Key\r\n\t\tpath string\r\n\t}{\r\n\t\t// https://msdn.microsoft.com/en-us/goglobal/bb688098.aspx\r\n\t\t//{registry.CURRENT_USER, `SOFTWARE\\Classes\\Local Settings\\RegMuiCache`},                               // Vista and Windows 2008\r\n\t\t//{registry.CURRENT_USER, `SOFTWARE\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\MuiCache`}, // Vista and Windows 2008\r\n\t\t{registry.CURRENT_USER, `SOFTWARE\\Classes\\Local Settings\\MuiCache`}, // Windows 7\r\n\t\t//{registry.CLASSES_ROOT, `Local Settings\\MuiCache`},                                                   // Windows 7\r\n\t}\r\n\r\n\tfor _, key := range keys {\r\n\t\tif err := walkLeafs(key.k, key.path, visitorFn); err != nil \u0026\u0026 err != registry.ErrNotExist {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc walkLeafs(k registry.Key, path string, visitorFn func(registry.Key)) error {\r\n\r\n\tsubk, err := registry.OpenKey(k, path, registry.ENUMERATE_SUB_KEYS|registry.QUERY_VALUE|registry.SET_VALUE)\r\n\tif err != nil {\r\n\t\tif err == syscall.ERROR_ACCESS_DENIED {\r\n\t\t\t// ignore error, if we are not allowed to access this key\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\treturn err\r\n\t}\r\n\tdefer subk.Close()\r\n\r\n\tsubkNames, err := subk.ReadSubKeyNames(-1)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\r\n\tif len(subkNames) == 0 {\r\n\t\tvisitorFn(subk)\r\n\t\treturn nil\r\n\t}\r\n\r\n\tfor _, subkName := range subkNames {\r\n\t\tif err := walkLeafs(k, path+\"\\\\\"+subkName, visitorFn); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n```\r\n",
	"user": {
		"login": "dajoo75",
		"id": 6588569,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-22T22:31:09Z",
	"updated_at": "2015-12-22T22:31:09Z"
}
