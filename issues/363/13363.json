{
	"id": 118290524,
	"number": 13363,
	"state": "closed",
	"title": "runtime: nil pointer dereference in sigtrampgo",
	"body": "While stress testing TestStackBarrierProfiling at 54bd5a7 on master, I got a segfault in `sigtrampgo` in signal_linux.go because g != nil, but g.m == nil.\r\n\r\nI've saved the binary and core file. Here is some preliminary digging through the core:\r\n\r\n```\r\nCore was generated by `./pprof.test -test.run=TestStackBarrierProfiling'.\r\nProgram terminated with signal SIGSEGV, Segmentation fault.\r\n#0  0x000000000043de2e in runtime.sigtrampgo (sig=11, info=0xc820061bf0, \r\n    ctx=0xc820061ac0) at /home/austin/go.dev/src/runtime/signal_linux.go:20\r\n20\t\tsetg(g.m.gsignal)\r\nLoading Go Runtime support.\r\n(gdb) bt\r\n#0  0x000000000043de2e in runtime.sigtrampgo (sig=11, info=0xc820061bf0, \r\n    ctx=0xc820061ac0) at /home/austin/go.dev/src/runtime/signal_linux.go:20\r\n#1  0x000000000045c93b in runtime.sigtramp ()\r\n    at /home/austin/go.dev/src/runtime/sys_linux_amd64.s:234\r\n#2  0x000000000045c940 in runtime.sigtramp ()\r\n    at /home/austin/go.dev/src/runtime/sys_linux_amd64.s:235\r\n#3  0x0000000000000001 in ?? ()\r\n#4  0x0000000000000000 in ?? ()\r\n(gdb) print/x *g\r\n$5 = {stack = {lo = 0xc820092000, hi = 0xc820092800}, \r\n  stackguard0 = 0xfffffffffffffade, stackguard1 = 0xffffffffffffffff, \r\n  _panic = 0x0, _defer = 0x0, m = 0x0, stackAlloc = 0x1000, sched = {sp = 0x0, \r\n    pc = 0x459140, g = 0xc820001200, ctxt = 0x0, ret = 0x0, lr = 0x0, \r\n    bp = 0x4}, syscallsp = 0x0, syscallpc = 0x0, stkbar =  []runtime.stkbar, \r\n  stkbarPos = 0x0, stktopsp = 0xc8200927d8, param = 0x0, atomicstatus = 0x2, \r\n  stackLock = 0x0, goid = 0x6, waitsince = 0x0, \r\n  waitreason = \"GC worker (idle)\", schedlink = 0x0, preempt = 0x1, \r\n  paniconfault = 0x0, preemptscan = 0x0, gcscandone = 0x1, gcscanvalid = 0x0, \r\n  throwsplit = 0x0, raceignore = 0x0, sysblocktraced = 0x0, \r\n  sysexitticks = 0x0, sysexitseq = 0x0, lockedm = 0x0, sig = 0x0, \r\n  writebuf =  []uint8, sigcode0 = 0x0, sigcode1 = 0x0, sigpc = 0x0, \r\n  gopc = 0x418163, startpc = 0x4181d0, racectx = 0x0, waiting = 0x0, \r\n  gcAssistBytes = 0x0}\r\n(gdb) x/i g.sched.pc\r\n   0x459140 \u003cruntime.systemstack_switch\u003e:\tretq   \r\n(gdb) x/i g.gopc\r\n   0x418163 \u003cruntime.gcBgMarkStartWorkers+147\u003e:\t\r\n    lea    0x2a4c96(%rip),%rbx        # 0x6bce00 \u003cruntime.work\u003e\r\n(gdb) x/i g.startpc\r\n   0x4181d0 \u003cruntime.gcBgMarkWorker\u003e:\tmov    %fs:0xfffffffffffffff8,%rcx\r\n\r\n(gdb) print/x *(struct 'runtime.sigcontext'*)(ctx+40)\r\n$11 = {r8 = 0x0, r9 = 0x0, r10 = 0xc82003ef18, r11 = 0x206, r12 = 0x800, \r\n  r13 = 0x400, r14 = 0x9, r15 = 0x8, rdi = 0x6bcdb0, rsi = 0x0, \r\n  rbp = 0xc820026000, rbx = 0x0, rdx = 0x0, rax = 0xc820001200, \r\n  rcx = 0xc820001200, rsp = 0xc820092738, rip = 0x45920d, eflags = 0x10246, \r\n  cs = 0x33, gs = 0x0, fs = 0x0, __pad0 = 0x0, err = 0x4, trapno = 0xe, \r\n  oldmask = 0x0, cr2 = 0x0, fpstate = 0xc820061c80, __reserved1 = {0x0, 0x0, \r\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}\r\n(gdb) x/i $11.rip\r\n   0x45920d \u003cruntime.morestack+13\u003e:\tmov    (%rbx),%rsi\r\n(gdb) x/21a $11.rsp\r\n0xc820092738:\t0x4189e2 \u003cruntime.gcFlushGCWork+130\u003e\t0x417390 \u003cruntime.gcMarkDone+560\u003e\r\n0xc820092748:\t0x619060 \u003cruntime.stopTheWorldWithSema.f\u003e\t0xffffffff00000001\r\n0xc820092758:\t0xffffffff00000001\t0x4186a8 \u003cruntime.gcBgMarkWorker+1240\u003e\r\n0xc820092768:\t0x0\t0x0\r\n0xc820092778:\t0xffffffff\t0x10\r\n0xc820092788:\t0x14\t0x0\r\n0xc820092798:\t0xffffffff01000000\t0xfffffffe\r\n0xc8200927a8:\t0x2120869068188\t0x0\r\n0xc8200927b8:\t0xc820034800\t0xc820001200\r\n0xc8200927c8:\t0x618e78 \u003cruntime.gcBgMarkWorker.func1.f\u003e\t0x45bba1 \u003cruntime.goexit+1\u003e\r\n0xc8200927d8:\t0xc820024a00\r\n(gdb) disassemble 'runtime.gcBgMarkWorker'\r\n   0x00000000004186a3 \u003c+1235\u003e:\tcallq  0x417160 \u003cruntime.gcMarkDone\u003e\r\n   0x00000000004186a8 \u003c+1240\u003e:\tmov    %fs:0xfffffffffffffff8,%rax\r\n(gdb) disassemble 'runtime.gcMarkDone'\r\n   0x000000000041738b \u003c+555\u003e:\tcallq  0x418960 \u003cruntime.gcFlushGCWork\u003e\r\n   0x0000000000417390 \u003c+560\u003e:\tcallq  0x41a650 \u003cruntime.gcWakeAllAssists\u003e\r\n(gdb) disassemble 'runtime.gcFlushGCWork'  \r\n   0x00000000004189dd \u003c+125\u003e:\tcallq  0x459290 \u003cruntime.morestack_noctxt\u003e\r\n   0x00000000004189e2 \u003c+130\u003e:\tjmpq   0x418960 \u003cruntime.gcFlushGCWork\u003e\r\n```\r\n\r\nThis appears to be a nested signal. The original signal was a SIGSEGV in morestack at `MOVQ\tm_g0(BX), SI` because BX (getg().m) is 0. The signal handler then also crashed for the same reason. We clearly tried to grow the stack in gcFlushGCWork (the stack is very small because this test runs in gcstackbarrierall mode), but I'm not sure why there wasn't an M at that point. It may be related to the fact that we've stopped the world in gcMarkDone at that point.\r\n\r\nThis is relatively easy to reproduce. It happened five times out of 3,000 stress runs on my workstation (which took ~25 minutes).",
	"user": {
		"login": "aclements",
		"id": 2688315,
		"type": "User",
		"site_admin": false
	},
	"comments": 8,
	"closed_at": "2016-01-27T02:14:10Z",
	"created_at": "2015-11-22T21:42:45Z",
	"updated_at": "2016-01-27T02:14:10Z",
	"milestone": {
		"id": 1096159,
		"number": 24,
		"title": "Go1.6"
	}
}
