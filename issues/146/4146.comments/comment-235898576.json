{
	"id": 235898576,
	"body": "The ability to create a new types with a method sets would greatly reduce the boilerplate in many use cases I have. I find myself forced to implement various interfaces(i.e.  MarshalJSON/UnmarshalJSON,  datastore.PropertyLoadSaver) when I need to unmarshal data into types with overlapping fields even if the process/body of the methods is basically same except the types involved. See a stub below[0]. This could be generalised [1] if there was a way to create types with method sets.\r\n\r\n[1]\r\n```\r\n// NewQueryDecoder creates a virtual struct using StructOf and implements PropertyLoadSaver\r\ndq := NewQueryDecoder(reflect.TypeOf(T1{}), reflect.TypeOf(T2{}), reflect.TypeOf(T3{}))\r\n// Execute a query\r\n// dq.Query wraps the datastore query, allocates a new value using the virtual struct\r\n//  and returns the value matching one of the types from NewQueryDecoder as interface{} \r\nresult, err := dq.Query(\"filter1=\", true, \"filter2=\", false)\r\n// type assert\r\nswitch result.(type){\r\ncase T1:\r\ncase T2:\r\ncase T3\r\n}\r\n```\r\n\r\n```\r\ntype T1 struct{\r\n  F1 string\r\n  FT1 bool\r\n} \r\n\r\ntype T2 struct{\r\n  F1 string\r\n  FT2 bool\r\n} \r\n\r\ntype T2 struct{\r\n  F1 string\r\n  FT3 bool\r\n} \r\n\r\n```\r\n\r\n[0]\r\n```\r\ntype TOneOf struct{\r\n\tType string `datastore:\"@type\"`\r\n\t*T1\r\n\t*T2\r\n\t*T3\r\n}\r\n\r\nfunc (x *TOneOf) Load(ps []datastore.Property) error {\r\n\tFor k := range ps{\r\n\t\tif ps[k].Name != \"@type\"{\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tx.Type = ps[k].Value.(string)\r\n\t\tbreak\r\n\t}\r\n        st := reflect.TypeOf(x)\r\n\tswitch x.Type{\r\n\tcase RefReflect(st.Field(1)):\r\n\t\tval = reflect.New(st.Field(1))\r\n\t\tif err = datastore.LoadStruct(val.Interface(), ps); err != nil{\r\n\t\t\treturn err\r\n\t\t}\r\n\t\treflect.ValueOf(x).Field(1).Set(val.Elem())\r\n\t\treturn nil\r\n\tcase RefReflect(st.Field(2)):\r\n\t\tval = reflect.New(st.Field(2))\r\n\t\tif err = datastore.LoadStruct(val.Interface(), ps); err != nil{\r\n\t\t\treturn err\r\n\t\t}\r\n\t\treflect.ValueOf(x).Field(2).Set(val.Elem())\r\n\t\treturn nil\r\n\tcase RefReflect(st.Field(3)):\r\n\t\tval = reflect.New(st.Field(3))\r\n\t\tif err = datastore.LoadStruct(val.Interface(), ps); err != nil{\r\n\t\t\treturn err\r\n\t\t}\r\n\t\treflect.ValueOf(x).Field(3).Set(val.Elem())\r\n\t\treturn nil\r\n\t}\r\n\treturn errors.New(\"Invalid type: \"+  x.Type)\r\n}\r\n\r\n// RefReflect returns the type path (importPath.Type)\r\n// e.g. encoding/json.Encoder\r\nfunc RefReflect(t reflect.Type)string{\r\n  // stub\r\n    return t.String()\r\n}\r\n```",
	"user": {
		"login": "themihai",
		"id": 1800192,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-28T13:45:15Z",
	"updated_at": "2016-07-28T13:45:15Z"
}
