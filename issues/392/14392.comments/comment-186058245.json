{
	"id": 186058245,
	"body": "I've been thinking about this since your initial response, and I still am in agreement that requests with headers like this should be rejected. But I wonder if it was necessary to make this change in a way that cannot be managed by the person consuming `net/http`.\r\n\r\nIn the document, [Go 1 and the Future of Go Programs](https://golang.org/doc/go1compat), there is the following statement made in the introduction:\r\n\r\n\u003eIt is intended that programs written to the Go 1 specification will continue to compile and run correctly, unchanged, over the lifetime of that specification. At some indefinite point, a Go 2 specification may arise, but until that time, Go programs that work today should continue to work even as future \"point\" releases of Go 1 arise (Go 1.1, Go 1.2, etc.).\r\n\r\nOf course, it is intended that they do not change. In no way is it stating this is a binding statement. That's also confirmed based on a later section:\r\n\r\n\u003eAlthough we expect that the vast majority of programs will maintain this compatibility over time, it is impossible to guarantee that no future change will break any program. This document is an attempt to set expectations for the compatibility of Go 1 software in the future. There are a number of ways in which a program that compiles and runs today may fail to do so after a future point release. They are all unlikely but worth recording.\r\n\u003e\r\n\u003e ...\r\n\u003e \r\n\u003e* Specification errors. If it becomes necessary to address an inconsistency or incompleteness in the specification, resolving the issue could affect the meaning or legality of existing programs. We reserve the right to address such issues, including updating the implementations. Except for security issues, no incompatible changes to the specification would be made.\r\n\r\nI think it was necessary to update `net/http` to reject requests with invalid headers. I'm not sure it was necessary to do so in a way that cannot be controlled by the consumer. I think it's possible to enhance this implementation in a way that achieves the goal of meeting spec, while having a clean workaround to achieve backwards-compatible behavior. Right now there isn't one.\r\n\r\nAny favorite whiskies I could bribe you with to allow one small API addition to give consumers control of the whitelist? :smile: \r\n\r\nHonestly, the more I think about having the one item added to a whitelist the more gross it feels. I'd rather not go down that path. Is there a way it could be implemented that feels natural and doesn't add much weight? I'd be happy to offer my time to implement it and go through the CR process.",
	"user": {
		"login": "theckman",
		"id": 787332,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-02-19T05:26:44Z",
	"updated_at": "2016-02-19T05:26:44Z"
}
