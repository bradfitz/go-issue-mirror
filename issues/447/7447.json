{
	"id": 51286721,
	"number": 7447,
	"state": "open",
	"title": "runtime: propose default alg-\u003eequals and alg-\u003ehash when nil",
	"body": "by **carlchatfield**:\n\n\u003cpre\u003eHello,\n\nI have been grappling with defining a suitable Alg for types created at runtime.\nThe problem is that for each comparable type not stored in continuous (memcmp-able)\nmemory, specific code is generated by the compiler to perform the equals/hash operations.\n\nTo create types at runtime, e.g. using reflect, emitting type specific equals/hash code\nis difficult because the code must somehow reference the type.\nAfter much grappling, I have come to the conclusion that having a default equals and\nhash function may be the simplest solution.\n\nTypes not compiled into the binary can only ever exist in the runtime as interfaces. If\na type assertion from Value.Interface() to X existed in the code, X would also exist in\nthe binary. Note that if the type is compiled into the binary, there is no need to\ngenerate an Alg.\n\nThis means types created at runtime are only ever compared/hashed indirectly through\nruntime.interhash() and runtime.interequal(). In each case, there is exactly one spot in\nthe code where the underlying type-\u0026gt;alg-\u0026gt;equals/hash is called, ifaceeq1 and\nifacehash1 of iface.goc. Note that at both points the type of the underlying memory is\nknown, making generic algorithms feasible.\n\nTherefore, IMHO a clean solution to the problem is to add an extra case here to make a\ngeneric equals/hash when the corresponding field is nil.\n\nIf this sounds reasonable I am prepared to try my hand at it.\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "Thinking"
		}
	],
	"comments": 5,
	"created_at": "2014-03-03T20:06:15Z",
	"updated_at": "2015-04-14T19:45:22Z",
	"milestone": {
		"id": 1055141,
		"number": 6,
		"title": "Unplanned"
	}
}
