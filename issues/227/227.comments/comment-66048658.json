{
	"id": 66048658,
	"body": "\u003ca id=\"c12\"\u003e\u003c/a\u003eComment 12:\n\n\u003cpre\u003eI've run into a number of cases where, say, a given Linux distribution doesn't provide a\nuseful/secure/correct daemonization wrapper utility, if any at all. In this case,\nself-daemonization, which is the defacto method, is assumed (and a good self-daemonizing\nprogram will have an option to leave a pidfile and logfiles, which will make it easy to\nmonitor the process).  Since daemonization really only occurs in the wild during\ninitialization, it really ought to be called from an init function.\n\nIn order to make fork safe for daemonization, and seeing that the spec has now changed\n(goroutines now *can* run during initialization), all we need to do is any one of three\nthings:\n\n1) Disallow creation of os threads during initialization, where go's concurrency support\nis only for concurrency, not parallelization, as Rob Pike might say -- all goroutine\nswitching during init would probably need to be cooperative (through blocking or\nruntime.Gosched), which may not be possible to accomplish in the current runtime.\n\n2) Create something like a runtime.SuspendAll() function, upon returning, guarantees\nthat all other threads are muxed off of os threads (which are destroyed) and the calling\ngoroutine is run alone until a complimentary function, like a runtime.ResumeAll() is\ncalled. This is not the same as GOMAXPROCS, which doesn't restrict the number of threads\nused by the runtime (this option would need to account for those as well).\n\n3) Amend the published spec to require that unrelated dependencies initialize in\ncode-order (this would also mean that gofmt wouldn't be allowed to reorder imports), or\nat least that independent import groups occur in source order. So at the minimum, the\nfollowing should require that daemon initialize fully before threadspawner:\n\nimport \"daemon\" // daemon imports nothing\nimport (\n  \"fmt\"\n  \"os\"\n  \"threadspawner\" // threadspawner imports nothing\n)\n\n(Binaries produced from 6g and friends appear to do this in either undefined or reverse\norder).\n\nKnowing nothing about the toolchain/runtime internals, #3 is probably the simplest to\nimplement -- if you want to argue that the compiler be allowed to optimize for speed\n(putting goroutines-spawning initializers before non-concurrent initializers), keep in\nmind that initialization is not a critical place for speed (in a long running program,\ninitialization time counts for nothing, and in short running programs, heavy lifting is\nusually *not* done in initialization).\u003c/pre\u003e",
	"user": {
		"login": "extemporalgenome",
		"id": 536740,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2012-01-10T09:27:12Z",
	"updated_at": "2014-12-08T10:03:44Z"
}
