{
	"id": 152540264,
	"body": "Thank you for filing this proposal. I found some information online that made the case for decimal floating-point a bit clearer to me, and I want to summarize what helped me.\n\nMike Cowlishaw appears to be the driving force behind the adoption of decimal floating-point, and he has an extensive web site dedicated to the topic at speleotrove.com/decimal.\n\n- The first important fact is to remember that rounding twice necessarily introduces errors. If you are working in binary floating-point then each operation rounds to nearest binary float and then printing rounds to decimal, making it nearly impossible _not_ to round twice. If you're doing complex numerical calculations, there are already multiple rounding steps, so one more is not a big deal. But many basic financial calculations are not complex, so that in decimal they may be possible to do with no rounding or with just one rounding step, and in those common cases, the difference between binary and decimal manifests as apparently incorrect computations. Cowlishaw's usual example is that 5% tax on a $0.70 purchase computes in binary float64s as 0.73499999999999998667732370449812151491641998291015625 instead of 0735, so rounding to two decimal places with half-up or half-even incorrectly rounds down ([playground](http://play.golang.org/p/rDRWDeYq7B)). In many applications it's important that simple calculations like this match what humans do by hand, and the imprecision due to binary rounding introduces mismatches.\n\n- The second important fact is that (surprise!) decimal floating-point uses a non-normalized representation. 2.5 and 2.50 have different representations, and 1.13+1.37 = 2.50, not 2.5. In general if you're using a decimal floating-point type with storage for N digits and a computation produces a result with fewer than N digits, you know that computation was exact: it involved no implicit round-off whatsoever. For example, assuming for simplicity a 5-digit decimal type, 1.0/3 = 0.33333 but 1.0/5 = 0.2 and 1.00/5 = 0.20. In the last two cases, the results 0.2 and 0.20 (both not 0.20000) signals that the math that produced them was exact. Binary floating-point, being normalized, does not carry this information about number of digits needed for the result, and not many people would care about the number of binary digits anyway.\n\nAs I understand it, these are the two compelling reasons to have separate support for decimal floating-point. For more I suggest the entire speleotrove.com/decimal site, but especially the [FAQ](http://speleotrove.com/decimal/decifaq.html) and the paper [Decimal Floating-Point: Algorism for Computers](http://speleotrove.com/decimal/IEEE-cowlishaw-arith16.pdf)\n\nNow suppose we want to make decimal floating-point available to Go programmers. What do we do next? We need more experience with the implementation, API choices, and how many people can use it. I would not wrap Cowlishaw's code (both for licensing and for Go maintenance reasons) but I would certainly use his test suite, much as package regexp does not wrap RE2 but reuses its test suite.\n\nIt seems to me the thing to do is to get the developers interested in an implementation working together on a single implementation. It's fine with me if they use golang.org/x/exp/decimal for now, and when we think it is ready for general use we can move it out of exp.\n\nWho is interested in working on this?",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-10-30T14:26:35Z",
	"updated_at": "2015-10-30T14:26:35Z"
}
