{
	"id": 130128365,
	"body": "The various trace* functions found in src/runtime/trace.go provide a skip parameter to elide \"uninteresting\" bits from the results of traces that is used by `traceEvent()`.\r\n\r\nIn particular, traceGoSysCall specifies a skip of 4 which seems to match what @rsc noted about Solaris missing the top three frames consistently (yes, it's off-by-one, but read on).\r\n\r\nIf we zero out the use of skip in traceEvent on Linux and then run this test again, we can see the extra bits that are normally elided:\r\n\r\n```\r\n\ttrace_stack_test.go:282: ---\r\n\ttrace_stack_test.go:280:   runtime.mcall:207\r\n\ttrace_stack_test.go:280:   runtime.reentersyscall:1826\r\n\ttrace_stack_test.go:280:   runtime.entersyscall:1879\r\n\ttrace_stack_test.go:280:   syscall.Syscall:18\r\n\ttrace_stack_test.go:280:   syscall.read:783\r\n\ttrace_stack_test.go:280:   syscall.Read:160\r\n\ttrace_stack_test.go:280:   os.(*File).read:211\r\n\ttrace_stack_test.go:280:   os.(*File).Read:95\r\n\ttrace_stack_test.go:280:   runtime/trace_test.TestTraceSymbolize.func11:101\r\n\ttrace_stack_test.go:280:   runtime.goexit:1696\r\n\ttrace_stack_test.go:282: ---\r\n```\r\n\r\nUnderstandably, we'd generally want to elide the calls to Syscall, entersyscall, reentersyscall, and mcall when tracing.\r\n\r\nOn Solaris without any other changes, when we do the same thing, we see:\r\n\r\n```\r\n        trace_stack_test.go:282: ---\r\n        trace_stack_test.go:280:   runtime.syscall_sysvicall6:36\r\n        trace_stack_test.go:280:   syscall.read:680\r\n        trace_stack_test.go:280:   syscall.Read:160\r\n        trace_stack_test.go:280:   os.(*File).read:211\r\n        trace_stack_test.go:280:   os.(*File).Read:95\r\n        trace_stack_test.go:280:   runtime/trace_test.TestTraceSymbolize.func11:101\r\n        trace_stack_test.go:280:   runtime.goexit:1696\r\n        trace_stack_test.go:282: ---\r\n```\r\n\r\nAt first glance, it seems like the right fix would be to simply change traceGoSysCall() to specify a skip of 1 instead of 4 on Solaris, and that would \"fix\" the test.\r\n\r\nHowever, what bothered me was that this wasn't happening on other platforms, and as @rsc noted, while Solaris is special in that it makes its system calls through asmcgocall, that should be okay.  So I reverted that change.\r\n\r\nDigging deeper, we find that on every other platform, system calls pass through functions that invoke `runtime.entersyscall()`, usually like this:\r\n\r\n```\r\n 17 TEXT    ·Syscall(SB),NOSPLIT,$0-56\r\n 18         CALL    runtime·entersyscall(SB)\r\n```\r\n\r\nHowever, on Solaris, system calls generally pass through syscall_sysvicall6, which invokes `runtime.entersyscallblock()` instead:\r\n\r\n```\r\n 29 //go:nosplit\r\n 30 func syscall_sysvicall6(fn, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\r\n 31         call := libcall{\r\n 32                 fn:   fn,\r\n 33                 n:    nargs,\r\n 34                 args: uintptr(unsafe.Pointer(\u0026a1)),\r\n 35         }\r\n 36         entersyscallblock(0)\r\n 37         asmcgocall(unsafe.Pointer(\u0026asmsysvicall6), unsafe.Pointer(\u0026call))\r\n 38         exitsyscall(0)\r\n 39         return call.r1, call.r2, call.err\r\n 40 }\r\n```\r\n\r\nIf we change sysvicall6() to invoke entersyscall() instead of entersyscallblock(), then the test passes and we see this trace stack instead:\r\n\r\n```\r\n        trace_stack_test.go:282: ---\r\n        trace_stack_test.go:280:   runtime.mcall:207\r\n        trace_stack_test.go:280:   runtime.reentersyscall:1826\r\n        trace_stack_test.go:280:   runtime.entersyscall:1879\r\n        trace_stack_test.go:280:   runtime.syscall_sysvicall6:36\r\n        trace_stack_test.go:280:   syscall.read:680\r\n        trace_stack_test.go:280:   syscall.Read:160\r\n        trace_stack_test.go:280:   os.(*File).read:211\r\n        trace_stack_test.go:280:   os.(*File).Read:95\r\n        trace_stack_test.go:280:   runtime/trace_test.TestTraceSymbolize.func11:101\r\n        trace_stack_test.go:280:   runtime.goexit:1696\r\n        trace_stack_test.go:282: ---\r\n```\r\n\r\nNow that stack is nearly identical to the Linux one and importantly, the number of items to skip is the same.\r\n\r\nSo the cause of the issue appears to be the use of entersyscallblock() vs. entersyscall().  What I don't know yet is how entersyscallblock() is broken.\r\n\r\nIf we only change the Linux version of Go to use `runtime.entersyscallblock() ` for its system call invocations as well, we see the same problem as Solaris:\r\n\r\n```\r\n\ttrace_stack_test.go:282: ---\r\n\ttrace_stack_test.go:280:   os.(*File).Read:95\r\n\ttrace_stack_test.go:280:   runtime/trace_test.TestTraceSymbolize.func11:101\r\n\ttrace_stack_test.go:282: ---\r\n```\r\n\r\nSo this is not a problem unique to Solaris; any platform that uses entersyscallblock() will hit the same issues when tracing.\r\n\r\nI would like to suggest this bug be retitled as \"tracing broken when using entersyscallblock()\".  I don't know what the right fix is here at the moment.",
	"user": {
		"login": "binarycrusader",
		"id": 541114,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-12T01:12:02Z",
	"updated_at": "2015-08-12T01:13:42Z"
}
