{
	"id": 130439601,
	"body": "So the cause of the issue is ultimately the placement and invocation of `traceGoSysCall` when using `entersyscallblock()` instead of `entersyscall()`.\r\n\r\nNotably, normally when `entersyscall()` starts, the first thing it does it trigger `traceGoSysCall`:\r\n\r\n```\r\n1804 // Syscall tracing:\r\n1805 // At the start of a syscall we emit traceGoSysCall to capture the stack trace.    \r\n...\r\n1825         if trace.enabled {\r\n1826                 systemstack(traceGoSysCall)\r\n1827         }\r\n...\r\n```\r\n\r\nThis causes three additional functions to be recorded in the trace stack on Linux (with respect to the invocation of syscall.Syscall itself):\r\n```\r\n    trace_stack_test.go:280:   runtime.mcall:207\r\n    trace_stack_test.go:280:   runtime.reentersyscall:1826\r\n    trace_stack_test.go:280:   runtime.entersyscall:1879\r\n    trace_stack_test.go:280:   syscall.Syscall:18\r\n```\r\n\r\nHowever, when using `entersyscallblock()`, it waits until almost before the function is done and then invokes `systemstack(entersyscallblock_handoff)` which in turn invokes `traceGoSysCall()`:\r\n\r\n```\r\n1952 func entersyscallblock_handoff() {                                                                              \r\n1953         if trace.enabled {                                                                                      \r\n1954                 traceGoSysCall() \r\n1955                 traceGoSysBlock(getg().m.p.ptr())                                                               \r\n1956         }       \r\n1957         handoffp(releasep())\r\n1958 }       \r\n```\r\n\r\nBecause of where the invocation happens and how it is done, all three calls to the runtime methods are omitted.\r\n\r\nSo it looks like there are two possible solutions.  The first is to simply change how the `traceGoSysCall` is emitted / invoked to match `entersyscall()`:\r\n```\r\ndiff --git a/src/runtime/proc1.go b/src/runtime/proc1.go\r\nindex 09cb775..3d1fc93 100644\r\n--- a/src/runtime/proc1.go\r\n+++ b/src/runtime/proc1.go\r\n@@ -1911,6 +1911,10 @@ func entersyscall_gcwait() {\r\n func entersyscallblock(dummy int32) {\r\n        _g_ := getg()\r\n \r\n+       if trace.enabled {\r\n+               traceGoSysCall()\r\n+       }\r\n+\r\n        _g_.m.locks++ // see comment in entersyscall\r\n        _g_.throwsplit = true\r\n        _g_.stackguard0 = stackPreempt // see comment in entersyscall\r\n@@ -1951,7 +1955,6 @@ func entersyscallblock(dummy int32) {\r\n \r\n func entersyscallblock_handoff() {\r\n        if trace.enabled {\r\n-               traceGoSysCall()\r\n                traceGoSysBlock(getg().m.p.ptr())\r\n        }\r\n        handoffp(releasep())\r\n```\r\n\r\nThe second would be to change `entersyscall()`  to delay the invocation of `traceGoSysCall` to later just as `entersyscallblock` does and change runtime/trace.go to only skip 1 event:\r\n```\r\ndiff --git a/src/runtime/proc1.go b/src/runtime/proc1.go\r\nindex 09cb775..b7c7698 100644\r\n--- a/src/runtime/proc1.go\r\n+++ b/src/runtime/proc1.go\r\n@@ -1822,10 +1822,6 @@ func reentersyscall(pc, sp uintptr) {\r\n        // but can have inconsistent g-\u003esched, do not let GC observe it.\r\n        _g_.m.locks++\r\n \r\n-       if trace.enabled {\r\n-               systemstack(traceGoSysCall)\r\n-       }\r\n-\r\n        // Entersyscall must not call any function that might split/grow the stack.\r\n        // (See details in comment above.)\r\n        // Catch calls that might, by replacing the stack guard with something that\r\n@@ -1845,6 +1841,10 @@ func reentersyscall(pc, sp uintptr) {\r\n                })\r\n        }\r\n \r\n+       if trace.enabled {\r\n+               systemstack(traceGoSysCall)\r\n+       }\r\n+\r\n        if atomicload(\u0026sched.sysmonwait) != 0 { // TODO: fast atomic\r\n                systemstack(entersyscall_sysmon)\r\n                save(pc, sp)\r\ndiff --git a/src/runtime/trace.go b/src/runtime/trace.go\r\nindex c818462..af3bf61 100644\r\n--- a/src/runtime/trace.go\r\n+++ b/src/runtime/trace.go\r\n@@ -828,7 +828,7 @@ func traceGoUnpark(gp *g, skip int) {\r\n }\r\n \r\n func traceGoSysCall() {\r\n-       traceEvent(traceEvGoSysCall, 4)\r\n+       traceEvent(traceEvGoSysCall, 1)\r\n }\r\n \r\n func traceGoSysExit(seq uint64, ts int64) {\r\n```\r\nOf the two options, the latter seems preferable since we'll be recording less information which we're going to throw away anyway.  However, this is not my area of expertise and I would appreciate advice as to the best solution.\r\n\r\nWith either of my proposed solutions, the test passes on Solaris.",
	"user": {
		"login": "binarycrusader",
		"id": 541114,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-12T20:36:12Z",
	"updated_at": "2015-08-12T20:37:57Z"
}
