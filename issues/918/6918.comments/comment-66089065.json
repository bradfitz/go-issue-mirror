{
	"id": 66089065,
	"body": "\u003ca id=\"c2\"\u003e\u003c/a\u003eComment 2:\n\n\u003cpre\u003eI think a big problem is, that the row values are fetched before the destination type is\nknown ( \u003ca href=\"http://golang.org/src/pkg/database/sql/sql.go?s=38680:38720#L1502\"\u003ehttp://golang.org/src/pkg/database/sql/sql.go?s=38680:38720#L1502\u003c/a\u003e ).\nSo we don't know when to pass Sink pointers.\n\nMaybe I understand something wrong, but if we do this for every value, this will likely\ncause a lot of additional (and waste) allocations.\n\nIn my opinion the best option would be to allow the drivers to bypass the converter of\ndatabase/sql and somehow pass the args of Scan directly to the driver.\nThis has several benefits:\n\n1. It allows type aware conversions:\nCurrently the drivers \"guess\" the destination type for best results. For example numeric\nvalues are converted to int64 or float64. Date and Time values lead to problems in this\ncase. If the value is converted to time.Time, the value can not be scanned to string /\n[]byte / sql.RawBytes, if the value is returned as []byte, it can not be scanned into a\ntime.Time var.\nIf the driver knows the destination type, it can directly convert to the correct type.\nFor example if the destination type is sql.RawBytes, the driver can just pass a slice of\nits net buffer. The driver does not need to convert numeric values first, which the\ndatabase/sql package would convert back. This can get very expensive, e.g. when the\nconverter uses something like []byte(fmt.Sprintf(...)).\nFor date and time values, the driver can also choose the right type.\n\n2. It is more flexible and allows to support additional types:\nCurrently the database/sql package is VERY restrictive. It only allows the driver.Value\ntypes, which makes it impossible to even support uint64 with the high bit set (since it\nmust be converted to int64):\n\u003ca href=\"http://golang.org/src/pkg/database/sql/convert.go?s=2152:2306#L70\"\u003ehttp://golang.org/src/pkg/database/sql/convert.go?s=2152:2306#L70\u003c/a\u003e\nBut this would also allow the driver to support additional types like complex numbers or\neven database specific types.\n\n3. It allows performance improvements and requires less allocations:\nI think this point is obvious.\n\nTo be clear, this is a optimization for a rather high hanging fruit. I don't intend that\nevery single driver implements this. This adds responsibility to the driver to support\nall types correctly. But this path is purely optional. Driver authors could still choose\nthe easy way and let the database/sql package convert the values.\n\nWe would still have the problem that the destination type is unknown before rows.Scan.\nTherefore, this requires 2 steps: 1) In rows.Next ask the driver if more rows are\navailable or an error occurred 2) In rows.Scan pass the args to the driver and let the\ndriver copy the values into it, converting where necessary.\u003c/pre\u003e",
	"user": {
		"login": "julienschmidt",
		"id": 944947,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-12-09T18:55:55Z",
	"updated_at": "2014-12-08T10:38:32Z"
}
