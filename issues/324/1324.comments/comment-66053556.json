{
	"id": 66053556,
	"body": "\u003ca id=\"c7\"\u003e\u003c/a\u003eComment 7:\n\n\u003cpre\u003eAfter re-reading the spec a bit more closely, and discussing this with Rob and Ian, I am\ninclined to say that the original submission is correct about the misleading compiler\nerror message and that the pointer type (P) should not \"inherit\" the method. For the\nprogram:\n\npackage main\n\ntype T struct{}\nfunc (t T) m()\n\ntype P *T\n\nfunc main() {\n\tvar t T \n\tt.m()\n\t\n\tvar p P\n\tp.m()        // p.m undefined (line 13)\n\t(*p).m()    // legal and accepted (line 14)\n}\n\nAgain, according to the spec: \u003ca href=\"http://golang.org/doc/go_spec.html#Type_declarations\"\u003ehttp://golang.org/doc/go_spec.html#Type_declarations\u003c/a\u003e\n\na) \"The declared type does not inherit any methods bound to the existing type, but the\nmethod set of an interface type or of elements of a composite type remains unchanged\"\n\nand P is a composite type according to \u003ca href=\"http://golang.org/doc/go_spec.html#Types\"\u003ehttp://golang.org/doc/go_spec.html#Types\u003c/a\u003e (P is a\npointer type _composed_ of an other element type T).\n\nSo: P does not inherit any methods bound to T, but the method set of an element of the\ncomposite type P remains unchanged. So, certainly, for a p of type P, (*p).m() is legal\nsince the type of *p is T and those methods remain unchanged (line 14).\n\nAccording to \u003ca href=\"http://golang.org/doc/go_spec.html#Types\"\u003ehttp://golang.org/doc/go_spec.html#Types\u003c/a\u003e:\n\nb) \"The method set of any other named type T consists of all methods with receiver type\nT. The method set of the corresponding pointer type *T is the set of all methods with\nreceiver *T or T (that is, it also contains the method set of T). Any other type has an\nempty method set.\"\n\nFor P there are no methods with receiver type P (and they cannot be declared either, see\nmethod declarations) and thus p.m() is illegal (line 13). Note that rule b talks about\nthe \"method set of the _corresponding_ pointer type *T\" where \"corresponding\" refers to\na \"named type T\" (which is P in our case, not *T!). We have a new type P and thus the\ncorresponding pointer type would be *P. I think my original interpretation was incorrect\n(rule b was considered out of context).\n\nTo summarize:\n\n1) bug117.go is a correct test case\n2) The program above correctly reports an error, but the error message is wrong:\n\n6g test.go\ntest.go:13: p.m undefined (type T has no field or method m)\n\nIt should say:\n\ntest.go:13: p.m undefined (type P has no field or method m)\n\n3) The spec does not need to be adjusted; but it may benefit from clearer\nexplanations/examples.\u003c/pre\u003e",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2011-02-07T23:22:11Z",
	"updated_at": "2014-12-08T10:07:48Z"
}
