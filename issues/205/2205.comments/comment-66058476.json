{
	"id": 66058476,
	"body": "\u003ca id=\"c9\"\u003e\u003c/a\u003eComment 9:\n\n\u003cpre\u003eI run into this often, but I should start listing examples.\n\nIn goprotobuf, text.go calls writeString with both a string and a []byte converted to a\nstring:\n\n// writeAny writes an arbitrary field.\nfunc writeAny(w *textWriter, v reflect.Value, props *Properties) {\n        v = reflect.Indirect(v)\n\n        // We don't attempt to serialise every possible value type; only those\n        // that can occur in protocol buffers, plus a few extra that were easy.\n        switch v.Kind() {\n        case reflect.Slice:\n                // Should only be a []byte; repeated fields are handled in writeStruct.\n                writeString(w, string(v.Interface().([]byte)))\n        case reflect.String:\n                writeString(w, v.String())\n\n\nNote that the function writeString reallly just wants a read-only slice of bytes:\n\nfunc writeString(w *textWriter, s string) {\n        w.WriteByte('\"')\n\n        // Loop over the bytes, not the runes.\n        for i := 0; i \u0026lt; len(s); i++ {\n                // Divergence from C++: we don't escape apostrophes.\n                // There's no need to escape them, and the C++ parser\n                // copes with a naked apostrophe.\n                switch c := s[i]; c {\n                case '\\n':\n                        w.Write([]byte{'\\\\', 'n'})\n                case '\\r':\n                        w.Write([]byte{'\\\\', 'r'})\n                case '\\t':\n                        w.Write([]byte{'\\\\', 't'})\n                case '\"':\n                        w.Write([]byte{'\\\\', '\"'})\n                case '\\\\':\n                        w.Write([]byte{'\\\\', '\\\\'})\n                default:\n                        if isprint(c) {\n                                w.WriteByte(c)\n                        } else {\n                                fmt.Fprintf(w, \"\\\\%03o\", c)\n                        }\n                }\n        }\n\n        w.WriteByte('\"')\n}\n\nIt doesn't matter that it's frozen (like a string), nor writable (like a []byte).  But\nGo lacks that type, so if instead it'd be nice to write writeAny with a []byte parameter\nand invert the switch above to be like:\n\n        switch v.Kind() {\n        case reflect.Slice:\n                // Should only be a []byte; repeated fields are handled in writeStruct.\n                writeString(w, v.Interface().([]byte))\n        case reflect.String:\n                writeString(w, []byte(v.String())) // no copy!\n\nWhere the []byte(v.String()) just makes a slice header pointing in to the string's\nmemory, since the compiler can verify that writeAny never mutates its slice.\u003c/pre\u003e",
	"user": {
		"login": "bradfitz",
		"id": 2621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2012-10-25T14:54:57Z",
	"updated_at": "2014-12-22T06:02:56Z"
}
