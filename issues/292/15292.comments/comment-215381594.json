{
	"id": 215381594,
	"body": "@andrewcymyers interesting that you think Go interfaces work as Genus-style constraints. I would have thought they still have the problem that you can't express multi-type-parameter constraints with them.\r\n\r\nOne thing I just realized, however, is that in Go you can write an interface inline. So with the right syntax you could put the interface in scope of all the parameters and capture multi-parameter constraints:\r\n\r\ntype [V, E] Graph [V interface { Edges() E }, E interface { Endpoints() (V, V) }] ...\r\n\r\nI think the bigger problem with interfaces as constraints is that methods are not as pervasive in Go as in Java. Built-in types do not have methods. There is no set of universal methods like those in java.lang.Object. Users don't typically define methods like Equals or HashCode on their types unless they specifically need to, because those methods don't qualify a type for use as map keys, or in any algorithm that needs equality.\r\n\r\n(Equality in Go is an interesting story. The language gives your type \"==\" if it meets certain requirements (see https://golang.org/ref/spec#Logical_operators, search for \"comparable\"). Any type with \"==\" can serve as a map key. But if your type doesn't deserve \"==\", then there is nothing you can write that will make it work as a map key.)\r\n\r\nBecause methods aren't pervasive, and because there is no easy way to express properties of the built-in types (like what operators they work with), I suggested using code itself as the generic constraint mechanism. See the link in my comment of April 18, above. This proposal has its problems, but one nice feature is that generic numeric code could still use the usual operators, instead of cumbersome method calls.\r\n\r\nThe other way to go is to add methods to types that lack them. You can do this in the existing language in a much lighter way than in Java:\r\n\r\ntype Int int\r\nfunc (i Int) Less(j Int) bool { return i \u003c j }\r\n\r\nThe Int type \"inherits\" all the operators and other properties of int. Though you have to cast between the two to use Int and int together, which can be a pain.\r\n\r\nGenus models could help here. But they would have to be kept very simple. I think @ianlancetaylor was too narrow in his characterization of Go as writing more code, fewer types. The general principal is that Go abhors complexity. We look at Java and C++ and are determined never to go there. (No offense.)\r\n\r\nSo one quick idea for a model-like feature would be: have the user write types like Int above, and in generic instantiations allow \"int with Int\", meaning use type int but treat it like Int. Then there is no overt language construct called model, with its keyword, inheritance semantics, and so on. I don't understand models well enough to know whether this is feasible, but it is more in the spirit of Go.",
	"user": {
		"login": "jba",
		"id": 18483045,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-04-28T10:36:16Z",
	"updated_at": "2016-04-28T10:36:16Z"
}
