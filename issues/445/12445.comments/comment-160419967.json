{
	"id": 160419967,
	"body": "Let me try again. Various concurrent moving collectors including those\nusing a Brooks' barrier as well as the Sapphire algorithm rely on the fact\nthat two different bit pattern can be used to represent the same (pointer\nto an) object. One bit pattern may refer to the \"old\" version of the object\nand another to the \"new\" version of the object. Depending on the algorithm\na read and/or write barrier is used to ensure that values returned from the\nobject are consistent. The literature explains how the algorithms\nextinguish the \"old\" version by replacing them with \"new\" version and what\ninvariants the read and write barriers need to maintain to ensure object\nidentity, consistency, completeness, and termination.\n\nThis creates implementation issues around the implementation of == which\ndoesn't dereference the pointer and thus fall outside the barriers used\nwhen the object is dereferenced. This == problem was first noted and solved\nin the original Brooks paper as well as being noted, referenced, and solved\nin the Sapphire paper. It is important to note that in at least the\nSapphire algorithm the implementation of == is the only place where reads\nof (pointers to) objects require special consideration. Go's spec allows\nfor such an implementation.\n\nThe single example found in the unsafe part of the spec seems to extend the\nsemantics of == to include calls to unsafe.Pointer in the same ==\nexpression where the compiler can statically determine that the arguments\npassed to unsafe.Pointer refer to the same object and eliminate one of the\ncalls using CSE. The unsafe.Offset call can be replaced with known static\noffset to a field within a struct. I would be surprised if the compiler\ndoesn't already do this. I believe that this extension of == semantics is\ntractable and object identity can be maintained.\n\nThe examples provided in this thread use unsafe.Pointer in different\nstatements and then expect the returned bits to be comparable. This is\nunsafe though it works in current implementation.\n\nIn summary, the statement that \"Something like below seems like it should\nbe safe even under a moving GC.\" is not true for at least two well known\nconcurrent copying collectors.\n\nMore to the point is that both #7192\n\u003chttps://github.com/golang/go/issues/7192\u003e and #8994\n\u003chttps://github.com/golang/go/issues/8994\u003e have resisted changing the spec.\nWhat has changed since those decisions? Changing the stable spec is a very\nhigh bar, particularly when the change will alter fundamental concepts like\nobject identity that GC algorithms have wrestled with for decades.\n\n\n\n\n\n\n\nOn Sat, Nov 28, 2015 at 9:32 PM, Dan Kortschak \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e Yes, that's true, though I think that once the rules for the other issue\n\u003e are settled that defines what happens here.\n\u003e\n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/12445#issuecomment-160361749\u003e.\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-29T14:44:35Z",
	"updated_at": "2015-11-29T14:44:35Z"
}
