{
	"id": 117276599,
	"body": "We have a testcase that reproduces the problem, which shows that it is due to the Entersyscall and Exitsyscall within libgo/go/syscall/libcall_linux.go function Getdents.  It should not be in Getdents, since Entersyscall and Exitsyscall are called within the call to Syscall().  Calling Exitsyscall on this path is what causes the panic in checkdead.\r\n\r\nI have a patch to fix this here:  https://go-review.googlesource.com/#/c/11761/\r\n\r\nI built did a bootstrap build on ppc64le and tested it.\r\n\r\nTestcase to reproduce the problem with gccgo from gcc5 branch on both ppc64le and x86 is below.  You must do mkdir temp to cause the panic to occur:\r\n\r\n    package main\r\n     \r\n    import (\r\n            \"fmt\"\r\n            \"os\"\r\n            \"sort\"\r\n            \"syscall\"\r\n            \"unsafe\"\r\n    )\r\n     \r\n    type nameIno struct {\r\n            name string\r\n            ino  uint64\r\n    }\r\n     \r\n    type nameInoSlice []nameIno\r\n     \r\n    func (s nameInoSlice) Len() int           { return len(s) }\r\n    func (s nameInoSlice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\r\n    func (s nameInoSlice) Less(i, j int) bool { return s[i].name \u003c s[j].name }\r\n     \r\n    func readdirnames(dirname string) (names []nameIno, err error) {\r\n            var (\r\n                    size = 100\r\n                    buf  = make([]byte, 4096)\r\n                    nbuf int\r\n                    bufp int\r\n                    nb   int\r\n            )\r\n     \r\n            f, err := os.Open(dirname)\r\n            if err != nil {\r\n                    return nil, err\r\n            }\r\n            defer f.Close()\r\n     \r\n            names = make([]nameIno, 0, size) // Empty with room to grow.\r\n            for {\r\n                    // Refill the buffer if necessary\r\n                    if bufp \u003e= nbuf {\r\n                            bufp = 0\r\n                            nbuf, err = syscall.ReadDirent(int(f.Fd()), buf) // getdents on linux\r\n                            if nbuf \u003c 0 {\r\n                                    nbuf = 0\r\n                            }\r\n                            if err != nil {\r\n                                    return nil, os.NewSyscallError(\"readdirent\", err)\r\n                            }\r\n                            if nbuf \u003c= 0 {\r\n                                    break // EOF\r\n                            }\r\n                    }\r\n     \r\n                    // Drain the buffer\r\n                    nb, names = parseDirent(buf[bufp:nbuf], names)\r\n                    bufp += nb\r\n            }\r\n     \r\n            sl := nameInoSlice(names)\r\n            sort.Sort(sl)\r\n            return sl, nil\r\n    }\r\n     \r\n    // parseDirent is a minor modification of syscall.ParseDirent (linux version)\r\n    // which returns {name,inode} pairs instead of just names.\r\n    func parseDirent(buf []byte, names []nameIno) (consumed int, newnames []nameIno) {\r\n            origlen := len(buf)\r\n            for len(buf) \u003e 0 {\r\n                    dirent := (*syscall.Dirent)(unsafe.Pointer(\u0026buf[0]))\r\n                    buf = buf[dirent.Reclen:]\r\n                    if dirent.Ino == 0 { // File absent in directory.\r\n                            continue\r\n                    }\r\n                    bytes := (*[10000]byte)(unsafe.Pointer(\u0026dirent.Name[0]))\r\n                    var name = string(bytes[0:clen(bytes[:])])\r\n                    if name == \".\" || name == \"..\" { // Useless names\r\n                            continue\r\n                    }\r\n                    names = append(names, nameIno{name, dirent.Ino})\r\n            }\r\n            return origlen - len(buf), names\r\n    }\r\n     \r\n    func clen(n []byte) int {\r\n            for i := 0; i \u003c len(n); i++ {\r\n                    if n[i] == 0 {\r\n                            return i\r\n                    }\r\n            }\r\n            return len(n)\r\n    }\r\n     \r\n    func main() {\r\n            names, _ := readdirnames(\"temp/\")\r\n            fmt.Println(\"list %s\\n\", names)\r\n    } ",
	"user": {
		"login": "laboger",
		"id": 9433228,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-06-30T17:43:42Z",
	"updated_at": "2015-06-30T17:43:42Z"
}
