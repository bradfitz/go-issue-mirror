{
	"id": 213811635,
	"body": "\u003e I was originally going to propose a driver model here, but I'm not sure how a common API should expose differences in flags and features that are available. How would you do it?\r\n\r\nYes, I do have an idea how this may be resolved. However, this is not an official proposal for the file system notification library, but rather loose thoughts about the design, so all variable/type names should not be taken as an official naming.\r\n\r\n**fsnotify** package - it's like `sql` package from std. It defines:\r\n- An event as int64 type.(int32 was sufficient for notify package. However, we sometimes used it to carry additional watcher *state* information [(example)](https://github.com/rjeczalik/notify/blob/master/watcher_readdcw.go#L34). It would be nice to have extra 32 bits only for that)\r\n\r\n- Three interfaces:\r\n```go\r\ntype FileWatcher interface {\r\n    WatchFile(path string, events ...Event)\r\n}\r\n\r\ntype DirectoryWatcher interface {\r\n    WatchDirectory(path string, events ...Event)\r\n}\r\n\r\ntype RecursiveWatcher interface {\r\n    WatchRecursively(path string, events ...Event)\r\n}\r\n```\r\n\r\nThe package `Watcher` type will use drivers and implement all three interfaces. Eventually, it will mimic these interfaces which were not defined in imported driver.\r\n\r\n```go\r\nfunc Use(\"driver_name\", ...) (*Watcher, err) // similar to sql.DB.Open\r\n``` \r\nIt would be nice if Watcher supports filtering etc. \r\n\r\nThis approach makes it easy to mock and test this package since it doesn't know anything about underlying notification systems.\r\n\r\n**driver packages** -they are pure system dependent things. So:\r\n\r\n  - there are no generic events like `inotify.Create` etc.\r\n  - only system specific event are defined (`inotify.InCreate, inotify.InDeleteSelf etc.)\r\n  - they implement only these interfaces they can support eg. `fsnotify.DirectoryWatcher` and `fsnotify.RecursiveWatcher` for ReadDireectoryChangesW on windows.\r\n  - they may expose extra system dependent functionality.\r\n  - they have their own system dependent tests.\r\n\r\nSince no one who writes system independent code wants to import different drivers for different systems. There is one *special* driver:\r\n\r\n**agnostic driver** - it defines a common behavior across different systems:\r\n\r\n  - defines generic events like `agnostic.Create`, `agnostic.Delete` etc.\r\n  - defines a wrapper that transforms system dependent events to system independent ones.\r\n  - tests are system independent.\r\n  - the interfaces it implements still depend on underlying operating system.\r\n\r\nSo:\r\n\r\n - **fsnotify** package acts like `tree` from `rjeczalik/notify` package.\r\n - **agnostic driver** package acts like notify and fsnotify.\r\n - **driver** packages are just low level implementations.\r\n\r\nIf you want to use fsnotify in system independent way:\r\n```go\r\nimport (\r\n    \"whatever/fsnotify\"\r\n    \"whatever/fsnotify/agnostic\"\r\n)\r\n// ...\r\nw, err := fsnotify.Use(\"agnostic\", ...)\r\n// ...\r\nw.WatchDirectory(\"something/path\", agnostic.Create)\r\n// ...\r\n```\r\n\r\nIf you want to use system specific thing you can use eg. inotify directly or if you still want to have benefits of filtering etc:\r\n```go\r\nimport (\r\n    \"whatever/fsnotify\"\r\n    \"whatever/fsnotify/inotify\"\r\n)\r\n// ...\r\nw, err := fsnotify.Use(\"inotify\", ...)\r\n// ...\r\nw.WatchDirectory(\"something/path\", inotify.InCreate)\r\n// ...\r\n```\r\n\r\nHowever, just as I said, these are just my thoughts after implementing different notification watchers to one common interface.\r\n\r\n\r\n",
	"user": {
		"login": "ppknap",
		"id": 5021246,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-04-23T19:18:32Z",
	"updated_at": "2016-04-23T19:18:32Z"
}
