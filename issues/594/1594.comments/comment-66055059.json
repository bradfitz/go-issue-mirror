{
	"id": 66055059,
	"body": "\u003ca id=\"c12\"\u003e\u003c/a\u003eComment 12:\n\n\u003cpre\u003eThis is a lengthy comment but I think some more reasoning than\njust \"that function would be cool\" or \"python does it right\"\nwould be appropriate; especially as calendar and clock stuff\nare obviously hard to do right (if you look at any other programming\nlanguage) and Go is missing some needed functionality here.\n\nThe following are my opinions based on excessive reading about\ndate/time and a real world programming issue with date/time I\ntried to solve in Go.  Below \"current\" state of Go referes to\nrelease.r.59 (but should be accurate for r60 too).\n\n\n1) Go should not try to provide generic calendars: If someone needs a\nMaya or Egyptian calendar he should code his one. (Even Java\nships only Gregorian, and the Java date/time API is bloated crop.)\n\n2) Go should not try to deal with leap seconds. If you're doing\nradio astronomy you will know which \"time\" you are using and code\nyour own.\n\n3) So there is no need for date/time comparison:  We're dealing \nwith simple Newtonian (totally ordered) time so \u0026lt;, == and \u0026gt; on \nUTC seconds should be enough.  (Implement your own spacetime for \nrelativistic quantum mechanics if you need one.)\n\n4) Comparing dates (ignoring time) is usefull _only_ if both are in\nthe _same_ zone (e.g. local time) and than you just do lexical\ncomparison on Year, Month, Day ignoring the other fields.\nToo simple for an API function.  If you get string timestamps\nwith different zones: Parse, convert to UTC, convert to local time\nand compare. This fails only in the unlikely case that your local\ndaylight saving shift hits between both timestamps and put them\nwrongly into same/different day.  This unlikely issues vanishes\nif a proper solution to 8a) below is available.\n\n5) Some real problems can be solved perfectly fine with the current\npackage time:  \n - Absolute (Newtonian) time deltas can be done in UTC seconds\n - UTC seconds can be converted to local time (clock reading).\n \n6) Package time should provide a function to determine the calendar\nweek of a given timestamp.  The ISO calendar week (not the\nUS American one:-).  The calendar week could even be incorporated into\nthe Time struct itself.\n\n7) Time does not provide sub-second resolution which makes it hard\nto use for stuff like process control or even logging.  Wrapping\nTime in a struct with additional nanoseconds is easy, but this\n\"workaround\" won't be that easy any more once a solution (API)\nfor number 8) below is found. \n\n\n8) Some real life issues _cannot_ be handled properly with the \ncurrent package time:\n\na) There is no way to convert UTC seconds to some local time at an \nother location (than my servers location):  E.g. my local time zone is \nBerlin, I have a time in UTC seconds and want its local time (clock\nreading) in Sydney (honouring daylight savings and that like).\n\nb) All issues regarding \"shifted clock reading\" in the sense of:\n\"This time but in 3 days\", \"same date 20 years ago\" or \"same day\nin three month\".\nThese type of time manipulations cannot be translated to simple\ndifferences in absolute UTC time as such shifts might cross arbitrary\ndaylight saving switches (and other).\n\nc) Question like \"What's the start time (UTC) of this day (or \nweek/month/...)\" cannot be answered properly, again because start \nof this day (week/month/...) might have a different zoneoffset \nthan the current time.\n\n\nIMHO: \na) Is an inconvenience if you write an application for a\nserver located in ZÃ¼rich which must provide local clock readings\nof UTC time for Boston, Sydney and Moscow.  No focus should be put\non this until proper solution to b) is found.\n\nc) Most probably this issue could be answered quite easily if a \ngood solution to b) is available.\n\nb) A solution to b) might provide enough packed intelligence to\nsolve all these tiny question which bloat traditional date/time \nAPIs.\n\n\nAny manipulation of absolute time can be done in UTC seconds.\nThere is (currently) no way of manipulating \"calendar readings\"\nor \"clock readings\".  While increasing/decreasing/comparing\nabsolute times is i) easy and ii) never fails (ignoring int64\noverflows) dealing with calendar/clock reading manipulations\nis neither easy nor always possible: Some manipulation requests\nare impossible to perform and will fail.\nEverything below deals with calendar/clock reading.\n\n\nPreliminary notes to understand the examples:\nIn central Europe we switched to summer time (daylight saving) at\n\"27.03.2011 02:00:00 CET\" which means that one second later it was\n\"27.03.2011 03:00:01 CEST\".  So there are no times like \"27.03.2011 \n02:15:00 CET\" and no clock readings from 02:00:00 to 02:59:59.\nFebruary 29. occurs just once every four years (roughly) and there\nare no 30. of February and 31. of June (okay, you knew that).\n\nVery simple examples (those that could be handled properly by \nmanipulating UTC seconds):\n  \"17.05.2011 15:30:00 CEST\" + \"3 days\"   == \"20.05.2011 15:30:00 CEST\"\n  \"17.05.2011 15:30:00 CEST\" + \"18 hours\" == \"19.05.2011 09:30:00 CEST\"\n\nNot so simple examples (if doing in UTC seconds as months have \ndifferent length, crossing February must take care of leap years)\n  \"17.05.2011 15:30:00 CEST\" + \"3 months\" == \"17.08.2011 15:30:00 CEST\"\n  \"09.01.2011 15:30:00 CET\" + \"2 months\"  == \"09.03.2011 15:30:00 CET\"\n\nExamples which _cannot_ be handled by manipulating UTC seconds\n(as we switch zone offsets)\n  \"27.03.2011 01:30:00 CET\" + \"2 hours\"  == \"27.03.2011 03:30:00 CEST\"\n  \"27.03.2011 01:30:00 CET\" + \"2 days\"   == \"29.03.2011 01:30:00 CEST\"\n  \"15.02.2011 12:00:00 CET\" + \"3 months\" == \"15.05.2011 12:00:00 CEST\"\nThe +2hour case looks strange as the UTC time difference is only\none hour. But it is consistent with the 2 days and the 3 months case.\n  \nExamples which fail as the target calendar/clock reading does not\nexist:\n  \"27.03.2011 01:30:00 CET\"  + \"1 hour\"   (neither 02:30:00 CET nor CEST)\n  \"31.03.2011 12:00:00 CETS\" + \"3 months\" (no jun. 31. in any year)\n  \"29.02.2008 15:30:00 CET\"  + \"1 year\"   (no feb. 29. in 2009)\n\nThe failing cases could be made non-failing by rounding up or down\nto the next possible calendar/clock reading:\n  \"27.03.2011 01:30:00 CET\"  + \"1 hour\"   -\u0026gt; 03:00:00 (up and down!)\n  \"31.03.2011 12:00:00 CETS\" + \"3 months\" -\u0026gt; 30.6.2011 or 1.7.2011\n  \"29.02.2008 15:30:00 CET\"  + \"1 year\"   -\u0026gt; 29.2.2009 or 1.3.2011\n\nThe problem with the very simple expamples is: You do not now in advance\nthat they are simple: The are simple (UTC-handable) only because the \ntarget time has the same zone offset \n  \n  \nSo I would propose functions to manipulate calendar/clock readings\nof the following types:\n\nfunc ManipulateCCReading(t *Time, [delta]) (*Time, os.Err)\nfunc MustManipulateCCReading(t *Time, roundUp bool, [delta]) *Time\n\n\"CC\" is for CalendarAndOrClockReading\".  I would make it very\nclear in the name of those functions that they do not plain UTC\nsecond addition/subtraction.  Obviously the names need to be discussed.\n\nHow to specify the [delta] should be discussed.  One \"obvious\" way is\n  interface CCDelta { \u0026lt;whats needed\u0026gt;... }\n  type HourDelta ...  implementing CCDelta\n  type DayDelta ...  implementing CCDelta\n  type MonthDelta ...  implementing CCDelta\n  type \u0026lt;XYZ\u0026gt;Delta ... implementing CCDelta\n  func ManipulateCCReading(t *Time, deltas ...CCDelta) (*Time, os.Err)\n\nThe possibly more Go idiomatic way would be\n  type CCDelta struct {Hour, Day, Month, ... int}\n  func ManipulateCCReading(t *Time, delta CCDelta) (*Time, os.Err)\n\n  \nThe implementation would be straight forward: Just some bookkeeping\non leap years, month length, manipulation parsed fields in Time\nwith carry.  The tricky stuff lies in determining if the manipulation\nyields a new time with a different zone offset and correcting for\nthe difference in the old and new zone offset.\n\nI admit I have not found a proper solution to the \"zone offset of\nthe target clock reading\" problem.  I asume (unprooved), that an \niterative algorithm along (ignoring error cases)\n  i) adjust reading, keep zone offset\n  ii)convert to UTC, parse to local time\n  iii) if zone offset changed: rerun from step i)\nwould converge in 1 to 2 iterations.\n\nI could spend some time on this issue if there is some kind of consensus\nthat package time need some improvements and which functions it should\nprovide for which tasks.\u003c/pre\u003e",
	"user": {
		"login": "vdobler",
		"id": 701382,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2011-09-08T09:37:17Z",
	"updated_at": "2014-12-22T05:54:31Z"
}
