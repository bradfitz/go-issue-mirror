{
	"id": 106112246,
	"number": 12594,
	"state": "open",
	"title": "archive/tar: package understanding of GNU format is wrong",
	"body": "Using ```go1.5```\r\n\r\nAlso discovered this while fixing other archive/tar issues (and I found fair number of them, mostly minor). However, fixing this will change the way archive/tar reads and writes certain formats.\r\n\r\n#### What the current archive/tar thinks the GNU format is:\r\n* A magic and version that forms the string [```\"ustar\\x20\\x20\\x00\"```](https://github.com/golang/go/blob/a1d093d95dfb888e55f960943bd3ad3d181ec743/src/archive/tar/reader.go#L493) (this is correct).\r\n* That the structure is [identical to the POSIX format](https://github.com/golang/go/blob/a1d093d95dfb888e55f960943bd3ad3d181ec743/src/archive/tar/reader.go#L510). That is, there is a 155byte prefix section (this is incorrect).\r\n* That it extends the POSIX format by [adding the ability to perform base-256 encoding](https://github.com/golang/go/blob/a1d093d95dfb888e55f960943bd3ad3d181ec743/src/archive/tar/writer.go#L211) (this is not necessarily specific to GNU format).\r\n\r\n#### What the GNU manual actually says the format is:\r\n\r\nThe [GNU manual](https://www.gnu.org/software/tar/manual/html_node/Standard.html) says that the format for headers using this magic is the following (in Go syntax):\r\n```go\r\ntype headerGNU struct {\r\n\t// Original V7 header\r\n\tname     [100]byte //   0\r\n\tmode     [8]byte   // 100\r\n\tuid      [8]byte   // 108\r\n\tgid      [8]byte   // 116\r\n\tsize     [12]byte  // 124\r\n\tmtime    [12]byte  // 136\r\n\tchksum   [8]byte   // 148\r\n\ttypeflag [1]byte   // 156\r\n\tlinkname [100]byte // 157\r\n\r\n\t// This section is based on the Posix standard.\r\n\tmagic      [6]byte         // 257: \"ustar \"\r\n\tversion    [2]byte         // 263: \" \\x00\"\r\n\tuname      [32]byte        // 265\r\n\tgname      [32]byte        // 297\r\n\tdevmajor   [8]byte         // 329\r\n\tdevminor   [8]byte         // 337\r\n\r\n\t// The GNU format replaces the prefix field with this stuff.\r\n\t// The fact that GNU replaces the prefix with this makes it non-compliant.\r\n\tatime      [12]byte        // 345\r\n\tctime      [12]byte        // 357\r\n\toffset     [12]byte        // 369\r\n\tlongnames  [4]byte         // 381\r\n\tunused     [1]byte         // 385\r\n\tsparse     [4]headerSparse // 386\r\n\tisextended [1]byte         // 482\r\n\trealsize   [12]byte        // 483\r\n\t                           // 495\r\n}\r\n\r\ntype headerSparse struct {\r\n\toffset   [12]byte //  0\r\n\tnumbytes [12]byte // 12\r\n\t                  // 24\r\n}\r\n```\r\n\r\nIn fact, the structure for GNU swaps out the prefix section of POSIX, for a bunch of extra fields for atime, ctime, and sparse file support (contrary to what Go thinks).\r\n\r\nRegarding the use of base-256 encoding, it seems that GNU was the first to [introduce this encoding  back in 1999](http://git.savannah.gnu.org/cgit/tar.git/commit/?id=e4e624848b53ac02f1212af2209a63d28e40afec). Since then, pretty much every tar decoder handles reading base-256 encoding regardless of whether it is GNU format or not. Marking the format as GNU may or may not be necessary just because base-256 encoding was used.\r\n\r\n#### Problem 1: \r\nWhen reading, if the decoder detects the GNU magic number, it will attempt to read 155bytes for the prefix. This is just plain wrong and will start to read the atime, ctime, etc instead. This causes the prefix to be incorrect.\r\n\r\n[See this playground example](https://play.golang.org/p/oARo0DMzys)\r\nThe paths there have something like \"12574544345\" prepended to it. This is because when the tar archive tries to read the the prefix, it is actually reading the atime (which is in ASCII octal and is null terminated). Thus, it incorrectly uses the atime as the prefix.\r\n\r\nThis probably went undetected for so long since the \"incremental\" mode of GNU tar is rarely used, and thus the atime and ctime fields are never filled out and left as null bytes. This happens to work in the common case, since the cstring for this field ends up being an empty string.\r\n\r\n#### Problem 2:\r\nWhen writing, if a numeric field was ever too large to represent in octal format, it would trigger the ```usedBinary``` flag and cause the library to output the GNU magic numbers, but subsequently fail to encode in the GNU format. Since it believes that the GNU format has a prefix field, it erroneously tries to use it, losing some information in the process.\r\n\r\nThis is ultimately what causes #9683, but is rare in practice since the perfect conditions need to be met for GNU format to be used. There is a very narrow range between the use cases of USTAR and PAX where the logic will use GNU.\r\n\r\n#### Solution:\r\n\r\nWhen decoding, change it so that the reader doesn't read the 155byte prefix field (since this is just plain wrong). Optionally, support parsing of the atime and ctime from the GNU format. Nothing needs to change for sparse file support since that logic correctly understood the GNU format.\r\n\r\nWhen encoding, I propose the following order of precedence:\r\n* First, use the 1988 POSIX (USTAR) standard when possible for maximum backwards compatibility. \r\n* If any numeric field goes beyond the octal representation, or any names are longer than what is supported, just use the 2001 POSIX (PAX) standard.\r\n\r\nLet's avoid writing the GNU format. In fact the GNU manual itself, [says the following under the POSIX section](https://www.gnu.org/software/tar/manual/html_node/Formats.html#SEC132):\r\n\u003e This archive format will be the default format for future versions of GNU tar.\r\n\r\nThe only advantages that GNU offers over USTAR is:\r\n* Unlimited length filenames (only ASCII)\r\n* Relatively large filesizes\r\n* Possibly atime and ctime\r\n\r\nHowever, PAX offers all of these over USTAR and far more:\r\n* Unlimited length strings (including UTF-8) support for filenames, usernames, etc.\r\n* Unlimited large integers for filesizes, uids, etc.\r\n* Sub-second resolution times.\r\n* No need for base-256 encoding (and assuming that decoders can handle them) since PAX has its own well-defined method of encoding arbitrarily large integers.\r\n\r\nNot to mention, we are already outputting PAX in many situations. What's the point of straggling between 3 different output formats?\r\n\r\nThoughts?",
	"user": {
		"login": "dsnet",
		"id": 6354026,
		"type": "User",
		"site_admin": false
	},
	"assignee": {
		"login": "dsnet",
		"id": 6354026,
		"type": "User",
		"site_admin": false
	},
	"comments": 7,
	"created_at": "2015-09-11T23:30:50Z",
	"updated_at": "2016-05-17T20:35:05Z",
	"milestone": {
		"id": 1709363,
		"number": 38,
		"title": "Go1.8"
	}
}
