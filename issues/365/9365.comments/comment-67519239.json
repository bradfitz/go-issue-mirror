{
	"id": 67519239,
	"body": "I couldn't get any useful information from the slides, but there is a good paper at https://131002.net/siphash/siphash.pdf .  It basically argues that timing information is always available, even across the network.  The basic attack on an HTTP server is to send many headers, attempting to get them to collide in such a way that hash lookups become less efficient.  The Go net/http package is somewhat resistant to this kind of attack, because it limits the size of the headers in an incoming HTTP request.  The default limit is 1MB.  So an attack on the Go net/http package has only a limited number of strings to play with.  And each new HTTP request gets a new map, with a different seed, so the earlier timing information is useless.  So I don't see a serious attack on Go's HTTP server here.\r\n\r\nAn attack requires a single map stored across multiple requests, such that each new request can add entries to the map, with no limit on the number of entries, and where timing information is available for each new request.  When that is the case, an attacker can cause the map to flood.  In the case of Go's implementation this will mean a long series of overflow buckets for the same hash value, shifting map lookup time, and, perhaps more importantly, map insertion time, from O(1) to O(N).\r\n\r\nIt's difficult for me to judge the risks here.  In a modern server, a single map that retains entries across multiple requests does not seem to be a likely case.  A single map that accepts new entries with no bounds also seems unlikely, and such a map would seem to be susceptible to much simpler attackes.  But it is certainly possible.  The question at hand is whether to slow down the map implementation for everybody to protect against this unlikely but possible case.\r\n\r\nAnother possible approach would be to change the hash seed each time the hashmap grows.  That would require sometimes computing the hash key twice while map growth was in progress.  I think we already rehash each key as we evacuate an old bucket, so I don't think it would cost anything there.  I think this would significantly reduce the scope of any attack, as the seed would have to be recomputed each time the hash map grows.\r\n\r\nAnyhow, khr can make a real decision here.  I'm having a hard time translating from the theoretical attacks on things like caching DNS servers to practical attacks on real Go programs, but there could well be aspects of this that I am missing.",
	"user": {
		"login": "ianlancetaylor",
		"id": 3194333,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-12-18T17:07:56Z",
	"updated_at": "2014-12-18T17:07:56Z"
}
