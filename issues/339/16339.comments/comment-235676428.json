{
	"id": 235676428,
	"body": "After thinking about this a bit more I'm going to have to change my opinion\nto being +1.\n\nPositives:\n- Helps in refactoring large code bases. See context discussion.\n- Simplifies what we can almost already do with wrappers and makes it a\nfirst class citizen.\n\nNegatives:\n- Sometimes type comparisons will work (aliases), sometimes not (vendored).\nThe vendored type issue though is a separate matter and we don't have to\nboil the ocean.\n- Adds to cognitive overhead, but less so than\nhttps://github.com/golang/net/blob/master/context/go17.go IMO.\n\nI am still worried this will be abused, but (shrug), as pointed out so are\nother language constructs.\n\nOn Wed, Jul 27, 2016 at 8:47 AM Bryan C. Mills \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e @atdiar \u003chttps://github.com/atdiar\u003e\n\u003e\n\u003e If your type/func/etc was initially in net/context, packages that import\n\u003e net/context expect the type/func/var to come from net/context. (the package\n\u003e name is part of the type information).\n\u003e\n\u003e That's true, but most programs should not rely on that information (it's\n\u003e only visible using reflection). Fortunately, golang.org/x/net/context is\n\u003e not subject to the same compatibility requirements as context: it aims\n\u003e for API compatibility but does not guarantee perfect compatibility.\n\u003e Defining golang.org/x/net/context in terms of context would be fine; it\n\u003e wouldn't break most programs and would require only minor changes in the\n\u003e remainder.\n\u003e\n\u003e But you're correct that we could not, say, use this same mechanism to\n\u003e refactor the Go standard library without technically breaking Go 1\n\u003e compatibility.\n\u003e\n\u003e Aliasing seems to get things backwards. If you move types to, let's say,\n\u003e an internal package, you don't want clients to use this type. The type info\n\u003e has changed.\n\u003e\n\u003e Correct. You want clients to refer to the type by its name in the public\n\u003e package. But they can do that; the only place that doesn't work is when\n\u003e using reflection to get the package-qualified name of the type. And as I\n\u003e understand it that approach is fragile in the presence of vendoring anyway:\n\u003e if the build system rewrites import paths, the paths as seen through\n\u003e reflection will change regardless.\n\u003e\n\u003e If you did that, any change at the bottom of the dependency tree would\n\u003e have to be propagated upwards, to clients of clients and clients of clients\n\u003e of clients etc.\n\u003e\n\u003e Yes. The point of aliasing is that it propagates those changes\n\u003e automatically (without requiring manual editing).\n\u003e\n\u003e Now, let's say the context.Context type has methods that returns types\n\u003e that have been moved to a different packages, if these types are not copied\n\u003e back, things are going to break.\n\u003e\n\u003e Let's be precise: how would they break? (In particular, how would they\n\u003e break if the context package includes aliases for the types that have\n\u003e been moved?)\n\u003e\n\u003e â€”\n\u003e You are receiving this because you were mentioned.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/16339#issuecomment-235628616\u003e, or mute\n\u003e the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AAAAZ9X4eANBwZbCScBDZHsHUfD9PIokks5qZ32DgaJpZM4JK0gz\u003e\n\u003e .\n\u003e\n",
	"user": {
		"login": "freeformz",
		"id": 103,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-27T18:28:48Z",
	"updated_at": "2016-07-27T18:28:48Z"
}
