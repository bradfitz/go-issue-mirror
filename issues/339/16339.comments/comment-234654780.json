{
	"id": 234654780,
	"body": "@bcmills \r\n\r\n\u003e That doesn't seem any better to me from the perspective of documentation and discoverability.\r\n\r\nSure that might be the case. I was rather questioning whether \"alias\" is the best way to solve protobuf-s `XXX_` problem, because there have been other solutions to packages solving similar problem. Alternatively, let's say you had inheritance, meta-programming or feature X... maybe there exists some other solution that solves that particular problem much better.\r\n\r\n\u003e Even if there were a better way to structure the package, how would we get from here to there without either breaking everything that uses the existing proto package or including two separate (and perhaps incompatible) versions in ~every Go binary? \r\n\r\nThe same way you handle refactoring/adjustments that require adding/removing fields (e.g. deprecated fields in https://golang.org/pkg/archive/zip/#FileHeader). Which is to say, it still is a problem, even if you have aliasing.\r\n\r\nLet's say over the next 20 years, you have additional 4 different versions of protobuf - at which point do you remove the aliases? Or do you keep them all around? What will you do when it's not possible to alias version 3 into version 6, because of version 4 removed some fields and methods.. and added some methods that are required to be called? How would supporting all of those versions look like?\r\n\r\n_I'm aware that it's technically not a refactor because the external behavior changes, but it's still common._\r\n\r\nI would let outside packages using \"proto\" either depend on a particular version or vendor it. To upgrade, based on limited overview, I would make a \"proto3\" package and, since it's widely used, create/use some utility for easy migration to the newer package. So, as long as you haven't run that utility or fixed your dependencies, yes you could have two (potentially incompatible) versions. (For the breaking builds in huge code-bases, I already mentioned the \"gomigrate\" possibility)\r\n\r\nI would predict that with aliasing in the 20yr case, you would end up with different packages with some numeric suffix _(because I'm not sure how you would use aliasing together with semantic versioning)_. Then only some of those version migrations can actually use aliasing, because of removed/added fields/structs/types/methods introduced in refactoring/rewriting. Which means you still could have several incompatible versions of the package.",
	"user": {
		"login": "egonelbre",
		"id": 192964,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-22T20:58:33Z",
	"updated_at": "2016-07-22T21:03:08Z"
}
