{
	"id": 236384874,
	"body": "@bcmills:\r\n\r\n\u003e There are existing, backward-compatible patterns that suffice for most other API changes: for example, adding methods or fields to concrete struct or pointer types is already backward-compatible. Aliasing does not - and does not need to - address the use-cases that Go already handles well.\r\n\r\nAgreed, never said that the only change type is to remove, modify existing types.\r\n\r\n\u003e There is never a time during which people, users, and/or other automatic tooling are not working on the codebase. Doubly so for open-source projects (including protobuf). Even if there were such a time, at scale it is necessary to be able to make multiple changes at once. \r\n\r\nThey can safely rebase onto master + do a search \u0026 replace of the import statement from old to new which can be done like this:\r\n\r\n```\r\nsearch: \"github.com/dlsniper/demo\"\r\nreplace with: demo \"github.com/demo/otherpkg\"\r\n```\r\n\r\nAnd provide no breaking. If you refer to more complex cases where this type of refactoring is not possible due to moving just types not whole packages then a tool can be created that accepts the type that has been moved, the old package and the new package and do the changes at a source level. Not as transparent but at least the users are now aware of this change, which is far more valuable.\r\n\r\n\u003e For that matter, as Ian points out, you cannot upgrade the code you cannot see. If you provide an open-source package, how will you send pull requests to your users who have not published their source code?\r\n\r\nNo, publish the list of changes and let the users deal with the upgrade from 1.2 to 2.0. If a security issue happens to be discovered in 1.2 I'll publish the fist for it as 1.2.1 and add it to the main 2.0 releases as well. If I have already 2.2 or 2.3 out I won't bother to fix it and I'll let the users upgrade to the latest and greatest.\r\n\r\n\u003e An automated tool doesn't help resolve diamond dependencies (per my previous comment), particularly when only a subset of types are moved from one package to another. (Moving an entire package such as context is just one example - and a fairly simple one at that.)\r\n\r\nIn that case:\r\n- the users will push for the packages to be updated, maybe even help out by sending PRs instead of complaining that X or Y doesn't work\r\n- they will not upgrade any package until such time that the upgrade is possible\r\n- if forced to do the upgrade they will fork it, make the changes (it's supposed they've done that already and sent a PR) and use their fork as a source for that package (something that any decent package manager should be able to handle)\r\n\r\n\u003e So moving to the kind of semantic-versioning world you're proposing would require:\r\n\r\nI'm proposing for Go not to introduce this thing which adds complexity to the language and to learning it (also for changing ALL the tools that will need to get an understanding of aliases, because without tools how can you comprehend large code bases? and I'll call guru as one example but there are many many other tools out there).\r\n\r\n\u003e Aliases would not allow you to add methods to interfaces or change interface signatures. Fortunately, I think most providers of Go APIs already understand that and are careful to engineer around it (e.g. by exporting concrete types instead).\r\n\r\nI'll address this in a later comment, have some more replies for other comments to give. Thank you.",
	"user": {
		"login": "dlsniper",
		"id": 607868,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-30T19:22:28Z",
	"updated_at": "2016-07-30T19:23:10Z"
}
