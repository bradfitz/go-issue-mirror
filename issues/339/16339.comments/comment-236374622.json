{
	"id": 236374622,
	"body": "@Merovius:\r\n\r\n\u003e The issue that I take with that is, that it still means I can't upgrade until all transitive dependencies have bumped their stuff.\r\n\r\nCorrect. Help them by sending PRs in this case, that's how open-source works, no?\r\n\r\n\u003e  I don't have any faith in the general open source community that that happens in a timely manner. \r\n\r\nMe neither but I don't want to have to wait for it to follow up. With introducing the aliases I'll have a false sense of security which will then be shatter everyone's work with the next API break of the newly aliased package.\r\n\r\n\u003e So you'll end up with two incompatible versions and either the burden of maintaining both in the meantime, so that users can choose which they use, or only maintaining the newer one, in which case everyone else is left in the cold in regards to new features, bug- and security fixes.\r\n\r\nI will not backport anything unless it's a critical security fix (all security fixes are critical). And even then I would only do it for one, maximum two, previous versions.\r\nAs for new features, upgrade or don't get them, simple as it is.\r\n\r\n\u003e In short, they don't actually solve the problem of a large-scale, fast moving codebase, at least not without significant maintenance overhead for everyone involved.\r\n\r\nPlease explain how an automated tool which moves a huge amount of imports from `a/b/c` to `a/b/d/c`, which is the current problem suggested by the proposal isn't effective at any scale inside an organization with high velocity? Surely this can be done when people are not working on the code base, say for example weekends (I would assume that people are not forced to work in weekends), during the late night hours if the organization is around the same timezone and maybe a few other ways as well. The Go team displayed excellent craftmanship when they've created a tool that ported C to Go code for the compiler, I'm sure that something as simple as change an import path from one place to another can be done by people less technically inclined than them.\r\n\r\n\u003e The overwhelming majority of API changes can be done in a gradual, multi-phase-commit way of providing shims and wrappers. You add the new API, you wait until everyone has stopped using the old, you remove the old. Moving things from package to package isn't possible this way.\r\n\r\nWhich wouldn't be needed if people would bump this with SemVer to the next major version. That's how SemVer works and should be used. I don't want to and won't want to wait for all (or even the _known_ majority of them) the API consumers to finally introduce the next refactoring. If I'm changing the structure in a fundamental manner I don't want to have to wait months and months for people to catch up, no. I would just clearly communicate the API breaks of the next version, see if I can provide a transition path and let the importers deal with this at their own pace without involving me.\r\n\r\n\u003e The two aren't mutually exclusive. I can, with this change, provide the new API at foo/bar and leave a shim around in foo. Users can then update to the new API whenever they want, but - and that's the important part - in the meantime, they'll just silently profit from my maintenance of foo/bar and their users don't suffer from diamond dependency issues and incompatibilities.\r\n\r\nI'm not sure we are thinking about the same API changes as I'm thinking. If I suddenly want to add a method to an interface that's aliased or change its signature everything else will break, alias or not. If you are suggesting that we allow method definitions on aliases then I suggest that we, the people who see the problems with this, fork Go immediately and maintain it without this functionality.\r\n\r\n\u003e See above, I don't think Google should be viewed as the primary profiteer of this change, but the open source community\r\n\r\nThe open source community, including and not limited to users, package creators and tools developers for Go think this is a bad idea as it introduces nothing that can't be already fixed in the open-source community and by the open-source community without having a language change. Worse, like @davecheney pointed out above, and I'll quote this for emphasis, both existing Go developers and new Go developers don't want / need this feature due to the added complexity it introduces with no net gain for the community at large:\r\n\r\n\u003e Put simply, this proposal is not something the community is asking for, and at best, will solve a problem that nobody in the community has (although some are gleefully thinking of ways to find a problem to use this hammer for), yet at the same time it decreases the readability of the language by introducing ambiguity, which hurts every single Go programmer beginner or experienced. As someone who cares deeply about promoting the language to newcomers, those who in trying to learn the language, will obtain zero benefit from an ability to alias types to aid refactoring if they should find themselves in a bizarrely manufactured situation where they cannot refactor their code without staging the change in a branch.",
	"user": {
		"login": "dlsniper",
		"id": 607868,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-30T16:26:43Z",
	"updated_at": "2016-07-30T16:26:43Z"
}
