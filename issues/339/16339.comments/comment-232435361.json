{
	"id": 232435361,
	"body": "Thanks to everybody for providing this extremely valuable feedback. This is exactly what we (the Go team) were hoping for. Please keep it coming; especially if you have specific comments that have not been voiced so far. Please use the +1/-1 emoticons to express general support or disagreement. Thanks.\r\n\r\nHere is some feedback regarding the comments so far.\r\n\r\n@Merovius: The unsafe functions are actually built-in functions and we also disallow aliasing for built-in functions. Some of them (in fact all the unsafe built-in functions) have a \"generic\" signature. If it were possible to alias them, they could potentially be exported, and that would require special export/import machinery since they don't have a signature that can be expressed in Go. It does not seem worthwhile adding complexity for a mechanism that is questionable at best (aliasing unsafe functions). The reason we allow aliasing for unsafe.Pointer is that it's already possible to define a type that has unsafe.Pointer as underlying type. This is all outlined in the design doc.\r\n\r\n@matttproud, @cespare, @josharian, and others: A lot of people have raised concerns about using `-\u003e` and would prefer `=\u003e` instead. I'll adjust the design doc to use `=\u003e` going forward.\r\n\r\n@josharian: It is probably a good idea to restrict alias declarations, at least to start with. We can always remove restrictions down the road if necessary. I am inclined to say we should allow alias declarations for imported objects only (so no local aliases). Restricting them to be placed at the top-level only would be a secondary restriction in my mind. I'm not sure it's needed if we have the former restriction.\r\n\r\n@josharian: I believe you're right that it's going to be a bit tricky to get the compiler to give good error messages in the presence of aliases. But that's mostly an implementation detail. There are probably also a lot of issues that go doc and friends need to handle. That said, I believe this is something that can be refined over time w/o impacting the fundamentals of the proposal.\r\n\r\n@dlsniper: Your suggestion of writing `type from alias to` would require `alias` to be a keyword. As discussed in the design doc, introducing a new keyword is generally not possible, though it would be doable at the top-level; however not in the position you are suggesting without what I would call a \"gross hack\". But I agree that using `-\u003e` is perhaps not the best choice and `=\u003e` might be better.\r\n\r\n@Kunde21: We have spent several hours playing with different notations, and `@` was one of them, as were `~`, `~\u003e`, `~~`, `==`, `===`, and probably a few more (`=` really would be perfect if we could use it). Let's go forward with `=\u003e` for now, but keep `@` back in mind since others also like it. It's trivial to change the token down the road if people clearly start leaning strongly towards a specific one.\r\n\r\n@Kunde21, @mem: Regarding chains of aliases: That is a very valid concern. We should perhaps start with disallowing aliases to aliases. It's a simple, easy to understand restriction, doesn't limit the proposal much, and can be trivially lifted if need be down the road.\r\n\r\n@Kunde21: Allowing aliasing only internally defeats the purpose of the proposal (but perhaps I misunderstood your comment).\r\n\r\n@Kunde21: There's a lot we can do with go vet/lint, goimports, and friends. Let's discuss this as a separate issue.\r\n\r\n@jimmyfrasche: If we restrict aliasing to imported objects only, I believe your concerns are addressed. That is, an alias can only export something that was exported before (since it can only alias something that was imported).\r\n\r\n@mem: Using aliases to export objects of internal objects seems like a very important alternative use case. This would still be possible to do if we only permit aliases to exported objects.\r\n\r\n@josharian: Adding methods to a type via its alias name in the receiver specification seems like it should be possible if the alias refers to a locally declared type since the alias really just means that type. It should not be legal if the type is imported (it's not legal now). But it we restrict aliases to imported objects only, this question becomes moot.\r\n\r\n@zellyn: I think `:=` instead of `-\u003e` or `=\u003e` would be even more confusing given its existing use.\r\n\r\n@zellyn: Several people have expressed concerns abut exposing private things via exported aliases. Let's start small.\r\n\r\n@leighmcculloch: I believe your questions have been answered by others. I'm not sure versioning is helping here (see @zellyn's feedback). Renaming of packages may work in some cases but not others.\r\n\r\n@stephens2424: You are correct that one has to be very careful about not creating circular dependencies. I have hinted at that when discussing the work-around for variables. I think aliasing will make it possible to avoid circles which might occur if only other work-arounds were available.\r\n\r\n@perses: We did think about a special notation for variables only; including the possibility of making `@a` more generally useful (in fact, we internally discussed the very same notation). That is, `@x` could mean a something along the lines of`reference to x without using pointer notation`. But now we have two mechanisms to discuss: aliasing, and \"variable references\", and the latter seems to open an even bigger Pandorra's box. Let's not go there in this discussion.\r\n\r\n@Merovius: Agreed. There is strong sentiment in favor of not allowing aliases to export unexported objects.\r\n\r\n@atdiar: Thanks for your feedback. I believe many of your concerns have been brought up by others as well. Perhaps you can elaborate on the relationship to the \"functor\" mechanism of OCaml (with which I and probably many others are not familiar with).\r\n\r\n@natefinch, @jfrazelle: Your concerns have been echoed by many people. I think we do need to start with a smaller and restricted proposal and take it from there. I will update the proposal to take this feedback into account.\r\n",
	"user": {
		"login": "griesemer",
		"id": 8528975,
		"type": "User",
		"site_admin": false
	},
	"reactions": {
		"total_count": 3,
		"heart": 3
	},
	"created_at": "2016-07-13T17:55:33Z",
	"updated_at": "2016-07-13T17:55:33Z"
}
