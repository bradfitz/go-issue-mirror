{
	"id": 234447055,
	"body": "To me coming from majority Node and JavaScript before Go, I feel like people coming from the same past experience would absolutely use this to break a package into many internal subpackages, and then build a top-level package to be then exposed in the top level. That was my first thought on allowing this as a generic feature.\r\n\r\nPretty much, I like the idea, but I would rather not support the manual method of aliasing, and to not support that because that encourages either more tooling to automatically define them, and then bloating packages. But rather strive towards something that is supported down to the compiler, and adds something most want, which is blessed vendor / dependency management tool using existing go workflows. I have no idea on how.. realistic the below is :)\r\n\r\nAs well, it could support this idea of temporary aliasing. I don't pretend to have an idea of how this would effects everything down to compilation though or if it would even be feasible.\r\n\r\n```\r\n\timport Printf = fmt.Printf\r\n```\r\n\r\nor\r\n\r\n```\r\n\timport Printf fmt.Printf\r\n```\r\n\r\nOne might even permit the form\r\n\r\n```\r\n\timport context.Context\r\n```\r\n\r\nas a shorthand for\r\n\r\n```\r\n\timport Context context.Context\r\n```\r\n\r\nWhen reading the above in the proposal, it reminded me more of the ECMAScript 6 Module System,  such that `import [. || {LocalIdentifiers...}] \"packagename\"`. I thought that would be a great idea, but then I thought how you could use/abuse it in practice for doing API breaking changes, and you would then be pushing people towards making a `github.com/myname/myrepoV2` as a permanent change which imported/aliased everything they wanted from `myrepo` internally and only defined the new APIs. \r\n\r\nWhich would directly conflict with the current direction that the `vendor` folder is going towards the SemVer style say of Rusts Cargo, or Nodes NPM. For the intended usage of refactoring, I feel like if a new feature for this is being considered then perhaps it should be viewed as something you use via the import statement rather than special syntax with `type` keyword. Adding support then for loading two versions of the underlying source which decided which package won on functions called the same thing, but their implementation may have changed. This would be based on the direction of the arrow.\r\n\r\nAs with the alias, anything that was the same would simply be accessed under either\r\n\r\n```\r\nimport json \"github.com/myname/myrepo@2.0.0\" \u003c- json134 \"github.com/myname/myrepo@~1.3.4\"\r\n```\r\n\r\nwhere\r\n\r\n```\r\nimport \u003cidentifier\u003e \"\u003cpath\u003e@\u003csemver/revision?\u003e\" \u003c- \u003cidentifier\u003e \"\u003cpath\u003e@\u003csemver/revision\u003e\"\r\n```\r\n\r\nyou can use values interchangeably between the two packages where the underlying type hasn't changed.\r\n\r\nThe arrow would define which package wins for any conflict resolution which had to happen. \r\n\r\nOn the smaller scale for refactoring piece-meal I've include an example which is the reverse using a syntax that would only upgrade `NewDecoder` (and include it's dependants if they differ) from 1.7 into the 1.6 version.\r\n\r\n```\r\nimport { NewDecoder } encoding/json@1.7 \u003c- encoding/json@1.6\r\n```\r\n\r\nPotentially this could allow for standardizing on one tool for the `vendor` process even making it part of the `go get`. ",
	"user": {
		"login": "itsjamie",
		"id": 1956521,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-07-22T03:38:12Z",
	"updated_at": "2016-07-22T03:48:50Z"
}
