{
	"id": 66080485,
	"body": "\u003ca id=\"c6\"\u003e\u003c/a\u003eComment 6:\n\n\u003cpre\u003eThe pointer maps are correct, the problem seems to be related to unsafe use of uintptr. \nHere is the offending function\n\n// encodeStruct encodes a single struct value.\nfunc (enc *Encoder) encodeStruct(b *bytes.Buffer, engine *encEngine, basep uintptr) {\n\tstate := enc.newEncoderState(b)\n\tstate.fieldnum = -1\n\tfor i := 0; i \u0026lt; len(engine.instr); i++ {\n\t\tinstr := \u0026engine.instr[i]\n\t\tp := unsafe.Pointer(basep + instr.offset)\n\t\tif instr.indir \u0026gt; 0 {\n\t\t\tif p = encIndirect(p, instr.indir); p == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tinstr.op(instr, state, p)\n\t}\n\tenc.freeEncoderState(state)\n}\n\nI suspect this is not the last bug we will have of this sort.  Fortunately, they are\neasy to diagnose.  \n\nThis is what I do.... Here is the decoding and pointer scanning loop inside\naddframeroots.  You want to start by adding the \"IGNORE\" printf and run the affected\ntest.\n\n\t\t\t\tfor((j = (rem \u0026lt; 32) ? rem : 32); j \u0026gt; 0; j--) {\n\t\t\t\t\tif(w \u0026 b)\n\t\t\t\t\t\taddroot((Obj){ap, sizeof(uintptr), 0});\n\t\t\t\t\telse {\n\t\t\t\t\t\truntime·printf(\"IGNORE %X @ %X in %S\\n\", *(uintptr*)ap, (uintptr)ap, f-\u0026gt;name);\n\t\t\t\t\t}\n\t\t\t\t\tb \u0026lt;\u0026lt;= 1;\n\t\t\t\t\tap += sizeof(uintptr);\n\nMost of the values being ignored will be junk.  That is not interesting to us.  Ignored\npointer values are interesting.  Grep the test output for \"^IGNORE 0xc2\" to find the\nignored pointers on 6g compiled code.  5g and 8g will need a different pattern.  You\nwill see something like this\n\nIGNORE 0xc2000186a0 @ 0x7fc8f7ba6d40 in bloom.genUUIDs\nIGNORE 0xc2000186a0 @ 0x7fc8f7ba6d40 in bloom.genUUIDs\nIGNORE 0xc210438b2c @ 0x7fc8f7ba6a20 in encoding/gob.(*Encoder).encodeArray\nIGNORE 0xc21000a980 @ 0x7fc8f7ba6ac0 in encoding/gob.(*Encoder).encodeStruct\nIGNORE 0xc21005fba0 @ 0x7fc8f7ba6b28 in encoding/gob.(*Encoder).encodeStruct\nIGNORE 0xc210438b2c @ 0x7fc8f7ba6a20 in encoding/gob.(*Encoder).encodeArray\nIGNORE 0xc21000a980 @ 0x7fc8f7ba6ac0 in encoding/gob.(*Encoder).encodeStruct\nIGNORE 0xc21005fba0 @ 0x7fc8f7ba6b28 in encoding/gob.(*Encoder).encodeStruct\nIGNORE 0xc21002c000 @ 0x7fc8f7ba69b0 in reflect.deepValueEqual\nIGNORE 0xc200000002 @ 0x7fc8f7ba6b50 in reflect.deepValueEqual\nIGNORE 0xc210011090 @ 0x7fc8f7ba6cf0 in reflect.deepValueEqual\nIGNORE 0xc21002c000 @ 0x7fc8f7ba69b0 in reflect.deepValueEqual\nIGNORE 0xc200000002 @ 0x7fc8f7ba6b50 in reflect.deepValueEqual\nIGNORE 0xc210011090 @ 0x7fc8f7ba6cf0 in reflect.deepValueEqual\n\nIn the absence of a hunch about what might be going wrong based on this data alone,\ninstrument the \"else\" clause as follows\n\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tStringCompare(f-\u0026gt;name, (byte*)\"bloom.genUUIDs\") ||\n\t\t\t\t\t\t\tStringCompare(f-\u0026gt;name, (byte*)\"encoding/gob.(*Encoder).encodeArray\") ||\n\t\t\t\t\t\t\tStringCompare(f-\u0026gt;name, (byte*)\"encoding/gob.(*Encoder).encodeStruct\") ||\n\t\t\t\t\t\t\tStringCompare(f-\u0026gt;name, (byte*)\"reflect.deepValueEqual) ||\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\taddroot((Obj){ap, sizeof(uintptr), 0});\n\t\t\t\t\t}\n\nStart commenting out the StringCompare lines one by one until something breaks.\n\nHere is my StringCompare definition\n\nstatic bool StringCompare(String s1, byte* s2) {\n\treturn s1.len == runtime·findnull(s2) \u0026\u0026 !runtime·mcmp(s1.str, s2, s1.len);\n}\u003c/pre\u003e",
	"user": {
		"login": "lexprfuncall",
		"id": 5360361,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-06-04T00:05:35Z",
	"updated_at": "2014-12-22T06:25:46Z"
}
