{
	"id": 116106155,
	"body": "On Fri, Jun 26, 2015 at 12:55 PM, dr2chase \u003cnotifications@github.com\u003e wrote:\n\n\u003e I'm fishing for comments. The current API gives away too much from the POV\n\u003e of a compiler-writer.\n\u003e And I need to be clear on one point -- if we don't resolve this, there's\n\u003e well-understood optimizations that Go compilers won't do, and these are\n\u003e sufficiently important optimizations that they affect the way people write\n\u003e programs.\n\u003e\n\u003e Current (1.\u003c=5) Go only inlines when it can inline entire call trees all\n\u003e the way to the leaves; it cannot, for example, inline a simple function\n\u003e Small that wraps a much larger function Huge, because Huge is not eligible\n\u003e for inlining and thus all callers of Huge are not eligible for inlining.\n\u003e The current total-inlining policies means that go programs never observe\n\u003e the call sites at which the inlining occurs, and thus are never presented\n\u003e with the dilemma that there can be a stack of \"callers\" corresponding to a\n\u003e single return PC.\n\u003e\n\u003e If we allow more flexible inlining, and if A calls B, B calls\n\u003e runtime.Callers(1, pcslice) and B is inlined into A, the \"return pc\" for\n\u003e Callers (pcslice[0]) will be an address within A (according to nm) and\n\u003e there will be no return PC identifying B or the file of B or the line\n\u003e number within B.\n\u003e\n\u003e And unfortunately, this return PC = single caller identity is exposed in\n\u003e an interface -- a \"return pc\" is a uintptr. We could in theory hack on that\n\u003e integer to embed inline depth information in some unused bits, but in\n\u003e practice that is likely to break some code.\n\u003e\n\u003e So, if we intend to improve inlining in the future, we need to do\n\u003e something about this. The options I see (and I may be myopic, other options\n\u003e are welcome) include:\n\u003e\n\u003e (a) simply ignore intermediate callers. In the example, the caller of\n\u003e Callers will be A, and any mention of B is lost. It's a systems programming\n\u003e language, optimizers do this stuff all the time in other languages and you\n\u003e love it when they do, put on your grown-up pants and deal with it.\n\u003e\n\u003e pros: easy.\n\u003e And it will prepare people for tail-call elimination.\n\u003e And it will discourage them from thinking that they can use this for\n\u003e implementing Java-style caller-sensitive security, which is slow, yet\n\u003e difficult to reason about and hard to maintain. Seriously, this has been a\n\u003e source of numerous security holes in Java, in JDK 8 they simplified it as\n\u003e much as possible to reduce their risk (see e.g.\n\u003e http://openjdk.java.net/jeps/176 and\n\u003e https://bugs.openjdk.java.net/browse/JDK-8046166 ).\n\u003e\n\u003e cons: people might already critically rely on exact stack traces.\n\u003e\nI'd rather not do this.  Not because people might rely programmatically on\nexact stack traces, but because stack traces with holes in them are hard to\nunderstand.  I care less about the actual PCs that show up, but somehow\ntext backtraces should make sense in the original (uninlined) program if at\nall possible.\n\n\u003e (b) hack on the encoding of the return PC to embed an index. I'd propose\n\u003e to grab the upper 2-3 bits on an Intel box or the lower 2 bits on a RISC\n\u003e architecture (this imposes an obvious restriction on inline depth, and I\n\u003e assume that I can grab these bits even on a 32-bit machine), and have the\n\u003e counter indicate the inline depth, thus the 00 case will match what is seen\n\u003e in the nm output (in the above example, \"A\") and the 01 case corresponds to\n\u003e B. The symbol table information for \"A\" will need to provide the inlining\n\u003e depth at this site. In the example above, if it is IA32 and the raw RPC is\n\u003e 0x01234567, then the caller of Callers (B) is return PC 0x41234567 and B's\n\u003e caller (\"A\") is return PC 0x01234567. On a RISC, raw PC 0x03217654 is the\n\u003e same as the RPC for \"A\" and 0x03217655 is the RPC for \"B\" (called by A).\n\u003e\n\u003e pros: no change to interface, we never promised that \"returnpc\" was good\n\u003e for anything, did we?\n\u003e\n\nWe did promise it would be a valid argument to FuncForPC/FileLine.\n\nThere's no need to steal bits - we can assign arbitrary PCs to encode\ninlined bodies.  At one (virtual address) byte per PC, it shouldn't be too\nexpensive.\n\n\u003e cons: people thought we promised \"returnpc\" was a real live returnpc, and\n\u003e acted accordingly.\n\u003e Fails to adequately discourage Java-style caller-sensitive security.\n\u003e Also fails to prepare people for tail-call elimination.\n\u003e\n\u003e (c) = (a) + extend the interface with a more generalized notion of program\n\u003e counter. Most old code will continue to sort-of work without change and no\n\u003e risk of gigantic surprise (e.g., illegal address dereference from believing\n\u003e that an option-b PC was a real address), new code will use the improved\n\u003e interface.\n\u003e\n\u003e Note that there's nothing novel about abstracting on the \"return PC\" to\n\u003e get something that allows you to talk precisely about backtraces in the\n\u003e presence of inlining -- Java implementations have been doing this for more\n\u003e than 15 years.\n\u003e\nI think this is what I was describing above.  We should do this one.\n\n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/11432\u003e.\n\u003e\n",
	"user": {
		"login": "randall77",
		"id": 6889504,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-06-27T17:25:30Z",
	"updated_at": "2015-06-27T17:25:30Z"
}
