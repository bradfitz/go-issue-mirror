{
	"id": 161081378,
	"body": "Thanks for the feedback!\r\n\r\n\u003e How about adding AudioFormat string to the Clip interface? For instance a wav audio file can be encoded in a variety of coding formats. It might not belong to the interface since it's a detail that maybe only the decoder cares but I can think of a few examples where it would be useful.\r\n\r\nThe AudioFormat would represent the coding format of the original source, not the Clip's. The decoders won't work with Clips but arbitrary encoded streams of bytes and convert them into a Clip. The decoder can return the audio format of the original source. Consider the following decoder function:\r\n\r\n```\r\nfunc Decode(src io.ReadSeeker) (clip Clip, format string, err error)\r\n```\r\n\r\n\u003e I think we should, any kind of audio processing would more than likely done in float values, using float right away seems to be a better move IMHO (not a deal breaker tho).\r\n\r\nThis is unfortunately coming with a performance cost. We need to find a way to support float values but also allow integer-only values for faster processing for those who doesn't care about float-level precision.\r\n\r\n\u003e We can implement the decoders in pure Go code for when codecs are not available.\r\n\r\nWe won't have enough human resources probably to reimplement decoders in Go, therefore using the available codecs is going to be our initial step. The proposal is not against of a decoder being implemented in vanilla Go though.\r\n\r\n\u003e Question, why would we have a generic DecodeWAVBytes decoder function? It seems very specific to wav decoders only, doesn't it? DecodeBytes might be a better choice (?)\r\n\r\nIt was a sample for decoder implementations, I was not proposing it to be in the audio package. DecodeBytes is a better name in any case, I will update the proposal.\r\n\r\n\u003e I think it might be missing an API to get frames out of a clip.\r\n\r\nWe had an earlier debate about providing APIs that work with frames rather than byte slices. The previous API was in the lines of what's below.\r\n\r\n```\r\ntype Frame []int64\r\n\r\ntype Clip interface {\r\n     Read(f []Frame, offset int64) (n int, err error)\r\n}\r\n```\r\n\r\nThere are two arguments against the frame-based APIs:\r\n* It is easy to calculate how long a frame is, therefore working with byte slices doesn't require much additional work.\r\n* `Read(f []Frame, offset int64) (n int, err error)` almost reads like io.ReadSeeker. Not introducing a new interface type allows us to reuse utility functions from the stdlib on Clip instances (such as io.Copy).",
	"user": {
		"login": "rakyll",
		"id": 108380,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-12-01T20:09:21Z",
	"updated_at": "2015-12-01T20:09:21Z"
}
