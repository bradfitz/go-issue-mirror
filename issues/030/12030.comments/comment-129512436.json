{
	"id": 129512436,
	"body": "This is kind of amazing. Here is a C program:\n\n\t#include \u003cstdio.h\u003e\n\t#include \u003cstring.h\u003e\n\t#include \u003cstdlib.h\u003e\n\t#include \u003cwindows.h\u003e\n\t\n\tDWORD WINAPI thread(LPVOID x) {\n\t\tchar buf[128];\n\t\tdouble d = 1.0;\n\t\n\t\tprintf(\"printf: d=%g\\n\", d);\n\t\tsprintf(buf, \"sprintf: d=%g\\n\", d);\n\t\tprintf(\"%s\", buf);\n\t\n\t\treturn 0;\n\t}\n\t\n\tint main(void)\n\t{\n\t\tHANDLE h;\n\t\th = CreateThread(NULL, 0, \u0026thread, 0, 0, NULL);\n\t\tWaitForSingleObject(h, INFINITE);\n\t\tCloseHandle(h);\n\t\treturn 0;\n\t}\n\nIt prints:\n\n\tprintf: d=1\n\tsprintf: d=1\n\nHere is a very similar Go program:\n\n\tpackage main\n\t\n\t/*\n\t\n\t#include \u003cstdio.h\u003e\n\t#include \u003cstring.h\u003e\n\t#include \u003cstdlib.h\u003e\n\t#include \u003cwindows.h\u003e\n\t\n\tDWORD WINAPI thread(LPVOID x) {\n\t\tchar buf[128];\n\t\tdouble d = 1.0;\n\t\n\t\tprintf(\"printf: d=%g\\n\", d);\n\t\tsprintf(buf, \"sprintf: d=%g\\n\", d);\n\t\tprintf(\"%s\", buf);\n\t\n\t\treturn 0;\n\t}\n\t\n\tint cmain(void)\n\t{\n\t\tHANDLE h;\n\t\th = CreateThread(NULL, 0, \u0026thread, 0, 0, NULL);\n\t\tWaitForSingleObject(h, INFINITE);\n\t\tCloseHandle(h);\n\t\treturn 0;\n\t}\n\t\n\t*/\n\timport \"C\"\n\timport \"runtime\"\n\t\n\tfunc init() {\n\t\truntime.LockOSThread()\n\t}\n\t\n\tfunc main() {\n\t\tC.cmain()\n\t}\n\nIt prints:\n\n\tprintf: d=1\n\tsprintf: d=g\n\nThe use of a separate thread to run the code was meant to make sure that Go execution had not somehow poisoned that thread. The thread running the code in this case was created by Windows and has never been used for anything but C. Even so sprintf doesn't work. No matter what you try, %g formats as \"g\". Similarly, %e formats as \"e\" and %f formats as \"f\".\n\nI found that if you try to print 0 with %q (not valid) you get just \"q\" out, much like %g producing just \"g\". I wonder if the default case in this printf is to drop the %, as if %% were generalized. Then the question is just why %e, %f, %g are invalid like %q in a Go binary, but valid in a C binary. And why they are invalid in sprintf but valid in printf.\n\nOn 32-bit x86 systems Go changes the FPU mode at startup, but there is no such change on 64-bit systems. And again printf works while sprintf does not.\n\nI also tried snprintf (fails the same way) and sprintf_s (returns -1, indicating some kind of error, but we knew that).\n\nIt's quite the mystery.",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-10T16:10:58Z",
	"updated_at": "2015-08-10T16:10:58Z"
}
