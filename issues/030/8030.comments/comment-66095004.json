{
	"id": 66095004,
	"body": "\u003ca id=\"c5\"\u003e\u003c/a\u003eComment 5:\n\n\u003cpre\u003eThere are two things going on here: (1) the new stack copying code still falls back to\nsplitting the stack in some cases, which means that stack split hot spots can still\nhappen, and (2) we reduced the default stack size from 8 kB to 4 kB, which creates more\npotential for hot spots. \n\nI think we should raise the minimum stack back to 8 kB for Go 1.3. Once the hot spots\nare impossible, we can go back to 4 kB. Raising the stack size is trivial, matches Go\n1.2, and fixes the problem. \n\nThe Makefile is broken but this works for reproducing:\n\ng% go1.2 test -a -v -run TestBucket_Put_Multiple -cpuprofile cpu.prof\nseed: 81221\nquick settings: count=5, items=1000, ksize=1024, vsize=1024\n=== RUN TestBucket_Put_Multiple\n--- PASS: TestBucket_Put_Multiple (0.33 seconds)\nPASS\nok  \tgithub.com/boltdb/bolt\t0.347s\ng% \n\ng% go test -a -v -run TestBucket_Put_Multiple -cpuprofile cpu.prof\nseed: 67155\nquick settings: count=5, items=1000, ksize=1024, vsize=1024\n=== RUN TestBucket_Put_Multiple\n--- PASS: TestBucket_Put_Multiple (10.55 seconds)\nPASS\nok  \tgithub.com/boltdb/bolt\t10.559s\ng% \n\nIf I change runtime/stack.h to say StackDebug=1, it explains whether copystack was able\nto copy all the frames on the stack (showing the frame count) or else it explains why it\ncould not. In this test, the stack copy failure is being caused by efaceeq_c and\nifaceeq_c, over and over. The cost of the split is larger than in Go 1.2 because it\nfirst prepares to copy and fails, something Go 1.2 didn't have to do. The 0.3-second\ntest ends up trying to split the stack an amazing number of times:\n\n      1 copystack: 15 copyable frames\n      1 copystack: 16 copyable frames\n      1 copystack: 7 copyable frames\n      1 copystack: locals size info only for runtime.MSpan_Sweep\n      1 copystack: locals size info only for settype\n      2 copystack: locals size info only for runtime.MCentral_UncacheSpan\n      3 copystack: locals size info only for evacuate\n      4 copystack: locals size info only for runtime.MCache_Refill\n      5 copystack: locals size info only for runtime.starttheworld\n     20 copystack: locals size info only for MCentral_Grow\n     20 copystack: locals size info only for MHeap_FreeLocked\n     21 copystack: locals size info only for runtime.MHeap_Alloc\n     26 copystack: locals size info only for MHeap_AllocLocked\n     30 copystack: locals size info only for runtime.mallocgc\n     43 copystack: locals size info only for runtime.MCentral_CacheSpan\n     83 copystack: locals size info only for pcvalue\n   1295 copystack: locals size info only for runtime.mapassign1\n   2666 copystack: locals size info only for growslice1\n   2666 copystack: locals size info only for runtime.cnew\n1353678 copystack: locals size info only for runtime.efaceeq_c\n1353678 copystack: locals size info only for runtime.ifaceeq_c\n2719241 copystack: no locals info for runtime.call32\n\nIf I change StackMin back to 8192 in runtime/stack.h then the performance goes back to\n1.2 levels. I think we should do that for Go 1.3. The stack growth code is not ready to\nbe relied on to eliminate all hot spots yet. Leaving it at 8 kB means that at least we\nwon't cause any new hot spots by a reduction in initial stack size.\n\nThe call32 are particularly bad, because they can be arbitrarily far up the call stack.\nHere is one growth stack I captured. Note that call32 is basically at the top of the\nstack, which means the stack walk takes a while before it figures out that this stack\ncannot be copied.\n\ngoroutine 20 [stack growth]:\nruntime.markspan(0x208448000, 0x1000, 0x2, 0x22084b1f00)\n\t/Users/rsc/g/go/src/pkg/runtime/mgc0.c:2800 fp=0x22084b1ec8\nMCentral_Grow(0x2becb0)\n\t/Users/rsc/g/go/src/pkg/runtime/mcentral.c:283 +0x145 fp=0x22084b1f28\nruntime.MCentral_CacheSpan(0x2becb0)\n\t/Users/rsc/g/go/src/pkg/runtime/mcentral.c:84 +0x14b fp=0x22084b1f58\nruntime.MCache_Refill(0x22082f5000, 0x2b)\n\t/Users/rsc/g/go/src/pkg/runtime/mcache.c:78 +0x119 fp=0x22084b1f88\nruntime.mallocgc(0x1000, 0x139701, 0x1)\n\t/Users/rsc/g/go/src/pkg/runtime/malloc.goc:151 +0x30e fp=0x22084b1ff0\ncnew(0x139700, 0x1000, 0x1)\n\t/Users/rsc/g/go/src/pkg/runtime/malloc.goc:835 +0xc1 fp=0x22084b2010\nruntime.cnewarray(0x139700, 0x1000)\n\t/Users/rsc/g/go/src/pkg/runtime/malloc.goc:848 +0x3a fp=0x22084b2030\nmakeslice1(0x130aa0, 0x1000, 0x1000, 0x22084b2090)\n\t/Users/rsc/g/go/src/pkg/runtime/slice.goc:55 +0x4d fp=0x22084b2048\nruntime.makeslice(0x130aa0, 0x1000, 0x1000, 0x0, 0x1000, 0x1000)\n\t/Users/rsc/g/go/src/pkg/runtime/slice.goc:36 +0xb3 fp=0x22084b2078\ngithub.com/boltdb/bolt.(*DB).allocate(0x208325a40, 0x1, 0x0, 0x2083e1880, 0x36f)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/db.go:589 +0x50 fp=0x22084b2118\ngithub.com/boltdb/bolt.(*Tx).allocate(0x208329040, 0x1, 0x1b, 0x0, 0x0)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/tx.go:315 +0x35 fp=0x22084b2168\ngithub.com/boltdb/bolt.(*node).spill(0x20832a690, 0x208302a80, 0x22084b2470)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/node.go:288 +0x200 fp=0x22084b22d0\ngithub.com/boltdb/bolt.(*Bucket).spill(0x208302a50, 0x208302900, 0x22084b2668)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/bucket.go:532 +0x189 fp=0x22084b24c8\ngithub.com/boltdb/bolt.(*Bucket).spill(0x208329058, 0x279c1198, 0x2a3080)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/bucket.go:503 +0x7a3 fp=0x22084b26c0\ngithub.com/boltdb/bolt.(*Tx).Commit(0x208329040, 0x0, 0x0)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/tx.go:152 +0x1c7 fp=0x22084b27f8\ngithub.com/boltdb/bolt.(*DB).Update(0x208325a40, 0x22084b28c8, 0x0, 0x0)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/db.go:455 +0xe7 fp=0x22084b2850\ngithub.com/boltdb/bolt.func·111(0x208325a40, 0x20833a840, 0x3f)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/bucket_test.go:857 +0x86 fp=0x22084b2908\ngithub.com/boltdb/bolt.func·190(0x20833a840, 0x3f)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/db_test.go:509 +0x11c fp=0x22084b2970\ngithub.com/boltdb/bolt.withTempPath(0x22084b29b0)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/db_test.go:498 +0x6b fp=0x22084b29a8\ngithub.com/boltdb/bolt.withOpenDB(0x22084b29d0)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/db_test.go:518 +0x38 fp=0x22084b29c8\ngithub.com/boltdb/bolt.func·112(0x208368000, 0x11e, 0x11e, 0x22084b2a00)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/bucket_test.go:871 +0x40 fp=0x22084b29f0\nruntime.call32(0x2082f4390, 0x208322200, 0x1800000019)\n\t/Users/rsc/g/go/src/pkg/runtime/asm_amd64.s:346 +0x32 fp=0x22084b2a18\nreflect.Value.call(0x14ff60, 0x2082f4390, 0x0, 0x130, 0x19e9b0, 0x4, 0x208322100, 0x1,\n0x1, 0x1, ...)\n\t/Users/rsc/g/go/src/pkg/reflect/value.go:563 +0x1069 fp=0x22084b2d40\nreflect.Value.Call(0x14ff60, 0x2082f4390, 0x0, 0x130, 0x208322100, 0x1, 0x1, 0x0, 0x0,\n0x22082f9780)\n\t/Users/rsc/g/go/src/pkg/reflect/value.go:411 +0xb3 fp=0x22084b2da8\ntesting/quick.Check(0x14ff60, 0x2082f4390, 0x2083220e0, 0x0, 0x0)\n\t/Users/rsc/g/go/src/pkg/testing/quick/quick.go:258 +0x42d fp=0x22084b2eb8\ngithub.com/boltdb/bolt.TestBucket_Put_Multiple(0x208356090)\n\t/Users/rsc/g/src/github.com/boltdb/bolt/bucket_test.go:874 +0x166 fp=0x22084b2f60\ntesting.tRunner(0x208356090, 0x2a1d20)\n\t/Users/rsc/g/go/src/pkg/testing/testing.go:422 +0x8b fp=0x22084b2f90\nruntime.goexit()\n\t/Users/rsc/g/go/src/pkg/runtime/proc.c:1445 fp=0x22084b2f98\ncreated by testing.RunTests\n\t/Users/rsc/g/go/src/pkg/testing/testing.go:504 +0x876\u003c/pre\u003e",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-05-20T02:06:59Z",
	"updated_at": "2014-12-08T10:44:31Z"
}
