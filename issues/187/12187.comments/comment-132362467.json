{
	"id": 132362467,
	"body": "This is expected behavior.  From the spec:\r\n\r\nWhen converting between integer types, if the value is a signed integer, it is sign extended to implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the result type's size. For example, if v := uint16(0x10F0), then uint32(int8(v)) == 0xFFFFFFF0. The conversion always yields a valid value; there is no indication of overflow.\r\n",
	"user": {
		"login": "randall77",
		"id": 6889504,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-18T21:39:03Z",
	"updated_at": "2015-08-18T21:39:03Z"
}
