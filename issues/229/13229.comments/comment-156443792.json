{
	"id": 156443792,
	"body": "\u003e is a deep ignorance \u0026 shame for the Go project\r\n\r\nPlease be civil. There's no shame in wanting to understand advantages and disadvantages of a proposal before implementing it. You failed to provide some information.\r\n\r\n\u003e without reading the relevant literature\r\n\r\nyou did not provide \"the relevant literature\" (wikipedia is not literature). I understand that you may expect a reviewer to go on wikipedia and then doing a literature search, but this is really something that you should help with as part of your proposal.\r\n\r\nI have a few comments. First of all:\r\n\r\n\u003e [Java's isPrime for bigInts] does one or more Miller-Rabin tests with random bases. If n, the number being tested, has 100 bits or more, this method also does a non-strong Lucas test \r\n\r\nSo what they do is MR for `bits \u003c 100` and MR + Lucas on `bits \u003e= 100`. But this is not what you're doing in your patch. First of all there's no `100` threshold: you make the caller choose what the method does - i.e. `n \u003e 0` means MR and `n \u003c= 0` means calling `sprp() \u0026\u0026 slprp()` (as a side note, the function names you have choosen really do not help understanding your code). This is confusing. Java's behaviour is nice: the method configures itself. This would not be the case in go (at least not with your proposal).\r\n\r\nWhen should the user call isProbablyPrime with `n == 0` ? And when not? You have to explain this (since we'll have to explain it to our users if we are to implement this).\r\n\r\nMaple's `isPrime` function requires no configuration. Mathematica's `PrimeQ` function requires no configuration. \r\n\r\nAlso Java uses a non-strong Lucas test. Your patch seems to test for strong-Lucas primality. Care to explain why? \r\n\r\nSecond:\r\n\r\n\u003e GNU Multiple Precision Arithmetic Library's mpz_probab_prime_p function uses a Miller-Rabin test, but does not use a Lucas test.\r\n\r\nGMPL is is a widely used bignum library and what they do is MR. I'm not saying we should use pure MR just because GMPL does that, but the fact that they do suggests that a pure MR primality test is not an horrible crime. Go `big` package is much much simpler and smaller than GMPL.\r\n\r\nThird: you have been asked several times to explain what guarantees (if any) the test gives regards to the probability of false-positives or false-negatives. The current PM implementation is pretty clear about that (the usual `4^-k` bound). What about BPSW? \r\nIn your patch you only write\r\n\r\n\u003e returns true only if x is a probable prime\r\n\r\nmaybe it's me, but this mean everything and nothing.\r\n\r\nFourth: performances. Is this faster or slower? You only did a single benchmark with `n = 100` on MR, but almost nobody will call MR with parameter `100`. `n = 20` is a tipical value. \r\n\r\n\r\n\r\n\r\n\r\n\r\n",
	"user": {
		"login": "ALTree",
		"id": 3586803,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-13T14:16:04Z",
	"updated_at": "2015-11-13T15:11:54Z"
}
