{
	"id": 85391208,
	"body": "\u003e The == operator is said to \"apply to operands that are comparable\", but obviously a compiler cannot know whether the operands are comparable in general.\r\n\r\nI fail to see the \"obviously a compiler cannot know whether the operands are comparable in general.\" in this part of the [specs](http://golang.org/ref/spec#Comparison_operators):\r\n\r\n\u003e - Boolean values are comparable. Two boolean values are equal if they are either both true or both false.\r\n\u003e - Integer values are comparable and ordered, in the usual way.\r\n\u003e - Floating point values are comparable and ordered, as defined by the IEEE-754 standard.\r\n\u003e - Complex values are comparable. Two complex values u and v are equal if both real(u) == real(v) and imag(u) == imag(v).\r\n\u003e - String values are comparable and ordered, lexically byte-wise.\r\n\u003e - Pointer values are comparable. Two pointer values are equal if they point to the same variable or if both have value nil. Pointers to distinct zero-size variables may or may not be equal.\r\n\u003e - Channel values are comparable. Two channel values are equal if they were created by the same call to make or if both have value nil.\r\n\u003e - Interface values are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value nil.\r\n\u003e - A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t's dynamic type is identical to X and t's dynamic value is equal to x.\r\n\u003e - Struct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal.\r\n\u003e - Array values are comparable if values of the array element type are comparable. Two array values are equal if their corresponding elements are equal.\r\n\u003e \r\n\u003e A comparison of two interface values with identical dynamic types causes a run-time panic if values of that type are not comparable. This behavior applies not only to direct interface value comparisons but also when comparing arrays of interface values or structs with interface-valued fields.\r\n\u003e \r\n\u003e Slice, map, and function values are not comparable. However, as a special case, a slice, map, or function value may be compared to the predeclared identifier nil. Comparison of pointer, channel, and interface values to nil is also allowed and follows from the general rules above.\r\n\r\nThe above enumeration of what is comparable is constructing a set of comparable things, ie. what's not listed as comparable is not comparable and thus the compiler knows what is and what is not comparable in every case where the types are statically known to it, AFAICT. What cases are not covered by the above? Dynamic types comparison is defined above as well so the only other case where the compiler does not know statically the types is when things and/or the types of things are not defined at all, but such program is not valid. (Declarations and scope: _Every identifier in a program must be declared._)\r\n\u003e ...so that a program such as this one\r\n\u003e var m map[int]int\r\n\u003e _ = m == m\r\n\u003e is unambiguously illegal.\r\n\r\nThis is explicitly an unambiguously specified in the last paragraph quoted from the specs above (_Slice, map, and function values are not comparable._).\r\n\r\n\r\n",
	"user": {
		"login": "cznic",
		"id": 729580,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-03-24T08:12:16Z",
	"updated_at": "2015-03-24T08:12:16Z"
}
