{
	"id": 150006976,
	"body": "Thanks minux for the response.\r\n\r\nRedirect.c basically creates pseudo terminals and forks and execvp's a process based on the command line args it receives. Please see the code below\r\n\r\n#define _XOPEN_SOURCE 600\r\n#include \u003cstdlib.h\u003e\r\n#include \u003cfcntl.h\u003e\r\n#include \u003cerrno.h\u003e\r\n#include \u003cunistd.h\u003e\r\n#include \u003cstdio.h\u003e\r\n#define __USE_BSD\r\n#include \u003ctermios.h\u003e\r\n#include \u003csys/select.h\u003e\r\n#include \u003csys/ioctl.h\u003e\r\n#include \u003cstring.h\u003e\r\n\r\n\r\nint main(int ac, char *av[])\r\n{\r\n\tint fdm, fds;\r\n\tint rc;\r\n\tchar input[1500];\r\n\tchar buffer[10000];\r\n\r\n\t // Check arguments\r\n\t if (ac \u003c= 1)\r\n\t {\r\n\t \tfprintf(stderr, \"Usage: %s program_name [parameters]\\n\", av[0]);\r\n\t \texit(1);\r\n\t }\r\n\t\r\n\t fdm = posix_openpt(O_RDWR);\r\n\t if (fdm \u003c 0)\r\n\t {\r\n\t \tfprintf(stderr, \"Error %d on posix_openpt()\\n\", errno);\r\n\t \treturn 1;\r\n\t }\r\n\t\r\n\t rc = grantpt(fdm);\r\n\t if (rc != 0)\r\n\t {\r\n\t \tfprintf(stderr, \"Error %d on grantpt()\\n\", errno);\r\n\t \treturn 1;\r\n\t }\r\n\t\r\n\t rc = unlockpt(fdm);\r\n\t if (rc != 0)\r\n\t {\r\n\t \tfprintf(stderr, \"Error %d on unlockpt()\\n\", errno);\r\n\t \treturn 1;\r\n\t }\r\n\t\r\n\t // Open the slave side ot the PTY\r\n\t fds = open(ptsname(fdm), O_RDWR);\r\n\t\r\n\t // Create the child process\r\n\t if (fork())\r\n\t {\r\n\t \tfd_set fd_in;\r\n\r\n\t \t// Parent\r\n\t     \t// Close the slave side of the PTY\r\n\t       \tclose(fds);\r\n\t\r\n\t        while (1)\r\n\t        {\r\n\t        \t// Wait for data from standard input and master side of PTY\r\n\t        \tFD_ZERO(\u0026fd_in);\r\n\t                FD_SET(0, \u0026fd_in);\r\n\t                FD_SET(fdm, \u0026fd_in);\r\n\r\n\t                rc = select(fdm + 1, \u0026fd_in, NULL, NULL, NULL);\r\n\t                switch(rc)\r\n\t                {\r\n\t                \tcase -1 : fprintf(stderr, \"Error %d on select()\\n\", errno);\r\n\t                                                             exit(1);\r\n\t                        default :\r\n\t                        {\r\n\t                        \t// If data on standard input\r\n\t                                if (FD_ISSET(0, \u0026fd_in))                        \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\trc = read(0, input, sizeof(input));\r\n\t\t\t\t\t\tif (rc \u003e 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Send data on the master side of PTY\r\n\t\t\t\t\t\t\twrite(fdm, input, rc);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (rc \u003c 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tfprintf(stderr, \r\n\t\t\t\t\t\t\t\t        \"Error %d on read standard input\\n\", errno);\r\n\t\t\t\t\t\t\t\texit(1);\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t                        \r\n\t\t\t\t\t// If data on master side of PTY\r\n\t\t\t\t\tif (FD_ISSET(fdm, \u0026fd_in))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\trc = read(fdm, buffer, sizeof(buffer));\r\n\t\t\t\t\t\tif (rc \u003e 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t//write(1, \"\\n----Data chunk----\\n\", 21);\r\n\t\t\t\t\t\t\t// Send data on standard output\r\n\t\t\t\t\t\t\twrite(1, buffer, rc);\r\n\t\t\t\t\t\t\tmemset(buffer, 0, sizeof(buffer));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (rc \u003c 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tfprintf(stderr, \"Error %d on read master PTY\\n\", errno);\r\n\t\t\t\t\t\t\t\texit(1);\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} // End switch\r\n\r\n\t\t} // End while\r\n\t }\r\n\t else\r\n\t {\r\n\r\n\t\t struct termios slave_orig_term_settings; // Saved terminal settings\r\n\r\n\t\t struct termios new_term_settings; // Current terminal settings\r\n\r\n\t\t // CHILD\r\n\t\t // Close the master side of the PTY\r\n\t\t close(fdm);\r\n\r\n\t\t // Save the defaults parameters of the slave side of the PTY\r\n\t\t rc = tcgetattr(fds, \u0026slave_orig_term_settings);\r\n\r\n\t\t // Set RAW mode on slave side of PTY\r\n\t\t new_term_settings = slave_orig_term_settings;\r\n\t\t cfmakeraw (\u0026new_term_settings);\r\n\t\t tcsetattr (fds, TCSANOW, \u0026new_term_settings);\r\n\t\t //cfsetospeed(\u0026new_term_settings, B9600);\r\n\r\n\t\t // The slave side of the PTY becomes the standard input and outputs of the child process\r\n\t\t close(0); // Close standard input (current terminal)\r\n\t\t close(1); // Close standard output (current terminal)\r\n\t\t close(2); // Close standard error (current terminal)\r\n\r\n\t\t dup(fds); // PTY becomes standard input (0)\r\n\t\t dup(fds); // PTY becomes standard output (1)\r\n\t\t dup(fds); // PTY becomes standard error (2)\r\n\t\r\n\t\t // Now the original file descriptor is useless\r\n\t\t close(fds);\r\n\t \r\n\t\t // Make the current process a new session leader\r\n\t\t setsid();\r\n\t \r\n\t\t // As the child is a session leader, \r\n\t\t // set the controlling terminal to be the slave side of the PTY\r\n\t\t // (Mandatory for programs like the shell to make them manage \r\n\t\t // correctly their outputs)\r\n\t\t ioctl(0, TIOCSCTTY, 1);\r\n\t\t struct winsize ws = {1, 1, 0, 0};\r\n\t\t ioctl(0, TIOCGWINSZ, \u0026ws);\r\n\r\n\t\t // Execution of the program\r\n\t\t {\r\n\t\t\t char **child_av;\r\n\r\n\t\t\t int i;\r\n\r\n\t\t\t // Build the command line\r\n\t\t\t child_av = (char **)malloc(ac * sizeof(char *));\r\n\t\t\t for (i = 1; i \u003c ac; i ++)\r\n\t\t\t {\r\n\t\t\t\t child_av[i - 1] = strdup(av[i]);\r\n\t\t\t }\r\n\t\t\t child_av[i - 1] = NULL;\r\n\t\t\t rc = execvp(child_av[0], child_av);\r\n\t \t}\r\n\t\t // if Error...\r\n\t\t return 1;\r\n\t }\r\n\r\n\t return 0;\r\n\r\n} // main",
	"user": {
		"login": "shravan86",
		"id": 7562354,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-10-21T19:52:26Z",
	"updated_at": "2015-10-21T19:52:26Z"
}
