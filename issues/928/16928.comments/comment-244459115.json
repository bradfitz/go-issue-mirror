{
	"id": 244459115,
	"body": "\r\nOk. That is a legitimate choice.\r\n\r\nTo not be remiss then, I should point out that unless there's an incidental HWSYNC (say in the to or from C paths), the programmer putting in HWSYNCs may not be enough: \r\n\r\nST to data register\r\ngo_function_call_so_can_preempt()\r\nHWSYNC\r\nST to ctrl register\r\n\r\nwill also fail. The HWSYNC the programmer inserted executes on the thread we migrated to and that does not push out the CI store on the thread we migrated from.  In the absence of proper run-time support the programmer inserting even correct barriers may not be enough. \r\n\r\nSo, at this point I'll assume the issues around barriers in the thread migration path are either avoided or handled by whatever barriers are there or in the C path. There are a few other hygiene clean up things that are generally necessary when migrating threads in Power. I will list them below and leave it to you folks to decide if they matter in the context of Go's thread scheduler.  All of these operations are executed on the thread being departed. (I think this list is complete). \r\n\r\n1) Doing a stcx to a scratch location to clear the reservation for larx/stcx instructions. This prevents a STCX on the thread being dispatched on the H/W thread errantly succeeding based on the prior S/W threads larx. \r\n\r\n2) Doing a tabort instruction (P8 and later). This resets the transactional tracking mechansim and prevents a thread being dispatched from errantly committing a partial transaction.\r\n\r\n3) Doing a cp_abort instruction (P9 and later). This resets the copy-paste instruction machinery so that an interrupted copy-paste pair doesn't errantly execute on the new thread.\r\n\r\nIf there are any questions, I'm happy to answer, but otherwise I'll consider this subject closed.\r\n\r\nIf programmers do manage to do things that cause issues with the context switching, those bugs are extremely difficult to isolate and debug. They'll happen quite randomly and usually only in cases of heavy load (yes I've had the misfortune of doing this). \r\n\r\nThis is probably not the entirely correct place to ask, but who (if anyone) is responsible for deciding what the Go programming language memory model is? Are there any written documents? Like the C++ or C or (shudder) Java memory models? To figure out if the atomic routines in Go can use more efficient Power barriers, I need to better understand what the language's memory model requirements are. Any help is appreciated. \r\n\r\nThanks ,\r\n\r\nDerek \r\n\r\n\r\n\r\n",
	"user": {
		"login": "strikerdw",
		"id": 21373762,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-09-02T18:54:01Z",
	"updated_at": "2016-09-02T18:54:01Z"
}
