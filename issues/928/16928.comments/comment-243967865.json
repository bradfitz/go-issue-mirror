{
	"id": 243967865,
	"body": "I think you're overthinking this.  Almost any parallel computation does:\n\nthread 1:\n*x = 5\nunlock y\n\nthread 2:\nlock y\n... = *x\n\nAny implementation has to implement lock and unlock so the read in thread 2\nis guaranteed to see 5.\n\nThat's all we need for the Go scheduler to work properly.  The unlock\ny/lock y pair are inside the scheduler (what gets called when a Goroutine\ntakes an \"interrupt\" and is descheduled, then rescheduled).  There's\nnothing special about goroutine state - it is just data guarded by locks.\n\nThere's a few optimizations in the scheduler where we don't actually do a\nlock/unlock but a cheaper compare-and-swap or other atomic operation.\nYou're also going to have to implement those atomic ops so that their\nmemory semantics are correct.  The implementations are in\nruntime/sync/atomic.\n\n\nOn Wed, Aug 31, 2016 at 7:14 PM, strikerdw \u003cnotifications@github.com\u003e wrote:\n\n\u003e I was afraid of that. I follow much of that, but not all of it.\n\u003e\n\u003e So let me just try to explain from a machine code level what can happen.\n\u003e We'll have to map this up to the Go reality later.\n\u003e\n\u003e Suppose I have this machine code:\n\u003e\n\u003e st r1, X // r1=1\n\u003e ...context switch.... // took a context switch here (in your world that's\n\u003e some function call that allows it)\n\u003e ld r2, X // read X back.\n\u003e\n\u003e In Power, the st r1, X doesn't propagate to memory immediately (and in\n\u003e fact propagates to other processors and memory at varying points in time).\n\u003e So, memory write for the st r1, X can hang out in a queue on the processor\n\u003e you started executing on and not be visible to anyone else for a very long\n\u003e time unless a barrier pushes it around. If the bit doesn't have a barrier\n\u003e (an HWSYNC in this case) in the path, when the S/W thread here wakes up on\n\u003e the other processor, that other processor may not have yet seen the st r1,\n\u003e X and could easily see a stale cached version of X. So the ld r2, X can see\n\u003e \"0\" (assume inital before write of X is 0).\n\u003e\n\u003e That's bad. Coherence (or uniprocessor data dependencies -- depending on\n\u003e who you're talking to) just went out the window. Don't cross the streams\n\u003e kinda bad......\n\u003e\n\u003e The way we cope with this in POWER is for context switches to have an\n\u003e HWSYNC. That also doesn't technically push the store out by itself (I'm\n\u003e fibbing a bit here, but it's close enough for this discussion), but what it\n\u003e does do is order the st X,1 ahead of the stores to whatever job queue\n\u003e control data structure that the H/W thread we're destined for will read in\n\u003e order to realize it can dispatch the S/W thread. So by the time the S/W\n\u003e thread dispatches on the new H/W thread, the HWSYNC has ensured that the ST\n\u003e X,1 is visible to the new H/W thread.\n\u003e\n\u003e Normal programmers never see this. It just happens in the OS and no one is\n\u003e the wiser. Once you start taking on thread migration at a user level,\n\u003e however, you start feeling and having to manage these effects.\n\u003e\n\u003e So when Ian said earlier something to the effect that \"everything else is\n\u003e in memory somewhere\", it's probably a bit more accurate to say that\n\u003e everything is at least on its way to memory and will get there eventually\n\u003e or when a barrier pushes it through.\n\u003e\n\u003e It's really hard for me to imagine how you avoid this. Sadly it'll take me\n\u003e a long time to learn enough Go to read your scheduler code and look at the\n\u003e barriers in that and determine if that synchronization will fix this\n\u003e (unless there's an obvious HWSYNC that's executed on the departing thread\n\u003e :-)).\n\u003e\n\u003e As an aside, I don't work for ARM, and I don't play an ARM engineer on\n\u003e television, but their memory model has a great many technical similarities\n\u003e to ours. As a matter of architecture, I would expect them to have similar\n\u003e issues. As a matter of most of the current implementations I've aware of,\n\u003e they may get away with skipping the barrier..... for now. You should check\n\u003e with them at some point.\n\u003e\n\u003e Let's agree about SYNC before we start into STCX/reservations. The case\n\u003e there is open for more debate.\n\u003e\n\u003e Derek\n\u003e\n\u003e â€”\n\u003e You are receiving this because you were mentioned.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/16928#issuecomment-243956966\u003e, or mute\n\u003e the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AGkgIEedZlkRkrD2SwVR4SQsAqqZgqznks5qljUYgaJpZM4Jw0w5\u003e\n\u003e .\n\u003e\n",
	"user": {
		"login": "randall77",
		"id": 6889504,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-09-01T03:42:11Z",
	"updated_at": "2016-09-01T03:42:11Z"
}
