{
	"id": 181447946,
	"number": 17357,
	"state": "closed",
	"title": "math: math on 387 does not match float64 due to extended exponents",
	"body": "In runtime/asm_386.s's asminit, we try to set the floating point control word so that all 387 floating-point math happens at 64-bit precision, with rounding to 64-bit after every operation. \r\n\r\nThe Intel manual says:\r\n\r\n\u003e The precision-control (PC) field (bits 8 and 9 of the x87 FPU control word) determines the precision\r\n(64, 53, or 24 bits) of floating-point calculations made by the x87 FPU (see Table 8-2). The\r\ndefault precision is double extended precision, which uses the full 64-bit significand available\r\nwith the double extended-precision floating-point format of the x87 FPU data registers. This\r\nsetting is best suited for most applications, because it allows applications to take full advantage\r\nof the maximum precision available with the x87 FPU data registers.\r\n\u003e \r\n\u003e The double precision and single precision settings reduce the size of the significand to 53 bits\r\nand 24 bits, respectively. These settings are provided to support IEEE Standard 754 and to\r\nprovide compatibility with the specifications of certain existing programming languages. Using\r\nthese settings nullifies the advantages of the double extended-precision floating-point format's\r\n64-bit significand length. When reduced precision is specified, the rounding of the significand\r\nvalue clears the unused bits on the right to zeros.\r\n\u003e \r\n\u003e The precision-control bits only affect the results of the following floating-point instructions:\r\nFADD, FADDP, FIADD, FSUB, FSUBP, FISUB, FSUBR, FSUBRP, FISUBR, FMUL,\r\nFMULP, FIMUL, FDIV, FDIVP, FIDIV, FDIVR, FDIVRP, FIDIVR, and FSQRT.\r\n\r\nSuppose x=1, y=100, z=1e308 and we compute x/(y\\*z). \r\n\r\nThe value y\\*z is 1e310, which is too big for a float64, so it should compute as +Inf. Then 1/+Inf is 0. So we expect to get zero from x/(y\\*z), and we do in x86 with SSE and on non-x86 systems. But on x86 using 387 instructions, even with the FPU precision set to 64-bit, we get 1e-310. Clearly the FPU is storing the intermediate y\\*z result in something more than a float64.\r\n\r\nHere is a program, suppose its in a directory called x:\r\n\r\n\t$ cat x.go\r\n\tpackage main\r\n\t\r\n\timport (\r\n\t\t\"fmt\"\r\n\t\t\"runtime\"\r\n\t)\r\n\t\r\n\tfunc fpuControlWord() uint16\r\n\t\r\n\tfunc main() {\r\n\t\truntime.LockOSThread()\r\n\t\r\n\t\tfmt.Printf(\"Control Word: %#x\\n\", fpuControlWord())\r\n\t\tx, y, z := vals()\r\n\t\tfmt.Printf(\"x=%v y=%v z=%v y*z=%v x/(y*z)=%v\\n\", x, y, z, y*z, x/(y*z))\r\n\t\tfmt.Printf(\"g(x, y, z)=%v\\n\", g(x, y, z))\r\n\t\tfmt.Printf(\"Control Word: %#x\\n\", fpuControlWord())\r\n\t}\r\n\t\r\n\t//go:noinline\r\n\tfunc g(x, y, z float64) float64 {\r\n\t\treturn x / (y * z)\r\n\t}\r\n\t\r\n\t//go:noinline\r\n\tfunc vals() (float64, float64, float64) {\r\n\t\treturn 1, 100, 1e308\r\n\t}\r\n\t$ cat fld.s\r\n\t#include \"go_asm.h\"\r\n\t\r\n\tTEXT ·fpuControlWord(SB),$0-0\r\n\t\tFSTCW ret+0(FP)\r\n\t\tRET\r\n\t$ GOARCH=386 GO386=387 go build\r\n\t$ ./x\r\n\tControl Word: 0x27f\r\n\tx=1 y=100 z=1e+308 y*z=+Inf x/(y*z)=1e-310\r\n\tg(x, y, z)=1e-310\r\n\tControl Word: 0x27f\r\n\t$ \r\n\r\nThe control word is set correctly.\r\n\r\nThe function g is here to make it easier to see the computation instructions. Here they are from compile -S:\r\n\r\n\t\"\".g t=1 size=52 args=0x20 locals=0x0\r\n\t\t0x0000 00000 (x.go:20)\tTEXT\t\"\".g(SB), $0-32\r\n\t\t0x0000 00000 (x.go:20)\tMOVL\t(TLS), CX\r\n\t\t0x0007 00007 (x.go:20)\tCMPL\tSP, 8(CX)\r\n\t\t0x000a 00010 (x.go:20)\tJLS\t45\r\n\t\t0x000c 00012 (x.go:20)\tFUNCDATA\t$0, gclocals·895d0569a38a56443b84805daa09d838(SB)\r\n\t\t0x000c 00012 (x.go:20)\tFUNCDATA\t$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)\r\n\t\t0x000c 00012 (x.go:21)\tFMOVD\t\"\".y+12(FP), F0\r\n\t\t0x0010 00016 (x.go:21)\tFMOVD\t\"\".z+20(FP), F0\r\n\t\t0x0014 00020 (x.go:21)\tFMOVD\tF0, F0\r\n\t\t0x0016 00022 (x.go:21)\tFMULDP\tF0, F2\r\n\t\t0x0018 00024 (x.go:21)\tFMOVD\t\"\".x+4(FP), F0\r\n\t\t0x001c 00028 (x.go:21)\tFMOVDP\tF0, F1\r\n\t\t0x001e 00030 (x.go:21)\tFMOVD\tF1, F0\r\n\t\t0x0020 00032 (x.go:21)\tFDIVDP\tF0, F1\r\n\t\t0x0022 00034 (x.go:21)\tFMOVD\tF0, F0\r\n\t\t0x0024 00036 (x.go:21)\tFMOVDP\tF0, \"\".~r3+28(FP)\r\n\t\t0x0028 00040 (x.go:21)\tFMOVDP\tF0, F0\r\n\t\t0x002a 00042 (x.go:21)\tFMOVDP\tF0, F0\r\n\t\t0x002c 00044 (x.go:21)\tRET\r\n\t\t0x002d 00045 (x.go:21)\tNOP\r\n\t\t0x002d 00045 (x.go:20)\tPCDATA\t$0, $-1\r\n\t\t0x002d 00045 (x.go:20)\tCALL\truntime.morestack_noctxt(SB)\r\n\t\t0x0032 00050 (x.go:20)\tJMP\t0\r\n\r\n\r\nAnd here they are from lldb, just to confirm:\r\n\r\n\t(lldb) disas -n main.g\r\n\tx`main.g:\r\n\tx[0x2370] \u003c+0\u003e:  movl   %gs:0x468, %ecx\r\n\tx[0x2377] \u003c+7\u003e:  cmpl   0x8(%ecx), %esp\r\n\tx[0x237a] \u003c+10\u003e: jbe    0x239d                    ; \u003c+45\u003e at x.go:20\r\n\tx[0x237c] \u003c+12\u003e: fldl   0xc(%esp)\r\n\tx[0x2380] \u003c+16\u003e: fldl   0x14(%esp)\r\n\tx[0x2384] \u003c+20\u003e: fld    %st(0)\r\n\tx[0x2386] \u003c+22\u003e: fmulp  %st(2)\r\n\tx[0x2388] \u003c+24\u003e: fldl   0x4(%esp)\r\n\tx[0x238c] \u003c+28\u003e: fstp   %st(1)\r\n\tx[0x238e] \u003c+30\u003e: fld    %st(1)\r\n\tx[0x2390] \u003c+32\u003e: fdivrp %st(1)\r\n\tx[0x2392] \u003c+34\u003e: fld    %st(0)\r\n\tx[0x2394] \u003c+36\u003e: fstpl  0x1c(%esp)\r\n\tx[0x2398] \u003c+40\u003e: fstp   %st(0)\r\n\tx[0x239a] \u003c+42\u003e: fstp   %st(0)\r\n\tx[0x239c] \u003c+44\u003e: retl   \r\n\tx[0x239d] \u003c+45\u003e: calll  0x41f40                   ; runtime.morestack_noctxt at asm_386.s:395\r\n\tx[0x23a2] \u003c+50\u003e: jmp    0x2370                    ; \u003c+0\u003e at x.go:20\r\n\r\nI think this shows:\r\n\r\n - The multiplication result (product) is stored in a 387 register and then used in the division.\r\n - The control word is set such that the product should be rounded to float64.\r\n - If the product were rounded, you'd get +Inf.\r\n - From the division result, it's clear that the product is stored as 1e310.\r\n\r\nAs I finish writing this, I realize the problem: the product mantissa is being rounded to double precision, but the exponent is being left alone: the truncated registers still have extended exponents until they are converted to float64 by transiting memory. Hence the discrepancy.\r\n\r\nLesson: even with the control word change the 387 does not behave exactly like standard float64 hardware.\r\n\r\nI'm bothering to file this at all so that maybe I can find it the next time I get confused by this.",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"comments": 1,
	"closed_at": "2016-10-06T15:28:17Z",
	"created_at": "2016-10-06T15:28:13Z",
	"updated_at": "2016-10-06T17:36:05Z",
	"milestone": {
		"id": 1055141,
		"number": 6,
		"title": "Unplanned"
	},
	"reactions": {
		"total_count": 1,
		"+1": 1
	}
}
