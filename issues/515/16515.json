{
	"id": 167875994,
	"number": 16515,
	"state": "closed",
	"title": "cmd/compile: should not spill Duff-adjusted address",
	"body": "What version of Go are you using (`go version`)?\r\n`go version devel +c80e0d3 Wed Jul 27 05:43:36 2016 +0000 darwin/amd64`\r\n\r\nIn SSA, Duff-adjusted address may be spilled and reused if there are more than one Duff calls within the same function. On AMD64, this address is currently spilled as a scalar, which means if the stack is moved, the spilled value is no longer useful. This is demonstrated with the first call of `f` in the following code:\r\n\r\n```\r\npackage main\r\n\r\nimport \"runtime\"\r\n\r\ntype T [62]int\r\n\r\nvar sink interface{}\r\n\r\n//go:noinline\r\nfunc f(x *T) {\r\n\t// Two DUFFZEROs on the same address with a function call in between.\r\n\t// Duff-adjusted address will be spilled and loaded\r\n\r\n\t*x = T{} // DUFFZERO\r\n\truntime.GC()\r\n\t(*x)[0] = 1\r\n\tg()      // call a function with large frame, trigger a stack move\r\n\t*x = T{} // DUFFZERO again\r\n}\r\n\r\n//go:noinline\r\nfunc g() {\r\n\tvar x [1000]int\r\n\t_ = x\r\n}\r\n\r\n//go:noinline\r\nfunc h() {\r\n\tvar d1 [1152]byte\r\n\tsink = \u0026d1 // force heap allocation\r\n\tvar d2 [1152]byte\r\n\tsink = \u0026d2 // force heap allocation\r\n\tvar d3 [1152]byte\r\n\tsink = \u0026d3 // force heap allocation\r\n\tvar d4 [1152]byte\r\n\tsink = \u0026d4 // force heap allocation\r\n\tvar d5 [1152]byte\r\n\tsink = \u0026d5 // force heap allocation\r\n\tvar d6 [1152]byte\r\n\tsink = \u0026d6 // force heap allocation\r\n\tvar d7 [1152]byte\r\n\tsink = \u0026d7 // force heap allocation\r\n\tvar d8 [1152]byte\r\n\tsink = \u0026d8 // force heap allocation\r\n}\r\n\r\nfunc main() {\r\n\tvar a T // on stack\r\n\ta[0] = 2\r\n\tf(\u0026a)\r\n\tif a[0] != 0 {\r\n\t\tprintln(\"a[0] = \", a[0])\r\n\t\tpanic(\"zeroing failed\")\r\n\t}\r\n\r\n\th() // allocate many objects to clear spans\r\n\r\n\tvar s struct { a T; b [1986]int } // allocate 16K, hopefully it's in a new span and a few bytes before it is garbage\r\n\tsink = \u0026s // force heap allocation\r\n\ts.a[0] = 2\r\n\tf(\u0026s.a)\r\n\tif s.a[0] != 0 {\r\n\t\tprintln(\"s.a[0] =\", s.a[0])\r\n\t\tpanic(\"zeroing failed\")\r\n\t}\r\n\r\n}\r\n```\r\nwhere `f` is compiled to\r\n```\r\n   \t00000 (/tmp/duff.go:10)\tTEXT\t\"\".f(SB), $0\r\n   \t00001 (/tmp/duff.go:10)\tFUNCDATA\t$0, \"\".gcargs·0(SB)\r\n   \t00002 (/tmp/duff.go:10)\tFUNCDATA\t$1, \"\".gclocals·1(SB)\r\n   \t00003 (/tmp/duff.go:10)\tTYPE\t\"\".x(FP)type.*\"\".T, $8\r\n   \t00004 (/tmp/duff.go:10)\tTYPE\t\"\".autotmp_9(SP)type.uint64, $8\r\nv21\t00005 (/tmp/duff.go:14)\tMOVQ\t\"\".x(FP), AX\r\nv6\t00006 (/tmp/duff.go:14)\tTESTB\tAX, (AX)\r\nv24\t00007 (/tmp/duff.go:14)\tLEAQ\t-16(AX), DI\r\nv22\t00008 (/tmp/duff.go:14)\tMOVQ\tDI, \"\".autotmp_9(SP)\r\nv13\t00009 (/tmp/duff.go:14)\tXORPS\tX0, X0\r\nv8\t00010 (/tmp/duff.go:14)\tDUFFZERO\t$155\r\nv9\t00011 (/tmp/duff.go:15)\tCALL\truntime.GC(SB)\r\nv12\t00012 (/tmp/duff.go:15)\tVARLIVE\t\"\".x(FP)\r\nv17\t00013 (/tmp/duff.go:16)\tMOVQ\t\"\".x(FP), AX\r\nv19\t00014 (/tmp/duff.go:16)\tMOVQ\t$1, (AX)\r\nv20\t00015 (/tmp/duff.go:17)\tCALL\t\"\".g(SB)\r\nv23\t00016 (/tmp/duff.go:17)\tVARLIVE\t\"\".x(FP)\r\nv25\t00017 (/tmp/duff.go:18)\tMOVQ\t\"\".autotmp_9(SP), DI\r\nv27\t00018 (/tmp/duff.go:14)\tXORPS\tX0, X0\r\nv26\t00019 (/tmp/duff.go:18)\tDUFFZERO\t$155\r\nv28\t00020 (/tmp/duff.go:19)\tVARLIVE\t\"\".x(FP)\r\nb6\t00021 (/tmp/duff.go:19)\tRET\r\n```\r\nRun with SSA on:\r\n```\r\na[0] =  1\r\npanic: zeroing failed\r\n\r\ngoroutine 1 [running]:\r\npanic(0x568e0, 0xc42000a070)\r\n\t/Users/cherryyz/src/go-tip/src/runtime/panic.go:500 +0x1a1\r\nmain.main()\r\n\t/tmp/duff.go:53 +0x25b\r\nexit status 2\r\n```\r\n(ok running with SSA off)\r\n\r\nNote that it does not work if we change the type of the spill to pointer, since Duff-adjusted address (in this case `x-16`) may not point to valid object, causing stack scanning code to panic (may not always happen):\r\n```\r\nruntime: pointer 0xc420073ff0 to unused region of spanidx=0x39 span.base()=0xc420072000 span.limit=0xc420073f80 span.state=0\r\nruntime: found in object at *(0xc420033cd8+0x0)\r\nobject=0xc420033cd8 k=0x6210019 s.base()=0xc420032000 s.limit=0x0 s.sizeclass=0 s.elemsize=0\r\nfatal error: found bad pointer in Go heap (incorrect use of unsafe or cgo?)\r\n```\r\n\r\nOne solution is to do Duff-adjustment in `genValue`, so reg allocator cannot see the intermediate value.\r\n\r\nFound when doing ARM64 port.\r\n/cc @aclements ",
	"user": {
		"login": "cherrymui",
		"id": 14119929,
		"type": "User",
		"site_admin": false
	},
	"comments": 6,
	"closed_at": "2016-07-29T01:10:42Z",
	"created_at": "2016-07-27T14:58:57Z",
	"updated_at": "2016-07-29T01:10:43Z",
	"milestone": {
		"id": 1414133,
		"number": 31,
		"title": "Go1.7"
	}
}
