{
	"id": 239568568,
	"body": "@kardianos Sqlite may not be the best example (don't get me wrong, I love it) but it's still an example of a database that needs to be supported. \r\n\r\nMySql is another example of a database that's wishy-washy about types (this one I do not love). \r\n\r\nHowever, my point was that the definition of type in SQL across databases isn't something that can be set in stone. Even standardized types can be different between databases, sometimes in subtle ways.\r\n\r\nIf you define a lot of types, even if most dbs support all of them, the drivers for the ones that don't are going to need to deal with handling the ones they don't support. If they have types not in that set, the driver and the user has to deal with it.\r\n\r\nI don't see a lot of value in filling database/sql up with a lot of constants that may or may not apply and don't really mean a lot on their own without knowing what driver you're using.\r\n\r\nIf there's a Type interface that has nice semantics it can cover as many or as few types as a particular database provides and reflect the native semantics more accuratelyâ€”even for databases that don't exist yet. This does push the implementation burden onto the provider of the driver, but it also affords them the ability to define their types to fit their underlying database better.\r\n\r\nUltimately, what matters is how users of the database/sql package are going to be using this information. Admittedly, I've only ever used it for debugging, so strings would suit me just fine.\r\n\r\nConstants are cheaper but do not cover all the cases, so you still need a way to compare arbitrary types anyway since TypeCustom equaling TypeCustom isn't really the whole story. So there should probably be an Equal(t Type) method on Type and an AssignableTo(t Type). This would have to be provided by the driver even for common types.\r\n\r\nMost users will only be dealing with one database at a time so it doesn't really matter if sqlite3.TypeText != pg.TypeText: you're probably going to have to handle that specially anyway if you're writing code that cares about such things.\r\n\r\nI'm not convinced an interface is better than just strings: strings are much simpler and easier for a driver to implement. I'm pretty sure constants in database/sql aren't the way to go here, though. It makes the world seem more uniform than it is.\r\n",
	"user": {
		"login": "jimmyfrasche",
		"id": 375553,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-12T21:51:42Z",
	"updated_at": "2016-08-12T21:51:42Z"
}
