{
	"id": 177541306,
	"body": "The GC will do whatever it can to avoid an OOM and as GC matures it will\nget better and better. As this happens the application's chances of\nrecovery will become less and less likely.\n\nEven today attempts to recover seem doomed to failure. For example, the\nimmediate cause of an OOM may be in a Goroutine that has little to do with\nthe root cause of the OOM. This means that the innocent Goroutine that\nallocated the final object that caused the OOM would have to do global\nreasoning about the cause of the OOM and then have to correct the problem\nlocally. Cascading OOMs across Goroutines only make reasoning about global\nproperties  and maintaining coherency less likely. Algorithms with the\nability to reason globally and react locally are complex and hard. The most\nobvious example of such an algorithm is the GC itself which has to reason\nabout the global property of reachability. Getting into an arms race with\nthe GC about how to manage memory will waste a lot of energy that could be\nspent articulating and understanding real world use cases that can be then\nused to improve the GC for everyone.\n\n\n\nOn Sat, Jan 30, 2016 at 6:53 PM, rgooch \u003cnotifications@github.com\u003e wrote:\n\n\u003e Regarding the appearance of going backwards: it's not really the same as\n\u003e old-school memory management. Go would still be a fully garbage collected\n\u003e language, with all the conveniences that entails. Further, most people\n\u003e could just ignore the whole issue and keep playing the \"I'm feeling lucky\"\n\u003e game. Nothing changes for them.\n\u003e\n\u003e Regarding making the runtime more complex: are you sure about that? What\n\u003e I'm suggesting is pretty narrow in scope. No \"special memory\" regions.\n\u003e\n\u003e Regarding the emergency GC run: I haven't seen the proposal. If the\n\u003e suggestion is coupled with a recoverable panic(), so that the programme has\n\u003e the necessary feedback that memory is running out, this approach may help\n\u003e in many cases.\n\u003e\n\u003e Regarding the panic handler not being able to do much to remedy an OOM\n\u003e situation: that is not correct. There are many classes of problems where\n\u003e there is a fairly high-level point at which an entire transaction can be\n\u003e aborted. For example, if I get a transaction request via an RPC handler\n\u003e then I would put the work which allocates lots of objects into a function\n\u003e and place a panic handler in there. The handler would drop the references\n\u003e to the new objects and call runtime.GC(). If the function returns a status\n\u003e indicating an OOM was caught, a failure status would be send back in the\n\u003e RPC reply, and I could even apply some back-pressure on requests.\n\u003e\n\u003e It's essential to have an effective feedback mechanism when allocating\n\u003e memory. Without that, an application which dynamically scales its resource\n\u003e usage has no robust way to throttle.\n\u003e\n\u003e â€”\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/14162#issuecomment-177339824\u003e.\n\u003e\n",
	"user": {
		"login": "RLH",
		"id": 972447,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-31T16:22:03Z",
	"updated_at": "2016-01-31T16:22:03Z"
}
