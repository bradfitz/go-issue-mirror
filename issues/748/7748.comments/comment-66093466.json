{
	"id": 66093466,
	"body": "\u003ca id=\"c7\"\u003e\u003c/a\u003eComment 7:\n\n\u003cpre\u003eI narrowed down the problem by recompiling the runtime with Debug=3 in mgc0.c and then I\nran\n\n     ./upgrader.test 2\u003e\u00261 | gzip \u003e upgrader.log.gz\n\nWith Debug=3 there's a lot of repetitive output; the gzip is a trick to reduce I/O and\ndisk requirements, often dramatically. This one didn't generate too much output in the\nend. I wanted the full scan trace, bug setting Debug=3 also enabled some sanity checks\nthat found the mismatched type information even earlier and gave a mostly reasonable\nmessage. With some tweaks, the message is:\n\nscanblock 0xc2084d0120 32 type 0xc1a960 common.ToolsGetter pc=0xa2aca0\ngc_iface @0xc2084d0130: 0x7f8c9c97a7d8/0x0 0xc208213200\ngc_aptr @0xc2084d0130: 0xc2081cc140\nscanblock 0xc208090190 80 type 0xc208182e80\nmethodargs(upgrader.Upgrader)(func(params.Entities) (params.ToolsResults, error))\npc=0xc208094b00\ngc_ptr @0xc208090190: 0xc208748090 ti=0x9f1160\ninvalid gc type info for 'upgrader.UpgraderAPI', type info 0x9f1160 [1]=0x9, block info\n0xa90680 [1]=0x1\nfatal error: invalid gc type info\n\nThere's no direct way to map from the gc program to the name of the enclosing type, but\nthe enclosing type structure holds the gc pointer next to the string name pointer, so if\nyou can find the gc pointer in the type structure, the string pointer is next:\n\n(gdb) find \u0026rodata, \u0026erodata, 0x9f1160\n0xa0c5f8\n0xc313b8\n2 patterns found.\n(gdb) x/2xg 0xa0c5f8\n0xa0c5f8:\t0x00000000009f1160\t0x0000000000000000 # not this one\n(gdb) x/2xg 0xc313b8\n0xc313b8:\t0x00000000009f1160\t0x0000000000d9a6e0 # must be this one\n(gdb) x/2xg 0xd9a6e0\n0xd9a6e0:\t0x0000000000d9a6f0\t0x0000000000000011 # there's the string\n(gdb) x/17xc 0xd9a6f0\n0xd9a6f0:\t117 'u'\t112 'p'\t103 'g'\t114 'r'\t97 'a'\t100 'd'\t101 'e'\t114 'r'\n0xd9a6f8:\t46 '.'\t85 'U'\t112 'p'\t103 'g'\t114 'r'\t97 'a'\t100 'd'\t101 'e'\n0xd9a700:\t114 'r'\n(gdb)\n\n(gdb) find \u0026rodata, \u0026erodata, 0xa90680\n0xa0c638\n0xcac138\n2 patterns found.\n(gdb) x/2xg 0xa0c638\n0xa0c638:\t0x0000000000a90680\t0x0000000000000000 # again, not this one\n(gdb) x/2xg 0xcac138\n0xcac138:\t0x0000000000a90680\t0x0000000000d9a720 # yes, this one (it's almost always the\nlast one)\n(gdb) x/2xg 0xd9a720\n0xd9a720:\t0x0000000000d9a730\t0x0000000000000014\n(gdb) x/20xc 0xd9a730\n0xd9a730:\t117 'u'\t112 'p'\t103 'g'\t114 'r'\t97 'a'\t100 'd'\t101 'e'\t114 'r'\n0xd9a738:\t46 '.'\t85 'U'\t112 'p'\t103 'g'\t114 'r'\t97 'a'\t100 'd'\t101 'e'\n0xd9a740:\t114 'r'\t65 'A'\t80 'P'\t73 'I'\n(gdb)\n\nAs it happens, I trust the 'block info', which is registered during malloc, much more\nthese days than I trust the 'type info' obtained directly from the GC program, which has\nhad a variety of bugs in corner cases. The block info says this pointer is an\nupdater.UpdaterAPI, while the type info says it is an updater.Updater Looking at the\ncode, the former is a struct and the latter is an interface. Knowing that\nupdater.Updater is an interface makes the lines above the crash suspect:\nmethodargs(upgrader.Upgrader)(func(params.Entities) is strange because most methods take\na concrete value as the receiver, not an interface. (The exception is something like\nio.Reader.Read, which is a func(io.Reader, []byte) (int, error).) And that's the bug:\nreflect is writing down a function frame with an interface-typed receiver instead of\nusing the type of the thing in the interface.\n\nOn the Ubuntu VM you set up, if I run the test it fails \u003e\u003e50% of the time. With CL\n88100048 applied, it passes 20x in a row. Pretty sure that's the fix.\u003c/pre\u003e\n\n\n\n_Status changed to **Started**._",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-04-16T02:51:52Z",
	"updated_at": "2014-12-08T10:42:59Z"
}
