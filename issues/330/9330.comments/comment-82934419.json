{
	"id": 82934419,
	"body": "There's a non-typical use of terminology on golang.org/cl/7699 so just to make sure we are on the same page: interfaces can be broadly broken down into synchronous and asynchronous.\r\n\r\nA synchronous interface can block and is safe to call repeatedly in a tight loop without wasting CPU.\r\n\r\nAn asynchronous interface will never block, and will waste CPU if called unchecked in a tight loop.\r\n\r\nThe difference does not need to appear in the method signatures. For example, the classic synchronous UNIX open/read/write/close system calls become asynchronous when you pass the O_NONBLOCK to open.\r\n\r\nAsynchronous interfaces are much more work to use well, lead to much harder-to-read code, and leave the system in a state that is hard to debug from a stack trace when an error occurs. The only reason to use them is that threads are expensive in the C family of languages. When handling a large number of concurrent data streams, programs cannot afford a million system threads, with the associated stack space and kernel bookkeeping.\r\n\r\nThat's not a problem in Go. We have goroutines which map N:M onto system threads, and are cheap (and getting cheaper, we are down to 2kb initial stacks).\r\n\r\nWith this one limit removed, converting between the various flavors of interfaces: channels, iterator objects, etc, becomes cheap. Unless the resolution on the device sensors is higher than 10kHz I doubt performance is a concern in the interface design. Right now Apple devices have a maximum sensor resolution of 100Hz.\r\n\r\nCL 7699 presents an argument for a non-blocking interface: to ease the development of a traditional game loop. I'm not convinced by this argument. What's proposed must be an asynchronous interface to be useful in such a game loop. That is, it returns what information is available and will not block. (It has a secondary problem: it forces allocations for reading from a data stream. Alternative designs can avoid that.)\r\n\r\nI would like to see a blocking interface, and have designers of game loops who need an asynchronous view of events build it themselves in a separate goroutine and deliver it to their main loop. A blocking interface for events could take many forms:\r\n\r\n    Get() Motion\r\n\r\nor\r\n\r\n    Read([]Motion) (n int, err error)\r\n\r\nIndependent of interface synchrony, there is a question of sampling. The only way to design an interface that both does not sample and does not have an infinite buffer is to register a callback. This would be equivalent to the Push model described in https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/motion_event_basics/motion_event_basics.html. I'd like to avoid callbacks if possible. As events are processed on an entirely separate ARM Cortex-M4 in modern phones, I don't believe perfect sensor reads under heavy loads is possible. With the potential to drop events, it simplifies the implementation of this and, at least on iOS, let's us make use of the system's underlying ring buffer. Programmers can dedicate a goroutine to reading events and have a high likelihood of reading them all.\r\n\r\nGiven that events may be dropped I would shy away from using a channel. Firstly, channels are usually lossless streams, so it is a confusing interface. Secondly, the interface would be trickier and more expensive, an extra goroutine would be needed inside the sensor package. I believe a Read function can avoid that.",
	"user": {
		"login": "crawshaw",
		"id": 161319,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-03-18T12:00:25Z",
	"updated_at": "2015-03-18T12:00:25Z"
}
