{
	"id": 147447237,
	"number": 15234,
	"state": "open",
	"title": "Floating point error panic",
	"body": "1. What version of Go are you using (`go version`)?\r\n1.5.3\r\n\r\n2. What operating system and processor architecture are you using (`go env`)?\r\nplan9/386\r\n\r\n3. What did you do?\r\nI am building go 1.5.3 on plan9 (latest 9front) 386 bootstrapping it from a build of go 1.4 on the system. I set the GOROOT_BOOTSTRAP variable and run the make.rc script.\r\n\r\n4. What did you expect to see?\r\nI expected that the bootstrapping process would allow me to build go 1.5.3.\r\n\r\n5. What did you see instead?\r\nPart way through building go 1.5 there are floating point error panics thrown that stop the build. I see a virtually identical stack as mentioned in this email thread:\r\nhttps://www.mail-archive.com/9fans@9fans.net/msg34991.html\r\n\r\n\r\n\r\nHere are the results of my initial investigation so far:\r\n\r\nI temporarily worked around that particular problem by changing the code and ran into another floating point error later on in the build process.\r\n\r\nI managed to create and build a simple Go program that passes with the 1.4 compiler and fails with the 1.5 compiler (built enough to test it). The failure panic is very similar to what I saw in the link above (\"floating point error\").\r\nhttp://play.golang.org/p/rtYF4uasa2\r\n\r\nI modified the 1.5 compiler slightly to try to get a better idea of the note sent to the process that resulted in the internal _SIGFLOAT. Here is the full panic with the note text sent from the operating system:\r\n\r\n\r\n\r\nsys: fp: precision loss fppc=0x1098 status=0x20 pc=0x00001098\r\nPC=0x1098\r\n\r\ngroutine 1 [running]:\r\nmain.main()\r\n    /usr/glenda/tmp/test.go:7 +0x38 fp=0x102e9f88 sp=0x102e9f44\r\nruntime.main()\r\n    /usr/glenda/go1.5/go/src/runtime/proc.go:111 +0x272 fp=0x102e9fb0 sp=0x102e9f88\r\nruntime.goexit()\r\n    /usr/glenda/go1.5/go/src/runtime/asm_386.s:1662 +0x1 fp=0x102e9fb4 sp=0x102e9fb0\r\n\r\nax 0x102540e0\r\nbx 0x0\r\ncx 0x102540e0\r\ndx 0x20\r\ndi 0x10252be4\r\nsi 0x10294068\r\nbp 0x137ac0\r\nsp 0x102e9f44\r\npc 0x1098\r\nflags 0x10206\r\ncs 0x23\r\nfs 0x0\r\ngs 0x0\r\n\r\n\r\n\r\nI disassembled the main function in both the 1.4 version and the 1.5 version:\r\n1.4:\r\nruntime.text+0xf 0x0000102f\tJHI\truntime.text+0x18(SB)\r\nruntime.text+0x11 0x00001031\tCALL\truntime.morestack_noctxt(SB)\r\nruntime.text+0x16 0x00001036\tJMP\truntime.text(SB)\r\nruntime.text+0x18 0x00001038\tSUBL\t$0x58,SP\r\nruntime.text+0x1b 0x0000103b\tFMOVD\t$f64.4024000000000000(SB),F0\r\nruntime.text+0x21 0x00001041\tFMOVDP\tF0,0x0(SP)\r\nruntime.text+0x24 0x00001044\tCALL\tmath.Log2(SB)\r\nruntime.text+0x29 0x00001049\tFMOVD\t0x8(SP),F0\r\nruntime.text+0x2d 0x0000104d\tFMOVDP\tF0,0x34(SP)\r\nruntime.text+0x31 0x00001051\tFMOVD\t0x34(SP),F0\r\n**runtime.text+0x35 0x00001055\tFDIVRD\t$f64.4080000000000000(SB),F0**\r\nruntime.text+0x3b 0x0000105b\tFMOVDP\tF0,0x2c(SP)\r\nruntime.text+0x3f 0x0000105f\tFMOVD\t0x2c(SP),F0\r\nruntime.text+0x43 0x00001063\tFSTCW\t0x22(SP)\r\nruntime.text+0x47 0x00001067\tMOVW\t$0xf7f,0x20(SP)\r\nruntime.text+0x4e 0x0000106e\tFLDCW\t0x20(SP)\r\nruntime.text+0x52 0x00001072\tFMOVLP\tF0,0x24(SP)\r\nruntime.text+0x56 0x00001076\tFLDCW\t0x22(SP)\r\nruntime.text+0x5a 0x0000107a\tMOVL\t0x24(SP),BX\r\nruntime.text+0x5e 0x0000107e\tMOVL\tBX,0x28(SP)\r\nruntime.text+0x62 0x00001082\tLEAL\t0x44(SP),BX\r\nruntime.text+0x66 0x00001086\tMOVL\t$0x0,0x0(BX)\r\nruntime.text+0x6c 0x0000108c\tMOVL\t$0x0,0x4(BX)\r\nruntime.text+0x73 0x00001093\tLEAL\t0x44(SP),BX\r\nruntime.text+0x77 0x00001097\tCMPL\tBX,$0x0\r\nruntime.text+0x7a 0x0000109a\tJEQ\truntime.text+0x102(SB)\r\nruntime.text+0x80 0x000010a0\tMOVL\t$0x1,0x24(SP)\r\n\r\n\r\n1.5:\r\nmain.main 0x00001060\tMOVL\t_privates(SB),CX\r\nmain.main+0x6 0x00001066\tMOVL\t0x0(CX),CX\r\nmain.main+0xc 0x0000106c\tCMPL\t0x8(CX),SP\r\nmain.main+0xf 0x0000106f\tJLS\tmain.main+0xf6(SB)\r\nmain.main+0x15 0x00001075\tSUBL\t$0x40,SP\r\nmain.main+0x18 0x00001078\tMOVSD\t$f64.4024000000000000(SB),X0\r\nmain.main+0x20 0x00001080\tMOVSD\tX0,0x0(SP)\r\nmain.main+0x25 0x00001085\tCALL\tmath.Log2(SB)\r\nmain.main+0x2a 0x0000108a\tMOVSD\t0x8(SP),X0\r\nmain.main+0x30 0x00001090\tMOVSD\t$f64.4080000000000000(SB),X1\r\n**main.main+0x38 0x00001098\tDIVSD\tX0,X1**\r\nmain.main+0x3c 0x0000109c\tCVTTSD2SL\tX1,BX\r\nmain.main+0x40 0x000010a0\tMOVL\tBX,main.autotmp_0001+0x20(SP)\r\nmain.main+0x44 0x000010a4\tXORL\tBX,BX\r\nmain.main+0x46 0x000010a6\tMOVL\tBX,main.autotmp_0005+0x2c(SP)\r\nmain.main+0x4a 0x000010aa\tMOVL\tBX,0x30(SP)\r\nmain.main+0x4e 0x000010ae\tLEAL\tmain.autotmp_0005+0x2c(SP),BX\r\nmain.main+0x52 0x000010b2\tCMPL\tBX,$0x0\r\nmain.main+0x55 0x000010b5\tJEQ\tmain.main+0xef(SB)\r\nmain.main+0x5b 0x000010bb\tMOVL\t$0x1,0x38(SP)\r\nmain.main+0x63 0x000010c3\tMOVL\t$0x1,0x3c(SP)\r\nmain.main+0x6b 0x000010cb\tMOVL\tBX,main.autotmp_0002+0x34(SP)\r\nmain.main+0x6f 0x000010cf\tMOVL\t$0xa3d40,0x0(SP)\r\nmain.main+0x76 0x000010d6\tLEAL\tmain.autotmp_0001+0x20(SP),BX\r\nmain.main+0x7a 0x000010da\tMOVL\tBX,0x4(SP)\r\nmain.main+0x7e 0x000010de\tMOVL\t$0x0,0x8(SP)\r\nmain.main+0x86 0x000010e6\tCALL\truntime.convT2E(SB)\r\nmain.main+0x8b 0x000010eb\tMOVL\t0xc(SP),CX\r\n\r\n\r\nWhen I debug the 1.5 binary the floating point loss of precision occurs at the DIVSD X0,X1 instruction at main.main+0x38. It seems that the 1.4 version uses a different instruction to do the division (FDIVRD). I don't know enough about x86 instruction set to know why DIVSD could cause a loss of precision where FDIVRD would not.",
	"user": {
		"login": "sirnewton01",
		"id": 3670311,
		"type": "User",
		"site_admin": false
	},
	"comments": 14,
	"created_at": "2016-04-11T14:27:12Z",
	"updated_at": "2016-04-12T22:33:17Z",
	"milestone": {
		"id": 1055141,
		"number": 6,
		"title": "Unplanned"
	}
}
