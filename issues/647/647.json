{
	"id": 51276754,
	"number": 647,
	"state": "closed",
	"title": "Excessive memory usage in Go : A concrete example  ",
	"body": "by **serge.hulne**:\n\n\u003cpre\u003eHere is the exact same program writtem in Python, in D and in Go.\n\nIt is used to sort a relatively large text file which is made by\nconcatenating Shakespeare plays (downloaded from Gutenberg.com)\n\nThe program extracts words form said text using a trivial tokenizer (the\nsame algorithm in all three cases), stores them is a hash map to keep only\none exemplar of each word and increments a counter, every time a word which\nis already in said map is detected again, hence counting the frequency of\noccurence of words in the text. The pair (frequency, word) are stored in an\narray which is sorted according to frequency in order to display a list of\nthe word appearing the most frequently in the text.\n\nThe problem\n-----------\n\nThe Go version uses about 90 megabites of RAM whereas the two other\nversions use about 8 megabytes of RAM to do the exact same job.\n\nSo, basically Go seems to use up 10 times more RAM than Python (or D) for\nthat kind od task.\n\nHere are the sources:\n---------------------\n\n\n1) Python:\n----------\n\n\n#!/usr/bin/env python\n\n\n\ndef read_lines(fname):\n    \n    words_count = {}\n    f = file (fname, \u0026quot;r\u0026quot;)\n    l_cnt = 0\n    w_cnt = 0\n    words_array  = []\n    char_cpt = 0\n    inword = False\n\n    for l in f:\n        l_cnt+=1\n        for c in l:\n            char_cpt += 1\n            if not c.isspace():\n                if inword == False:\n                    buf = \u0026quot;\u0026quot;\n                    buf += c\n                    inword = True\n                    w_cnt +=1\n                #end if\n                else:\n                    buf += c\n                #end else\n            else: \n                if inword ==True:\n                    #print \u0026quot;buf = %s\u0026quot; % buf\n                    if not buf in words_count:\n                        words_count[buf]=0\n                    else:\n                        words_count[buf]+=1\n                    inword = False\n                    buf    = \u0026quot;\u0026quot;\n                #end if\n            #end else\n        #end for c\n    #end for l\n    \n    for key in words_count:\n        words_array.append((words_count[key], key))\n    \n    words_array.sort(reverse=True)\n    for item in words_array:\n        print \u0026quot;(%s,%s)\u0026quot; % (item[0], item[1])\n    \n    print \u0026quot;lines= %d\u0026quot; % l_cnt\n    print \u0026quot;words = %d\u0026quot; % w_cnt\n\nif __name__ == \u0026quot;__main__\u0026quot;:\n    read_lines(\u0026quot;../../shakespeare.txt\u0026quot;)\n\n\n\nGo language:  \n-----------\n\npackage main\n\nimport (\n\t\u0026quot;fmt\u0026quot;\n\t\u0026quot;os\u0026quot;\n\t\u0026quot;bufio\u0026quot;\n\t\u0026quot;unicode\u0026quot;\n\t\u0026quot;sort\u0026quot;\n)\n\n\n\n\n//---\ntype int_word_array []int_word\n\n// Methods required by sort.Interface for to sort structures of the type\nint_word.\nfunc (s int_word_array) Len() int           { return len(s) }\nfunc (s int_word_array) Less(i, j int) bool { return s[i].cpt \u0026gt; s[j].cpt }\n//(reverse sort)\nfunc (s int_word_array) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\ntype int_word struct {\n\tcpt  int\n\tword string\n}\n//---\n\n\n\n\n\nfunc main() int {\n\n\twords_map := map[string]int{}\n\n\tl_cnt := 0\n\tw_cnt := 0\n\tcpt_chars := 0\n\tinword := false\n\tbuf := \u0026quot;\u0026quot;\n\t\n\tf, err := os.Open(\u0026quot;../shakespeare.txt\u0026quot;, os.O_RDONLY, 0666)\n\t//f, err := os.Open(\u0026quot;hamlet.txt\u0026quot;, os.O_RDONLY, 0666)\n\n\tif err != nil {\n\t\tfmt.Printf(\u0026quot;\\nError =\u0026gt; %s\\n\\n\u0026quot;, err)\n\t\tos.Exit(1)\n\t}\n\n\treader := bufio.NewReader(f) //Buffered reader\n\t\n\t\n\tfor {\n\t\tc, _ ,err := reader.ReadRune() \n\n\t\tcpt_chars++\n\t\tif err != os.EOF \u0026amp;\u0026amp; err == nil {\n\t\t\tif c == '\\n' {\n\t\t\t\tl_cnt++\n\t\t\t}\n\n\t\t\tif unicode.IsSpace(c) == false { \n\t\t\t\tif inword == false {\n\t\t\t\t\tbuf =  \u0026quot;\u0026quot;\n\t\t\t\t\tbuf += string(c)\n\t\t\t\t\tinword = true\n\t\t\t\t\tw_cnt++\n\t\t\t\t} else {\n\t\t\t\t\tbuf += string(c)\n\t\t\t\t}\n\t\t\t} else if inword == true {\n\t\t\t\t\n\t\t\tif _, ok := words_map[buf]; ok {\n\t\t\t\twords_map[buf]++\n\t\t\t} else {\n\t\t\t\t\twords_map[buf] = 1\n\t\t\t}\n\t\t\t\n\t\t\t//fmt.Printf(\u0026quot;buf = (%s)\\n\u0026quot;, buf)\n\t\t\tinword = false\n\t\t\tbuf =  \u0026quot;\u0026quot;\n\t\t\t}\n\n\t\t\t} else { //EOF detected\n\t\t\t\tif err == os.EOF  {\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t} //end if (err=nil)\n\t} // end for (main loop)\n\n\t\t\n\t\n\t//---\n\tvar words_map_size int = len(words_map)\n\tvar int_words int_word_array\n\tint_words = make(int_word_array, words_map_size)\n\tvar iw int_word\n\n\tint_words_index := 0\n\tfor word, cpt := range words_map {Ã¥\n\t\t//fmt.Printf(\u0026quot;%d =\\t\\t%s\\n\u0026quot;, cpt, word)\n\t\tiw.cpt = cpt\n\t\tiw.word = word\n\t\tint_words[int_words_index] = iw\n\t\tint_words_index++\n\t}\n\t\n\tsort.Sort(int_words)\n\tfor _, item := range int_words[0:100] {\n\t\tfmt.Printf(\u0026quot;(%d,%s)\\n\u0026quot;, item.cpt, item.word)\n\t}\n\t//---\n\t\n\t\t\n\tfmt.Printf(\u0026quot;\\nlines = %d, words = %d, chars = %d\\n\u0026quot;, l_cnt, w_cnt, cpt_chars)\n\treturn 0\n}\n\n--------------\n\nSerge Hulne\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		}
	],
	"assignee": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"comments": 9,
	"closed_at": "2014-12-08T10:05:23Z",
	"created_at": "2010-03-05T11:18:55Z",
	"updated_at": "2016-06-24T19:14:18Z"
}
