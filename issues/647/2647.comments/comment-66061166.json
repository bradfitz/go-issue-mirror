{
	"id": 66061166,
	"body": "\u003ca id=\"c1\"\u003e\u003c/a\u003eComment 1:\n\n\u003cpre\u003e\u0026gt; fork fails with errors.\n\nWhich errors?  I can run your program (modifying it, since it doesn't compile), but it's\nbest to include any referenced errors in bug reports.\n\nRegarding your os/exec fatalism: you can set the Stdin/Stdout/Stderr in os/exec to\nos.Stdin, os.Stdout, and os.Stderr, to use their fds. It doesn't always use pipes.\n\nstracing this on Linux, I see:\n\ngetpid()                                = 6333\npipe([3, 4])                            = 0\nfcntl(3, F_SETFD, FD_CLOEXEC)           = 0\nfcntl(4, F_SETFD, FD_CLOEXEC)           = 0\nfork(Process 6334 attached (waiting for parent)\nProcess 6334 resumed (parent 6333 ready)\n)                                  = 6334\n[pid  6334] fcntl(0, F_SETFD, 0 \u0026lt;unfinished ...\u0026gt;\n[pid  6333] close(4 \u0026lt;unfinished ...\u0026gt;\n[pid  6334] \u0026lt;... fcntl resumed\u0026gt; )       = 0\n[pid  6333] \u0026lt;... close resumed\u0026gt; )       = 0\n[pid  6334] fcntl(1, F_SETFD, 0 \u0026lt;unfinished ...\u0026gt;\n[pid  6333] read(3,  \u0026lt;unfinished ...\u0026gt;\n[pid  6334] \u0026lt;... fcntl resumed\u0026gt; )       = 0\n[pid  6334] fcntl(2, F_SETFD, 0)        = 0\n[pid  6334] ioctl(0, TIOCSCTTY)         = -1 EPERM (Operation not permitted)\n[pid  6334] write(4, \"\\1\\0\\0\\0\\0\\0\\0\\0\", 8) = 8\n[pid  6333] \u0026lt;... read resumed\u0026gt; \"\\1\\0\\0\\0\\0\\0\\0\\0\", 8) = 8\n[pid  6334] _exit(253)                  = ?\nProcess 6334 detached\nclose(3)                                = 0\n\nSo the TIOCSTTY ioctl is failing.  Why?  Perhaps because you're not a session leader\nalready?\n\nI can never remember this stuff, but \u003ca href=\"http://www.win.tue.nl/~aeb/linux/lk/lk-10.html\"\u003ehttp://www.win.tue.nl/~aeb/linux/lk/lk-10.html\u003c/a\u003e says:\n\nGetting a controlling tty\n\nHow does one get a controlling terminal? Nobody knows, this is a great mystery.\n\nThe System V approach is that the first tty opened by the process becomes its\ncontrolling tty.\n\nThe BSD approach is that one has to explicitly call\n\nioctl(fd, TIOCSCTTY, ...);\nto get a controlling tty.\nLinux tries to be compatible with both, as always, and this results in a very obscure\ncomplex of conditions. Roughly:\n\nThe TIOCSCTTY ioctl will give us a controlling tty, provided that (i) the current\nprocess is a session leader, and (ii) it does not yet have a controlling tty, and (iii)\nmaybe the tty should not already control some other session; if it does it is an error\nif we aren't root, or we steal the tty if we are all-powerful.\n\nOpening some terminal will give us a controlling tty, provided that (i) the current\nprocess is a session leader, and (ii) it does not yet have a controlling tty, and (iii)\nthe tty does not already control some other session, and (iv) the open did not have the\nO_NOCTTY flag, and (v) the tty is not the foreground VT, and (vi) the tty is not the\nconsole, and (vii) maybe the tty should not be master or slave pty.\n\n----------\n\nSo maybe you're not a session leader already?\u003c/pre\u003e",
	"user": {
		"login": "bradfitz",
		"id": 2621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2012-01-11T17:24:39Z",
	"updated_at": "2014-12-22T06:05:11Z"
}
