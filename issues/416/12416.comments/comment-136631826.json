{
	"id": 136631826,
	"body": "\u003e \u003e   Would those per-entry-point \"detailed\" features be available to third-party library/package writers (...)\r\n\u003e\r\n\u003e I don't know. The syscall and x/sys packages can provide functions to handle structs with pointers, doing things like copying the pointers into non-garbage-collected memory. I think it would be fine to make something like that generally available. I think we have to be careful about what we make generally available, to avoid overly constraining future GC work.\r\n\r\nThanks. I understand this is non-binding reply as of now, but it's somewhat reassuring to hear you want to consider this. I hope you'll manage to do that.\r\n\r\n\u003e There is not any intent to change the garbage collector behaviour. This proposal is about the very specific problem of how to safely pass a Go pointer to C code. You're right: I was wrong about the types. A value of type uintptr is not a pointer. You are already in potential trouble if you convert a Go pointer to uintptr. This proposal won't make that worse or better. The type of a Go pointer doesn't matter, but it does have to be some sort of pointer type.\r\n\r\nI'm aware I'm stepping somewhat risky border full of mines, but talking to WinAPI is already C-style dangerous out of itself, so that's not so much different. As long as it's possible at all. And given the benefits of Go, and its difference to C, I'm generally ok with the rules changing with every Go release version. As long as I can know the rough rules. For now, it was generally possible to kinda learn them... eventually... after asking on golang-nuts/-dev. What I'm afraid of, is that it may become \"officially neglected\" at some point, to the extent of it becoming impossible to use any WinAPI calls in third-party libs without cgo. That's a very useful feature, and losing it would become... unfortunate, and somewhat costly. Including the fact, that currently it's easy to cross-compile from Linux to Windows, and having to use cgo there would be even more cumbersome.\r\n\r\nIn some other aspects, over the night I remembered of one particular WinAPI function, [`RegisterClassEx()`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms633587%28v=vs.85%29.aspx). This one is possibly especially troublesome, in that it takes a pointer to a struct which must contain a pointer to a C-function. And it then keeps hold of it (the func at least) *permanently*. On the other hand, it's the *only way any GUI apps* can be created in WinAPI. The first meaningful thing one must do after starting a GUI app is to register a callback via this function. For now, it seemed to be doable (with syscall.NewCallback, and keeping the pointer \"heap-pinned\" by some global var). Losing that would completely disable possibility of creating GUI apps on Windows without cgo. Again, that would be a serious pity.",
	"user": {
		"login": "akavel",
		"id": 273837,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-09-01T08:16:49Z",
	"updated_at": "2015-09-01T08:17:07Z"
}
