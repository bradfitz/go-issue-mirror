{
	"id": 136475773,
	"body": "@akavel \r\n\r\n\u003e Is this understood to cover the syscall package use cases too? I.e. when somebody does import \"syscall\", but does not import \"C\". Please state this explicitly, whether it is covered or not, and to what extent. I'm aware that the underlying mechanisms are the same to some extent (or at least were a few versions ago), but I'm especially not sure if that's assumed \"official\" or \"accidental\". I believe it isn't really stated anywhere in the official docs (or is it?). This proposal could be a very good place to clarify this, and I'd be really grateful for that.\r\n\r\nClearly the syscall package has to consider the same set of issues, but these rules are intended to apply to cgo.  We control all the entry points to the syscall package, so if appropriate we can do something different.  I think that for Windows we essentially need to define for each entry point what is permitted.\r\n\r\nFor example, currently on Unix the function syscall.ForkExec takes a pointer to a syscall.ProcAttr and that structure is permitted to contain Go pointers.  This is fine, and it demonstrates that the syscall functions are not required to precisely follow the rules for cgo.\r\n\r\n\u003e (Related to 1.) Specifically, the WinAPI syscalls often take uintptr as an argument. In +/-Go 1.4 it was (AFAIU) semi-officially named as a \"non-pointer\". Am I right to undertand this then falls outside the current wording of the discussed proposal? And thus, back into uncharted territory...? :( Or is uintptr now blessed into pointers family?\r\n\r\nWhat matters for this proposal is whether the value is a pointer into Go memory.  The actual type of the value does not matter.\r\n\r\n\u003e (Related to 2.) If uintptr is still not-a-pointer, is there a chance that any rules for \"pinning\" a pointer could become part of this proposal? Such that they'd enable taking a uintptr of a pointer in some \"officially safe\" way (hopefully \"in Go 1.x where x\u003e=4\") and passing it into syscall/C world for some (finite?) time?\r\n\r\nOne goal of this proposal is to avoid any documented rules for pinning pointers.  Sure, this may be implemented by pinning internally, but I don't think we want to make pinning pointers part of the Go runtime API.\r\n\r\n\u003e (Related to 2., 3.) Also, how about structs containing uintptr?\r\n\r\nWhat matters is the values stored in this uintptr fields.\r\n\r\nUpdate: some of my above comments were incorrect.  A Go value with type uintptr is not going to be treated as a Go pointer.  While the type of the pointer doesn't matter, it does have to be a pointer.",
	"user": {
		"login": "ianlancetaylor",
		"id": 3194333,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-08-31T19:29:30Z",
	"updated_at": "2015-09-01T05:16:16Z"
}
