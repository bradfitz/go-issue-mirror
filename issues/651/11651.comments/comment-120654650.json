{
	"id": 120654650,
	"body": "Again, thanks for taking the time to help.\r\n\r\nNo, I'm not validating client certificates. Apparently I meant `RootCAs` the whole time. The naming conventions are different in go than what I'm used to in nodeland and such.\r\n\r\n\u003csmall\u003eMy demo worked, so I thought I was using the right one... but since in the case of my demo there is no intermediate ca in the chain, only my fabricated root ca, it would have worked no matter what because I had the client already accept my fabricated root ca.\u003c/small\u003e\r\n\r\n\u003csmall\u003eI realize now that I probably should have been using `RootCAs`. Since a browser doesn't need to receive the root ca from a server - it already has it's own list and only the intermediate cas need to be sent, I misunderstood `RootCAs` to mean \"certificates the server uses to validate client certificates\" and `ClientCAs` to mean \"the chains that the server serves to clients to validate against their Root CAs\", but now I see that **it's the opposite**.\u003c/small\u003e\r\n\r\nConcern 1: Can't Create http.Server.Conn from net.Conn\r\n=========\r\n\r\nIn order to do things like count bytes of network traffic to a particular site, or examine raw headers (it seems http.Server.Conn.Request may strip certain headers - for example 'Transfer-Encoding' is stripped from client requests - which is odd, but not against the spec) or anything that relies on having access to the raw underlying socket, I need to be able to create http.Server.Conn from net.Conn so that I can spy on net.Conn or tls.Conn directly.\r\n\r\nConcern 2: Can't replace or delete from RootCAs\r\n=====================\r\n\r\nRealistically, this probably **isn't worth addressing** if my current understanding is correct.\r\n\r\nIn short:\r\n\r\nAlso I'm always adding to `RootCAs` and I never have a way of removing from it or replacing it, it could grow to an arbitrary size, full of old expired certificates. However, since there probably aren't enough root and intermediate CAs in the whole world to take up more than a few megabytes, this isn't a problem as long as my assumptions that duplicate certs are ignored and the browser is sent only the subset of necessary certs in the chain.\r\n \r\nBack the the earlier example as context:\r\n\r\n1. Imagine a shared hosting situation where hosts are added and deleted on the fly\r\n2. A user will automatically be provisioned certs from letsencrypt.org if no custom certs are provided (such as EV certs)\r\n\r\nAnd what happens when a browser connects\r\n\r\n1. The browser provides SNI\r\n2. The server selects some certificates via `tls.Config.GetCertificate`\r\n3. The server sends those certificates along with the chain from some (or all?) of the `x509.CertPool` to the browser\r\n4. The browser doesn't recognize the signing authority of the certificate, it crawls the chain\r\n5. If it finds an authority it knows, all green locks, EV bars, etc\r\n6. If it doesn't find that authority, it's a big scary red page\r\n\r\nAnd what happens in the code\r\n\r\n1. `tls.Conn.ClientHello.ServerName` is sent by the browser, say `foo.example.com`\r\n2. `tls.Config.GetCertificate` is called to retrieve the correct certificate\r\n3. `tls.Config.GetCertificate` does **not** provide `x509.CertPool`\r\n4. The chain for `foo.example.com` may be different from `bar.example.net`\r\n5. To ensure the correct chain is in the pool, I must call `x509.CertPool.AppendCertsFromPEM(buf)`\r\n6. I assume that internally `x509.CertPool` is a map\r\n7. I assume that calling `tls.Config.RootCAs.AppendCertsFromPEM(buf)` is an exception to the documentation's declaration that \"After `tls.Config` has been passed to a TLS function it must not be modified\"\r\n8. I assume that if I add a duplicate certificate chain to the pool, all duplicate certs in the chain are ignored\r\n9. I assume that `tls.Conn` pulls the chain from `tls.Config.RootCAs` (instance of `x509.CertPool`) to respond to the browser's request, using only the necessary members of the chain\r\n10. The browser receives the certificate issued by `tls.Config.GetCertificate` and the chain to validate against as only the relevant certs from `tls.Config.RootCAs`.",
	"user": {
		"login": "coolaj86",
		"id": 122831,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-07-11T19:41:26Z",
	"updated_at": "2015-07-11T19:44:30Z"
}
