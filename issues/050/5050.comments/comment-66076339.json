{
	"id": 66076339,
	"body": "\u003ca id=\"c1\"\u003e\u003c/a\u003eComment 1:\n\n\u003cpre\u003eI think that there's a broader issue than just erroring out early if the image header\n(width x height) is larger than the actual pixel data. Trying to decode a very large\n*legitimate* image can also lead to a long pause and unresponsive computer, even if the\ncompressed form of that image is very small.\n\nThe current image.Decode and {gif,jpeg,png}.Decode functions attempt to return a newly\nallocated image. I think that to avoid e.g. denial of service attacks via legitimate but\nvery large images, it needs to be possible to 1. decode just the WxH (and other\nmetadata), 2. decide whether to proceed based on that metadata and then 3. decode the\npixels into a buffer.\n\nNote that you can more or less do this already, if you e.g. buffer the first 16K of a\nreader, call image.DecodeConfig, and if you're happy with that, rewind the buffer and\ncall image.Decode.\n\nHowever, it would be nice if you didn't have to manually rewind a buffer. If it wasn't\nfor API backwards compatibility constraints, one could imagine image.DecodeConfig\nreturning metadata as well as some capability of continuing the decoding process from\nthe io.Reader.\n\nIt would also be nice if you could continue to decode into an existing image buffer\ninstead of allocating a new one. If decoding many still frames of a movie instead of\njust a single image, then the ability to decode into an existing buffer probably goes\nfrom nice-to-have to must-have. Without actually trying to implement an MPEG or WEBM\ndecoder, though, trying to design an API for this is possibly premature.\n\nIt would also be nice if the Decode, DecodeConfig, or some similar but new API allowed\nfor e.g. accessing the EXIF metadata for a JPEG image.\n\nIt would also be nice if there was some way to decode and process an image row by row so\nthat the entire image did not have to be in memory all at once; think of this as\nanalagous to io.Reader compared to []byte.\n\nAll these points suggest to me that there is a larger problem to be solved, and that any\nsolution would require some deep thinking about API. Given that we are currently in an\nAPI freeze for the upcoming Go 1.1 release, I don't think that this issue will be solved\nany time soon. In the meantime, I think that the rewindable buffer technique described\nabove will let your programs avoid trying to allocate a 1e8 pixel by 1e8 pixel GIF.\u003c/pre\u003e\n\n_Labels changed: added **priority-later**, removed **priority-triage**._\n\n\n_Status changed to **Thinking**._",
	"user": {
		"login": "nigeltao",
		"id": 8565232,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-03-15T11:16:39Z",
	"updated_at": "2014-12-08T10:27:00Z"
}
