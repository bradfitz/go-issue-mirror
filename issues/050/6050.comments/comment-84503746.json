{
	"id": 84503746,
	"body": "I'd like to suggest an alternate, higher-level API for streaming JSON decoding.\r\n\r\nTokenizers and the existing \"whole value\" API are two opposite extremes on a spectrum. Many applications that require streaming decoding need incremental parsing at the upper levels of the JSON structure, but closer to the leaves simply need to get (potentially compound) values. At these lower levels, a tokenizer interface simply gets in the way. For example, in @nitingupta910's Wikipedia example, it's necessary to incrementally parse the top-level array, but for each element of the array it's far more convenient to use the regular JSON parser to get whole objects than to piece them together from the token stream.\r\n\r\nHence, my suggestion is to view the JSON data as a tree and expose a caller-driven in-order traversal of this tree. At any point in the traversal, the caller can ask for the entire subtree as a decoded JSON value, or it can descend or ascend the tree as appropriate. This is not entirely unlike a tokenizer, except that it's hierarchical (not linear), the caller can switch into and out of the full JSON decoder as convenient (rather than being trapped in one world or the other), and it abstracts the details of syntax such as separating commas and balancing brackets and braces.\r\n\r\nThis can all be done as a natural extension to the existing Decoder. The Decode method already reads just the next value and stops (even if there's more data in the Reader). All we would need are methods for descending into compound values, ascending after the last member of a compound value, and reporting where we are in the in-order traversal. Something like:\r\n\r\n// Enter descends into the next compound JSON value in its input.\r\n//\r\n// If the next value is an array, subsequent calls to Decode will\r\n// return the elements of that array in order. If the next value is an\r\n// object, subsequent calls to Decode will return the key/value pairs\r\n// of that object, alternating between returning the key and the value\r\n// associated with that key. If the next value is any other type,\r\n// Enter returns TraversalError.\r\nfunc (*Decoder) Enter() error\r\n\r\n// Exit ascends from the current compound JSON value in its input.\r\n//\r\n// The decoder must be at the end of an array or object that was\r\n// previously Entered; otherwise, Exit returns TraversalError.\r\nfunc (*Decoder) Exit() error\r\n\r\n// Peek returns the type of the next value in the input. It may read\r\n// from the input in order to determine the type of the value.\r\n//\r\n// If the next value is a non-compound value, Peek returns TypeNumber,\r\n// TypeString, TypeBoolean, or TypeNull. If the next value is a\r\n// compound value, Peek returns TypeArray or TypeObject. If the\r\n// decoder has Entered an array and there are no more values in the\r\n// array, Peek returns EndArray. Likewise, if the decoder has Entered\r\n// an object and there are no more key/value pairs in the object, Peek\r\n// returns EndObject. If there are no more values, Peek returns an\r\n// io.EOF error.\r\nfunc (*Decoder) Peek() (ValueType, error)\r\n\r\nFor example, using this interface, @nitingupta910's example could be parsed with the following code (eliding error handling):\r\n\r\n```\r\nd.Enter()\r\nfor {\r\n\tif typ, _ := d.Peek(); type == EndArray {\r\n\t\tbreak\r\n\t}\r\n\td.Decode(\u0026object)\r\n\tprocess(object)\r\n}\r\nd.Exit()\r\n```",
	"user": {
		"login": "aclements",
		"id": 2688315,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-03-22T02:46:19Z",
	"updated_at": "2015-03-22T02:46:19Z"
}
