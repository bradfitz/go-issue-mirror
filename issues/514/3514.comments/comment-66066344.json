{
	"id": 66066344,
	"body": "\u003ca id=\"c14\"\u003e\u003c/a\u003eComment 14:\n\n\u003cpre\u003eHere's a repro (HTTPS + fake keep-alive response with forced disconnect).  With the 500\nmillisecond sleep uncommented, it's reliable.  Without, you get varying errors:\n\nserve_test.go:699:      Get \u003ca href=\"https://127.0.0.1:38706/\"\u003ehttps://127.0.0.1:38706/\u003c/a\u003e: EOF\nserve_test.go:699:      Get \u003ca href=\"https://127.0.0.1:58785/\"\u003ehttps://127.0.0.1:58785/\u003c/a\u003e: http: can't write HTTP request on\nbroken connection\n\n\n// Trying to repro golang.org/issue/3514\nfunc TestTLSServerClosesConnection(t *testing.T) {\n        closec := make(chan bool)\n        closedc := make(chan bool)\n        ts := httptest.NewTLSServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n                if strings.Contains(r.URL.Path, \"/kill\") {\n                        conn, _, _ := w.(Hijacker).Hijack()\n                        conn.Close()\n                        return\n                }\n                if strings.Contains(r.URL.Path, \"/keep-alive-then-die\") {\n                        conn, _, _ := w.(Hijacker).Hijack()\n                        conn.Write([]byte(\"HTTP/1.1 200 OK\\r\\nContent-Length: 3\\r\\n\\r\\nfoo\"))\n                        \u0026lt;-closec\n                        conn.Close()\n                        closedc \u0026lt;- true\n                        return\n                }\n                fmt.Fprintf(w, \"hello\")\n        }))\n        defer ts.Close()\n        noVerifyTransport := \u0026Transport{\n        TLSClientConfig: \u0026tls.Config{\n                        InsecureSkipVerify: true,\n                },\n        }\n        client := \u0026Client{Transport: noVerifyTransport}\n        _, err := client.Get(ts.URL + \"/kill\")\n        if err == nil {\n                t.Error(\"expected error from /kill request\")\n        }\n\n        res, err := client.Get(ts.URL + \"/keep-alive-then-die\")\n        if err != nil {\n                t.Fatal(err)\n        }\n        slurp, err := ioutil.ReadAll(res.Body)\n        if err != nil {\n                t.Fatal(err)\n        }\n        if string(slurp) != \"foo\" {\n                t.Errorf(\"Got %q, want foo\", slurp)\n        }\n\n        closec \u0026lt;- true\n        \u0026lt;-closedc\n        // time.Sleep(500 * time.Millisecond)\n\n        res, err = client.Get(ts.URL + \"/\")\n        if err != nil {\n                t.Fatal(err)\n        }\n        slurp, err = ioutil.ReadAll(res.Body)\n        if err != nil {\n                t.Fatal(err)\n        }\n        if string(slurp) != \"hello\" {\n                t.Errorf(\"Got %q, want hello\", slurp)\n        }\n}\n\n\nThe latter bug (\"http: can't write HTTP request on broken connection\") occurs before\nwe've written anything on the wire, so we could in theory back up a bit and pick a new\nconn.\n\nBut the EOF one seems more common, and that's the one where we can't really do anything.\n Short of maybe \u003ca href=\"https://golang.org/issue/4677\"\u003eissue #4677\u003c/a\u003e.\n\nNot quite sure what to do here, if anything.\u003c/pre\u003e\n\n\n\n_Status changed to **Thinking**._",
	"user": {
		"login": "bradfitz",
		"id": 2621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2013-01-22T23:40:06Z",
	"updated_at": "2014-12-22T06:13:29Z"
}
