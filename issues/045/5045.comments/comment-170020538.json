{
	"id": 170020538,
	"body": "I would be careful about tying the go MM to  hardware memory models - such\r\nas x86/amd64 etc.\r\n\r\nWhen reasoning about multi-threaded safety of at the source code level the\r\nhardware memory model is usually irrelevant. Not talking about compiler\r\nwriters here.\r\n\r\nAs an example we can look at Java, whose mm is weaker than x86/amd64. The\r\nfollowing classical piece of code is unsafe\r\n\r\n\r\n    public class Test {\r\n        public int constructorValue private static Test instance;\r\n        public Test() { constructorValue=42; }\r\n        public static Test getInstance() {\r\n            if (instance == null) {\r\n                synchronized (Test.class) { \r\n                    if (instance == null) {\r\n                        instance = new Test();\r\n                    }\r\n              }\r\n           } return instance; \r\n        }\r\n     }\r\n\r\nWe know that it is possible to get an instance on Test where\r\nconstructorValue isn't 42. This is because when we construct the Test\r\nobject, the non-null write to instance may become visible before the write\r\nto classValue. This is nothing new.\r\n\r\nBut, the important thing about this example is that it is broken even on\r\nx86/amd64. The strong ordering of writes guaranteed by x86/amd64 doesn't\r\nhelp us because the most dangerous actor here is the compiler who can (and\r\noften will) perform much more aggressive reorderings than even an alpha\r\nchip.\r\n\r\nOf course if the compiler isn't running aggressive optimisations you may\r\nhave a situation where x86/amd64 memory model is saving people from bugs.\r\n\r\nThe compiler has far more opportunities for read/write reordering, so I\r\ndon't think hardware memory models are a good guide for what should be\r\npresented to the application programmer.\r\n\r\nF\r\n\r\nOn Thu, Jan 7, 2016 at 6:37 PM, Russ Cox \u003cnotifications@github.com\u003e wrote:\r\n\r\n\u003e @RLH \u003chttps://github.com/RLH\u003e, @aclements \u003chttps://github.com/aclements\u003e,\r\n\u003e and I spent a few hours rereading the discussion here and trying to\r\n\u003e understand what we might do. Certainly it's too complex for Go 1.6.\r\n\u003e\r\n\u003e A large part of the problem seems to be that the program order\r\n\u003e happens-before and the atomic operation happens-befores interact in bad\r\n\u003e ways. It may not be a good idea to treat them as being the same kind of\r\n\u003e relationship. If give atomic operations a total order in happens-before\r\n\u003e that is the same happens-before as the per-goroutine program order (and you\r\n\u003e allow racing reads), then you end up needing to guarantee the program in\r\n\u003e Dmitriy's Comment 12 above, which imposes serious constraints on the atomic\r\n\u003e implementation but also on the compiler.\r\n\u003e\r\n\u003e One way to avoid this is to disallow programs with races: if you have a\r\n\u003e race anywhere in your program, all bets are off for the entire program. I\r\n\u003e am uncomfortable with this, because I don't think it's terribly good\r\n\u003e guidance. If I have a race-free program and I drop in an unlocked,\r\n\u003e non-atomic counter and increment it in a few different goroutines and print\r\n\u003e it at the end of the program, I believe the damage caused to the program by\r\n\u003e the counter race should be somewhat limited. The rest of the program\r\n\u003e execution should be unaffected. Saying the whole program is now invalid\r\n\u003e does not seem tenable to me, especially in large-scale programs.\r\n\u003e\r\n\u003e Another way to avoid this is to say that the happens-before arrow for\r\n\u003e atomics only exists from a Store to a Load observing the effect of that\r\n\u003e store (or more generally from one atomic operation to another observing the\r\n\u003e effect of the first). That would allow Dmitriy's program 2 in Comment 15 to\r\n\u003e panic(broken). That is, independent reads of independent writes would not\r\n\u003e need to be consistent with a global total order. Maybe we should allow\r\n\u003e that, but we've put barriers in even our x86 atomic implementations to\r\n\u003e disallow it, so empirically we seem not to want to allow that.\r\n\u003e\r\n\u003e Rick raised the point that we don't want the model to be significantly\r\n\u003e weaker than the guarantees unavoidable on the x86. If the model were weaker\r\n\u003e than the x86, then people would write Go programs for the x86 and blame Go\r\n\u003e when they didn't run on other systems. (I observe that this is similar to\r\n\u003e what happened with Alpha and Itanium.) And if we boost the other systems to\r\n\u003e match the x86's guarantees then it's important not to overshoot: it's just\r\n\u003e as bad for people to be writing programs that only work correctly on ARM\r\n\u003e because we over-strengthened the atomics there.\r\n\u003e\r\n\u003e As I mentioned above, it may be that the order of operations in a single\r\n\u003e goroutine and the order of atomic operations are simply different kinds of\r\n\u003e orders, and it is not tenable to express them with a single happens-before\r\n\u003e relation. Austin suggested that perhaps the model needs to be able to\r\n\u003e express that operations within a goroutine may appear to be in a different\r\n\u003e order to that goroutine as to another. The current model tries to do that\r\n\u003e with the idea of things happening concurrently, but perhaps the current\r\n\u003e formulation does not capture enough of the subtlety.\r\n\u003e\r\n\u003e It may be that we need to abandon happens-before and write something more\r\n\u003e operational. I tried in the memory model to guarantee as little as\r\n\u003e possible, so that the space of options for future formulations and\r\n\u003e revisions was as large as possible. So it is plausible that another\r\n\u003e formulation could still be backwards compatible with what's there today.\r\n\u003e\r\n\u003e It may also be that we should just continue to guarantee as little as\r\n\u003e possible. For example, I am wondering if we should say only that:\r\n\u003e\r\n\u003e If the effect of atomic operation A is observed by atomic operation B,\r\n\u003e then A happens before B.\r\n\u003e\r\n\u003e That allows 0,0 from Dmitriy's Comment 15 program 2 (independent reads of\r\n\u003e independent writes). Is that such a bad thing? That would imply that we\r\n\u003e don't need any barriers in atomic operations on x86, because TSO already\r\n\u003e guarantees what I just wrote. Can we safely take the x86 barriers out? What\r\n\u003e bad things would happen if we did? @dvyukov \u003chttps://github.com/dvyukov\u003e?\r\n\u003e\r\n\u003e â€”\r\n\u003e Reply to this email directly or view it on GitHub\r\n\u003e \u003chttps://github.com/golang/go/issues/5045#issuecomment-169748442\u003e.\r\n\u003e\r\n",
	"user": {
		"login": "fmstephe",
		"id": 527920,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-08T14:41:45Z",
	"updated_at": "2016-01-08T19:13:23Z"
}
