{
	"id": 51285826,
	"number": 6854,
	"state": "closed",
	"title": "cmd/gc: too many import specifiers in export data",
	"body": "\u003cpre\u003eHere is the export block marked\n\nexports automatically generated from\n  /Users/r/go/src/pkg/fmt/scan.go\n\nin package fmt:\n\n   package fmt\n\timport sync \u0026quot;sync\u0026quot;\n\timport runtime \u0026quot;runtime\u0026quot;\n\timport errors \u0026quot;errors\u0026quot;\n\timport io \u0026quot;io\u0026quot;\n\timport math \u0026quot;math\u0026quot;\n\timport os \u0026quot;os\u0026quot;\n\timport strconv \u0026quot;strconv\u0026quot;\n\timport utf8 \u0026quot;unicode/utf8\u0026quot;\n\timport reflect \u0026quot;reflect\u0026quot;\n\ttype @\u0026quot;\u0026quot;.State interface { Flag(@\u0026quot;\u0026quot;.c int) (? bool); Precision() (@\u0026quot;\u0026quot;.prec int, @\u0026quot;\u0026quot;.ok bool); Width() (@\u0026quot;\u0026quot;.wid int, @\u0026quot;\u0026quot;.ok bool); Write(@\u0026quot;\u0026quot;.b []byte) (@\u0026quot;\u0026quot;.ret int, @\u0026quot;\u0026quot;.err error) }\n\ttype @\u0026quot;\u0026quot;.Formatter interface { Format(@\u0026quot;\u0026quot;.f @\u0026quot;\u0026quot;.State, @\u0026quot;\u0026quot;.c rune) }\n\ttype @\u0026quot;\u0026quot;.Stringer interface { String() (? string) }\n\ttype @\u0026quot;\u0026quot;.GoStringer interface { GoString() (? string) }\n\ttype @\u0026quot;io\u0026quot;.Writer interface { Write(@\u0026quot;io\u0026quot;.p []byte) (@\u0026quot;io\u0026quot;.n int, @\u0026quot;io\u0026quot;.err error) }\n\tfunc @\u0026quot;\u0026quot;.Fprintf (@\u0026quot;\u0026quot;.w·3 @\u0026quot;io\u0026quot;.Writer, @\u0026quot;\u0026quot;.format·4 string \u0026quot;esc:0x0\u0026quot;, @\u0026quot;\u0026quot;.a·5 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Printf (@\u0026quot;\u0026quot;.format·3 string \u0026quot;esc:0x0\u0026quot;, @\u0026quot;\u0026quot;.a·4 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Sprintf (@\u0026quot;\u0026quot;.format·2 string \u0026quot;esc:0x0\u0026quot;, @\u0026quot;\u0026quot;.a·3 ...interface {} \u0026quot;esc:0x0\u0026quot;) (? string)\n\tfunc @\u0026quot;\u0026quot;.Errorf (@\u0026quot;\u0026quot;.format·2 string \u0026quot;esc:0x0\u0026quot;, @\u0026quot;\u0026quot;.a·3 ...interface {} \u0026quot;esc:0x0\u0026quot;) (? error)\n\tfunc @\u0026quot;\u0026quot;.Fprint (@\u0026quot;\u0026quot;.w·3 @\u0026quot;io\u0026quot;.Writer, @\u0026quot;\u0026quot;.a·4 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Print (@\u0026quot;\u0026quot;.a·3 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Sprint (@\u0026quot;\u0026quot;.a·2 ...interface {} \u0026quot;esc:0x0\u0026quot;) (? string)\n\tfunc @\u0026quot;\u0026quot;.Fprintln (@\u0026quot;\u0026quot;.w·3 @\u0026quot;io\u0026quot;.Writer, @\u0026quot;\u0026quot;.a·4 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Println (@\u0026quot;\u0026quot;.a·3 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Sprintln (@\u0026quot;\u0026quot;.a·2 ...interface {} \u0026quot;esc:0x0\u0026quot;) (? string)\n\ttype @\u0026quot;\u0026quot;.ScanState interface { Read(@\u0026quot;\u0026quot;.buf []byte) (@\u0026quot;\u0026quot;.n int, @\u0026quot;\u0026quot;.err error); ReadRune() (@\u0026quot;\u0026quot;.r rune, @\u0026quot;\u0026quot;.size int, @\u0026quot;\u0026quot;.err error); SkipSpace(); Token(@\u0026quot;\u0026quot;.skipSpace bool, @\u0026quot;\u0026quot;.f func(? rune) (? bool)) (@\u0026quot;\u0026quot;.token []byte, @\u0026quot;\u0026quot;.err error); UnreadRune() (? error); Width() (@\u0026quot;\u0026quot;.wid int, @\u0026quot;\u0026quot;.ok bool) }\n\ttype @\u0026quot;\u0026quot;.Scanner interface { Scan(@\u0026quot;\u0026quot;.state @\u0026quot;\u0026quot;.ScanState, @\u0026quot;\u0026quot;.verb rune) (? error) }\n\tfunc @\u0026quot;\u0026quot;.Scan (@\u0026quot;\u0026quot;.a·3 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Scanln (@\u0026quot;\u0026quot;.a·3 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Scanf (@\u0026quot;\u0026quot;.format·3 string \u0026quot;esc:0x0\u0026quot;, @\u0026quot;\u0026quot;.a·4 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Sscan (@\u0026quot;\u0026quot;.str·3 string, @\u0026quot;\u0026quot;.a·4 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Sscanln (@\u0026quot;\u0026quot;.str·3 string, @\u0026quot;\u0026quot;.a·4 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Sscanf (@\u0026quot;\u0026quot;.str·3 string, @\u0026quot;\u0026quot;.format·4 string \u0026quot;esc:0x0\u0026quot;, @\u0026quot;\u0026quot;.a·5 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\ttype @\u0026quot;io\u0026quot;.Reader interface { Read(@\u0026quot;io\u0026quot;.p []byte) (@\u0026quot;io\u0026quot;.n int, @\u0026quot;io\u0026quot;.err error) }\n\tfunc @\u0026quot;\u0026quot;.Fscan (@\u0026quot;\u0026quot;.r·3 @\u0026quot;io\u0026quot;.Reader, @\u0026quot;\u0026quot;.a·4 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Fscanln (@\u0026quot;\u0026quot;.r·3 @\u0026quot;io\u0026quot;.Reader, @\u0026quot;\u0026quot;.a·4 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.Fscanf (@\u0026quot;\u0026quot;.r·3 @\u0026quot;io\u0026quot;.Reader, @\u0026quot;\u0026quot;.format·4 string \u0026quot;esc:0x0\u0026quot;, @\u0026quot;\u0026quot;.a·5 ...interface {} \u0026quot;esc:0x0\u0026quot;) (@\u0026quot;\u0026quot;.n·1 int, @\u0026quot;\u0026quot;.err·2 error)\n\tfunc @\u0026quot;\u0026quot;.init ()\n\n\nEvery file in that package has this same set of exports, which I find interesting but\nnot necessarily problematic (why not include it once?).\n\nMore troubling is that the list of imports, I believe, means the compiler will execute\nthose imports when importing this package, whereas only \u0026quot;io\u0026quot; is actually\nnecessary to compile the imported declarations. Do these cause unnecessary work for the\ncompiler?\u003c/pre\u003e",
	"user": {
		"login": "robpike",
		"id": 4324516,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "FrozenDueToAge"
		}
	],
	"comments": 5,
	"closed_at": "2014-12-08T10:38:07Z",
	"created_at": "2013-11-30T18:42:42Z",
	"updated_at": "2016-06-25T01:23:06Z",
	"milestone": {
		"id": 1067211,
		"number": 17,
		"title": "Go1.3"
	}
}
