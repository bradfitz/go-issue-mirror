{
	"id": 176145082,
	"number": 17048,
	"state": "open",
	"title": "Proposal: Basic C API for the runtime",
	"body": "# Purpose\r\nThis is a proposal for a basic C API for the runtime.  It allows for non-Go main programs and for using specially written Go libraries from any language that can call C functions, with a few additional features beyond what are currently available by `buildmode=c-shared`.  This will be a new buildmode.\r\n\r\n# Background\r\nGo can call almost any C function via CGo.  However, the ability to have a non-Go main program is much more limited.  Go does have `buildmode=c-shared`, but it is limited by #11100 and also does not allow for useful features like passing `GOMAXPROCS` other than as an environment variable.\r\n\r\n# Goals\r\n\r\n- Allow for writing programs in a mixture of Go and another language, such that Go is not necessarily the language in which the program's entry point is written.\r\n- Allow for writing a a library partly or completely in Go for use by another language.\r\n- Provide handles that can passed to C and which can refer to any Go object.\r\n\r\n# Non-Goals\r\n\r\n- Allowing arbitrary Go functions to be called from C\r\n- Allowing C code to manipulate arbitrary Go data structures.\r\n\r\n# The API\r\n\r\n## Ground rules.\r\n\r\nThe entire API is provided in a single C header file, `goapi.h`.\r\n\r\nUnless otherwise specified, any function can be called from multiple threads simultaneously.  However, a single pointer in the API cannot be passed to API functions in 2 or more threads simultaneously, unless both functions take pointers to `const` data.\r\n\r\n## The API itself\r\n\r\n```c\r\nint go_runtime_init(char * const* errormsg, ssize_t *already_initialized, const char * const *options, const void * const* arguments);\r\n```\r\nInitializes the Go runtime.  Must be called before calling any other Go function.  Thread-safe and may be called multiple times.\r\n\r\n`options` is a pointer to an array of NUL-terminated strings.  Each string corresponds to a matching `void*` in `arguments` that corresponds to a matching pointer, which points to a flag that can be used to configure the runtime.  Currently, the only string in `options` that is meaningful is `GOMAXPROCS`, which replaces the `GOMAXPROCS` environment variable: the corresponding `void*` must point to a `size_t*`.  All other values are reserved and must not be used.\r\n\r\nIf the defaults are OK, both `arguments` and `options` may be set to NULL.  They are ignored if the runtime is already initialized.\r\n\r\nReturns 0 on success, a negative number on failure.\r\n\r\n- On success, `*errormsg` is set to `NULL` and `*already_initialized` is set to the number of times the runtime has been initialized (including this one).  It is safe to set `errormsg` and/or `already_initialized` to NULL, in which case they are not accessed.\r\n- On failure, `*errormsg` points to a NUL-terminated, human-readable error message, and `*already_initialized` holds a negative number.  Again, neither are written to if NULL.\r\n\r\n```c\r\nint go_runtime_shutdown(void);\r\n```\r\n\r\nThis function shuts down the runtime.  It must be called once for each call to `go_runtime_init`.  Only the last such call has any effect.\r\n\r\nOnce the number of calls to `go_runtime_shutdown` equals the number of calls to `go_runtime_init`, this function terminates all active goroutines and resets any signal handlers.\r\n\r\nThe following sentence may not be initially implemented:\r\n  Afterwards, it is safe to `dlclose` the shared library containing the runtime, or to restart the runtime with `go_runtime_init`.\r\n```c\r\ntypedef struct Go_Handle *Go_Handle;\r\n```\r\n\r\nA handle to an arbitrary Go object.  Analogous to a Haskell stable pointer.  It stays valid even across garbage collections.\r\n\r\nA `Go_Handle` is not guaranteed to point to valid memory.  Dereferencing it invokes undefined behavior.\r\n\r\n```c\r\nvoid go_runtime_delete_handle(Go_Handle handle_to_be_freed);\r\n```\r\n\r\nDeletes the handle passed as argument, rendering it invalid and freeing all underlying resources.  After this function is called, the object the handle pointed to may be garbage collected if there are no more references to it.\r\n\r\n```c\r\nGo_Handle go_runtime_duplicate_handle(Go_Handle handle_to_be_duplicated);\r\n```\r\nDuplicates the handle passed as argument.  The returned handle points to the same object as the original handle, but must be deallocated separately.\r\n\r\n```c\r\nuint8_t go_runtime_are_identical_handles(Go_Handle handle1, Go_Handle handle2);\r\n```\r\n\r\nTests if the 2 handles passed are identical.  Returns `true` if they point to the same object in memory.  Otherwise, returns `false`.\r\n\r\n## The Go side\r\n\r\nThese are additional functions exposed from the runtime package.\r\n\r\n```go\r\ntype CHandle\r\n```\r\nThe type of C handles to Go data.  When passed via CGo, becomes a `Go_Handle` on the C side.\r\n\r\nMay be accessed by multiple goroutines simultaneously.\r\n\r\n```go\r\nfunc NewHandle(object interface {}) CHandle\r\n```\r\nCreates a handle to a Go object that can safely be passed to C.\r\n\r\n```go\r\nfunc DuplicateHandle(handle CHandle) CHandle\r\n```\r\nDuplicates the handle.\r\n\r\n```go\r\nfunc TestIfIdenticalHandles(handle1 CHandle, handle2 CHandle) bool\r\n```\r\nTests if the 2 handles passed point to the same object; that is, if modifications of the object pointed to by one will affect the object pointed to by the other.\r\n\r\n```go\r\nfunc DeallocateHandle(handle CHandle)\r\n```\r\nDeallocates the handle, rendering it invalid.\r\n\r\n```go\r\nfunc DereferenceHandle(handle CHandle) interface {}\r\n```\r\nDereferences the handle, returning the contained object.  If the handle is invalid, invokes undefined behavior.",
	"user": {
		"login": "DemiMarie",
		"id": 6395399,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "Proposal"
		}
	],
	"comments": 5,
	"created_at": "2016-09-10T01:03:41Z",
	"updated_at": "2016-09-12T19:26:36Z",
	"milestone": {
		"id": 1373555,
		"number": 30,
		"title": "Proposal"
	}
}
