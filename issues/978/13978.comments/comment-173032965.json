{
	"id": 173032965,
	"body": "Thanks for looking into this, Austin.\r\n\r\nThe acquirem call in 1452891329 is the one towards the top of gcBgMarkWorker's for loop: https://github.com/golang/go/blob/505fa7b/src/runtime/mgc.go#L1390\r\n\r\nI've collected quite a few core dumps from reproducing #13363, which show five different call stacks at the time of the crash. I'm building binaries of the runtime/pprof test for linux/amd64 with `go version devel +01b8640 Sat Jan 16 03:35:23 2016 +0000 darwin/amd64`, with a toolchain built with GOEXPERIMENT=framepointer and with the pprof frequency set to 500Hz. I have a gdb script that uses the frame pointer to unwind the stacks.\r\n\r\n```\r\n$ for core in ./core-* ; do gdb --batch --command unwind.gdb ./pprof.test $core 2\u003e/dev/null | grep -A 2 '^\\$' | sed -n -e 's/ in section .*//p' | sed -e 's/ //g' | tac | tr '\\n' ';' | sed -e 's/;$/\\n/' ; done | sort | uniq -c | sort -n -r\r\n     38 runtime.goexit+1;runtime.gcBgMarkWorker+1273;runtime.gcMarkDone+62;runtime.semacquire+46\r\n     30 runtime.goexit+1;runtime.gcBgMarkWorker+1273;runtime.morestack+13\r\n     24 runtime.goexit+1;runtime.gcBgMarkWorker+321;runtime.gopark+46\r\n      1 runtime.goexit+1;runtime.gcBgMarkWorker+718;runtime.gcDrain+277;runtime.(*gcWork).balance+148;runtime.handoff+162\r\n      1 runtime.goexit+1;runtime.gcBgMarkWorker+321;runtime.gopark+432;runtime.writebarrierptr+129;runtime.writebarrierptr_nostore1+27\r\n```\r\n\r\nstress command:\r\n\r\n```\r\n./stress sh -c \"GODEBUG=gcstackbarrierall=1,gcstackbarrierall=0 GOGC=1 ./pprof.test -test.run TestStackBarrierProfiling\"\r\n```\r\n\r\ngdb script:\r\n\r\n```\r\n$ cat unwind.gdb \r\nprintf \"\\n\"\r\np/x (('runtime.sigcontext'*)(ctx+0x28)).rip\r\ni sym (('runtime.sigcontext'*)(ctx+0x28)).rip\r\nset $ptr = (long *)(('runtime.sigcontext'*)(ctx+0x28)).rbp\r\n\r\nwhile $ptr != 0\r\n  printf \"\\n\"\r\n  set $instr = *($ptr+1)\r\n  p/x $instr\r\n  i sym $instr\r\n  set $ptr = *(long **)($ptr)\r\nend\r\n```\r\n\r\nchanges to core packages to make reproducing easier, per #13363:\r\n\r\n```\r\ndiff --git a/src/runtime/pprof/pprof.go b/src/runtime/pprof/pprof.go\r\nindex d32b315..f1d8cbb 100644\r\n--- a/src/runtime/pprof/pprof.go\r\n+++ b/src/runtime/pprof/pprof.go\r\n@@ -577,7 +577,7 @@ func StartCPUProfile(w io.Writer) error {\r\n        // system, and a nice round number to make it easy to\r\n        // convert sample counts to seconds.  Instead of requiring\r\n        // each client to specify the frequency, we hard code it.\r\n-       const hz = 100\r\n+       const hz = 500\r\n \r\n        cpu.Lock()\r\n        defer cpu.Unlock()\r\ndiff --git a/src/runtime/pprof/pprof_test.go b/src/runtime/pprof/pprof_test.go\r\nindex c241b54..6d83236 100644\r\n--- a/src/runtime/pprof/pprof_test.go\r\n+++ b/src/runtime/pprof/pprof_test.go\r\n@@ -103,7 +103,7 @@ func parseProfile(t *testing.T, bytes []byte, f func(uintptr, []uintptr)) {\r\n        }\r\n \r\n        hd, val, tl := val[:5], val[5:l-3], val[l-3:]\r\n-       if hd[0] != 0 || hd[1] != 3 || hd[2] != 0 || hd[3] != 1e6/100 || hd[4] != 0 {\r\n+       if hd[0] != 0 || hd[1] != 3 || hd[2] != 0 /*|| hd[3] != 1e6/100*/ || hd[4] != 0 {\r\n                t.Fatalf(\"unexpected header %#x\", hd)\r\n        }\r\n \r\n```",
	"user": {
		"login": "rhysh",
		"id": 230685,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-01-20T00:27:42Z",
	"updated_at": "2016-01-20T00:27:42Z"
}
