{
	"id": 227716622,
	"body": "\u003eI still cannot reproduce this crash.\r\n\r\nHere you are.\r\n\r\n```\r\npackage os_test\r\n\r\nimport (\r\n\t\"encoding/binary\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"syscall\"\r\n\r\n\t\"testing\"\r\n)\r\n\r\nconst FSCTL_SET_REPARSE_POINT = 0x900a4\r\n\r\nvar le = binary.LittleEndian\r\n\r\nfunc TestReadlink(t *testing.T) {\r\n\tdefer chtmpdir(t)()\r\n\r\n\tf, err := os.Create(\"test\")\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\tf.Close()\r\n\r\n\terr = Symlink(\"test\", \"linkToTest\")\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\r\n\tdefer func() {\r\n\t\tif r := recover(); r != nil {\r\n\t\t\tt.Fatal(r)\r\n\t\t}\r\n\t}()\r\n\r\n\ttarget, err := os.Readlink(\"linkToTest\")\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\r\n\tif target != \"test\" {\r\n\t\tt.Error(\"readlink is broken\")\r\n\t}\r\n}\r\n\r\nfunc Symlink(symlinkfilename string, targetfilename string) (err error) {\r\n\t// typedef struct _REPARSE_DATA_BUFFER {\r\n\t//   uint32 ReparseTag;\r\n\t//   uint16 ReparseDataLength;\r\n\t//   uint16 Reserved;\r\n\t//   uint16 SubstituteNameOffset;\r\n\t//   uint16 SubstituteNameLength;\r\n\t//   uint16 PrintNameOffset;\r\n\t//   uint16 PrintNameLength;\r\n\t//   uint32  Flags;\r\n\t//   WCHAR  PathBuffer[1];\r\n\t// } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;\r\n\r\n\tfd, err := syscall.CreateFile(syscall.StringToUTF16Ptr(targetfilename), syscall.GENERIC_READ|syscall.GENERIC_WRITE, 0, nil, syscall.CREATE_ALWAYS,\r\n\t\tsyscall.FILE_FLAG_OPEN_REPARSE_POINT|syscall.FILE_FLAG_BACKUP_SEMANTICS, 0)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\tdefer syscall.CloseHandle(fd)\r\n\r\n\tsympath := syscall.StringToUTF16(symlinkfilename)\r\n\r\n\tsympath = sympath[:len(sympath)-1]\r\n\r\n\trdbbuf := make([]byte, 20+len(sympath)*4)\r\n\r\n\tle.PutUint32(rdbbuf[:4], syscall.IO_REPARSE_TAG_SYMLINK)\r\n\tle.PutUint16(rdbbuf[4:6], uint16(len(rdbbuf)-8))\r\n\tle.PutUint16(rdbbuf[8:10], 0)\r\n\tle.PutUint16(rdbbuf[10:12], uint16(len(sympath)*2))\r\n\tfor i, w := range sympath {\r\n\t\tle.PutUint16(rdbbuf[20+i*2:20+i*2+2], w)\r\n\t}\r\n\tle.PutUint16(rdbbuf[12:14], uint16(len(sympath)*2))\r\n\tle.PutUint16(rdbbuf[14:16], uint16(len(sympath)*2))\r\n\tfor i, w := range sympath {\r\n\t\tle.PutUint16(rdbbuf[20+len(sympath)*2+i*2:20+len(sympath)*2+i*2+2], w)\r\n\t}\r\n\r\n\treturn syscall.DeviceIoControl(fd, FSCTL_SET_REPARSE_POINT, \u0026rdbbuf[0], uint32(len(rdbbuf)), nil, 0, nil, nil)\r\n}\r\n\r\n// chtmpdir changes the working directory to a new temporary directory and\r\n// provides a cleanup function. Used when PWD is read-only.\r\nfunc chtmpdir(t *testing.T) func() {\r\n\toldwd, err := os.Getwd()\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"chtmpdir: %v\", err)\r\n\t}\r\n\td, err := ioutil.TempDir(\"\", \"test\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"chtmpdir: %v\", err)\r\n\t}\r\n\tif err := os.Chdir(d); err != nil {\r\n\t\tt.Fatalf(\"chtmpdir: %v\", err)\r\n\t}\r\n\treturn func() {\r\n\t\tif err := os.Chdir(oldwd); err != nil {\r\n\t\t\tt.Fatalf(\"chtmpdir: %v\", err)\r\n\t\t}\r\n\t\tos.RemoveAll(d)\r\n\t}\r\n}\r\n```",
	"user": {
		"login": "hirochachacha",
		"id": 898442,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-06-22T11:30:24Z",
	"updated_at": "2016-06-22T11:30:24Z"
}
