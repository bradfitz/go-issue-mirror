{
	"id": 66049216,
	"body": "\u003ca id=\"c6\"\u003e\u003c/a\u003eComment 6:\n\n\u003cpre\u003eIts also a non issue. If you want complete control of your type, you don't have to\nexport it. You can still have an initializer return your type, and the function\ncaller can still access all its exported methods and fields, but can never refer to\nit by name. So no blank struct literals, no new() declarations, no var X t, no\nasserting or converting to your type, meaning you still have full control over over\nwhat's in your object. \n\n(I'm assuming that the fact that you can do this is a feature not a bug. It certainly\nsurprised me when I did it by accident. I still can't figure out how someone is\nsupposed to be able to call the methods of a type without being able to refer to the\ntype. I'd assumed you'd need to embed to get this functionality. But its darned handy)\u003c/pre\u003e",
	"user": {
		"login": "stevenblenkinsop",
		"id": 3118803,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2009-12-10T04:21:05Z",
	"updated_at": "2014-12-08T10:04:10Z"
}
