{
	"id": 189515566,
	"body": "The Reader expands sparse files transparently. The Writer is \"transparent\" in the sense that a user can just do io.Copy(tw, sparseFile) and so long as the user already specified where there sparse holes are, it will avoid writing the long runs of zeros.\r\n\r\nPurely transparent sparse files for Writer cannot easily done since the tar.Header is written before the file data. Thus, the Writer cannot know what sparse map to encode in the header prior to seeing the data itself. Thus, Writer.WriteHeader needs to be told where the sparse holes are.\r\n\r\nI don't think tar should automatically create sparse files (for backwards compatibility). As a data point, the tar utilities do not automatically generate sparse files unless the -S flag is passed in. However, it would be nice if the user didn't need to come up with the SparseHoles themselves. Unfortunately, I don't see an easy solution to this.\r\n\r\n---\r\n\r\nThere are three main ways that sparse files may be written:\r\n\r\n1. In the case of writing a file from the filesystem (the use case that spawned this issue is of this), I'm not aware of any platform independent way to easily query for all the sparse holes. There is a method to do this on Linux and Solaris with SEEK_DATA and SEEK_HOLE (see my test in [CL/17692](https://go-review.googlesource.com/#/c/17692)), but I'm not aware of ways to do this on other OSes like Windows or Darwin.\r\n\r\n2. In the case of a round-trip read-write, a tar.Header read from Reader.Next and written to Writer.WriteHeader will work just fine as expected since tar.Header will have the SparseHoles field populated.\r\n\r\n3. In the case of writing a file from a memory, the user will need to write their own zero detection scheme (assuming they don't already know where the holes are).\r\n\r\nI looked at the source for GNU and BSD tar to see what they do:\r\n\r\n* ([Source](https://github.com/libarchive/libarchive/blob/48b288a03347e49f2f9501f040f626f916195de6/libarchive/archive_read_disk_entry_from_file.c#L1024-L1239)) BSD tar attempts to use FIEMAP first, then SEEK_DATA/SEEK_HOLE, then (it seems) it avoids sparse files altogether.\r\n* ([Source](http://git.savannah.gnu.org/cgit/tar.git/tree/src/sparse.c?id=63f2e969ddc162da7ae49a955bba9c6a2a0e77dc#n354)) GNU tar attempts to use SEEK_DATA/SEEK_HOLE, then falls back on brute-force zero block detection.\r\n\r\nI'm not too fond of the OS specific things that they do to detect holes (granted archive/tar already has many OS specific things in it). I think it would be nice if tar.Writer provided a way to write spares files, but I think we should delegate detection of sparse holes to the user for now. If possible, we can try and get sparse info during [FileInfoHeader](https://golang.org/pkg/archive/tar/#FileInfoHeader), but I'm not sure that os.FileInfo has the necessary information to do the queries that are needed.",
	"user": {
		"login": "dsnet",
		"id": 6354026,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-02-26T22:51:03Z",
	"updated_at": "2016-02-26T23:56:00Z"
}
