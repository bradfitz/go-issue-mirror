{
	"id": 189504786,
	"body": "This my proposed addition to the tar API to support sparse writing.\r\n\r\nFirst, we modify tar.Header to have an extra field:\r\n```go\r\ntype Header struct {\r\n\t...\r\n\r\n\t// SparseHoles represents a sequence of holes in a sparse file.\r\n\t//\r\n\t// The regions must be sorted in ascending order, not overlap with\r\n\t// each other, and not extend past the specified Size.\r\n\t// If len(SparseHoles) \u003e 0 or Typeflag is TypeGNUSparse, then the file is\r\n\t// sparse. It is optional for Typeflag to be set to TypeGNUSparse.\r\n\tSparseHoles  []SparseHole\r\n}\r\n\r\n// SparseEntry represents a Length-sized fragment at Offset in the file.\r\ntype SparseEntry struct {\r\n\tOffset int64\r\n\tLength int64\r\n}\r\n```\r\n\r\nOn the reader side, nothing much changes. We already support sparse files. All that's being done is that we're now exporting information about the sparse file through the SparseHoles field.\r\n\r\nOn the writer side, the user must set the SparseHoles field if they intend to write a sparse file. It is optional for them to set Typeflag to TypeGNUSparse (there are multiple formats to represent sparse files so this is not important). The user then proceeds to write all the data for the file. For sparse holes, they will be required to write Length zeros for that given hole. It is a little inefficient writing zeros for the holes, but I decided on this approach because:\r\n* It is symmetrical with how tar.Reader already operates (which transparently expands a sparse file).\r\n* It is more representative of what the \"end result\" really looks like. For example, it allows a user to write a sparse file by just doing io.Copy(tarFile, sparseFile) and not worry about where the holes are (assuming they already populated the SparseHoles field).\r\n\r\nI should note that the tar format represents sparse files by indicating which regions have data, and treating everything else as a hole. The API exposed here does the opposite; it represents sparse files by indicating which regions are holes, and treating everything else as data. The reason for this inversion is because it fits the Go philosophy that the zero value of some be meaningful. The zero value of SparseHoles indicates that there are no holes in the file, and thus it is a normal file; i.e., the default makes sense. If we were to use SparseDatas instead, the zero value of that indicates that there is no data in the file, which is rather odd.\r\n\r\nIt is a little inefficient requiring that users write zeros and the bottleneck will be the memory bandwidth's ability to transfer potentially large chunks of zeros. Though not necessary, the following methods may be worth adding as well:\r\n```go\r\n// Discard skips the next n bytes, returning the number of bytes discarded.\r\n// This is useful when dealing with sparse files to efficiently skip holes.\r\nfunc (tr *Reader) Discard(n int64) (int64, error) {}\r\n\r\n// FillZeros writes the next n bytes by filling it in with zeros.\r\n// It returns the number of bytes written, and an error if any.\r\n// This is useful when dealing with sparse files to efficiently skip holes.\r\nfunc (tw *Writer) FillZeros(n int64) (int64, error) {}\r\n```\r\n\r\nPotential example usage: https://play.golang.org/p/Vy63LrOToO",
	"user": {
		"login": "dsnet",
		"id": 6354026,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-02-26T22:12:15Z",
	"updated_at": "2016-02-26T22:18:53Z"
}
