{
	"id": 241164306,
	"body": "One possible implementation path to address (A): inside x509.Verify, first filter the incoming opts.Intermediates to see if they actually contain any root certs (self-signed cert: RawSubject == RawIssuer).  If so, move these masquerading root certs from opts.Intermediates to opts.Roots before calling x509.buildChains.\r\n\r\nx509.Verify already scans all opts.Intermediates to ensure they're already parsed (https://golang.org/src/crypto/x509/verify.go?h=opts.Intermediates#L223; BTW: Should opts.Roots be similarly checked when opts.Roots != nil?), so the check for masquerading root certs could be added to that existing loop.  However, that loop occurs before opts.Roots are populated when opts.Roots == nil, so the actual move of any masquerading root certs should be deferred until just before the call to isValid (https://golang.org/src/crypto/x509/verify.go?#L252) to avoid disrupting that root cert population logic.\r\n\r\nThat is, I suggest changing the beginning of x509.Verify to something like the following (NOTE: I have not tested on Windows, so I do not know if systemVerify properly handles this case.  If not, additional adjustments will need to be made):\r\n\r\n```Go\r\nfunc (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error) {\r\n\t// Platform-specific verification needs the ASN.1 contents so\r\n\t// this makes the behaviour consistent across platforms.\r\n\tif len(c.Raw) == 0 {\r\n\t\treturn nil, errNotParsed\r\n\t}\r\n\r\n\tvar trueIntermediates *CertPool\r\n\tvar masqueradingRoots []*Certificate\r\n\tif opts.Intermediates != nil {\r\n\t\ttrueIntermediates = NewCertPool()\r\n\t\tfor _, intermediate := range opts.Intermediates.certs {\r\n\t\t\tif len(intermediate.Raw) == 0 {\r\n\t\t\t\treturn nil, errNotParsed\r\n\t\t\t}\r\n\t\t\tif len(intermediate.RawSubject) \u003e 0 \u0026\u0026 bytes.Equal(intermediate.RawSubject, intermediate.RawIssuer) {\r\n\t\t\t\tmasqueradingRoots = append(masqueradingRoots, intermediate)\r\n\t\t\t} else {\r\n\t\t\t\ttrueIntermediates.AddCert(intermediate)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Use Windows's own verification and chain building.\r\n\tif opts.Roots == nil \u0026\u0026 runtime.GOOS == \"windows\" {\r\n\t\treturn c.systemVerify(\u0026opts)\r\n\t}\r\n\r\n\tif len(c.UnhandledCriticalExtensions) \u003e 0 {\r\n\t\treturn nil, UnhandledCriticalExtension{}\r\n\t}\r\n\r\n\tif opts.Roots == nil {\r\n\t\topts.Roots = systemRootsPool()\r\n\t\tif opts.Roots == nil {\r\n\t\t\treturn nil, SystemRootsError{systemRootsErr}\r\n\t\t}\r\n\t}\r\n\r\n\tfor _, root := range masqueradingRoots {\r\n\t\topts.Roots.AddCert(root)\r\n\t}\r\n\r\n\t//TODO: Test on Windows; may need to move this before call to c.systemVerify above\r\n\topts.Intermediates = trueIntermediates\r\n\r\n\terr = c.isValid(leafCertificate, nil, \u0026opts)\r\n```\r\nThis approach avoids changing x509.buildChains, so it's probably less risky, not to mention just easier to understand and actually enforces the long-held assumption that opts.Intermediates only contains intermediate certs.",
	"user": {
		"login": "ramoas",
		"id": 13425463,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-08-20T00:12:16Z",
	"updated_at": "2016-08-20T00:12:16Z"
}
