{
	"id": 189417230,
	"body": "\u003e I think you might have overlooked the fact that that program puts a pointer to T into the interface, not T itself.\r\n\r\nI did, thanks. Nevertheless: https://github.com/golang/go/issues/14529\r\n\r\n\u003e the reflect package could panic\r\n\r\nRight--a runtime check, not just a compiler check. To my mind, that makes this a lot more like the race detector than a souped-up, compiler-enforced vet. \r\n\r\n\u003e Putting the nocopy element in a struct ... could also print \"// This value may not be copied\" ...\r\n\r\nTo reiterate a few things (apologies): This limits it to just structs, and godoc can be readily adapted to whatever purpose serves the users best.\r\n\r\n\u003e It does add reflect data and if the empty struct is the last field, it might make the structure larger.\r\n\r\nThis is what I meant; thanks, @minux, for summing it up. :) The last-field thing in particular seems like an abstraction leak. It is ugly to have to document \"the nocopy field should go first, if present, because, ummm, reasons having to do with GC\" and ugly docs are a sign that something is wrong. Also, if the user wrote \"_ nocopy\" instead of just \"nocopy\", that'll impact the generated algs. All small stuff, but why have to fuss with it at all?\r\n\r\n\r\nHaving said all that, here's a concrete, minimalist counter-proposal that I think satisfies the original request from @bradfitz and @alandonovan:\r\n\r\n* Stick with vet-only for the moment. Document that the presence of a NoCopy method on a type indicates that it should not be copied. Add vet support; this is a trivial adaptation of the existing copylocks check. Fixing #14529 would be nice. (If there is concern about adding new API surface area, we could use noCopy instead, but that makes it less visible to the user in many ways.) The method will be trivial to compile, will add negligible space to the object files, and will be stripped by the linker.\r\n\r\n* Optional: Teach go doc to look for a NoCopy method and surface it more visibly to the user--although exported methods are already pretty visible.\r\n\r\n* Wait and watch what people do with it. The existence of this annotation in the source makes it possible to run experiments at scale--take existing code, teach the compiler to look for the `NoCopy` method, do all the runtime instrumentation, and find out what the additional benefit in practice is of the deeper language integration. If deeper language integration is worthwhile, it would then be very easily to do an automated rewrite that removes the NoCopy method and inserts whatever other mechanism is desired, be at a comment directive, a predeclared identifier, a struct tag, a type tag (maybe someday), etc.\r\n",
	"user": {
		"login": "josharian",
		"id": 67496,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-02-26T18:37:36Z",
	"updated_at": "2016-02-26T18:37:36Z"
}
