{
	"id": 162400626,
	"number": 16192,
	"state": "open",
	"title": "cmd/compile: new backend; multiple efficiency issues...",
	"body": "Please answer these questions before submitting your issue. Thanks!\r\n\r\n1. **Version:**  go version go1.7beta2 windows/amd64\r\n\r\n2. **Environment:**\r\nset GOARCH=amd64\r\nset GOBIN=\r\nset GOEXE=.exe\r\nset GOHOSTARCH=amd64\r\nset GOHOSTOS=windows\r\nset GOOS=windows\r\nset GOPATH=F:\\Go\\\r\nset GORACE=\r\nset GOROOT=F:\\Go\r\nset GOTOOLDIR=F:\\Go\\pkg\\tool\\windows_amd64\r\nset CC=gcc\r\nset GOGCCFLAGS=-m64 -mthreads -fmessage-length=0 -fdebug-prefix-map=C:\\Users\\Super\\AppData\\Local\\Temp\\go-build631535858=/tmp/go-build -gno-record-gcc-switches\r\nset CXX=g++\r\nset CGO_ENABLED=1\r\n\r\n   However, these issues are likely also related to other operating systems and architectures, as in at least x386.\r\n\r\n3. **Runnable Program:**   [**Go Playground link:**](https://play.golang.org/p/lTaHmi9hiR)\r\n    ```go\r\n// SoE project main.go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n)\r\n\r\nfunc primesOdds(top uint32) func() uint32 {\r\n\ttopndx := int((top - 3) / 2)\r\n\ttopsqrtndx := (int(math.Sqrt(float64(top))) - 3) / 2\r\n\tcmpsts := make([]uint32, (topndx/32)+1)\r\n\tfor i := 0; i \u003c= topsqrtndx; i++ {\r\n\t\tif cmpsts[i\u003e\u003e5]\u0026(1\u003c\u003c(uint32(i)\u00260x1F)) == 0 {\r\n\t\t\tp := i + i + 3\r\n\t\t\tfor j := (p*p - 3) \u003e\u003e 1; j \u003c= topndx; j += p {\r\n\t\t\t\tcmpsts[j\u003e\u003e5] |= uint32(1) \u003c\u003c (uint32(j) \u0026 0x1F)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\ti := -1\r\n\treturn func() uint32 {\r\n\t\toi := i\r\n\t\tif i \u003c= topndx {\r\n\t\t\ti++\r\n\t\t}\r\n\t\tfor i \u003c= topndx \u0026\u0026 cmpsts[i\u003e\u003e5]\u0026(uint32(1)\u003c\u003c(uint32(i)\u00260x1F)) != 0 {\r\n\t\t\ti++\r\n\t\t}\r\n\t\tif oi \u003c 0 {\r\n\t\t\treturn 2\r\n\t\t} else {\r\n\t\t\treturn (uint32(oi) \u003c\u003c 1) + 3\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc main() {\r\n\titer := primesOdds(1000000)\r\n\tcount := 0\r\n\tfor v := iter(); v \u003c= 1000000; v = iter() {\r\n\t\tcount++\r\n\t}\r\n\tfmt.Printf(\"%v\\r\\n\", count)\r\n}\r\n```\r\n\r\n4.  **What I saw:**\r\n\r\n    The issue is the assembly code as viewed when \"go tool compile -S \u003e main.asm\" is run, with a portion of that file as follows:\r\n    ```\r\n\t0x00e9 00233 (main.go:15)\tLEAQ\t(CX)(CX*1), R8\t;; **ISSUE 1** - change\r\n\t0x00ed 00237 (main.go:15)\tLEAQ\t3(CX)(CX*1), R9\t;; prime 'p' calculation; good\r\n\t0x00f2 00242 (main.go:16)\tIMULQ\tR9, R9\t;; 'sqr' calculation - good\r\n\t0x00f6 00246 (main.go:16)\tADDQ\t$-3, R9\t;; 'sqr' - 3 is good\r\n\t0x00fa 00250 (main.go:16)\tSARQ\t$1, R9\t;; including shortcut divide by 2 - good\r\n\t0x00fd 00253 (main.go:16)\tCMPQ\tR9, SI\t;; advance range compare\r\n\t0x0100 00256 (main.go:16)\tJGT\t$0, 319\t\t;; check - good\r\n\t0x0102 00258 (main.go:17)\tMOVQ\tR9, R11\t;; **ISSUE 2** - change\r\n\t0x0105 00261 (main.go:17)\tSARQ\t$5, R9\t;; calculate word address - good\r\n\t0x0109 00265 (main.go:17)\tCMPQ\tR9, DX\t;; *** only here if array bounds check\r\n\t0x010c 00268 (main.go:17)\tJCC\tPANIC\t\t;; *** only here if array bounds check\r\n\t0x0112 00274 (main.go:17)\tMOVL\t(AX)(R9*4), R12\t;; **ISSUE 3** - not this way\r\n\t0x0116 00278 (main.go:17)\tMOVQ\tR11, R13\t;; **ISSUE 4** - not this way\r\n\t0x0119 00281 (main.go:17)\tANDQ\t$31, R11\t\t;; **ISSUE 5** - unnecessary\r\n\t0x011d 00285 (main.go:17)\tMOVQ\tR11, CX\t\t;; part of **ISSUE 2** - change\r\n\t0x0120 00288 (main.go:17)\tMOVL\tR10, R14\t\t;; **ISSUE 6** - unnecessary\r\n\t0x0123 00291 (main.go:17)\tSHLL\tCX, R10\t\t;; 1 \u003c\u003c ('j'\u00260x1F) - good\r\n\t0x0126 00294 (main.go:17)\tORL\tR10, R12\t\t\t\t;; part of **ISSUE 3**\r\n\t0x0129 00297 (main.go:17)\tMOVL\tR12, (AX)(R9*4)\t;; part of **ISSUE 3**\r\n\t0x012d 00301 (main.go:16)\tLEAQ\t3(R8)(R13*1), R9\t;; part of **ISSUE 1**\r\n\t0x0132 00306 (main.go:13)\tMOVQ\t\"\".i+64(SP), CX ;; **ISSUE 7**; unnecessary\r\n\t0x0137 00311 (main.go:17)\tMOVL\tR14, R10\t\t;; part of **ISSUE 6**\r\n\t0x013a 00314 (main.go:16)\tCMPQ\tR9, SI\t;; end of loop\r\n\t0x013d 00317 (main.go:16)\tJLE\t$0, 258\t\t;; check - good\r\n\t0x013f 00319 (main.go:13)\tLEAQ\t1(CX), R9\t\t;; part of **ISSUE #7** - not this way\r\n```\r\n\r\n5. **Expected:**  78498 is expected and that is what is output - not the issue:\r\n\r\n    The issue is the assembly code as viewed when \"go tool compile -S \u003e main.asm\" is run, with a portion of that file as follows:\r\n    ```\r\nOuterLoop:\r\n\tLEAQ\t3(CX)(CX*1), R8 ;; prime 'p' calculation; good, **left in R8 as per ISSUE 1**\r\n\tMOVQ\tR8, R9\t;; **ISSUE 1** fixed\r\n\tIMULQ\tR9, R9\t;; 'sqr' calculation - good\r\n\tADDQ\t$-3, R9\t;; 'sqr' - 3 is good\r\n\tSARQ\t$1, R9\t;; including shortcut divide by 2 - good - left in R9\r\n\tCMPQ\tR9, SI\t;; advance range compare\r\n\tJGT\tPastInner\t\t;; check - good\r\nInnerLoop:\r\n\tMOVQ\tR9, R11\t;; **ISSUE 2** fixed\r\n\tMOVQ\tR9,CX\t;; **ISSUE 4** fixed\r\n\tSARQ\t$5, R11\t;; calculate word address - good\r\n\tMOVQ\t$1,R10\t;; **ISSUE 6** fixed\r\n\tCMPQ\tR11, DX\t;; *** only here if array bounds check\r\n\tJCC\tPANIC\t\t;; *** only here if array bounds check\r\n\tSHLL\tCX, R10\t;; 1 \u003c\u003c ('j'\u00260x1F) - good\r\n\tADDQ\tR8, R9\t;; part of **ISSUE  1** fixed\r\n\tORL\tR10, (AX)(R11*4)\t;; **ISSUE 3** fixed\r\n\tCMPQ\tR9, SI\t;; end of loop\r\n\tJLE\tInnerLoop\t;; check - good\r\nPastInner:\r\n\tMOVQ\t\"\".i+64(SP), CX ;; **ISSUE 7** fixed; 'i' may well already be in another register\r\n\tLEAQ\t1(CX), R9\t\t;; now more available registers, if other register, just ADD $1\r\n```\r\n\r\n    **ISSUE 1:**  Preserves \"2 * 'i'\", that requires a full 'p' calculation inside the loop using an LEAQ instruction at 272, instead of preserving the full 'p' ('i' + 'i' + 3), that would then eliminate needing to recalculate 'p' inside the loop and would allow for a simple add instruction at line 272, which is a little faster.\r\n\r\n    **ISSUE 2:**  Preserves the original in a new register before clobbering the original register in order to save latency (ignoring that the CPU will likely use Out of Order Execution - OOE, anyway), where a simple reordering of instructions would do the same and not require the advanced contents be calculated/moved back to the original register at the end of the loop.  This is a common pattern.\r\n\r\n    **ISSUE 3:**  Ignores that the \"cmpsts[j\u003e\u003e5] |= ...\" can be encoded with a single instruction \"ORL R..., (BASEREG)(INDEXREG*4)\" to save some complexity and time.\r\n\r\n    **ISSUE 4:**  the same as ISSUE 2, where a simple instruction order change can mean that no register use swap needs to be made and alleviates the need for more complex LEA use. \r\n\r\n    **ISSUE 5:**  When a uint32 value is shifted by uint32 bits, the compiler **correctly** eliminates a logical \"and\" by 0x1F (31) as the CPU limits the shift to this anyway; the issue is that if shifted by a uint, it doesn't eliminate it as it should (workaround is to use uint32 for shifts).  We should check to see if a int32 shifted by 31 bits also gets eliminated as it should; in fact any masking above 31 (above 63 for 64-bit registers) is unnecessary.\r\n\r\n    **ISSUE 6** is #16092, where a register is preserved instead of using a simple MOV immediate.  This is pervasive further outside these bounds:  as if the compiler has a - \"avoid immediate MOV at all costs\".\r\n\r\n    **ISSUE 7:**  This instruction is completely unnecessary in restoring a value to the CX register when it never gets used in the loop and gets clobbered for each loop.  Correctly, the CX register should be reloaded if necessary outside the loop. This is issue #14761.\r\n\r\nThe general observation is that the compiler tends to overuse LEA instructions, which instructions are very effective when necessary, but cost a little bit in speed as used instead of other simpler instructions:  they are slightly slower than those simpler instructions, which doesn't seem to be taken into account.\r\n\r\n**Summary:**  The golang compiler is quite a way from being optimum, and won't come close to \"Cee\" (C/C++) efficiency until is comes much closer than this.  The changes here aren't that complex, and some simple rule changes/additions should suffice.  While version 1.7 is better than 1.6, it still is nowhere near as efficient as it needs to be.  Rule changes/additions as suggested above can make tight inner loops run up to twice as fast or more on some architectures and some situations, although not that much here for the amd64 as a high end CPU will re-order instructions to minimize the execution time.",
	"user": {
		"login": "GordonBGood",
		"id": 10696269,
		"type": "User",
		"site_admin": false
	},
	"labels": [
		{
			"name": "Performance"
		}
	],
	"assignee": {
		"login": "randall77",
		"id": 6889504,
		"type": "User",
		"site_admin": false
	},
	"comments": 4,
	"created_at": "2016-06-27T08:41:08Z",
	"updated_at": "2016-06-28T20:30:48Z",
	"milestone": {
		"id": 1709363,
		"number": 38,
		"title": "Go1.8"
	}
}
