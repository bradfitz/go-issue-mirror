{
	"id": 66095041,
	"body": "\u003ca id=\"c5\"\u003e\u003c/a\u003eComment 5:\n\n\u003cpre\u003eRe #4, are you using -N? \n\nWhat I see with -N:\n\n\t000000 00000 (/tmp/x.go:7)\tTEXT\t\"\".F+0(SB),$16-8\n\t000000 00000 (/tmp/x.go:7)\tMOVQ\t(TLS),CX\n\t0x0009 00009 (/tmp/x.go:7)\tCMPQ\tSP,(CX)\n\t0x000c 00012 (/tmp/x.go:7)\tJHI\t,21\n\t0x000e 00014 (/tmp/x.go:7)\tCALL\t,runtime.morestack8_noctxt(SB)\n\t0x0013 00019 (/tmp/x.go:7)\tJMP\t,0\n\t0x0015 00021 (/tmp/x.go:7)\tSUBQ\t$16,SP\n\t0x0019 00025 (/tmp/x.go:7)\tFUNCDATA\t$2,gclocals路e1ae6533a9e39048ba0735a2264ce16a+0(SB)\n\t0x0019 00025 (/tmp/x.go:7)\tFUNCDATA\t$3,gclocals路0115f8d53b75c1696444f08ad03251d9+0(SB)\n\t0x0019 00025 (/tmp/x.go:7)\tMOVQ\t$0,\"\".t+24(FP)\n\t0x0022 00034 (/tmp/x.go:7)\tMOVQ\t$0,\"\".t+24(FP)\n\t0x002b 00043 (/tmp/x.go:8)\tMOVQ\t\"\".statictmp_0000+0(SB),BX\n\t0x0033 00051 (/tmp/x.go:8)\tMOVQ\tBX,\"\".t+24(FP)\n\t0x0038 00056 (/tmp/x.go:8)\tMOVQ\t$type.int+0(SB),(SP)\n\t0x0040 00064 (/tmp/x.go:8)\tPCDATA\t$0,$16\n\t0x0040 00064 (/tmp/x.go:8)\tPCDATA\t$1,$1\n\t0x0040 00064 (/tmp/x.go:8)\tCALL\t,runtime.new(SB)\n\nWhat I see normally:\n\n\t000000 00000 (/tmp/x.go:7)\tTEXT\t\"\".F+0(SB),$16-8\n\t000000 00000 (/tmp/x.go:7)\tMOVQ\t(TLS),CX\n\t0x0009 00009 (/tmp/x.go:7)\tCMPQ\tSP,(CX)\n\t0x000c 00012 (/tmp/x.go:7)\tJHI\t,21\n\t0x000e 00014 (/tmp/x.go:7)\tCALL\t,runtime.morestack8_noctxt(SB)\n\t0x0013 00019 (/tmp/x.go:7)\tJMP\t,0\n\t0x0015 00021 (/tmp/x.go:7)\tSUBQ\t$16,SP\n\t0x0019 00025 (/tmp/x.go:7)\tFUNCDATA\t$2,gclocals路e1ae6533a9e39048ba0735a2264ce16a+0(SB)\n\t0x0019 00025 (/tmp/x.go:7)\tFUNCDATA\t$3,gclocals路0115f8d53b75c1696444f08ad03251d9+0(SB)\n\t0x0019 00025 (/tmp/x.go:8)\tMOVQ\t\"\".statictmp_0000+0(SB),BX\n\t0x0021 00033 (/tmp/x.go:8)\tMOVQ\t$type.int+0(SB),(SP)\n\t0x0029 00041 (/tmp/x.go:8)\tPCDATA\t$0,$16\n\t0x0029 00041 (/tmp/x.go:8)\tPCDATA\t$1,$1\n\t0x0029 00041 (/tmp/x.go:8)\tCALL\t,runtime.new(SB)\n\nThe single-word value t+24(FP) is being registerized and the optimizer can see it's dead\neven though the liveness cannot. We could change the optimizer to match the liveness or\nwe could change the liveness to match the optimizer.\n\nI've done some experiments to understand what other cases are broken. It's more than\njust composite literals - not surprising since they just compile into simpler code.\n\nAny aggregate (struct, array) that can be fully registerized due to use of componentgen\nfor assignment has this problem. For example, 4-word structs registerize on 6g, so this\nprogram demonstrates the same issue:\n\npackage main\n\ntype T struct {\n\tP *int\n\tQ *int\n\tR *int\n\tS *int\n}\n\nfunc F() (t T) {\n\tt.P = new(int)\n\tt.Q = t.P\n\tt.R = t.P\n\tt.S = t.P\n\tF()\n\treturn\n}\n\nt is live at the call to new but all the fields are set afterward so the optimizer\neliminates all the earlier stores.\n\nIf you drop any of the assignments, so that some field in t is live across the call,\nthen all fields will be preserved by the registerizer - there is already code to expand\n'one' to 'all', more for multiword values like slices or interfaces than for this case.\nBut if none are live, that code doesn't trigger.\n\nArrays are the same:\n\npackage main\n\ntype T [4]*int\n\nfunc F() (t T) {\n\tt[0] = new(int)\n\tt[1] = t[0]\n\tt[2] = t[0]\n\tt[3] = t[0]\n\tF()\n\treturn\n}\n\nGiven this, it seems like we must change the optimizer to match the liveness, except\nthat I think it is hard for the optimizer to guess what the liveness is going to decide,\nand the liveness runs last (because it must record actual stack locations, which are\ninfluenced by the optimizer's passes).\n\nPerhaps the optimizer can push a VARDEF for a variable forward to the next mention of\nthe variable.\n\nStill thinking.\u003c/pre\u003e",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-05-28T23:36:02Z",
	"updated_at": "2014-12-08T10:44:32Z"
}
