{
	"id": 66095508,
	"body": "\u003ca id=\"c8\"\u003e\u003c/a\u003eComment 8 by **google@barrera.io**:\n\n\u003cpre\u003e\u003e I don't think so, because, a) the internet is always broken somewhere, it's hard,\npointless to provide a diehard API, b) your node configuration is your matter, API\ndoesn't care, c) API already provides several control knobs; for example, you can pick\nyour favorite one from:\n\na) But other languages do so. But not fixing this, I, as an end user find that\nconsistenly go application simply \"won't work\", with nothing I can do about them.\nc) Yes, my node is configured properly. Only go (and nodejs) applications fails. Every\nother library and language out there has managed to fix this.\nc) *I* can't. Not as an end user. Developers can, but I can't go around telling devs of\ndozens of different applications to start working around issues that could be fixed in a\ncore/library they all share in common.\n\n\u003e I think dealing with connected routes and/or assigned routable addresses doesn't make\nsense. How could we know that address belongs to which line: expensive LTE mobile line,\nsecure and censored company-VPN line, or dark/honeypot stuff. Instead you can implement\nyour own smart stuff that gathers environment information and selects the situational\npath, and connect to the resources using net.Dial.\n\nThat would be secondary. I think it's better if applications accidentally use a slower\nconnection rather than simply fail with no possible workaround. If I have *no* IPv4\nroutes, it's safe to assume IPv6 should be defaulted.\n\nWhy not just try the AAAA record if the A one failed? Once both fail, consider it a\nfailure. That's rather simple, and would not add any new issues or regressions.\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-06-06T23:43:21Z",
	"updated_at": "2014-12-08T10:45:02Z"
}
