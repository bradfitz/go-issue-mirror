{
	"id": 186366415,
	"body": "@bradfitz:\r\n\u003e The problem is that with \"reasonable\" flow control, reasonable often isn't known \r\n\r\nThere are two or three directions you can go with that, but they're ~all application-side: there is no change you can make to the runtime that fixes the problem that \"reasonable often isn't known\".  The problem is fundamentally one of balancing resource predictability against peak resource usage, and that depends very much on your execution environment: a reasonable \"peak usage\" on a small end-user desktop running many programs is fundamentally very different from a large server with strong resource isolation and/or only a few tasks.\r\n\r\n\u003e and implementations of interfaces can be selected at runtime with totally different properties.  Camlistore uses a package to do a VFS where different paths are mounted with different file implementations\r\n\r\nThat's an application design problem: do you want to maximize throughput, optimize for resource predictability, or both?  If you want to optimize for predictability, then you need some kind of estimate of the usage that each implementation is potentially going to need *at peak* (not just what it is currently using), and then you can implement a global throttle where each implementation says \"I'm going to need X resources\" and the throttle blocks it until those resources are available.  Presumably the /memfile implementation would use a different value for \"X\" than the ext3 one.\r\n\r\nBut that's all something you can only apply at the application layer: only you know what the peak resource consumption of each implementation is going to be like.\r\n\r\n----\r\n\r\nThere is certainly a broad design space for \"static analysis of peak resource consumption of a function call\", but Go is not exactly designed to be amenable to that kind of analysis.\r\n\r\nIf you want to do the equivalent dynamic analysis, you basically only have three options: failure (the current behavior when we exhaust the thread limit), blocking (with the associated risks of deadlock and/or priority inversion), or forcible cancellation of pending work (e.g. causing an arbitrary goroutine to panic when we run out of resources, but most Go code is not written to be panic-safe and it's not clear how you choose which goroutine to kill without risking livelock anyway).  None of those three options can be applied safely to arbitrary Go programs.  All of those options would violate Go 1 compatibility: they could cause previously correct-but-resource-intensive programs to become \"incorrect\" programs.\r\n\r\nThe only viable solution for Go as it is today is for application programmers who care about resource footprints to carefully apply their own flow-control at the application layer.",
	"user": {
		"login": "bcmills",
		"id": 5200974,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-02-19T19:18:25Z",
	"updated_at": "2016-02-19T19:18:25Z"
}
