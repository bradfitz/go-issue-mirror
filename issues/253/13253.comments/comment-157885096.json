{
	"id": 157885096,
	"body": "Here is an alternative proposal that tries to find a compromise between tables and strided slices. I tried to make it short, so it is not detailed at all,  but I hope everything will be well understood from the examples.\r\n\r\nStrided slices are generated slicing a slice (or array) in two or more dimensions. A slice expression in N dimensions consists of N ranges separated by commas.\r\n\r\n    s := make([]float64, 16)\r\n    m44 := s[:4,:4]  // == s[:4,:] == s[:4,] type [,]float64\r\n    m224 := m44[:2,:2,:4]  // == m44[:2,:2,] == s[:2,:2,] type [,,]float64\r\n\r\nIndexing a strided slice of N dimensions returns a strided slice of N-1 dimensions, or a slice if N is 2. Sugar: `m[i,j] == m[i][j]` (may be valid for slices of slices and arrays of arrays too).\r\n\r\n    r1 := m44[1]  // == s[4:8]\r\n    f12 := m44[1,2]  // == m44[1][2] == s[6]\r\n    f112 := m224[1,0,2]  // == m224[1][0][2] == s[10]\r\n\r\nSlicing a strided slice with the number of dimensions it has generates another strided slice with the same number of dimensions.\r\n\r\n    m22 := m44[1:3,1:3]  // type [,]float64\r\n    col1 := m44[:,1:2]  // type [,]float64\r\n    row1 := m44[1:2,:]  // type [,]float64 NB: m44[1:2,:] != m44[1]\r\n\r\nThe builtins len and cap applied to strided slices return the total number of indexable elements and the total number of contiguous elements in memory, respectively (therefore, if capacity is larger than length, it means that the strided slice has elements that cannot be accessed).\r\n\r\n    n, c := len(m44), cap(m44)  // == 16, 16 =\u003e contiguous\r\n    n, c = len(m22), cap(m22) // == 4, 6 =\u003e not contiguous\r\n\r\nTwo new builtins: dim returns []int with the dimensions and flat returns a slice with all the indexable elements (requires allocation and copying if len != cap, else it returns a slice of the original data)\r\n\r\n    d := dim(m224) // d == []int{2,2,4}\r\n    m28 := flat(m224)[:2,]  // reshape, same backing array\r\n    d = dim(m28)  // d == []int{2,8}\r\n    s4 := flat(m22)  // requires allocating a [4]float64 and copying 2 slices of length 2\r\n\r\nRange expressions work like for slices (from 0 to dim(ss)[0]), with the addition of a new form with index variables for each dimension:\r\n\r\n    for i, m2d := range(m3d) {\r\n        for j, row := range(m2d) {\r\n            for k, v := range(row) {\r\n                fmt.Printf(“m[%d,%d,%d] = %f\\n”, i, j, k, v)\r\n            }\r\n        }\r\n    }\r\n\r\n    for i, j, k, v := range(m3d) {\r\n        fmt.Printf(“m[%d,%d,%d] = %f\\n”, i, j, k, v)\r\n    }\r\n\r\nImplementation of strided slice of N dimensions (other representations are possible):\r\n\r\n    struct {\r\n        array *T\r\n        dim [N]int\r\n        stride [N-1]int\r\n    }\r\n\r\nWhat do you think?\r\n\r\n",
	"user": {
		"login": "yiyus",
		"id": 14241009,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-18T22:27:09Z",
	"updated_at": "2015-11-18T22:27:09Z"
}
