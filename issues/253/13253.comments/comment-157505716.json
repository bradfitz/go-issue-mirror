{
	"id": 157505716,
	"body": "This is a lot more feedback than I expected.\r\n\r\n@griesemer You're right: the proposed syntax doesn't work.  The ambiguity between a strided slice of arity \u003e 1 and a strided slice whose slice elements are strided slices is bad.  A better syntax might be what @nsf suggested: `[,]T` for a strided slice of arity 1 and type `T`.  Then we can use `[,,]T` for a strided slice of arity 2.  But now I'm not sure how to write a strided slice expression.  We could use `a[stride,]` with a trailing comma, but that is kind of ugly.\r\n\r\n@griesemer You're right: there is currently no obvious way to go from a strided slice back to a regular slice.  At first I thought you could index into the strided slice and use a slice expression, but that doesn't work because the cap of the index expression will limit you to the stride.  In order to go back based only on the strided slice, the strided slice would need to keep a copy of the cap of the original slice.  That could be done, but I don't know how often people will want to do that operation.\r\n\r\n@nsf You're right: the arity number is confusing.  Perhaps better to talk about the dimension, which is the arity plus 1, as you suggest.\r\n\r\n@nsf The suggestion of allowing an empty index to convert from the strided slice back to a regular slice is an interesting one, and it does seem implementable.  I can't think of any problem with it off hand.\r\n\r\n@somadivad As far as I can see this approach isn't going to support a transpose operation.  But I'm pretty sure that strided slices would be more efficient, and easier to set up, than slices of slices, because slices of slices require additional pointer fetching.\r\n\r\n@sbinet I think the implementation in the reflect package follows directly from the discussion of the internal implementation.\r\n\r\n@btracey I don't think your proposal is fundamentally flawed, though I do think it should plan for multiple dimensions right from the start.  I think the main advantage of this proposal is that it allows for different strides across the same data.  You've indicated in the past that you don't feel this is important, and it may not be, but it seems to me that there are people commenting here who would find that feature valuable.\r\n\r\n@btracey You're right that rectangular views are more awkward.  You have to do them by dropping down to the original slice and doing a new strided slice.  Something like `ss[,][a:d][b,]`.\r\n\r\n@btracey I agree that cap is needed for append operations, it's just not clear to me why anybody would use append on a strided slice.  You're right: you can't build up a matrix row by row using a strided slice.  But your proposal doesn't have append either, and I'm actually not sure why you have a capacity, must less two capacities.\r\n\r\n@kortschak I don't know the optimization to which you are referring.\r\n\r\n@somadivad I don't think the language should support an operation like transpose that implicitly allocates and copies.  That kind of operation should be done using a function call.",
	"user": {
		"login": "ianlancetaylor",
		"id": 3194333,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-17T20:59:39Z",
	"updated_at": "2015-11-17T20:59:39Z"
}
