{
	"id": 157992843,
	"body": "Thanks for your comments.\r\n\r\n\u003e Access/assignment\r\n\r\nI do not know what you mean by \"address overloading\". I have left away of the proposal the case of mixing single and multiple indices for brevity.\r\n\r\nThe idea is that only one index can be used in strided slices, multiple indices separated by comas are just syntactic sugar with the rule `t[i,j] == t[i][j]`. The cases you propose could be valid if the norm said that i must be a single index and j can be a single index or a slice expression in one or more dimensions, such that:\r\n\r\n    t[0, :, :] == t[0][:, :] ( == t[0] )\r\n    t[0, 1, :] == t[0,1][:] == t[0][1][:] ( == t[0][1] )\r\n    t[0, 1, 2] == t[0,1][2] == t[0][1,2] = t[0][1][2]\r\n\r\nThe behavior with one index is like Ian's strided slices. Applying this syntactic rule, the tables syntax is obtained. This norm could even be extended to slices of slices and arrays of arrays. It is a feature completely orthogonal to the a new type that could be discussed later.\r\n\r\n\u003e Capacity:\r\n\r\nUnless I am missing something, I think views are allowed in the implementation I propose. Please, let me know what is the exact problem you see. For example:\r\n\r\n    var a [16]float64\r\n    m44 := a[:4,:4]  // {array: a, dim: [4, 4], stride: [4]}\r\n    m22 := m44[1:3,1:3]  // {array: a[5], dim: [2, 2], stride: [4]}\r\n    m22[i,j] == a[5 + i*4 + j] // with i \u003c 2 and j \u003c 2\r\n    n, c := len(m22), cap(m22) // == 4, 6 == dim[0] * dim[1], (dim[0] - 1) * stride[0] + dim[1]\r\n\r\nWhile cap gives you the total number of elements you are storing, len tells you how many you can actually use. The utility of cap is indeed quite limited, but it is there to let you know if a flat operation will require an allocation or not. Also, in an extreme case like m[:2,:10000][:2,:2], it can be useful to know that you are storing more than 10000 elements when you are using only 4 (for example, you may decide to flat and reshape when len/cap reaches a certain ratio).\r\n\r\n\u003e Range:\r\n\r\nThis case would return two integers in case s is a []int, but not if it is a [,]int. It would return an int and a []int. To get both indices you would use `for i, j, _ := range s`\r\n\r\nI think you are misunderstanding something in my proposal. Range for strided slices works exactly like for slices of slices:\r\n\r\n    s := make([]float64, 4)\r\n    m22 := [][]int{s[0:2], s[2:4]}\r\n    for i, row := range m44 {\r\n        for j, v := range row {\r\n            // ...\r\n        }\r\n    }\r\n    // using m22 := s[:2,:2] would be equivalent\r\n\r\nIn the new case proposed, all the indices must be present (`for i, j, v := range m22`). This special case could again be applied to slices of slices and arrays of arrays too, and it is an orthogonal feature to strided slices that could be considered separately.\r\n\r\nTo iterate over the elements in the column you would slice a column and iterate over all the elements (`for i, _, v := range m[:,nc:nc+1]`) or would index in a row (`for i, row := range m { /* use row[nc] */ }`) or the whole matrix (`for i := 0; i \u003c dim(m)[0]; i++ { /* use m[i, nc] */ }`).\r\n\r\n\u003e Slice expressions:\r\n\r\nI was trying to mimic the behavior of slicing an array. The problems here are the same as when we do `a[:5]` and a can be an array or a slice. We do not do something like `slice(a, 0, 5)` or `a.([]int)[:5]` and it is not a problem you frequently see. But maybe a builtin could be a valid option too.\r\n\r\n\u003e Conclusion:\r\n\r\nSomething I am trying with my proposal is to reduce it as much as possible. Initially, I think it could consist of only a new type, the slicing in multiple dimensions operation (which could be a reshape builtin), and minimal changes to len, maybe cap and range to support the new type. I think this would give us enough to have views. What would you be missing for gonum then?\r\n\r\nAdditional features could be added later, eventually converging to something very similar to the tables in your proposal, but with multiple dimensions. For example, it would be possible to add more builtins (like dim, flat or reshape and support in make, copy and maybe append), syntactic sugar (like multiple indices separated by comas and new range expressions) and maybe capacities in multiple dimensions.\r\n\r\nIt would be great if we could find a general agreement in the basic type first.",
	"user": {
		"login": "yiyus",
		"id": 14241009,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-19T08:54:27Z",
	"updated_at": "2015-11-19T08:54:27Z"
}
