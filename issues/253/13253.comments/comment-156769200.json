{
	"id": 156769200,
	"body": "Hi, I was just passing by and noticed this discussion, which is rather interesting to me (as a hobby I write voxel stuff in C++ sometimes: https://github.com/nsf/nextgame/blob/master/source/Geometry/HermiteFieldToMesh.cpp). Just wanted to point that out, because it means I work with 3 dimensional data a lot and I care about efficiency. So, I hope you don't mind some input from just a stranger who also happens to be a Go user. After I introduced myself, few comments:\r\n\r\n1. I agree with @griesemer, `[*][*]T` syntax is slightly confusing. Because it implies a \"slice of slices\" kind. Similar syntax dispute can be seen in C# community, where they have both arrays of arrays as `int[][]` and multidimensional, but contiguous arrays as `int[,]`. A note about implementation implies that N-arity strided slices are a single thing and not a \"slice of slices\" kind, hence using something like `[,,,]int` for N-arity makes more sense. I will use `[,]int` syntax from now on.\r\n\r\n2. While technically saying that arity is a number of strides in strided slice is correct and hence `[,]int` is a 1-arity strided slice, imho people will find it confusing. Essentially 1-arity slice represents a two-dimensional array. Just wait when someone replaces arity with dimensionality and starts to say 1-dimensional strided slice. Perhaps it can be seen as correct as well, but confusing. My proposal: in terminology let's keep things closer to dimensionality of arrays, this is what most people are familiar with. `[,]int` is a strided slice which gives access to two-dimensional data. `[,,]int` is a strided slice which gives access to three-dimensional data.\r\n\r\n3. A good focus point in explanations would be to emphasize that stride is not dimensionality, while it may seem like one for 2-dimensional arrays. For a 3-dimensional array 3x3x3, strided slices will have two strides, one is 9 and the other is 3. Of course experienced people understand the difference, but education is important. It's a small note, when explaining strides - start with a 3-dimensional arrays.\r\n\r\n For math geeks, offset to an element calculated using strides:\r\n `offset = i1 * S1 + i2 * S2 + ... + iN * SN`\r\n\r\n This is what our CPUs love the most - linear math.\r\n\r\n4. As for \"strice expressions\" as Robert calls them. We can use a similar syntax mentioned above: `a[D,]`, which is an equivalent to `a[D,len(a)/D]`. For more than 2-dimensions the math gets slightly more complicated, but the idea is the same: `a[D1,D2,D3,]`. A good question would be: why `a[D,]` and not `a[,D]`. And given what I said in point number three, why I use **D** here instead of **S**.\r\n\r\n Let me elaborate on this a bit more. One of the most common things you will use this \"strice expression\" for is to go from slices to strided slices and back. See, we need a way to go back. I'll explain going back in point number 5, but let's talk about `slice -\u003e strided slice` path first.\r\n\r\n People are comfortable with dimensions. The stride matches one of the dimensions of an array in 1-arity case. But in 2-arity (3 dimensions) and further, strides are different from dimensions and when you perform \"stricing\", doing math manually seems pointless. However, people get confused by the whole \"row-major\" vs \"column-major\" thing. And the answer to that problem is really simple, because both are invalid when we talk about computing. Computer memory is linear and terms rows/columns do not apply here. In that regard I appreciate the stride term. But let's try to combine the two and put it this way for Go: **first dimension affects first stride**. We don't have rows and columns, so I'm not saying that first dimension is a row or column, both would be incorrect, but it does define a first stride value and in this sense it has a very perfect low level and semantical meaning. And this is how we will define multidimensional arrays in Go, in terms of strides. The formula for calculating strides from dimensions would be (I use functional notation instead of subscript here, sorry, markdown limitations):\r\n ```\r\nS(N) = S(N-1) / D(N), when N \u003e 0\r\nS(0) = len(slice)\r\nwhere S - stride, D - dimension\r\n```\r\n\r\n Let's go super formal and define slices as strided slices with stride equals 1 (and in addition they return elements instead of slices). Checking our formula. Having a slice of 10 elements, `S(1) = S(0) / D(1)`. Slice is a 1-dimensional thing and size of the dimension matches its length. Hence `S(1) = 1`. Seems correct.\r\n\r\n Let's say I have an array of 12 elements and I want a strided slice with stride 2, as a result we call it a two-dimensional array with dimensions: 6x2 (in that order). This will be the only order defined by Go semantically. What matters here is memory representation and strides.\r\n\r\n `S(1) = S(0) / 6 = 2`\r\n `S(2) = S(1) / 2 = 1`\r\n\r\n Because indexing a striding slice returns a strided slice (for our formality experiment nothing but strided slices exist). We can see how stride of a returned slice is 1, which makes it an ordinary slice.\r\n\r\n We would write this in code this way: `ss := s[6,]` or `ss := s[6,2]`. Because our notation of dimensions say that the first dimension affects the first stride and the second one affects the second stride. Of course in reality there is only one stride value, because the last one is always 1. This is also why last dimension is optional. We know the last stride is always 1. Stride of 1 means we have a normal slice. I hope you get what I mean.\r\n\r\n Similar for 3 dimensions. Let's say I have an array of 27 elements and I want a strided slice with strides 9 and 3, which represents a 3x3x3 array. So I can do it this way: `ss := s[3,3,]`. Checking math:\r\n\r\n `S(1) = S(0) / 3 = 27 / 3 = 9`\r\n `S(2) = S(1) / 3 = 3`\r\n `S(3) = S(2) / 3 = 1`\r\n\r\n In my opinion this way of connecting abstract term **dimension** with a very precise and technical term **stride** will yield a lot of benefits for Go programmers. Forget about rows and columns, please!\r\n\r\n5. And the final part. When we work with multi-dimensional arrays, we store them in memory and in other places as one-dimensional data. As a result of that process we often need to convert multi-dimensional data to a slice. For example if I have a 128x64x64 voxel array, at some point I might decide to copy a 2x64x64 chunk at the bottom of this array from another one. The question is - how would I do it with strided slices? ss[0] yields a strided slice which represents another strided slice which represents 64x64 array. Can I get a slice with length `2*64*64` directly? Can I convert arbitrary part of a strided slice of any arity to a slice? While most operations which operate on a part of N-dimensional array do it on a line level, sometimes I need that low level access to the whole data. You can even view it simpler. What if I have a strided slice of 128x64x64 3d array. Can I get a slice of length `128*64*64`, because I want to pass it down to a compression algorithm? Seems like Ian mentioned some of that, but using `*`-based syntax is very confusing.\r\n\r\n I think if we just use `[,,]` syntax it will be easier to understand. Let me try to make a few examples, based on my 128x64x64 array above.\r\n\r\n `ss := s[128,64,64]` creates a strided slice `[,,]T`\r\n `ss[0]` yields a 64x64 strided slice `[,]T`\r\n `ss[0:2]` yields a 2x64x64 strided slice `[,,]T`\r\n\r\n Which is great for getting strided slices from strided slices, but how do we get slices from strided slices? At some point Go had implicit conversion from arrays to slices, I don't think we need to repeat that idea with strided slices and allowing implicit conversion from strided slices to slices. But we have a lot of libraries which use slices, how can we connect two worlds?\r\n\r\n Technically it seems it should be allowed to convert any strided slice to a slice, but what's the syntax? Perhaps explicit conversion would suffice? `[]T(ss)`?\r\n\r\n Let me give you one more example why I need it:\r\n\r\n ```go\r\nvar a [,,]int // strided slice of 128x64x64 voxels\r\nvar b [,,]int // strided slice of 128x64x64 voxels\r\n// copy a chunk of 2x64x64 at the bottom of 'b' to the top of 'a'\r\ncopy([]int(a[len(a)-2:]), []int(b[:2])\r\n```\r\n\r\n Explicit conversion ruins fun quite a bit, but we need to connect the two worlds somehow.\r\n\r\n6. And the final final part is just an idea. If we talk about efficency, can we have fixed-size strided slices? Syntax allows the type: `var a [128,64,64]int`. Pros: no need to store stride values anywhere, Cons: size is fixed. It seems we can allow \"stricing\" a fixed-size strided slice just like slicing an array.\r\n \r\n",
	"user": {
		"login": "nsf",
		"id": 12567,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-15T01:30:02Z",
	"updated_at": "2015-11-15T01:54:02Z"
}
