{
	"id": 157527486,
	"body": "@ianlancetaylor  : Our notations are converging with different semantics. Below when I say [,]T, I am referring to my proposal, and I use the [\\*] notation for yours to distinguish.\r\n\r\n\u003e I do think it should plan for multiple dimensions right from the start.\r\n\r\nThe message we thought we were receiving from the Go team when it was originally written is different than the one now. Now that the initial proposal is in, I'll adapt it to include arbitrary dimensions. \r\n\r\n\u003e  You have to do them by dropping down to the original slice and doing a new strided slice. Something like ss[,][a:d][b,]\r\n\r\nI don't see how your sub-expression creates the correct view. If we have a 2-D slice, for example\r\n````\r\n0 1 2 3 \r\n4 5 6 7\r\n8 9 10 11\r\n12 13 14 15\r\n````\r\nWe need to be able to do t2 := t[1:3, 1:3] to give us\r\n````\r\n(0 1 2 3)\r\n(4) 5 6 (7)\r\n(8) 9 10 (11)\r\n(12 13 14 15)\r\n````\r\nwhere the data in parenthesis exists but isn't accessible through the sliced table. t2[0,0] == 5.\r\n\r\nIn your proposal, we can do ss := a[5:13]\\*[4]   (I think that's the syntax), but that gives us\r\n````\r\n(0 1 2 3 4)\r\n5 6 7 8\r\n9 10 11 12\r\n(13 14 15)\r\n````\r\nAn extra parameter is still needed to remember the effective number of columns.\r\n\r\n\u003e  it's just not clear to me why anybody would use append on a strided slice\r\n\r\nFor example, building up a matrix one element at a time when the full size is not known ahead of time. In Gaussian Processes, for example, one bulids up a Kernel matrix, where K_i,j = kernel(x_i, x_j). It is very typical that a prediction is made with N points. This prediction gives you the N+1th point, and then you expand the kernel matrix given the new point. Something along the lines of:\r\n````\r\nn := len(t)[0]\r\nif n == cap(t)[0] {\r\n      // allocate new table and slice\r\n      tnew = make([,]float64, n*2, n*2)\r\n      copy(tnew, t)\r\n      t = tnew[:n, :n]\r\n}\r\nt = t[:n+1, :n+1]\r\n// Add kernel data to row and column n+1\r\n````\r\nWithout slicing, either this make/copy needs to happen on each new data entry, or lots of meta data needs to be maintained about the effective size of the matrix. Capacities are necessary for both dimensions to see if you've sliced outside either bound, just like in normal slices. You can imagine code similar to the above, except extending an additional row or column. My proposal does not include behavior for append because it is not clear how to represent clean syntax for all of the possible cases, even though the behavior is useful.\r\n\r\nOne can argue that only one capacity is needed since the stride is equal to the capacity. However, it was felt that if one can do 3-element  slicing on []T, so should one be able to do so with [,]T.\r\n\r\n\u003e  I think the main advantage of this proposal is that it allows for different strides across the same data. You've indicated in the past that you don't feel this is important\r\n\r\nWhat I intended to say is that (copy-free) views are much more important than (copy-free) re-sizing, and that the interaction between the behaviors is not simple. I have been thinking about this since your proposal, and have been considering what could be done, if anything, about it. In particular, there are especially nice cases for resize when trying to avoid allocations. For this reason, it is worth thinking about some form of strided slice expression to allow a []T to go to a [,]T  (or a [,,]T or whatever). Possibly there can be a built-in function \r\n````\r\npack([]T, int...)\r\n````\r\nWhich turns a []T into a [,]T, with the given sizes (length = capacity) and the number of integer arguments must be fixed at compile time.\r\n\r\nGoing in the other direction (the equivalent unpack function) is much trickier. The expression\r\n````\r\npack(unpack(t), len(t)...)\r\n````\r\ndoes not return the original table if the table has been viewed.\r\n\r\nIn terms of other languages, Matlab copies everything. The reshape function in Numpy will either copy or not depending if the ndarray has been sliced (Go's implementation would have to be predictable). Julia does seem to be headed toward both being copy free (during their arraymageddon release). This sounds great, except in the end the type of the data may end up as ReshapedArray{SubArray{ReshapedArray{... T ...}}}. This is the opposite of simple. Additionally, this highly complicates array  accesses (see discussion: https://groups.google.com/forum/#!msg/julia-dev/7M5qzmXIChM/kOTlGSIvAwAJ and PR: https://github.com/JuliaLang/julia/pull/10507).  To quote directly from the discussion \"Specifically, reshaping does not compose with subarray-indexing, so you need two types of views\".\r\n\r\nIn short, I don't see a way to implement arbitrary re-sizing and also support views. I do agree that the pack code listed above would be useful, though perhaps that's best left as a function in Reflect. ",
	"user": {
		"login": "btracey",
		"id": 3680859,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-17T22:17:02Z",
	"updated_at": "2015-11-17T23:23:42Z"
}
