{
	"id": 157451087,
	"body": "Thanks for the reply. \r\nIn the general case, generators are not a good solution, at least in the sense of creating a domain specific language solely for making matrix operations a little better. This creates language bifurcation and means that users need to deal with multiple languages simultaneously (see: arguments for translating the compiler to go). \r\n\r\nI do not feel like the general discussion is asking for a bullet list of features. Just one feature (rectangular data support), and the rest is how that data type interacts with the language. As you say 'is there something from the language that would make this work better', and we think yes, the table data type.\r\n\r\nSpecifically to your points:\r\n- Types: As this is generic, it will already support all types\r\n- Layout: There are so many ways to implement sparse matrices (see all of the ScaLapack types). Supporting these types needs to happen at the package  level. Many important sparse matrices (block dense for example) benefit highly from having a table type to use in the underlying implementation. Your other examples (all the banded types) are already implemented using a rectangular data structure (see for example the documentation about Banded matrices https://godoc.org/github.com/gonum/blas/native)\r\n- Distribution/Access: Goroutines go a long way to addressing these issues. A fork-join model is very simple to code (https://godoc.org/github.com/gonum/blas/native#Implementation.Dgemm is already coded this way).\r\n- Operators: As discussed in my proposal, most operators are just as easily implemented as functions/methods. It's a couple extra characters, but it's a price you're frequently willing to pay anyway to save allocations, etc.\r\n- Aliasing: Again, best implemented at the package level as we have in gonum/matrix.\r\n\r\nThe point of the above discussion is that tables go a long way to address all of these issues, and this is not a Pandora's box for requesting more features (at least on our end). Compiler optimizations are extremely useful. SSA is moving toward bounds checking alleviation, and I hope they work on SIMD next (it's already there for copy). As documented in my proposal, however, tables make it much easier to implement such optimizations.\r\n\r\nGenerators, a la go generate, are useful in dealing with the generics problem. In fact, we autogenerate the float32 BLAS implementation from the float64 implementation. Generics/Generators can only go so far though, the complex128 implementation has different behavior in many cases, so specialized code is necessary. I imagine this would be the case with a quaternion256 as well -- you'd need specialized code to say what \"transpose\" means (I suspect). ",
	"user": {
		"login": "btracey",
		"id": 3680859,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-11-17T17:50:04Z",
	"updated_at": "2015-11-17T17:50:04Z"
}
