{
	"id": 66095283,
	"body": "\u003ca id=\"c3\"\u003e\u003c/a\u003eComment 3 by **toddw@google.com**:\n\n\u003cpre\u003eWhile admittedly this issue comes up rarely in regular code, as a data point, I run into\nthis issue quite a bit.  I've built an RPC stub compiler that takes an API specified in\nmy own language, compiles it, and then generates RPC stubs in different languages.  Go\nis the core generated language.\n\nAs a simplified example, let's say the user tells me to generate stubs for a RPC\nfunction \"Print\" that streams int32 from client to server, and streams strings from the\nserver back to the client.  Here's the Go API that I generate for the user on the client\nside.\n\ntype PrintClientStream interface {\n\t// SendStream returns the send side of the client stream.\n\tSendStream() interface {\n\t\tSend(item int32) error // Places an item on the output stream\n\t\tClose() error // Indicates no more items will be sent\n\t}\n\t// RecvStream returns the receiver side of the client stream.\n\tRecvStream() interface {\n\t\tAdvance() bool // Stages an item to be retrieved via Value\n\t\tValue() string // Returns the staged item\n\t\tErr() error // Returns errors\n\t}\n}\n\nObviously the choice of \"int32\" and \"string\" are up to the user, as is the RPC function\nname.  The reason SendStream() and RecvStream() return anonymous interfaces is because\nof this issue.  A client may need to use two different services that define different\nAPIs, but result in the same streaming types; client sends int32 and receives string. \nI'd like them to be able to write a single function that operates over the two different\nPrintClientStream interfaces.  But if I named the return types from SendStream and\nRecvStream, they'd lose this ability.\n\nI also have a straw man proposal.  \n\nI understand the concepts of type identity and assignability as defined in the language\nspec:\n\u003ca href=\"http://golang.org/ref/spec#Properties_of_types_and_values\"\u003ehttp://golang.org/ref/spec#Properties_of_types_and_values\u003c/a\u003e\n\nI also appreciate the consistency of the current type identity rules wrt named types: a\nnamed and an unnamed type are always different.  Whenever you see a \"type\" declaration\nin a source file, you know that a distinct type is being defined.\n\nLet's say we changed the language spec to say that type identity for interfaces ignores\nthe name.  I.e. interface names are simply a convenient shorthand, but for type identity\npurposes, it's as if every interface were anonymous.  The rules for comparing these\ninterfaces remains the same; it's an order-agnostic comparison of method names and their\nfunction types, and unexported methods in different packages are always different.\n\nI think this is a nice and consistent way to specify this feature.  The main downside I\nsee is that it's yet another special-case in the language spec.  But interfaces are\nalready special; we already have the special-case in our value assignability rules.\n\n\u0026lt;wishful thinking\u0026gt;\nIf you haven't tuned out so far, here's a thought.  Why wait until Go2 to incorporate\nthis feature?  My rationale: it seems unlikely that anyone was actually relying on the\nexisting semantics.  After all the compiler has ensured that all static type checks obey\nthe existing rules, and we're simply relaxing those rules so that more cases are allowed.\n\nBut for full disclosure, I do recognize that if we change this in Go1, existing code can\nnotice a change in behavior.  After all we provide type assertions in the language, as\nwell as the reflect package.  E.g.\n\n\u003ca href=\"http://play.golang.org/p/OscKQCdDOL\"\u003ehttp://play.golang.org/p/OscKQCdDOL\u003c/a\u003e\n\nThat's where my wishful thinking comes in.  I can't think of a reasonable way someone\nwould be using the existing semantics; my assertion is that if they're relying on\nsomething this subtle, their code deserves to be broken (and I'm only half-kidding). \nBut I can see that if we strictly follow the Go 1 compatibility rules, we simply cannot\nchange this feature, regardless of how much the code that relies on this deserves to be\nbroken.\n\nThoughts?\u003c/pre\u003e",
	"user": {
		"login": "gopherbot",
		"id": 8566911,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-11-08T18:52:38Z",
	"updated_at": "2014-12-22T06:34:57Z"
}
