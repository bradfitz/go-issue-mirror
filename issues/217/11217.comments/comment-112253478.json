{
	"id": 112253478,
	"body": "It is hit and miss, but I can reproduce the failure sometimes. Given this changes:\r\n```\r\ndiff --git a/src/cmd/go/go_test.go b/src/cmd/go/go_test.go\r\nindex cdbdfd7..1d78fa2 100644\r\n--- a/src/cmd/go/go_test.go\r\n+++ b/src/cmd/go/go_test.go\r\n@@ -8,6 +8,7 @@ import (\r\n \t\"bytes\"\r\n \t\"flag\"\r\n \t\"fmt\"\r\n+\t\"io\"\r\n \t\"io/ioutil\"\r\n \t\"os\"\r\n \t\"os/exec\"\r\n@@ -16,6 +17,7 @@ import (\r\n \t\"runtime\"\r\n \t\"strconv\"\r\n \t\"strings\"\r\n+\t\"syscall\"\r\n \t\"testing\"\r\n \t\"time\"\r\n )\r\n@@ -419,6 +421,120 @@ func (tg *testgoData) grepCountBoth(match string) int {\r\n \treturn tg.doGrepCount(match, \u0026tg.stdout) + tg.doGrepCount(match, \u0026tg.stderr)\r\n }\r\n \r\n+func alexRemove(name string) error {\r\n+\tp, e := syscall.UTF16PtrFromString(name)\r\n+\tif e != nil {\r\n+\t\treturn \u0026os.PathError{\"remove\", name, e}\r\n+\t}\r\n+\r\n+\t// Go file interface forces us to know whether\r\n+\t// name is a file or directory. Try both.\r\n+\te = syscall.DeleteFile(p)\r\n+\tif e == nil {\r\n+\t\treturn nil\r\n+\t}\r\n+\te1 := syscall.RemoveDirectory(p)\r\n+\tif e1 == nil {\r\n+\t\treturn nil\r\n+\t}\r\n+\r\n+\t// Both failed: figure out which error to return.\r\n+\tif e1 != e {\r\n+\t\tprintln(\"JOHN1\", e.Error())\r\n+\t\tprintln(\"JOHN2\", e1.Error())\r\n+\t\ta, e2 := syscall.GetFileAttributes(p)\r\n+\t\tif e2 != nil {\r\n+\t\t\tprintln(\"JOHN3\", e2.Error())\r\n+\t\t\te = e2\r\n+\t\t} else {\r\n+\t\t\tif a\u0026syscall.FILE_ATTRIBUTE_DIRECTORY != 0 {\r\n+\t\t\t\tprintln(\"JOHN4\")\r\n+\t\t\t\te = e1\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\tprintln(\"JOHN5\", e.Error())\r\n+\treturn \u0026os.PathError{\"remove\", name, e}\r\n+}\r\n+\r\n+func alexRemoveAll(path string) error {\r\n+\twd, _ := os.Getwd()\r\n+\t// Simple case: if Remove works, we're done.\r\n+\tprintln(\"ALEX1\", path, wd)\r\n+\terr := alexRemove(path)\r\n+\tif err == nil {\r\n+\t\tprintln(\"ALEX2\")\r\n+\t\treturn nil\r\n+\t}\r\n+\tif os.IsNotExist(err) {\r\n+\t\tprintln(\"ALEX3\")\r\n+\t\treturn nil\r\n+\t}\r\n+\r\n+\tprintln(\"ALEX4\", err.Error())\r\n+\t// Otherwise, is this a directory we need to recurse into?\r\n+\tdir, serr := os.Lstat(path)\r\n+\tif serr != nil {\r\n+\t\tif serr, ok := serr.(*os.PathError); ok \u0026\u0026 (os.IsNotExist(serr.Err) || serr.Err == syscall.ENOTDIR) {\r\n+\t\t\treturn nil\r\n+\t\t}\r\n+\t\tprintln(\"ALEX5\")\r\n+\t\treturn serr\r\n+\t}\r\n+\tif !dir.IsDir() {\r\n+\t\t// Not a directory; return the error from Remove.\r\n+\t\tprintln(\"ALEX6\")\r\n+\t\treturn err\r\n+\t}\r\n+\r\n+\t// Directory.\r\n+\tfd, err := os.Open(path)\r\n+\tif err != nil {\r\n+\t\tif os.IsNotExist(err) {\r\n+\t\t\t// Race. It was deleted between the Lstat and Open.\r\n+\t\t\t// Return nil per RemoveAll's docs.\r\n+\t\t\treturn nil\r\n+\t\t}\r\n+\t\treturn err\r\n+\t}\r\n+\r\n+\t// Remove contents \u0026 return first error.\r\n+\terr = nil\r\n+\tfor {\r\n+\t\tnames, err1 := fd.Readdirnames(100)\r\n+\t\tfor _, name := range names {\r\n+\t\t\terr1 := alexRemoveAll(path + string(os.PathSeparator) + name)\r\n+\t\t\tif err == nil {\r\n+\t\t\t\terr = err1\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\tif err1 == io.EOF {\r\n+\t\t\tbreak\r\n+\t\t}\r\n+\t\t// If Readdirnames returned an error, use it.\r\n+\t\tif err == nil {\r\n+\t\t\terr = err1\r\n+\t\t}\r\n+\t\tif len(names) == 0 {\r\n+\t\t\tbreak\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t// Close directory, because windows won't remove opened directory.\r\n+\tfd.Close()\r\n+\r\n+\t// Remove directory.\r\n+\terr1 := os.Remove(path)\r\n+\tif err1 == nil || os.IsNotExist(err1) {\r\n+\t\treturn nil\r\n+\t}\r\n+\tif err == nil {\r\n+\t\terr = err1\r\n+\t}\r\n+\treturn err\r\n+}\r\n+\r\n+\r\n // creatingTemp records that the test plans to create a temporary file\r\n // or directory.  If the file or directory exists already, it will be\r\n // removed.  When the test completes, the file or directory will be\r\n@@ -433,7 +549,7 @@ func (tg *testgoData) creatingTemp(path string) {\r\n \tif tg.wd != \"\" \u0026\u0026 !filepath.IsAbs(path) {\r\n \t\tpath = filepath.Join(tg.pwd(), path)\r\n \t}\r\n-\ttg.must(os.RemoveAll(path))\r\n+\ttg.must(alexRemoveAll(path))\r\n \ttg.temps = append(tg.temps, path)\r\n }\r\n \r\n@@ -526,7 +642,7 @@ func (tg *testgoData) cleanup() {\r\n \t\t}\r\n \t}\r\n \tfor _, path := range tg.temps {\r\n-\t\ttg.check(os.RemoveAll(path))\r\n+\t\ttg.check(alexRemoveAll(path))\r\n \t}\r\n \tif tg.tempdir != \"\" {\r\n \t\ttg.check(os.RemoveAll(tg.tempdir))\r\n```\r\n\r\nI get this output:\r\n```\r\nc:\\go\\root\\src\\cmd\\go\u003ego test -v -run=LocalImports\r\n=== RUN   TestLocalImportsEasy\r\nALEX1 ./hello.exe c:\\go\\root\\src\\cmd\\go\r\nJOHN5 The system cannot find the file specified.\r\nALEX3\r\nALEX1 ./hello.exe c:\\go\\root\\src\\cmd\\go\r\nALEX2\r\n--- PASS: TestLocalImportsEasy (0.64s)\r\n        go_test.go:250: running testgo [build -o hello.exe testdata\\local\\easy.go]\r\n=== RUN   TestLocalImportsEasySub\r\nALEX1 ./hello.exe c:\\go\\root\\src\\cmd\\go\r\nJOHN5 The system cannot find the file specified.\r\nALEX3\r\nALEX1 ./hello.exe c:\\go\\root\\src\\cmd\\go\r\nALEX2\r\n--- PASS: TestLocalImportsEasySub (0.67s)\r\n        go_test.go:250: running testgo [build -o hello.exe testdata\\local\\easysub\\main.go]\r\n=== RUN   TestLocalImportsHard\r\nALEX1 ./hello.exe c:\\go\\root\\src\\cmd\\go\r\nJOHN5 Access is denied.\r\nALEX4 remove ./hello.exe: Access is denied.\r\nALEX5\r\n--- FAIL: TestLocalImportsHard (0.01s)\r\n        go_test.go:154: GetFileAttributesEx ./hello.exe: Access is denied.\r\n=== RUN   TestLocalImportsGoInstallShouldFail\r\n--- PASS: TestLocalImportsGoInstallShouldFail (0.09s)\r\n        go_test.go:250: running testgo [install testdata\\local\\easy.go]\r\n        go_test.go:269: standard error:\r\n        go_test.go:270: go install: no install location for .go files listed on command line (GOBIN not set)\r\n        go_test.go:289: testgo failed as expected: exit status 1\r\nFAIL\r\nexit status 1\r\nFAIL    cmd/go  6.054s\r\n\r\nc:\\go\\root\\src\\cmd\\go\u003e\r\n```\r\n\r\nIt looks to me that TestLocalImportsEasySub removes ./hello.exe at the end of the test (successfully). But then TestLocalImportsHard (following test) gets \"Access is denied\" while trying to remove ./hello.exe that does not exists now. Very confusing, but I wouldn't be surprised to discover that this is how Windows work in this situation. Removing executable file after it just finished executing has always been a problem on windows. I don't know of a sure way to know when it is safe to delete. We even have small \"sleep\" at the end of (*os.process).wait for that reason.\r\n\r\nI could be missing something here, but I don't see and reasonable resolution here. Maybe we could just have different name for that file for different tests.\r\n\r\nAlex",
	"user": {
		"login": "alexbrainman",
		"id": 9796621,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-06-16T01:29:05Z",
	"updated_at": "2015-06-16T01:29:05Z"
}
