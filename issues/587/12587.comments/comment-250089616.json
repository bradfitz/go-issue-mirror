{
	"id": 250089616,
	"body": "Provide \"mem_windows.go\" source file\r\n\r\n`// Copyright 2010 The Go Authors.  All rights reserved.\r\n// Use of this source code is governed by a BSD-style\r\n// license that can be found in the LICENSE file.\r\n\r\npackage runtime\r\n\r\nimport (\r\n\t\"unsafe\"\r\n)\r\n\r\nconst (\r\n\t_MEM_COMMIT   = 0x1000\r\n\t_MEM_RESERVE  = 0x2000\r\n\t_MEM_DECOMMIT = 0x4000\r\n\t_MEM_RELEASE  = 0x8000\r\n\r\n\t_PAGE_READWRITE = 0x0004\r\n\t_PAGE_NOACCESS  = 0x0001\r\n)\r\n\r\n// Don't split the stack as this function may be invoked without a valid G,\r\n// which prevents us from allocating more stack.\r\n//go:nosplit\r\nfunc sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer {\r\n\tmSysStatInc(sysStat, n)\r\n\treturn unsafe.Pointer(stdcall4(_VirtualAlloc, 0, n, _MEM_COMMIT|_MEM_RESERVE, _PAGE_READWRITE))\r\n}\r\n\r\nfunc sysUnused(v unsafe.Pointer, n uintptr) {\r\n\tr := stdcall3(_VirtualFree, uintptr(v), n, _MEM_DECOMMIT)\r\n\tif r != 0 {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Decommit failed. Usual reason is that we've merged memory from two different\r\n\t// VirtualAlloc calls, and Windows will only let each VirtualFree handle pages from\r\n\t// a single VirtualAlloc. It is okay to specify a subset of the pages from a single alloc,\r\n\t// just not pages from multiple allocs. This is a rare case, arising only when we're\r\n\t// trying to give memory back to the operating system, which happens on a time\r\n\t// scale of minutes. It doesn't have to be terribly fast. Instead of extra bookkeeping\r\n\t// on all our VirtualAlloc calls, try freeing successively smaller pieces until\r\n\t// we manage to free something, and then repeat. This ends up being O(n log n)\r\n\t// in the worst case, but that's fast enough.\r\n\tfor n \u003e 0 {\r\n\t\tsmall := n\r\n\t\tfor small \u003e= 4096 \u0026\u0026 stdcall3(_VirtualFree, uintptr(v), small, _MEM_DECOMMIT) == 0 {\r\n\t\t\tsmall /= 2\r\n\t\t\tsmall \u0026^= 4096 - 1\r\n\t\t}\r\n\t\tif small \u003c 4096 {\r\n\t\t\tprint(\"runtime: VirtualFree of \", small, \" bytes failed with errno=\", getlasterror(), \"\\n\")\r\n\t\t\tthrow(\"runtime: failed to decommit pages\")\r\n\t\t}\r\n\t\tv = add(v, small)\r\n\t\tn -= small\r\n\t}\r\n}\r\n\r\nfunc sysUsed(v unsafe.Pointer, n uintptr) {\r\n\tr := stdcall4(_VirtualAlloc, uintptr(v), n, _MEM_COMMIT, _PAGE_READWRITE)\r\n\tif r == uintptr(v) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Commit failed. See SysUnused.\r\n\tfor n \u003e 0 {\r\n\t\tsmall := n\r\n\t\tfor small \u003e= 4096 \u0026\u0026 stdcall4(_VirtualAlloc, uintptr(v), small, _MEM_COMMIT, _PAGE_READWRITE) == 0 {\r\n\t\t\tsmall /= 2\r\n\t\t\tsmall \u0026^= 4096 - 1\r\n\t\t}\r\n\t\tif small \u003c 4096 {\r\n\t\t\tprint(\"runtime: VirtualAlloc of \", small, \" bytes failed with errno=\", getlasterror(), \"\\n\")\r\n\t\t\tthrow(\"runtime: failed to commit pages\")\r\n\t\t}\r\n\t\tv = add(v, small)\r\n\t\tn -= small\r\n\t}\r\n}\r\n\r\n// Don't split the stack as this function may be invoked without a valid G,\r\n// which prevents us from allocating more stack.\r\n//go:nosplit\r\nfunc sysFree(v unsafe.Pointer, n uintptr, sysStat *uint64) {\r\n\tmSysStatDec(sysStat, n)\r\n\tr := stdcall3(_VirtualFree, uintptr(v), 0, _MEM_RELEASE)\r\n\tif r == 0 {\r\n\t\tprint(\"runtime: VirtualFree of \", n, \" bytes failed with errno=\", getlasterror(), \"\\n\")\r\n\t\tthrow(\"runtime: failed to release pages\")\r\n\t}\r\n}\r\n\r\nfunc sysFault(v unsafe.Pointer, n uintptr) {\r\n\t// SysUnused makes the memory inaccessible and prevents its reuse\r\n\tsysUnused(v, n)\r\n}\r\n\r\nfunc sysReserve(v unsafe.Pointer, n uintptr, reserved *bool) unsafe.Pointer {\r\n\t*reserved = true\r\n\t// v is just a hint.\r\n\t// First try at v.\r\n\tv = unsafe.Pointer(stdcall4(_VirtualAlloc, uintptr(v), n, _MEM_RESERVE, _PAGE_READWRITE))\r\n\tif v != nil {\r\n\t\treturn v\r\n\t}\r\n\r\n\t// Next let the kernel choose the address.\r\n\treturn unsafe.Pointer(stdcall4(_VirtualAlloc, 0, n, _MEM_RESERVE, _PAGE_READWRITE))\r\n}\r\n\r\nfunc sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64) {\r\n\tmSysStatInc(sysStat, n)\r\n\tp := stdcall4(_VirtualAlloc, uintptr(v), n, _MEM_COMMIT, _PAGE_READWRITE)\r\n\tif p != uintptr(v) {\r\n\t\tprint(\"runtime: VirtualAlloc of \", n, \" bytes failed with errno=\", getlasterror(), \"\\n\")\r\n\t\tthrow(\"runtime: cannot map pages in arena address space\")\r\n\t}\r\n}\r\n`",
	"user": {
		"login": "wukehong",
		"id": 696704,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2016-09-28T07:12:11Z",
	"updated_at": "2016-09-28T07:12:11Z"
}
