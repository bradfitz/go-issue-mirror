{
	"id": 76951384,
	"body": "As Rick mentioned, I think my GC scheduler design should help with this.\nI'm going to send out the design doc in the next few days. It doesn't\ndirectly damp the target heap size, but it does damp other things like the\nGC trigger point that should indirectly damp the target heap size. Once\nit's implemented, we can see how much this helps and if it's not enough we\ncan integrate some direct damping of the base heap size.\nOn Mar 3, 2015 8:59 AM, \"Richard L. Hudson\" \u003cnotifications@github.com\u003e\nwrote:\n\n\u003e I believe this is also true for 1.4 so it isn't a problem we are\n\u003e introducing in 1.5. When to trigger a GC is part of the problem and Austin\n\u003e is working on that. The work includes dampening functions to control\n\u003e oscillations but it is not intended to deal with constrained memory GC.\n\u003e\n\u003e That said I do believe that constrained memory GC is an important part of\n\u003e the design space and when Go starts to move in that direction I am sure we\n\u003e will tackle the problem.\n\u003e\n\u003e On Tue, Mar 3, 2015 at 2:29 AM, Dmitry Vyukov \u003cnotifications@github.com\u003e\n\u003e wrote:\n\u003e\n\u003e \u003e Currently GC allows heap to grow to 2x of live memory during the previous\n\u003e \u003e GC. This can play badly with spiky memory usage. Consider that in steady\n\u003e \u003e state program has live set X. GC will allow heap to grow to 2X and then\n\u003e \u003e collect it back to X, and so on. Now consider that there is a 1.5X spike\n\u003e in\n\u003e \u003e memory usage. If GC happens *after* the spike (when live set is again X),\n\u003e \u003e then GC will collect X memory (garbage generated during the spike) and\n\u003e set\n\u003e \u003e heap limit to 2X as before. Now if GC happens to happen *during* the\n\u003e \u003e spike (when live set is 1.5X), then GC will collect only 0.5X and set\n\u003e heap\n\u003e \u003e limit to 3X.\n\u003e \u003e\n\u003e \u003e Basically bad timing can increase maximum heap (RSS) by up to 2x.\n\u003e \u003e\n\u003e \u003e Memory-constrained environments, like browsers, pay a great deal of\n\u003e \u003e attention to this problem. The idea is to set smarter GC threshold when\n\u003e \u003e heap grows/shrinks.\n\u003e \u003e\n\u003e \u003e I did not work out a solution. But what I have in mind is: if heap grows,\n\u003e \u003e and especially if the next threshold (next_gc) will be larger than the\n\u003e \u003e current RSS (heap_sys - heap_released), then set next_gc to, say,\n\u003e \u003e heap_inuse * (1 + GOGC/100) * 0.75.\n\u003e \u003e Since heap cannot grow all the time, this throttling is only temporal.\n\u003e \u003e\n\u003e \u003e @rsc \u003chttps://github.com/rsc\u003e @RLH \u003chttps://github.com/RLH\u003e @aclements\n\u003e \u003e \u003chttps://github.com/aclements\u003e @randall77 \u003chttps://github.com/randall77\u003e\n\u003e \u003e\n\u003e \u003e —\n\u003e \u003e Reply to this email directly or view it on GitHub\n\u003e \u003e \u003chttps://github.com/golang/go/issues/10064\u003e.\n\u003e \u003e\n\u003e\n\u003e —\n\u003e Reply to this email directly or view it on GitHub\n\u003e \u003chttps://github.com/golang/go/issues/10064#issuecomment-76949539\u003e.\n\u003e\n",
	"user": {
		"login": "aclements",
		"id": 2688315,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2015-03-03T14:09:44Z",
	"updated_at": "2015-03-03T14:09:44Z"
}
