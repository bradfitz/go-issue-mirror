{
	"id": 66091381,
	"body": "\u003ca id=\"c20\"\u003e\u003c/a\u003eComment 20:\n\n\u003cpre\u003eI've looked at a handful of these on the builder. The typical failure trace looks like\nthis:\n\n(gdb) thread 3\n[Switching to thread 3 (Thread 664.0x9a4)]\n#0  0x774b5f4f in ntdll!_chkstk () from C:\\Windows\\system32\\ntdll.dll\n(gdb) where\n#0  0x774b5f4f in ntdll!_chkstk () from C:\\Windows\\system32\\ntdll.dll\n#1  0x75f60262 in OpenProfileUserMapping ()\n   from C:\\Windows\\system32\\kernel32.dll\n#2  0x003a06dc in ?? ()\n#3  0x75f3fa12 in KERNEL32!GetApplicationRestartSettings ()\n   from C:\\Windows\\system32\\kernel32.dll\n#4  0x75f5e080 in OpenProfileUserMapping ()\n   from C:\\Windows\\system32\\kernel32.dll\n#5  0xffffffff in ?? ()\n#6  0x003a0708 in ?? ()\n#7  0x75f4042e in UnhandledExceptionFilter ()\n   from C:\\Windows\\system32\\kernel32.dll\n#8  0x003a07e4 in ?? ()\n#9  0x774c80f9 in ntdll!EtwpNotificationThread ()\n   from C:\\Windows\\system32\\ntdll.dll\n#10 0x77491696 in ntdll!RtlInitializeNtUserPfn ()\n   from C:\\Windows\\system32\\ntdll.dll\n#11 0x00000000 in ?? ()\n(gdb)\n\nMany of these symbols are bogus: gdb only knows about symbols in the dynamic link\ntables, so many of these are just the last exported symbol before a large chunk of\nunexported symbols. However, ntdll!_chkstk is accurate, as is\nKERNEL32!GetApplicationRestartSettings.\n\nntdll!_chkstk is what Windows calls from any function that allocates a large stack frame\n(\u0026gt;4kB). It works by touching one word per new page created, so that if you have just\na single 4kB guard page for your stack, you can't skip over it. The problem here is that\nthis code is running on a Go stack, presumably in response to the divide-by-zero. The\nfunction mislabeled as OpenProfileUserMapping is trying to allocate a 4300-byte stack\nframe, but Go only leaves 2 kB for Windows (StackSystem in runtime.h). The hope was that\n2k is \"big enough\" but apparently it is not.\n\nThis happens in divmod with some regularity because I wrote divmod to generate test\ncases using a deeply recursive function. Eventually this check ends up running near the\nbottom of a stack that happens to have nothing mapped just before it in memory, and\n_chkstk works as intended and faults. The new copying stacks exacerbate the problem, but\nit could happen in the old stacks too. I believe it started happening reliably when we\nreenabled concurrent sweep only because concurrent sweep created a new couple stack\nframes and therefore disrupted the usual allocation patterns.\n\nI would like to see a disassembly of the KiUserExceptionDispatcher implementation [1]\nalong with the things it uses, but I have been unable to produce one. Gdb seems not to\nknow enough about the symbols, and windbg is inscrutable.\n\nI have also observed that the SEH information is often corrupt in the thread with the\nproblem. It is possible that this stack overflow is a distraction and only happens\nbecause the Go SEH registration has been lost and we're stuck in Windows SEH routines.\nIt is also possible that this stack overflow - happening on some other thread, earlier,\nundetected - is why the SEH registrations are being lost. I think that's not too likely\nbecause it makes the most sense for GetApplicationRestartSettings to be called during a\ncrash, and we are trying to understand how the crash came to be, not bugs revealed\nduring its handling. Of course, it could be some other stack overflow. What else might\nWindows be running at the bottom of the goroutine stacks that we're unaware of?\n\nOn the SEH registration problem, one theory is that when Windows code runs on the Go\nstack, it registers and then deregisters its own SEH handlers. Normally we make sure\nthat the SEH chain is on the m (aka g0, aka OS) stack, but this Windows code is\nexecuting on an arbitrary Go stack. It may be confused by seeing SEH registrations not\non the OS stack. In particular, the thread information block contains two words giving\nthe bounds of the OS stack, and some sources online claim that if Windows sees SEH\nentries outside those bounds it will ignore/reject them somehow [2]:\n\n    The OS is pretty paranoid about corrupt stacks during this chain traversal.\n    It checks that all chain entries are within the bounds of the stack. \n    (These bounds are also recorded in the TEB).  The OS also checks that all\n    entries are in ascending order on the stack.  If you violate these rules,\n    the OS will consider the stack to be corrupt and will be unable to process\n    exceptions.  This is one of the reasons that a Win32 application cannot\n    break its stack into multiple disjoint segments as an innovative technique\n    for dealing with stack overflow.\n\nWe have certainly not observed that, however, and I think if it were true we'd have seen\nmore problems.\n\nI wonder if the deregistration of handlers during an exception is based on stack\naddress. If so, suppose that the Go SEH handler is registered on the OS stack at address\n0x6fff0, and then we make a Go stack at 0x1010000, and then Windows code running on that\nGo stack pushes a SEH handler or two around 0x100fff0, and then an exception happens. It\nis possible that the unwind of the SEH stack during the exception is a while loop that\nwaits until it finds an entry larger than the stack address being returned to. (That's\nsimilar to what we do in panic.) Windows would see the 0x6fff0 address as \"lower\" on the\nstack than 0x100fff0, instead of realizing that they are two different stacks entirely,\nand incorrectly remove the top-level SEH handler we've registered along with the others.\nThe next exception would not be caught by the now-removed Go SEH, and we end up seeing\nthe failure we see today.\n\nIt is possible that we could bypass some of this by switching to Vectored Exception\nHandling [3]. VEH is nice because it applies to the whole program, not just one thread,\nso they are not constantly being registered and deregistered. We can register it once\nand not worry about the handler not being called or being overridden by Windows code due\nto confusion about stack addresses. Go's VEH handler could pick off just the entries\nwith a PC in the Go text segment and let the others fall through to the other handlers\nand then eventually to SEH. This is similar to what we do on windows/amd64, except that\non amd64 the handler information is in the executable header instead of registered at\nrun time. If the VEH implementation is low-level enough and doesn't call too many other\nfunctions, it might fit in the 2k we are currently reserving. Using VEH would exclude\nWindows 2000 (requiring Windows XP/Windows Server 2003 or later). \n\nAnother possibility is to have a separate SEH chain for every goroutine stack, and make\nthe goroutine switch update all three words in the thread information block: stack\nbottom, stack top, stack, SEH chain. This would mean that the Windows per-thread SEH\nhandlers would be excluded from executing (ever), which might break debug breakpoints\n(the only time Go's SEH handler ever declines an opportunity to handle an exception).\n\nIt is also possible that we are causing this problem ourselves, similar to \u003ca href=\"https://golang.org/issue/7470\"\u003eissue #7470\u003c/a\u003e.\nHowever, we do next to no manipulation of the SEH ourselves, and the code that was buggy\nin 7470 is not involved at all in test/divmod.go (no cgo).\n\nI really don't know what to do here. None of the options are great. Using VEH is\nprobably simplest, if we can drop win2k and if it helps, but there's no guarantee it\nwill fix the general problem. It's easy to try though, I guess.\n\n[1] \u003ca href=\"http://www.microsoft.com/msj/0197/exception/exception.aspx\"\u003ehttp://www.microsoft.com/msj/0197/exception/exception.aspx\u003c/a\u003e\n[2] \u003ca href=\"http://blogs.msdn.com/b/cbrumme/archive/2003/10/01/51524.aspx\"\u003ehttp://blogs.msdn.com/b/cbrumme/archive/2003/10/01/51524.aspx\u003c/a\u003e\n[3] \u003ca href=\"http://msdn.microsoft.com/en-us/magazine/cc301714.aspx\"\u003ehttp://msdn.microsoft.com/en-us/magazine/cc301714.aspx\u003c/a\u003e\n\n(gdb) x/20i 0x75f60253\n   0x75f60253 \u0026lt;OpenProfileUserMapping+20435\u0026gt;:   mov    %edi,%edi\n   0x75f60255 \u0026lt;OpenProfileUserMapping+20437\u0026gt;:   push   %ebp\n   0x75f60256 \u0026lt;OpenProfileUserMapping+20438\u0026gt;:   mov    %esp,%ebp\n   0x75f60258 \u0026lt;OpenProfileUserMapping+20440\u0026gt;:   mov    $0x10cc,%eax\n   0x75f6025d \u0026lt;OpenProfileUserMapping+20445\u0026gt;:\n    call   0x75f60fc5 \u0026lt;OpenProfileUserMapping+23877\u0026gt;\n   0x75f60262 \u0026lt;OpenProfileUserMapping+20450\u0026gt;:   mov    0x75f6e4ac,%eax\n   0x75f60267 \u0026lt;OpenProfileUserMapping+20455\u0026gt;:   xor    %ebp,%eax\n   0x75f60269 \u0026lt;OpenProfileUserMapping+20457\u0026gt;:   mov    %eax,-0x4(%ebp)\n   0x75f6026c \u0026lt;OpenProfileUserMapping+20460\u0026gt;:   push   %ebx\n   0x75f6026d \u0026lt;OpenProfileUserMapping+20461\u0026gt;:   mov    0x8(%ebp),%ebx\n\nNOTE: 75f6e4ac is a PLT entry jumping to 0x774b5f28\n\n(gdb) x/30i 'ntdll!_chkstk'\n   0x774b5f28 \u0026lt;ntdll!_chkstk\u0026gt;:  push   %ecx\n   0x774b5f29 \u0026lt;ntdll!_chkstk+1\u0026gt;:        lea    0x4(%esp),%ecx\n   0x774b5f2d \u0026lt;ntdll!_chkstk+5\u0026gt;:        sub    %eax,%ecx\n   0x774b5f2f \u0026lt;ntdll!_chkstk+7\u0026gt;:        sbb    %eax,%eax\n   0x774b5f31 \u0026lt;ntdll!_chkstk+9\u0026gt;:        not    %eax\n   0x774b5f33 \u0026lt;ntdll!_chkstk+11\u0026gt;:       and    %eax,%ecx\n   0x774b5f35 \u0026lt;ntdll!_chkstk+13\u0026gt;:       mov    %esp,%eax\n   0x774b5f37 \u0026lt;ntdll!_chkstk+15\u0026gt;:       and    $0xfffff000,%eax\n   0x774b5f3c \u0026lt;ntdll!_chkstk+20\u0026gt;:       cmp    %eax,%ecx\n   0x774b5f3e \u0026lt;ntdll!_chkstk+22\u0026gt;:       jb     0x774b5f4a \u0026lt;ntdll!_chkstk+34\u0026gt;\n   0x774b5f40 \u0026lt;ntdll!_chkstk+24\u0026gt;:       mov    %ecx,%eax\n   0x774b5f42 \u0026lt;ntdll!_chkstk+26\u0026gt;:       pop    %ecx\n   0x774b5f43 \u0026lt;ntdll!_chkstk+27\u0026gt;:       xchg   %eax,%esp\n   0x774b5f44 \u0026lt;ntdll!_chkstk+28\u0026gt;:       mov    (%eax),%eax\n   0x774b5f46 \u0026lt;ntdll!_chkstk+30\u0026gt;:       mov    %eax,(%esp)\n   0x774b5f49 \u0026lt;ntdll!_chkstk+33\u0026gt;:       ret\n   0x774b5f4a \u0026lt;ntdll!_chkstk+34\u0026gt;:       sub    $0x1000,%eax\n   0x774b5f4f \u0026lt;ntdll!_chkstk+39\u0026gt;:       test   %eax,(%eax)\n   0x774b5f51 \u0026lt;ntdll!_chkstk+41\u0026gt;:       jmp    0x774b5f3c \u0026lt;ntdll!_chkstk+20\u0026gt;\n   0x774b5f53 \u0026lt;ntdll!_chkstk+43\u0026gt;:       nop\n   0x774b5f54 \u0026lt;ntdll!_chkstk+44\u0026gt;:       nop\n   0x774b5f55 \u0026lt;ntdll!_chkstk+45\u0026gt;:       nop\n   0x774b5f56 \u0026lt;ntdll!_chkstk+46\u0026gt;:       nop\n   0x774b5f57 \u0026lt;ntdll!_chkstk+47\u0026gt;:       nop\n   0x774b5f58 \u0026lt;ntdll!_chkstk+48\u0026gt;:       nop\n   0x774b5f59 \u0026lt;ntdll!_chkstk+49\u0026gt;:       nop\u003c/pre\u003e",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-03-10T21:20:14Z",
	"updated_at": "2014-12-22T06:32:41Z"
}
