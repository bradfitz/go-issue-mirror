{
	"id": 66091373,
	"body": "\u003ca id=\"c13\"\u003e\u003c/a\u003eComment 13:\n\n\u003cpre\u003e[Hi Hector! Question for you at the bottom.]\n\nThis is still happening on the windows/386 builder. I was able to connect to a broken\ndivmod with gdb and take a look. \n\nFor future reference, when you're looking for thread-local storage on 32-bit windows, it\nseems that the thread structures are allocated 0x7ffde000 moving downward: 0x7ffde000 is\nthread 1, 0x7ffdd000 is thread 2, and so on: 0x7ffdb000 is thread 4 is as far as I got\nin this program. Or maybe gdb numbers the threads in reverse and the thread structures\nare actually allocated upward. \n\nAnyway, there is a divide by zero happening (as expected) but the SEH handler for the Go\nthread has been removed from the SEH chain. That is, the chain should look like\n\n0(FS) = m-\u003eseh = 0x31ff78\nseh at 0x31ff78 = {0x31ffc4, 0x41ffb0}\nseh at 0x31ffc4 = {0x31ffe4, 0x77459ac2}\nseh at 0x31ffe4 = {0xffffffff, 0x774f7b76}\n\nThe 0x41ffb0 is our handler. the others are windows handlers earlier in the chain.\n\nIn the broken divmod program, 0(FS) is 0x31ffc4: the go SEH block has been removed. But\nwho removed it? The only code in Go that removes a SEH block is used during calls from C\nback into Go, and that is not happening here.\n\nSo it seems like Windows removed it. Why? The only time Windows is supposed to remove a\nSEH structure is if it declines to handle an exception and then an outer SEH does handle\nit. The assumption is that the code is returning to something near the outer SEH, so the\ninner code is gone and the inner SEH should be gone too. The only thing\nruntime.sighandler passes on is EXCEPTION_BREAKPOINT:\n\n\tswitch(info-\u003eExceptionCode) {\n\tcase EXCEPTION_BREAKPOINT:\n\t\tr-\u003eEip--;\t// because 8l generates 2 bytes for INT3\n\t\treturn 1;\n\t}\n\nIf Windows sent an EXCEPTION_BREAKPOINT, then Go's handler would pass, an outer handler\nwould handle it, and Go's handler would be removed. But I do not understand why Windows\nwould send an EXCEPTION_BREAKPOINT. But also if this didn't happen in practice it's hard\nto believe the code would be here at all. \n\nHector, this code was in the very first implementation of Windows exception handling, in\n\u003ca href=\"https://golang.org/cl/4079041\"\u003ehttps://golang.org/cl/4079041\u003c/a\u003e aka b897d583e187. Clearly you had hit this,\nbecause otherwise you wouldn't have thought to do the r-\u003eEip--. \n\nHow did this come up? Can it come up if a debugger is not involved and the program is\nnot crashing?\n\nIf it's not the breakpoint explanation, then I have no idea why Windows would remove the\nSEH block. Maybe there is just a Windows kernel bug, but that's not encouraging. I ran\nthe test (divmod.exe) over and over and over by itself and couldn't make it fail. But it\nfails somewhat regularly (maybe 1/4 of the time) during the builder all.bat tests.\n\nThread 1 (the main thread, I can tell) is not running Go code at the moment but also has\na broken SEH. It is in Windows code that may have pushed its own SEH, but the SEH link\npointer it has doesn't make sense, and it does not lead back to the Go SEH frame for\nthat m.\n\nIt is hard to see what Go could be doing wrong here other than the breakpoint thing, but\nit is also hard to see how the breakpoint thing could happen. If it's really a Windows\nbug, our options for working around this seem limited. One possibility would be to\nalways update the SEH head pointer at 0(FS) during runtime.gogo, so that on entry to any\ngoroutine, we know we have the right SEH setting. That's the best I can come up with\nright now.\n\nAnyone else? Hector?\n\nThanks.\nRuss\u003c/pre\u003e\n\n\n\n_Status changed to **Accepted**._",
	"user": {
		"login": "rsc",
		"id": 104030,
		"type": "User",
		"site_admin": false
	},
	"created_at": "2014-03-07T18:59:40Z",
	"updated_at": "2014-12-08T10:40:47Z"
}
